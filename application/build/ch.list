
build/ch.elf:     file format elf32-littlearm


Disassembly of section .vectors:

08000000 <_vectors>:
 8000000:	20000400 	.word	0x20000400
 8000004:	08000279 	.word	0x08000279
 8000008:	0800027b 	.word	0x0800027b
 800000c:	0800027b 	.word	0x0800027b
 8000010:	0800027b 	.word	0x0800027b
 8000014:	0800027b 	.word	0x0800027b
 8000018:	0800027b 	.word	0x0800027b
 800001c:	0800027b 	.word	0x0800027b
 8000020:	0800027b 	.word	0x0800027b
 8000024:	0800027b 	.word	0x0800027b
 8000028:	0800027b 	.word	0x0800027b
 800002c:	08003fe1 	.word	0x08003fe1
 8000030:	0800027b 	.word	0x0800027b
 8000034:	0800027b 	.word	0x0800027b
 8000038:	0800027b 	.word	0x0800027b
 800003c:	0800027b 	.word	0x0800027b
 8000040:	0800027b 	.word	0x0800027b
 8000044:	0800027b 	.word	0x0800027b
 8000048:	0800027b 	.word	0x0800027b
 800004c:	0800027b 	.word	0x0800027b
 8000050:	0800027b 	.word	0x0800027b
 8000054:	0800027b 	.word	0x0800027b
 8000058:	0800027b 	.word	0x0800027b
 800005c:	0800027b 	.word	0x0800027b
 8000060:	0800027b 	.word	0x0800027b
 8000064:	0800027b 	.word	0x0800027b
 8000068:	0800027b 	.word	0x0800027b
 800006c:	08000db1 	.word	0x08000db1
 8000070:	08000de1 	.word	0x08000de1
 8000074:	08000e21 	.word	0x08000e21
 8000078:	08000e61 	.word	0x08000e61
 800007c:	08000ea1 	.word	0x08000ea1
 8000080:	08000ee1 	.word	0x08000ee1
 8000084:	08000f21 	.word	0x08000f21
 8000088:	08000cf1 	.word	0x08000cf1
 800008c:	0800027b 	.word	0x0800027b
 8000090:	0800027b 	.word	0x0800027b
 8000094:	0800027b 	.word	0x0800027b
 8000098:	0800027b 	.word	0x0800027b
 800009c:	0800027b 	.word	0x0800027b
 80000a0:	0800027b 	.word	0x0800027b
 80000a4:	0800027b 	.word	0x0800027b
 80000a8:	0800027b 	.word	0x0800027b
 80000ac:	0800027b 	.word	0x0800027b
 80000b0:	08000a21 	.word	0x08000a21
 80000b4:	0800027b 	.word	0x0800027b
 80000b8:	0800027b 	.word	0x0800027b
 80000bc:	0800027b 	.word	0x0800027b
 80000c0:	0800027b 	.word	0x0800027b
 80000c4:	0800027b 	.word	0x0800027b
 80000c8:	0800027b 	.word	0x0800027b
 80000cc:	0800027b 	.word	0x0800027b
 80000d0:	0800027b 	.word	0x0800027b
 80000d4:	0800027b 	.word	0x0800027b
 80000d8:	08000a01 	.word	0x08000a01
 80000dc:	0800027b 	.word	0x0800027b
 80000e0:	0800027b 	.word	0x0800027b
 80000e4:	0800027b 	.word	0x0800027b
 80000e8:	0800027b 	.word	0x0800027b
 80000ec:	0800027b 	.word	0x0800027b
 80000f0:	0800027b 	.word	0x0800027b
 80000f4:	0800027b 	.word	0x0800027b
 80000f8:	0800027b 	.word	0x0800027b
 80000fc:	0800027b 	.word	0x0800027b
 8000100:	0800027b 	.word	0x0800027b
 8000104:	0800027b 	.word	0x0800027b
 8000108:	0800027b 	.word	0x0800027b
 800010c:	0800027b 	.word	0x0800027b
 8000110:	0800027b 	.word	0x0800027b
 8000114:	0800027b 	.word	0x0800027b
 8000118:	0800027b 	.word	0x0800027b
 800011c:	0800027b 	.word	0x0800027b
 8000120:	08000f61 	.word	0x08000f61
 8000124:	08000f91 	.word	0x08000f91
 8000128:	08000fd1 	.word	0x08000fd1
 800012c:	08001011 	.word	0x08001011
 8000130:	08001051 	.word	0x08001051
 8000134:	0800027b 	.word	0x0800027b
 8000138:	0800027b 	.word	0x0800027b
 800013c:	0800027b 	.word	0x0800027b
 8000140:	0800027b 	.word	0x0800027b
 8000144:	0800027b 	.word	0x0800027b
 8000148:	0800027b 	.word	0x0800027b
 800014c:	0800027b 	.word	0x0800027b
 8000150:	08001091 	.word	0x08001091
 8000154:	080010d1 	.word	0x080010d1
 8000158:	0800027b 	.word	0x0800027b
 800015c:	0800027b 	.word	0x0800027b
 8000160:	0800027b 	.word	0x0800027b
 8000164:	0800027b 	.word	0x0800027b
 8000168:	0800027b 	.word	0x0800027b
 800016c:	0800027b 	.word	0x0800027b
 8000170:	0800027b 	.word	0x0800027b
 8000174:	0800027b 	.word	0x0800027b
 8000178:	0800027b 	.word	0x0800027b
 800017c:	0800027b 	.word	0x0800027b
 8000180:	0800027b 	.word	0x0800027b
 8000184:	0800027b 	.word	0x0800027b
 8000188:	0800027b 	.word	0x0800027b
 800018c:	0800027b 	.word	0x0800027b
 8000190:	0800027b 	.word	0x0800027b
 8000194:	0800027b 	.word	0x0800027b
 8000198:	0800027b 	.word	0x0800027b
 800019c:	0800027b 	.word	0x0800027b

Disassembly of section .text:

080001a0 <_crt0_entry>:
                .align  2
                .thumb_func
                .global _crt0_entry
_crt0_entry:
                /* Interrupts are globally masked initially.*/
                cpsid   i
 80001a0:	b672      	cpsid	i

#if CRT0_FORCE_MSP_INIT == TRUE
                /* MSP stack pointers initialization.*/
                ldr     r0, =__main_stack_end__
 80001a2:	4827      	ldr	r0, [pc, #156]	; (8000240 <endfiniloop+0x4>)
                msr     MSP, r0
 80001a4:	f380 8808 	msr	MSP, r0
#endif

                /* PSP stack pointers initialization.*/
                ldr     r0, =__process_stack_end__
 80001a8:	4826      	ldr	r0, [pc, #152]	; (8000244 <endfiniloop+0x8>)
                msr     PSP, r0
 80001aa:	f380 8809 	msr	PSP, r0

#if CRT0_VTOR_INIT == TRUE
                ldr     r0, =_vectors
 80001ae:	4826      	ldr	r0, [pc, #152]	; (8000248 <endfiniloop+0xc>)
                movw    r1, #SCB_VTOR & 0xFFFF
 80001b0:	f64e 5108 	movw	r1, #60680	; 0xed08
                movt    r1, #SCB_VTOR >> 16
 80001b4:	f2ce 0100 	movt	r1, #57344	; 0xe000
                str     r0, [r1]
 80001b8:	6008      	str	r0, [r1, #0]

                /* Enforcing FPCA bit in the CONTROL register.*/
                movs    r0, #CRT0_CONTROL_INIT | CONTROL_FPCA

#else
                movs    r0, #CRT0_CONTROL_INIT
 80001ba:	2002      	movs	r0, #2
#endif

                /* CONTROL register initialization as configured.*/
                msr     CONTROL, r0
 80001bc:	f380 8814 	msr	CONTROL, r0
                isb
 80001c0:	f3bf 8f6f 	isb	sy

#if CRT0_INIT_CORE == TRUE
                /* Core initialization.*/
                bl      __cpu_init
 80001c4:	f000 f90c 	bl	80003e0 <__cpu_init>
#endif

                /* Early initialization.*/
                bl      __early_init
 80001c8:	f001 f952 	bl	8001470 <__early_init>

#if CRT0_INIT_STACKS == TRUE
                ldr     r0, =CRT0_STACKS_FILL_PATTERN
 80001cc:	f04f 3055 	mov.w	r0, #1431655765	; 0x55555555
                /* Main Stack initialization. Note, it assumes that the
                   stack size is a multiple of 4 so the linker file must
                   ensure this.*/
                ldr     r1, =__main_stack_base__
 80001d0:	491e      	ldr	r1, [pc, #120]	; (800024c <endfiniloop+0x10>)
                ldr     r2, =__main_stack_end__
 80001d2:	4a1b      	ldr	r2, [pc, #108]	; (8000240 <endfiniloop+0x4>)

080001d4 <msloop>:
msloop:
                cmp     r1, r2
 80001d4:	4291      	cmp	r1, r2
                itt     lo
 80001d6:	bf3c      	itt	cc
                strlo   r0, [r1], #4
 80001d8:	f841 0b04 	strcc.w	r0, [r1], #4
                blo     msloop
 80001dc:	e7fa      	bcc.n	80001d4 <msloop>

                /* Process Stack initialization. Note, it assumes that the
                   stack size is a multiple of 4 so the linker file must
                   ensure this.*/
                ldr     r1, =__process_stack_base__
 80001de:	491c      	ldr	r1, [pc, #112]	; (8000250 <endfiniloop+0x14>)
                ldr     r2, =__process_stack_end__
 80001e0:	4a18      	ldr	r2, [pc, #96]	; (8000244 <endfiniloop+0x8>)

080001e2 <psloop>:
psloop:
                cmp     r1, r2
 80001e2:	4291      	cmp	r1, r2
                itt     lo
 80001e4:	bf3c      	itt	cc
                strlo   r0, [r1], #4
 80001e6:	f841 0b04 	strcc.w	r0, [r1], #4
                blo     psloop
 80001ea:	e7fa      	bcc.n	80001e2 <psloop>
#endif

#if CRT0_INIT_DATA == TRUE
                /* Data initialization. Note, it assumes that the DATA size
                  is a multiple of 4 so the linker file must ensure this.*/
                ldr     r1, =__textdata_base__
 80001ec:	4919      	ldr	r1, [pc, #100]	; (8000254 <endfiniloop+0x18>)
                ldr     r2, =__data_base__
 80001ee:	4a1a      	ldr	r2, [pc, #104]	; (8000258 <endfiniloop+0x1c>)
                ldr     r3, =__data_end__
 80001f0:	4b1a      	ldr	r3, [pc, #104]	; (800025c <endfiniloop+0x20>)

080001f2 <dloop>:
dloop:
                cmp     r2, r3
 80001f2:	429a      	cmp	r2, r3
                ittt    lo
 80001f4:	bf3e      	ittt	cc
                ldrlo   r0, [r1], #4
 80001f6:	f851 0b04 	ldrcc.w	r0, [r1], #4
                strlo   r0, [r2], #4
 80001fa:	f842 0b04 	strcc.w	r0, [r2], #4
                blo     dloop
 80001fe:	e7f8      	bcc.n	80001f2 <dloop>
#endif

#if CRT0_INIT_BSS == TRUE
                /* BSS initialization. Note, it assumes that the DATA size
                  is a multiple of 4 so the linker file must ensure this.*/
                movs    r0, #0
 8000200:	2000      	movs	r0, #0
                ldr     r1, =__bss_base__
 8000202:	4917      	ldr	r1, [pc, #92]	; (8000260 <endfiniloop+0x24>)
                ldr     r2, =__bss_end__
 8000204:	4a17      	ldr	r2, [pc, #92]	; (8000264 <endfiniloop+0x28>)

08000206 <bloop>:
bloop:
                cmp     r1, r2
 8000206:	4291      	cmp	r1, r2
                itt     lo
 8000208:	bf3c      	itt	cc
                strlo   r0, [r1], #4
 800020a:	f841 0b04 	strcc.w	r0, [r1], #4
                blo     bloop
 800020e:	e7fa      	bcc.n	8000206 <bloop>
#endif

#if CRT0_INIT_RAM_AREAS == TRUE
                /* RAM areas initialization.*/
                bl      __init_ram_areas
 8000210:	f000 f8fe 	bl	8000410 <__init_ram_areas>
#endif

                /* Late initialization..*/
                bl      __late_init
 8000214:	f000 f8ec 	bl	80003f0 <__late_init>

#if CRT0_CALL_CONSTRUCTORS == TRUE
                /* Constructors invocation.*/
                ldr     r4, =__init_array_base__
 8000218:	4c13      	ldr	r4, [pc, #76]	; (8000268 <endfiniloop+0x2c>)
                ldr     r5, =__init_array_end__
 800021a:	4d14      	ldr	r5, [pc, #80]	; (800026c <endfiniloop+0x30>)

0800021c <initloop>:
initloop:
                cmp     r4, r5
 800021c:	42ac      	cmp	r4, r5
                bge     endinitloop
 800021e:	da03      	bge.n	8000228 <endinitloop>
                ldr     r1, [r4], #4
 8000220:	f854 1b04 	ldr.w	r1, [r4], #4
                blx     r1
 8000224:	4788      	blx	r1
                b       initloop
 8000226:	e7f9      	b.n	800021c <initloop>

08000228 <endinitloop>:
endinitloop:
#endif

                /* Main program invocation, r0 contains the returned value.*/
                bl      main
 8000228:	f00a f912 	bl	800a450 <main>

#if CRT0_CALL_DESTRUCTORS == TRUE
                /* Destructors invocation.*/
                ldr     r4, =__fini_array_base__
 800022c:	4c10      	ldr	r4, [pc, #64]	; (8000270 <endfiniloop+0x34>)
                ldr     r5, =__fini_array_end__
 800022e:	4d11      	ldr	r5, [pc, #68]	; (8000274 <endfiniloop+0x38>)

08000230 <finiloop>:
finiloop:
                cmp     r4, r5
 8000230:	42ac      	cmp	r4, r5
                bge     endfiniloop
 8000232:	da03      	bge.n	800023c <endfiniloop>
                ldr     r1, [r4], #4
 8000234:	f854 1b04 	ldr.w	r1, [r4], #4
                blx     r1
 8000238:	4788      	blx	r1
                b       finiloop
 800023a:	e7f9      	b.n	8000230 <finiloop>

0800023c <endfiniloop>:
endfiniloop:
#endif

                /* Branching to the defined exit handler.*/
                b       __default_exit
 800023c:	f000 b8e0 	b.w	8000400 <__default_exit>
                ldr     r0, =__main_stack_end__
 8000240:	20000400 	.word	0x20000400
                ldr     r0, =__process_stack_end__
 8000244:	20000800 	.word	0x20000800
                ldr     r0, =_vectors
 8000248:	08000000 	.word	0x08000000
                ldr     r1, =__main_stack_base__
 800024c:	20000000 	.word	0x20000000
                ldr     r1, =__process_stack_base__
 8000250:	20000400 	.word	0x20000400
                ldr     r1, =__textdata_base__
 8000254:	0800cec4 	.word	0x0800cec4
                ldr     r2, =__data_base__
 8000258:	20000800 	.word	0x20000800
                ldr     r3, =__data_end__
 800025c:	200008dc 	.word	0x200008dc
                ldr     r1, =__bss_base__
 8000260:	200008e0 	.word	0x200008e0
                ldr     r2, =__bss_end__
 8000264:	20001e60 	.word	0x20001e60
                ldr     r4, =__init_array_base__
 8000268:	080001a0 	.word	0x080001a0
                ldr     r5, =__init_array_end__
 800026c:	080001a0 	.word	0x080001a0
                ldr     r4, =__fini_array_base__
 8000270:	080001a0 	.word	0x080001a0
                ldr     r5, =__fini_array_end__
 8000274:	080001a0 	.word	0x080001a0

08000278 <Reset_Handler>:

        .align      2
        .thumb_func
        .weak       Reset_Handler
Reset_Handler:
         b          _crt0_entry
 8000278:	e792      	b.n	80001a0 <_crt0_entry>

0800027a <BusFault_Handler>:
        .thumb_func
Vector3F8:
        .thumb_func
Vector3FC:
#endif
        bl          _unhandled_exception
 800027a:	f000 f800 	bl	800027e <_unhandled_exception>

0800027e <_unhandled_exception>:

        .thumb_func
        .weak       _unhandled_exception
_unhandled_exception:
.stay:
        b           .stay
 800027e:	e7fe      	b.n	800027e <_unhandled_exception>

08000280 <__port_switch>:
 * Performs a context switch between two threads.
 *--------------------------------------------------------------------------*/
                .thumb_func
                .globl  __port_switch
__port_switch:
                push    {r4, r5, r6, r7, r8, r9, r10, r11, lr}
 8000280:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
#if PORT_SWITCHED_REGIONS_NUMBER == 4
                push    {r4, r5, r6, r7, r8, r9, r10, r11}
#endif
#endif

                str     sp, [r1, #CONTEXT_OFFSET]
 8000284:	f8c1 d00c 	str.w	sp, [r1, #12]
#if (CORTEX_SIMPLIFIED_PRIORITY == FALSE) &&                                \
    ((CORTEX_MODEL == 3) || (CORTEX_MODEL == 4))
                /* Workaround for ARM errata 752419, only applied if
                   condition exists for it to be triggered.*/
                ldr     r3, [r0, #CONTEXT_OFFSET]
 8000288:	68c3      	ldr	r3, [r0, #12]
                mov     sp, r3
 800028a:	469d      	mov	sp, r3

#if CORTEX_USE_FPU
                /* Restoring FPU context.*/
                vpop    {s16-s31}
#endif
                pop     {r4, r5, r6, r7, r8, r9, r10, r11, pc}
 800028c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}

08000290 <__port_thread_start>:
                bl      __stats_stop_measure_crit_thd
#endif
#if CORTEX_SIMPLIFIED_PRIORITY
                cpsie   i
#else
                movs    r3, #0              /* CORTEX_BASEPRI_DISABLED */
 8000290:	2300      	movs	r3, #0
                msr     BASEPRI, r3
 8000292:	f383 8811 	msr	BASEPRI, r3
#endif
                mov     r0, r5
 8000296:	4628      	mov	r0, r5
                blx     r4
 8000298:	47a0      	blx	r4
                movs    r0, #0              /* MSG_OK */
 800029a:	2000      	movs	r0, #0
                bl      chThdExit
 800029c:	f001 fdf0 	bl	8001e80 <chThdExit>

080002a0 <.zombies>:
.zombies:       b       .zombies
 80002a0:	e7fe      	b.n	80002a0 <.zombies>

080002a2 <__port_switch_from_isr>:
                bl      __stats_start_measure_crit_thd
#endif
#if CH_DBG_SYSTEM_STATE_CHECK
                bl      __dbg_check_lock
#endif
                bl      chSchDoPreemption
 80002a2:	f001 fc5d 	bl	8001b60 <chSchDoPreemption>

080002a6 <__port_exit_from_isr>:
                movt    r3, #:upper16:SCB_ICSR
                mov     r2, ICSR_PENDSVSET
                str     r2, [r3, #0]
                cpsie   i
#else /* !CORTEX_SIMPLIFIED_PRIORITY */
                svc     #0
 80002a6:	df00      	svc	0
#endif /* !CORTEX_SIMPLIFIED_PRIORITY */
.L1:            b       .L1
 80002a8:	e7fe      	b.n	80002a8 <__port_exit_from_isr+0x2>
	...

080002ac <memcpy>:
 80002ac:	4684      	mov	ip, r0
 80002ae:	ea41 0300 	orr.w	r3, r1, r0
 80002b2:	f013 0303 	ands.w	r3, r3, #3
 80002b6:	d16d      	bne.n	8000394 <memcpy+0xe8>
 80002b8:	3a40      	subs	r2, #64	; 0x40
 80002ba:	d341      	bcc.n	8000340 <memcpy+0x94>
 80002bc:	f851 3b04 	ldr.w	r3, [r1], #4
 80002c0:	f840 3b04 	str.w	r3, [r0], #4
 80002c4:	f851 3b04 	ldr.w	r3, [r1], #4
 80002c8:	f840 3b04 	str.w	r3, [r0], #4
 80002cc:	f851 3b04 	ldr.w	r3, [r1], #4
 80002d0:	f840 3b04 	str.w	r3, [r0], #4
 80002d4:	f851 3b04 	ldr.w	r3, [r1], #4
 80002d8:	f840 3b04 	str.w	r3, [r0], #4
 80002dc:	f851 3b04 	ldr.w	r3, [r1], #4
 80002e0:	f840 3b04 	str.w	r3, [r0], #4
 80002e4:	f851 3b04 	ldr.w	r3, [r1], #4
 80002e8:	f840 3b04 	str.w	r3, [r0], #4
 80002ec:	f851 3b04 	ldr.w	r3, [r1], #4
 80002f0:	f840 3b04 	str.w	r3, [r0], #4
 80002f4:	f851 3b04 	ldr.w	r3, [r1], #4
 80002f8:	f840 3b04 	str.w	r3, [r0], #4
 80002fc:	f851 3b04 	ldr.w	r3, [r1], #4
 8000300:	f840 3b04 	str.w	r3, [r0], #4
 8000304:	f851 3b04 	ldr.w	r3, [r1], #4
 8000308:	f840 3b04 	str.w	r3, [r0], #4
 800030c:	f851 3b04 	ldr.w	r3, [r1], #4
 8000310:	f840 3b04 	str.w	r3, [r0], #4
 8000314:	f851 3b04 	ldr.w	r3, [r1], #4
 8000318:	f840 3b04 	str.w	r3, [r0], #4
 800031c:	f851 3b04 	ldr.w	r3, [r1], #4
 8000320:	f840 3b04 	str.w	r3, [r0], #4
 8000324:	f851 3b04 	ldr.w	r3, [r1], #4
 8000328:	f840 3b04 	str.w	r3, [r0], #4
 800032c:	f851 3b04 	ldr.w	r3, [r1], #4
 8000330:	f840 3b04 	str.w	r3, [r0], #4
 8000334:	f851 3b04 	ldr.w	r3, [r1], #4
 8000338:	f840 3b04 	str.w	r3, [r0], #4
 800033c:	3a40      	subs	r2, #64	; 0x40
 800033e:	d2bd      	bcs.n	80002bc <memcpy+0x10>
 8000340:	3230      	adds	r2, #48	; 0x30
 8000342:	d311      	bcc.n	8000368 <memcpy+0xbc>
 8000344:	f851 3b04 	ldr.w	r3, [r1], #4
 8000348:	f840 3b04 	str.w	r3, [r0], #4
 800034c:	f851 3b04 	ldr.w	r3, [r1], #4
 8000350:	f840 3b04 	str.w	r3, [r0], #4
 8000354:	f851 3b04 	ldr.w	r3, [r1], #4
 8000358:	f840 3b04 	str.w	r3, [r0], #4
 800035c:	f851 3b04 	ldr.w	r3, [r1], #4
 8000360:	f840 3b04 	str.w	r3, [r0], #4
 8000364:	3a10      	subs	r2, #16
 8000366:	d2ed      	bcs.n	8000344 <memcpy+0x98>
 8000368:	320c      	adds	r2, #12
 800036a:	d305      	bcc.n	8000378 <memcpy+0xcc>
 800036c:	f851 3b04 	ldr.w	r3, [r1], #4
 8000370:	f840 3b04 	str.w	r3, [r0], #4
 8000374:	3a04      	subs	r2, #4
 8000376:	d2f9      	bcs.n	800036c <memcpy+0xc0>
 8000378:	3204      	adds	r2, #4
 800037a:	d008      	beq.n	800038e <memcpy+0xe2>
 800037c:	07d2      	lsls	r2, r2, #31
 800037e:	bf1c      	itt	ne
 8000380:	f811 3b01 	ldrbne.w	r3, [r1], #1
 8000384:	f800 3b01 	strbne.w	r3, [r0], #1
 8000388:	d301      	bcc.n	800038e <memcpy+0xe2>
 800038a:	880b      	ldrh	r3, [r1, #0]
 800038c:	8003      	strh	r3, [r0, #0]
 800038e:	4660      	mov	r0, ip
 8000390:	4770      	bx	lr
 8000392:	bf00      	nop
 8000394:	2a08      	cmp	r2, #8
 8000396:	d313      	bcc.n	80003c0 <memcpy+0x114>
 8000398:	078b      	lsls	r3, r1, #30
 800039a:	d08d      	beq.n	80002b8 <memcpy+0xc>
 800039c:	f010 0303 	ands.w	r3, r0, #3
 80003a0:	d08a      	beq.n	80002b8 <memcpy+0xc>
 80003a2:	f1c3 0304 	rsb	r3, r3, #4
 80003a6:	1ad2      	subs	r2, r2, r3
 80003a8:	07db      	lsls	r3, r3, #31
 80003aa:	bf1c      	itt	ne
 80003ac:	f811 3b01 	ldrbne.w	r3, [r1], #1
 80003b0:	f800 3b01 	strbne.w	r3, [r0], #1
 80003b4:	d380      	bcc.n	80002b8 <memcpy+0xc>
 80003b6:	f831 3b02 	ldrh.w	r3, [r1], #2
 80003ba:	f820 3b02 	strh.w	r3, [r0], #2
 80003be:	e77b      	b.n	80002b8 <memcpy+0xc>
 80003c0:	3a04      	subs	r2, #4
 80003c2:	d3d9      	bcc.n	8000378 <memcpy+0xcc>
 80003c4:	3a01      	subs	r2, #1
 80003c6:	f811 3b01 	ldrb.w	r3, [r1], #1
 80003ca:	f800 3b01 	strb.w	r3, [r0], #1
 80003ce:	d2f9      	bcs.n	80003c4 <memcpy+0x118>
 80003d0:	780b      	ldrb	r3, [r1, #0]
 80003d2:	7003      	strb	r3, [r0, #0]
 80003d4:	784b      	ldrb	r3, [r1, #1]
 80003d6:	7043      	strb	r3, [r0, #1]
 80003d8:	788b      	ldrb	r3, [r1, #2]
 80003da:	7083      	strb	r3, [r0, #2]
 80003dc:	4660      	mov	r0, ip
 80003de:	4770      	bx	lr

080003e0 <__cpu_init>:

#if CORTEX_MODEL == 7
  SCB_EnableICache();
  SCB_EnableDCache();
#endif
}
 80003e0:	4770      	bx	lr
 80003e2:	bf00      	nop
	...

080003f0 <__late_init>:
 80003f0:	4770      	bx	lr
 80003f2:	bf00      	nop
	...

08000400 <__default_exit>:
#endif
/*lint -save -e9075 [8.4] All symbols are invoked from asm context.*/
void __default_exit(void) {
/*lint -restore*/

  while (true) {
 8000400:	e7fe      	b.n	8000400 <__default_exit>
 8000402:	bf00      	nop
	...

08000410 <__init_ram_areas>:
#endif

/**
 * @brief   Performs the initialization of the various RAM areas.
 */
void __init_ram_areas(void) {
 8000410:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8000412:	4d15      	ldr	r5, [pc, #84]	; (8000468 <__init_ram_areas+0x58>)
 8000414:	4f15      	ldr	r7, [pc, #84]	; (800046c <__init_ram_areas+0x5c>)
 8000416:	4916      	ldr	r1, [pc, #88]	; (8000470 <__init_ram_areas+0x60>)
 8000418:	4816      	ldr	r0, [pc, #88]	; (8000474 <__init_ram_areas+0x64>)
 800041a:	4a17      	ldr	r2, [pc, #92]	; (8000478 <__init_ram_areas+0x68>)
 800041c:	f105 0470 	add.w	r4, r5, #112	; 0x70
  do {
    uint32_t *tp = rap->init_text_area;
    uint32_t *p = rap->init_area;

    /* Copying initialization data.*/
    while (p < rap->clear_area) {
 8000420:	4281      	cmp	r1, r0
 8000422:	d90d      	bls.n	8000440 <__init_ram_areas+0x30>
 8000424:	3a04      	subs	r2, #4
 8000426:	4603      	mov	r3, r0
      *p = *tp;
 8000428:	f852 6f04 	ldr.w	r6, [r2, #4]!
 800042c:	f843 6b04 	str.w	r6, [r3], #4
    while (p < rap->clear_area) {
 8000430:	4299      	cmp	r1, r3
 8000432:	d8f9      	bhi.n	8000428 <__init_ram_areas+0x18>
      p++;
 8000434:	1e4b      	subs	r3, r1, #1
 8000436:	1a1b      	subs	r3, r3, r0
 8000438:	f023 0303 	bic.w	r3, r3, #3
 800043c:	3304      	adds	r3, #4
 800043e:	4418      	add	r0, r3
      tp++;
    }

    /* Zeroing clear area.*/
    while (p < rap->no_init_area) {
 8000440:	4287      	cmp	r7, r0
 8000442:	d907      	bls.n	8000454 <__init_ram_areas+0x44>
      *p = 0;
 8000444:	1e7a      	subs	r2, r7, #1
 8000446:	1a12      	subs	r2, r2, r0
 8000448:	f022 0203 	bic.w	r2, r2, #3
 800044c:	3204      	adds	r2, #4
 800044e:	2100      	movs	r1, #0
 8000450:	f00a f864 	bl	800a51c <memset>
      p++;
    }
    rap++;
  }
  while (rap < &ram_areas[CRT0_AREAS_NUMBER]);
 8000454:	42a5      	cmp	r5, r4
 8000456:	d005      	beq.n	8000464 <__init_ram_areas+0x54>
    uint32_t *p = rap->init_area;
 8000458:	e9d5 2004 	ldrd	r2, r0, [r5, #16]
    while (p < rap->no_init_area) {
 800045c:	e9d5 1706 	ldrd	r1, r7, [r5, #24]
 8000460:	3510      	adds	r5, #16
 8000462:	e7dd      	b.n	8000420 <__init_ram_areas+0x10>
#endif
}
 8000464:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8000466:	bf00      	nop
 8000468:	0800a640 	.word	0x0800a640
 800046c:	20001e60 	.word	0x20001e60
 8000470:	20001e60 	.word	0x20001e60
 8000474:	20001e60 	.word	0x20001e60
 8000478:	0800cfa0 	.word	0x0800cfa0
 800047c:	00000000 	.word	0x00000000

08000480 <halInit>:
 *          board-specific initialization is performed by invoking
 *          @p boardInit() (usually defined in @p board.c).
 *
 * @init
 */
void halInit(void) {
 8000480:	b508      	push	{r3, lr}

  /* Initializes the OS Abstraction Layer.*/
  osalInit();

  /* Platform low level initializations.*/
  hal_lld_init();
 8000482:	f000 fae5 	bl	8000a50 <hal_lld_init>

#if (HAL_USE_PAL == TRUE) || defined(__DOXYGEN__)
#if defined(PAL_NEW_INIT)
  palInit();
 8000486:	f000 fe6b 	bl	8001160 <_pal_lld_init>
#else
  palInit(&pal_default_config);
#endif
#endif
#if (HAL_USE_ADC == TRUE) || defined(__DOXYGEN__)
  adcInit();
 800048a:	f000 f9d1 	bl	8000830 <adcInit>
#endif
#if (HAL_USE_CRY == TRUE) || defined(__DOXYGEN__)
  cryInit();
#endif
#if (HAL_USE_DAC == TRUE) || defined(__DOXYGEN__)
  dacInit();
 800048e:	f000 f9e7 	bl	8000860 <dacInit>
#endif
#if (HAL_USE_PWM == TRUE) || defined(__DOXYGEN__)
  pwmInit();
#endif
#if (HAL_USE_SERIAL == TRUE) || defined(__DOXYGEN__)
  sdInit();
 8000492:	f000 fa3d 	bl	8000910 <sdInit>
  halCommunityInit();
#endif
#endif

  /* Board specific initialization.*/
  boardInit();
 8000496:	f001 f853 	bl	8001540 <boardInit>
 *  configured to require it.
 */
#if OSAL_ST_MODE != OSAL_ST_MODE_NONE
  stInit();
#endif
}
 800049a:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  stInit();
 800049e:	f000 b807 	b.w	80004b0 <stInit>
 80004a2:	bf00      	nop
	...

080004b0 <stInit>:

  for (i = 0U; i < (unsigned)ST_LLD_NUM_ALARMS; i++) {
    st_callbacks[i] = NULL;
  }
#endif
  st_lld_init();
 80004b0:	f000 be5e 	b.w	8001170 <st_lld_init>
	...

080004c0 <stGetCounter>:
 *
 * @notapi
 */
static inline systime_t st_lld_get_counter(void) {

  return (systime_t)STM32_ST_TIM->CNT;
 80004c0:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 80004c4:	6a58      	ldr	r0, [r3, #36]	; 0x24
 * @api
 */
systime_t stGetCounter(void) {

  return st_lld_get_counter();
}
 80004c6:	4770      	bx	lr
	...

080004d0 <stStartAlarm>:
 *
 * @notapi
 */
static inline void st_lld_start_alarm(systime_t abstime) {

  STM32_ST_TIM->CCR[0] = (uint32_t)abstime;
 80004d0:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
  STM32_ST_TIM->SR     = 0;
 80004d4:	2100      	movs	r1, #0
#if ST_LLD_NUM_ALARMS == 1
  STM32_ST_TIM->DIER   = STM32_TIM_DIER_CC1IE;
 80004d6:	2202      	movs	r2, #2
  STM32_ST_TIM->CCR[0] = (uint32_t)abstime;
 80004d8:	6358      	str	r0, [r3, #52]	; 0x34
  STM32_ST_TIM->SR     = 0;
 80004da:	6119      	str	r1, [r3, #16]
  STM32_ST_TIM->DIER   = STM32_TIM_DIER_CC1IE;
 80004dc:	60da      	str	r2, [r3, #12]
void stStartAlarm(systime_t abstime) {

  osalDbgAssert(stIsAlarmActive() == false, "already active");

  st_lld_start_alarm(abstime);
}
 80004de:	4770      	bx	lr

080004e0 <stStopAlarm>:
 * @notapi
 */
static inline void st_lld_stop_alarm(void) {

#if ST_LLD_NUM_ALARMS == 1
  STM32_ST_TIM->DIER = 0U;
 80004e0:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 80004e4:	2200      	movs	r2, #0
 80004e6:	60da      	str	r2, [r3, #12]
 * @api
 */
void stStopAlarm(void) {

  st_lld_stop_alarm();
}
 80004e8:	4770      	bx	lr
 80004ea:	bf00      	nop
 80004ec:	0000      	movs	r0, r0
	...

080004f0 <stSetAlarm>:
 *
 * @notapi
 */
static inline void st_lld_set_alarm(systime_t abstime) {

  STM32_ST_TIM->CCR[0] = (uint32_t)abstime;
 80004f0:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 80004f4:	6358      	str	r0, [r3, #52]	; 0x34
void stSetAlarm(systime_t abstime) {

  osalDbgAssert(stIsAlarmActive() != false, "not active");

  st_lld_set_alarm(abstime);
}
 80004f6:	4770      	bx	lr
	...

08000500 <iq_read>:
 *                      value 0 is reserved
 * @return              The number of bytes effectively transferred.
 *
 * @notapi
 */
static size_t iq_read(input_queue_t *iqp, uint8_t *bp, size_t n) {
 8000500:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8000502:	4604      	mov	r4, r0
  size_t s1, s2;

  osalDbgCheck(n > 0U);

  /* Number of bytes that can be read in a single atomic operation.*/
  if (n > iqGetFullI(iqp)) {
 8000504:	6880      	ldr	r0, [r0, #8]
    n = iqGetFullI(iqp);
  }

  /* Number of bytes before buffer limit.*/
  /*lint -save -e9033 [10.8] Checked to be safe.*/
  s1 = (size_t)(iqp->q_top - iqp->q_rdptr);
 8000506:	6926      	ldr	r6, [r4, #16]
  if (n > iqGetFullI(iqp)) {
 8000508:	4290      	cmp	r0, r2
static size_t iq_read(input_queue_t *iqp, uint8_t *bp, size_t n) {
 800050a:	460b      	mov	r3, r1
  s1 = (size_t)(iqp->q_top - iqp->q_rdptr);
 800050c:	69a1      	ldr	r1, [r4, #24]
    n = iqGetFullI(iqp);
 800050e:	bf34      	ite	cc
 8000510:	68a5      	ldrcc	r5, [r4, #8]
 8000512:	4615      	movcs	r5, r2
  s1 = (size_t)(iqp->q_top - iqp->q_rdptr);
 8000514:	1a76      	subs	r6, r6, r1
  /*lint -restore*/
  if (n < s1) {
 8000516:	42b5      	cmp	r5, r6
 8000518:	d31d      	bcc.n	8000556 <iq_read+0x56>
    memcpy((void *)bp, (void *)iqp->q_rdptr, n);
    iqp->q_rdptr += n;
  }
  else if (n > s1) {
 800051a:	d80a      	bhi.n	8000532 <iq_read+0x32>
    s2 = n - s1;
    memcpy((void *)bp, (void *)iqp->q_buffer, s2);
    iqp->q_rdptr = iqp->q_buffer + s2;
  }
  else {
    memcpy((void *)bp, (void *)iqp->q_rdptr, n);
 800051c:	462a      	mov	r2, r5
 800051e:	4618      	mov	r0, r3
 8000520:	f7ff fec4 	bl	80002ac <memcpy>
    iqp->q_rdptr = iqp->q_buffer;
  }

  iqp->q_counter -= n;
 8000524:	68a2      	ldr	r2, [r4, #8]
    iqp->q_rdptr = iqp->q_buffer;
 8000526:	68e3      	ldr	r3, [r4, #12]
 8000528:	61a3      	str	r3, [r4, #24]
  return n;
}
 800052a:	4628      	mov	r0, r5
  iqp->q_counter -= n;
 800052c:	1b55      	subs	r5, r2, r5
 800052e:	60a5      	str	r5, [r4, #8]
}
 8000530:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    memcpy((void *)bp, (void *)iqp->q_rdptr, s1);
 8000532:	4632      	mov	r2, r6
 8000534:	4618      	mov	r0, r3
 8000536:	f7ff feb9 	bl	80002ac <memcpy>
    s2 = n - s1;
 800053a:	1baf      	subs	r7, r5, r6
    memcpy((void *)bp, (void *)iqp->q_buffer, s2);
 800053c:	463a      	mov	r2, r7
 800053e:	68e1      	ldr	r1, [r4, #12]
 8000540:	4430      	add	r0, r6
 8000542:	f7ff feb3 	bl	80002ac <memcpy>
  iqp->q_counter -= n;
 8000546:	68a2      	ldr	r2, [r4, #8]
    iqp->q_rdptr = iqp->q_buffer + s2;
 8000548:	68e3      	ldr	r3, [r4, #12]
}
 800054a:	4628      	mov	r0, r5
    iqp->q_rdptr = iqp->q_buffer + s2;
 800054c:	443b      	add	r3, r7
  iqp->q_counter -= n;
 800054e:	1b55      	subs	r5, r2, r5
    iqp->q_rdptr = iqp->q_buffer + s2;
 8000550:	61a3      	str	r3, [r4, #24]
  iqp->q_counter -= n;
 8000552:	60a5      	str	r5, [r4, #8]
}
 8000554:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    memcpy((void *)bp, (void *)iqp->q_rdptr, n);
 8000556:	462a      	mov	r2, r5
 8000558:	4618      	mov	r0, r3
 800055a:	f7ff fea7 	bl	80002ac <memcpy>
    iqp->q_rdptr += n;
 800055e:	69a3      	ldr	r3, [r4, #24]
  iqp->q_counter -= n;
 8000560:	68a2      	ldr	r2, [r4, #8]
    iqp->q_rdptr += n;
 8000562:	442b      	add	r3, r5
}
 8000564:	4628      	mov	r0, r5
  iqp->q_counter -= n;
 8000566:	1b55      	subs	r5, r2, r5
    iqp->q_rdptr += n;
 8000568:	61a3      	str	r3, [r4, #24]
  iqp->q_counter -= n;
 800056a:	60a5      	str	r5, [r4, #8]
}
 800056c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 800056e:	bf00      	nop

08000570 <oq_write>:
  size_t s1, s2;

  osalDbgCheck(n > 0U);

  /* Number of bytes that can be written in a single atomic operation.*/
  if (n > oqGetEmptyI(oqp)) {
 8000570:	6883      	ldr	r3, [r0, #8]
 8000572:	4293      	cmp	r3, r2
static size_t oq_write(output_queue_t *oqp, const uint8_t *bp, size_t n) {
 8000574:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    n = oqGetEmptyI(oqp);
 8000578:	bf38      	it	cc
 800057a:	6885      	ldrcc	r5, [r0, #8]
static size_t oq_write(output_queue_t *oqp, const uint8_t *bp, size_t n) {
 800057c:	4604      	mov	r4, r0
  }

  /* Number of bytes before buffer limit.*/
  /*lint -save -e9033 [10.8] Checked to be safe.*/
  s1 = (size_t)(oqp->q_top - oqp->q_wrptr);
 800057e:	e9d0 6004 	ldrd	r6, r0, [r0, #16]
 8000582:	bf28      	it	cs
 8000584:	4615      	movcs	r5, r2
 8000586:	1a36      	subs	r6, r6, r0
  /*lint -restore*/
  if (n < s1) {
 8000588:	42b5      	cmp	r5, r6
static size_t oq_write(output_queue_t *oqp, const uint8_t *bp, size_t n) {
 800058a:	460f      	mov	r7, r1
  if (n < s1) {
 800058c:	d319      	bcc.n	80005c2 <oq_write+0x52>
    memcpy((void *)oqp->q_wrptr, (const void *)bp, n);
    oqp->q_wrptr += n;
  }
  else if (n > s1) {
 800058e:	d80a      	bhi.n	80005a6 <oq_write+0x36>
    s2 = n - s1;
    memcpy((void *)oqp->q_buffer, (const void *)bp, s2);
    oqp->q_wrptr = oqp->q_buffer + s2;
  }
  else {
    memcpy((void *)oqp->q_wrptr, (const void *)bp, n);
 8000590:	462a      	mov	r2, r5
 8000592:	f7ff fe8b 	bl	80002ac <memcpy>
    oqp->q_wrptr = oqp->q_buffer;
 8000596:	68e3      	ldr	r3, [r4, #12]
 8000598:	6163      	str	r3, [r4, #20]
  }

  oqp->q_counter -= n;
 800059a:	68a2      	ldr	r2, [r4, #8]
  return n;
}
 800059c:	4628      	mov	r0, r5
  oqp->q_counter -= n;
 800059e:	1b55      	subs	r5, r2, r5
 80005a0:	60a5      	str	r5, [r4, #8]
}
 80005a2:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    memcpy((void *)oqp->q_wrptr, (const void *)bp, s1);
 80005a6:	4632      	mov	r2, r6
    s2 = n - s1;
 80005a8:	eba5 0806 	sub.w	r8, r5, r6
    memcpy((void *)oqp->q_wrptr, (const void *)bp, s1);
 80005ac:	f7ff fe7e 	bl	80002ac <memcpy>
    memcpy((void *)oqp->q_buffer, (const void *)bp, s2);
 80005b0:	68e0      	ldr	r0, [r4, #12]
 80005b2:	19b9      	adds	r1, r7, r6
 80005b4:	4642      	mov	r2, r8
 80005b6:	f7ff fe79 	bl	80002ac <memcpy>
    oqp->q_wrptr = oqp->q_buffer + s2;
 80005ba:	68e3      	ldr	r3, [r4, #12]
 80005bc:	4443      	add	r3, r8
 80005be:	6163      	str	r3, [r4, #20]
 80005c0:	e7eb      	b.n	800059a <oq_write+0x2a>
    memcpy((void *)oqp->q_wrptr, (const void *)bp, n);
 80005c2:	462a      	mov	r2, r5
 80005c4:	f7ff fe72 	bl	80002ac <memcpy>
    oqp->q_wrptr += n;
 80005c8:	6963      	ldr	r3, [r4, #20]
 80005ca:	442b      	add	r3, r5
 80005cc:	6163      	str	r3, [r4, #20]
 80005ce:	e7e4      	b.n	800059a <oq_write+0x2a>

080005d0 <iqObjectInit>:
  iqp->q_buffer  = bp;
  iqp->q_rdptr   = bp;
  iqp->q_wrptr   = bp;
  iqp->q_top     = bp + size;
  iqp->q_notify  = infy;
  iqp->q_link    = link;
 80005d0:	f8dd c000 	ldr.w	ip, [sp]
  iqp->q_buffer  = bp;
 80005d4:	60c1      	str	r1, [r0, #12]
  iqp->q_notify  = infy;
 80005d6:	e9c0 3c07 	strd	r3, ip, [r0, #28]
  iqp->q_top     = bp + size;
 80005da:	440a      	add	r2, r1
  iqp->q_counter = 0;
 80005dc:	2300      	movs	r3, #0
 * @notapi
 */
static inline void ch_queue_init(ch_queue_t *qp) {

  qp->next = qp;
  qp->prev = qp;
 80005de:	e9c0 0000 	strd	r0, r0, [r0]
  iqp->q_wrptr   = bp;
 80005e2:	e9c0 1105 	strd	r1, r1, [r0, #20]
  iqp->q_top     = bp + size;
 80005e6:	6102      	str	r2, [r0, #16]
  iqp->q_counter = 0;
 80005e8:	6083      	str	r3, [r0, #8]
}
 80005ea:	4770      	bx	lr
 80005ec:	0000      	movs	r0, r0
	...

080005f0 <iqPutI>:
msg_t iqPutI(input_queue_t *iqp, uint8_t b) {

  osalDbgCheckClassI();

  /* Queue space check.*/
  if (!iqIsFullI(iqp)) {
 80005f0:	e9d0 3205 	ldrd	r3, r2, [r0, #20]
 80005f4:	4293      	cmp	r3, r2
 80005f6:	d011      	beq.n	800061c <iqPutI+0x2c>
    iqp->q_counter++;
 80005f8:	6882      	ldr	r2, [r0, #8]
msg_t iqPutI(input_queue_t *iqp, uint8_t b) {
 80005fa:	b510      	push	{r4, lr}
    iqp->q_counter++;
 80005fc:	3201      	adds	r2, #1
    *iqp->q_wrptr++ = b;
 80005fe:	1c5c      	adds	r4, r3, #1
 8000600:	6144      	str	r4, [r0, #20]
    iqp->q_counter++;
 8000602:	6082      	str	r2, [r0, #8]
    *iqp->q_wrptr++ = b;
 8000604:	7019      	strb	r1, [r3, #0]
    if (iqp->q_wrptr >= iqp->q_top) {
 8000606:	e9d0 3204 	ldrd	r3, r2, [r0, #16]
 800060a:	429a      	cmp	r2, r3
 800060c:	d301      	bcc.n	8000612 <iqPutI+0x22>
      iqp->q_wrptr = iqp->q_buffer;
 800060e:	68c3      	ldr	r3, [r0, #12]
 8000610:	6143      	str	r3, [r0, #20]
 *
 * @iclass
 */
static inline void osalThreadDequeueNextI(threads_queue_t *tqp, msg_t msg) {

  chThdDequeueNextI(tqp, msg);
 8000612:	2100      	movs	r1, #0
 8000614:	f001 fd44 	bl	80020a0 <chThdDequeueNextI>
    }

    osalThreadDequeueNextI(&iqp->q_waiting, MSG_OK);

    return MSG_OK;
 8000618:	2000      	movs	r0, #0
  }

  return MSG_TIMEOUT;
}
 800061a:	bd10      	pop	{r4, pc}
  if (!iqIsFullI(iqp)) {
 800061c:	6882      	ldr	r2, [r0, #8]
 800061e:	2a00      	cmp	r2, #0
 8000620:	d0ea      	beq.n	80005f8 <iqPutI+0x8>
  return MSG_TIMEOUT;
 8000622:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
}
 8000626:	4770      	bx	lr
	...

08000630 <iqGetTimeout>:
 * @retval MSG_TIMEOUT  if the specified time expired.
 * @retval MSG_RESET    if the queue has been reset.
 *
 * @api
 */
msg_t iqGetTimeout(input_queue_t *iqp, sysinterval_t timeout) {
 8000630:	b570      	push	{r4, r5, r6, lr}
  \details Assigns the given value to the Base Priority register.
  \param [in]    basePri  Base Priority value to set
 */
__STATIC_FORCEINLINE void __set_BASEPRI(uint32_t basePri)
{
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 8000632:	2330      	movs	r3, #48	; 0x30
 8000634:	4605      	mov	r5, r0
 8000636:	460e      	mov	r6, r1
 8000638:	f383 8811 	msr	BASEPRI, r3
}
 800063c:	e003      	b.n	8000646 <iqGetTimeout+0x16>
  return chThdEnqueueTimeoutS(tqp, timeout);
 800063e:	f001 fd17 	bl	8002070 <chThdEnqueueTimeoutS>
  osalSysLock();

  /* Waiting until there is a character available or a timeout occurs.*/
  while (iqIsEmptyI(iqp)) {
    msg_t msg = osalThreadEnqueueTimeoutS(&iqp->q_waiting, timeout);
    if (msg < MSG_OK) {
 8000642:	2800      	cmp	r0, #0
 8000644:	db19      	blt.n	800067a <iqGetTimeout+0x4a>
  while (iqIsEmptyI(iqp)) {
 8000646:	68ac      	ldr	r4, [r5, #8]
 8000648:	4631      	mov	r1, r6
 800064a:	4628      	mov	r0, r5
 800064c:	2c00      	cmp	r4, #0
 800064e:	d0f6      	beq.n	800063e <iqGetTimeout+0xe>
      return msg;
    }
  }

  /* Getting the character from the queue.*/
  iqp->q_counter--;
 8000650:	68ab      	ldr	r3, [r5, #8]
  b = *iqp->q_rdptr++;
 8000652:	69a9      	ldr	r1, [r5, #24]
  iqp->q_counter--;
 8000654:	3b01      	subs	r3, #1
 8000656:	60ab      	str	r3, [r5, #8]
  if (iqp->q_rdptr >= iqp->q_top) {
 8000658:	692b      	ldr	r3, [r5, #16]
  b = *iqp->q_rdptr++;
 800065a:	1c4a      	adds	r2, r1, #1
  if (iqp->q_rdptr >= iqp->q_top) {
 800065c:	429a      	cmp	r2, r3
    iqp->q_rdptr = iqp->q_buffer;
 800065e:	bf28      	it	cs
 8000660:	68eb      	ldrcs	r3, [r5, #12]
  b = *iqp->q_rdptr++;
 8000662:	61aa      	str	r2, [r5, #24]
 8000664:	780c      	ldrb	r4, [r1, #0]
    iqp->q_rdptr = iqp->q_buffer;
 8000666:	bf28      	it	cs
 8000668:	61ab      	strcs	r3, [r5, #24]
  }

  /* Inform the low side that the queue has at least one slot available.*/
  if (iqp->q_notify != NULL) {
 800066a:	69eb      	ldr	r3, [r5, #28]
 800066c:	b103      	cbz	r3, 8000670 <iqGetTimeout+0x40>
    iqp->q_notify(iqp);
 800066e:	4798      	blx	r3
 8000670:	2300      	movs	r3, #0
 8000672:	f383 8811 	msr	BASEPRI, r3
  }

  osalSysUnlock();

  return (msg_t)b;
 8000676:	4620      	mov	r0, r4
}
 8000678:	bd70      	pop	{r4, r5, r6, pc}
 800067a:	f384 8811 	msr	BASEPRI, r4
 800067e:	bd70      	pop	{r4, r5, r6, pc}

08000680 <iqReadTimeout>:
 * @return              The number of bytes effectively transferred.
 *
 * @api
 */
size_t iqReadTimeout(input_queue_t *iqp, uint8_t *bp,
                     size_t n, sysinterval_t timeout) {
 8000680:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8000684:	b083      	sub	sp, #12
  qnotify_t nfy = iqp->q_notify;
 8000686:	69c7      	ldr	r7, [r0, #28]
                     size_t n, sysinterval_t timeout) {
 8000688:	9201      	str	r2, [sp, #4]
 800068a:	469b      	mov	fp, r3
 800068c:	f04f 0830 	mov.w	r8, #48	; 0x30
 8000690:	f388 8811 	msr	BASEPRI, r8

  osalDbgCheck(n > 0U);

  osalSysLock();

  while (n > 0U) {
 8000694:	b1ca      	cbz	r2, 80006ca <iqReadTimeout+0x4a>
 8000696:	f8dd a004 	ldr.w	sl, [sp, #4]
 800069a:	4605      	mov	r5, r0
 800069c:	460e      	mov	r6, r1
 800069e:	f04f 0900 	mov.w	r9, #0
    size_t done;

    done = iq_read(iqp, bp, n);
 80006a2:	4652      	mov	r2, sl
 80006a4:	4631      	mov	r1, r6
 80006a6:	4628      	mov	r0, r5
 80006a8:	f7ff ff2a 	bl	8000500 <iq_read>
 80006ac:	4604      	mov	r4, r0
    }
    else {
      /* Inform the low side that the queue has at least one empty slot
         available.*/
      if (nfy != NULL) {
        nfy(iqp);
 80006ae:	4628      	mov	r0, r5
    if (done == (size_t)0) {
 80006b0:	b194      	cbz	r4, 80006d8 <iqReadTimeout+0x58>
      if (nfy != NULL) {
 80006b2:	b107      	cbz	r7, 80006b6 <iqReadTimeout+0x36>
        nfy(iqp);
 80006b4:	47b8      	blx	r7
 80006b6:	f389 8811 	msr	BASEPRI, r9
      }

      /* Giving a preemption chance in a controlled point.*/
      osalSysUnlock();

      n  -= done;
 80006ba:	ebaa 0a04 	sub.w	sl, sl, r4
      bp += done;
 80006be:	4426      	add	r6, r4
 80006c0:	f388 8811 	msr	BASEPRI, r8
  while (n > 0U) {
 80006c4:	f1ba 0f00 	cmp.w	sl, #0
 80006c8:	d1eb      	bne.n	80006a2 <iqReadTimeout+0x22>
 80006ca:	9801      	ldr	r0, [sp, #4]
 80006cc:	2300      	movs	r3, #0
 80006ce:	f383 8811 	msr	BASEPRI, r3
    }
  }

  osalSysUnlock();
  return max - n;
}
 80006d2:	b003      	add	sp, #12
 80006d4:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 80006d8:	4659      	mov	r1, fp
 80006da:	f001 fcc9 	bl	8002070 <chThdEnqueueTimeoutS>
      if (msg != MSG_OK) {
 80006de:	2800      	cmp	r0, #0
 80006e0:	d0df      	beq.n	80006a2 <iqReadTimeout+0x22>
  return max - n;
 80006e2:	9b01      	ldr	r3, [sp, #4]
 80006e4:	eba3 000a 	sub.w	r0, r3, sl
 80006e8:	2300      	movs	r3, #0
 80006ea:	f383 8811 	msr	BASEPRI, r3
}
 80006ee:	b003      	add	sp, #12
 80006f0:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	...

08000700 <oqObjectInit>:
  oqp->q_buffer  = bp;
  oqp->q_rdptr   = bp;
  oqp->q_wrptr   = bp;
  oqp->q_top     = bp + size;
  oqp->q_notify  = onfy;
  oqp->q_link    = link;
 8000700:	f8dd c000 	ldr.w	ip, [sp]
  oqp->q_counter = size;
 8000704:	6082      	str	r2, [r0, #8]
  oqp->q_top     = bp + size;
 8000706:	440a      	add	r2, r1
  oqp->q_notify  = onfy;
 8000708:	e9c0 3c07 	strd	r3, ip, [r0, #28]
 800070c:	e9c0 0000 	strd	r0, r0, [r0]
  oqp->q_buffer  = bp;
 8000710:	e9c0 1203 	strd	r1, r2, [r0, #12]
  oqp->q_wrptr   = bp;
 8000714:	e9c0 1105 	strd	r1, r1, [r0, #20]
}
 8000718:	4770      	bx	lr
 800071a:	bf00      	nop
 800071c:	0000      	movs	r0, r0
	...

08000720 <oqPutTimeout>:
 * @retval MSG_TIMEOUT  if the specified time expired.
 * @retval MSG_RESET    if the queue has been reset.
 *
 * @api
 */
msg_t oqPutTimeout(output_queue_t *oqp, uint8_t b, sysinterval_t timeout) {
 8000720:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8000722:	4604      	mov	r4, r0
 8000724:	460f      	mov	r7, r1
 8000726:	4616      	mov	r6, r2
 8000728:	2330      	movs	r3, #48	; 0x30
 800072a:	f383 8811 	msr	BASEPRI, r3
}
 800072e:	e003      	b.n	8000738 <oqPutTimeout+0x18>
  return chThdEnqueueTimeoutS(tqp, timeout);
 8000730:	f001 fc9e 	bl	8002070 <chThdEnqueueTimeoutS>
  osalSysLock();

  /* Waiting until there is a slot available or a timeout occurs.*/
  while (oqIsFullI(oqp)) {
    msg_t msg = osalThreadEnqueueTimeoutS(&oqp->q_waiting, timeout);
    if (msg < MSG_OK) {
 8000734:	2800      	cmp	r0, #0
 8000736:	db18      	blt.n	800076a <oqPutTimeout+0x4a>
  while (oqIsFullI(oqp)) {
 8000738:	68a5      	ldr	r5, [r4, #8]
 800073a:	4631      	mov	r1, r6
 800073c:	4620      	mov	r0, r4
 800073e:	2d00      	cmp	r5, #0
 8000740:	d0f6      	beq.n	8000730 <oqPutTimeout+0x10>
    }
  }

  /* Putting the character into the queue.*/
  oqp->q_counter--;
  *oqp->q_wrptr++ = b;
 8000742:	6962      	ldr	r2, [r4, #20]
  oqp->q_counter--;
 8000744:	68a3      	ldr	r3, [r4, #8]
  *oqp->q_wrptr++ = b;
 8000746:	1c51      	adds	r1, r2, #1
  oqp->q_counter--;
 8000748:	3b01      	subs	r3, #1
  *oqp->q_wrptr++ = b;
 800074a:	6161      	str	r1, [r4, #20]
  oqp->q_counter--;
 800074c:	60a3      	str	r3, [r4, #8]
  *oqp->q_wrptr++ = b;
 800074e:	7017      	strb	r7, [r2, #0]
  if (oqp->q_wrptr >= oqp->q_top) {
 8000750:	e9d4 3204 	ldrd	r3, r2, [r4, #16]
 8000754:	429a      	cmp	r2, r3
    oqp->q_wrptr = oqp->q_buffer;
 8000756:	bf24      	itt	cs
 8000758:	68e3      	ldrcs	r3, [r4, #12]
 800075a:	6163      	strcs	r3, [r4, #20]
  }

  /* Inform the low side that the queue has at least one character available.*/
  if (oqp->q_notify != NULL) {
 800075c:	69e3      	ldr	r3, [r4, #28]
 800075e:	b103      	cbz	r3, 8000762 <oqPutTimeout+0x42>
    oqp->q_notify(oqp);
 8000760:	4798      	blx	r3
 8000762:	2000      	movs	r0, #0
 8000764:	f380 8811 	msr	BASEPRI, r0
  }

  osalSysUnlock();

  return MSG_OK;
}
 8000768:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 800076a:	f385 8811 	msr	BASEPRI, r5
 800076e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

08000770 <oqGetI>:
msg_t oqGetI(output_queue_t *oqp) {

  osalDbgCheckClassI();

  /* Queue data check.*/
  if (!oqIsEmptyI(oqp)) {
 8000770:	e9d0 2305 	ldrd	r2, r3, [r0, #20]
 8000774:	429a      	cmp	r2, r3
 8000776:	d010      	beq.n	800079a <oqGetI+0x2a>
msg_t oqGetI(output_queue_t *oqp) {
 8000778:	b510      	push	{r4, lr}
    uint8_t b;

    oqp->q_counter++;
 800077a:	6882      	ldr	r2, [r0, #8]
    b = *oqp->q_rdptr++;
 800077c:	1c59      	adds	r1, r3, #1
    oqp->q_counter++;
 800077e:	3201      	adds	r2, #1
 8000780:	6082      	str	r2, [r0, #8]
    b = *oqp->q_rdptr++;
 8000782:	6181      	str	r1, [r0, #24]
 8000784:	781c      	ldrb	r4, [r3, #0]
    if (oqp->q_rdptr >= oqp->q_top) {
 8000786:	6903      	ldr	r3, [r0, #16]
 8000788:	4299      	cmp	r1, r3
 800078a:	d301      	bcc.n	8000790 <oqGetI+0x20>
      oqp->q_rdptr = oqp->q_buffer;
 800078c:	68c3      	ldr	r3, [r0, #12]
 800078e:	6183      	str	r3, [r0, #24]
  chThdDequeueNextI(tqp, msg);
 8000790:	2100      	movs	r1, #0
 8000792:	f001 fc85 	bl	80020a0 <chThdDequeueNextI>
    }

    osalThreadDequeueNextI(&oqp->q_waiting, MSG_OK);

    return (msg_t)b;
 8000796:	4620      	mov	r0, r4
  }

  return MSG_TIMEOUT;
}
 8000798:	bd10      	pop	{r4, pc}
  if (!oqIsEmptyI(oqp)) {
 800079a:	6882      	ldr	r2, [r0, #8]
 800079c:	2a00      	cmp	r2, #0
 800079e:	d0eb      	beq.n	8000778 <oqGetI+0x8>
  return MSG_TIMEOUT;
 80007a0:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
}
 80007a4:	4770      	bx	lr
 80007a6:	bf00      	nop
	...

080007b0 <oqWriteTimeout>:
 * @return              The number of bytes effectively transferred.
 *
 * @api
 */
size_t oqWriteTimeout(output_queue_t *oqp, const uint8_t *bp,
                      size_t n, sysinterval_t timeout) {
 80007b0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 80007b4:	b083      	sub	sp, #12
  qnotify_t nfy = oqp->q_notify;
 80007b6:	69c7      	ldr	r7, [r0, #28]
                      size_t n, sysinterval_t timeout) {
 80007b8:	9201      	str	r2, [sp, #4]
 80007ba:	469b      	mov	fp, r3
 80007bc:	f04f 0830 	mov.w	r8, #48	; 0x30
 80007c0:	f388 8811 	msr	BASEPRI, r8

  osalDbgCheck(n > 0U);

  osalSysLock();

  while (n > 0U) {
 80007c4:	b1ca      	cbz	r2, 80007fa <oqWriteTimeout+0x4a>
 80007c6:	f8dd a004 	ldr.w	sl, [sp, #4]
 80007ca:	4605      	mov	r5, r0
 80007cc:	460e      	mov	r6, r1
 80007ce:	f04f 0900 	mov.w	r9, #0
    size_t done;

    done = oq_write(oqp, bp, n);
 80007d2:	4652      	mov	r2, sl
 80007d4:	4631      	mov	r1, r6
 80007d6:	4628      	mov	r0, r5
 80007d8:	f7ff feca 	bl	8000570 <oq_write>
 80007dc:	4604      	mov	r4, r0
    }
    else {
      /* Inform the low side that the queue has at least one character
         available.*/
      if (nfy != NULL) {
        nfy(oqp);
 80007de:	4628      	mov	r0, r5
    if (done == (size_t)0) {
 80007e0:	b194      	cbz	r4, 8000808 <oqWriteTimeout+0x58>
      if (nfy != NULL) {
 80007e2:	b107      	cbz	r7, 80007e6 <oqWriteTimeout+0x36>
        nfy(oqp);
 80007e4:	47b8      	blx	r7
 80007e6:	f389 8811 	msr	BASEPRI, r9
      }

      /* Giving a preemption chance in a controlled point.*/
      osalSysUnlock();

      n  -= done;
 80007ea:	ebaa 0a04 	sub.w	sl, sl, r4
      bp += done;
 80007ee:	4426      	add	r6, r4
 80007f0:	f388 8811 	msr	BASEPRI, r8
  while (n > 0U) {
 80007f4:	f1ba 0f00 	cmp.w	sl, #0
 80007f8:	d1eb      	bne.n	80007d2 <oqWriteTimeout+0x22>
 80007fa:	9801      	ldr	r0, [sp, #4]
 80007fc:	2300      	movs	r3, #0
 80007fe:	f383 8811 	msr	BASEPRI, r3
    }
  }

  osalSysUnlock();
  return max - n;
}
 8000802:	b003      	add	sp, #12
 8000804:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  return chThdEnqueueTimeoutS(tqp, timeout);
 8000808:	4659      	mov	r1, fp
 800080a:	f001 fc31 	bl	8002070 <chThdEnqueueTimeoutS>
      if (msg != MSG_OK) {
 800080e:	2800      	cmp	r0, #0
 8000810:	d0df      	beq.n	80007d2 <oqWriteTimeout+0x22>
  return max - n;
 8000812:	9b01      	ldr	r3, [sp, #4]
 8000814:	eba3 000a 	sub.w	r0, r3, sl
 8000818:	2300      	movs	r3, #0
 800081a:	f383 8811 	msr	BASEPRI, r3
}
 800081e:	b003      	add	sp, #12
 8000820:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	...

08000830 <adcInit>:
 *
 * @init
 */
void adcInit(void) {

  adc_lld_init();
 8000830:	f000 b9fe 	b.w	8000c30 <adc_lld_init>
	...

08000840 <adcObjectInit>:
 * @init
 */
void adcObjectInit(ADCDriver *adcp) {

  adcp->state    = ADC_STOP;
  adcp->config   = NULL;
 8000840:	2300      	movs	r3, #0
  adcp->state    = ADC_STOP;
 8000842:	2201      	movs	r2, #1
  adcp->samples  = NULL;
 8000844:	e9c0 3301 	strd	r3, r3, [r0, #4]
  adcp->depth    = 0;
  adcp->grpp     = NULL;
 8000848:	e9c0 3303 	strd	r3, r3, [r0, #12]
  adcp->state    = ADC_STOP;
 800084c:	7002      	strb	r2, [r0, #0]
#if ADC_USE_WAIT == TRUE
  adcp->thread   = NULL;
 800084e:	6143      	str	r3, [r0, #20]
 * @init
 */
static inline void osalMutexObjectInit(mutex_t *mp) {

#if CH_CFG_USE_MUTEXES
  chMtxObjectInit(mp);
 8000850:	3018      	adds	r0, #24
 8000852:	f001 bdb5 	b.w	80023c0 <chMtxObjectInit>
 8000856:	bf00      	nop
	...

08000860 <dacInit>:
 *
 * @init
 */
void dacInit(void) {

  dac_lld_init();
 8000860:	f000 ba96 	b.w	8000d90 <dac_lld_init>
	...

08000870 <dacObjectInit>:
 * @init
 */
void dacObjectInit(DACDriver *dacp) {

  dacp->state = DAC_STOP;
  dacp->config = NULL;
 8000870:	2300      	movs	r3, #0
  dacp->state = DAC_STOP;
 8000872:	2201      	movs	r2, #1
#if DAC_USE_WAIT
  dacp->thread = NULL;
 8000874:	e9c0 3304 	strd	r3, r3, [r0, #16]
  dacp->state = DAC_STOP;
 8000878:	7002      	strb	r2, [r0, #0]
 800087a:	3018      	adds	r0, #24
 800087c:	f001 bda0 	b.w	80023c0 <chMtxObjectInit>

08000880 <_readt>:
}

static size_t _readt(void *ip, uint8_t *bp, size_t n,
                     sysinterval_t timeout) {

  return iqReadTimeout(&((SerialDriver *)ip)->iqueue, bp, n, timeout);
 8000880:	300c      	adds	r0, #12
 8000882:	f7ff befd 	b.w	8000680 <iqReadTimeout>
 8000886:	bf00      	nop
	...

08000890 <_read>:
  return iqReadTimeout(&((SerialDriver *)ip)->iqueue, bp,
 8000890:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
 8000894:	300c      	adds	r0, #12
 8000896:	f7ff bef3 	b.w	8000680 <iqReadTimeout>
 800089a:	bf00      	nop
 800089c:	0000      	movs	r0, r0
	...

080008a0 <_writet>:
  return oqWriteTimeout(&((SerialDriver *)ip)->oqueue, bp, n, timeout);
 80008a0:	3030      	adds	r0, #48	; 0x30
 80008a2:	f7ff bf85 	b.w	80007b0 <oqWriteTimeout>
 80008a6:	bf00      	nop
	...

080008b0 <_write>:
  return oqWriteTimeout(&((SerialDriver *)ip)->oqueue, bp,
 80008b0:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
 80008b4:	3030      	adds	r0, #48	; 0x30
 80008b6:	f7ff bf7b 	b.w	80007b0 <oqWriteTimeout>
 80008ba:	bf00      	nop
 80008bc:	0000      	movs	r0, r0
	...

080008c0 <_gett>:
  return iqGetTimeout(&((SerialDriver *)ip)->iqueue, timeout);
 80008c0:	300c      	adds	r0, #12
 80008c2:	f7ff beb5 	b.w	8000630 <iqGetTimeout>
 80008c6:	bf00      	nop
	...

080008d0 <_get>:
  return iqGetTimeout(&((SerialDriver *)ip)->iqueue, TIME_INFINITE);
 80008d0:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
 80008d4:	300c      	adds	r0, #12
 80008d6:	f7ff beab 	b.w	8000630 <iqGetTimeout>
 80008da:	bf00      	nop
 80008dc:	0000      	movs	r0, r0
	...

080008e0 <_putt>:
  return oqPutTimeout(&((SerialDriver *)ip)->oqueue, b, timeout);
 80008e0:	3030      	adds	r0, #48	; 0x30
 80008e2:	f7ff bf1d 	b.w	8000720 <oqPutTimeout>
 80008e6:	bf00      	nop
	...

080008f0 <_put>:
  return oqPutTimeout(&((SerialDriver *)ip)->oqueue, b, TIME_INFINITE);
 80008f0:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
 80008f4:	3030      	adds	r0, #48	; 0x30
 80008f6:	f7ff bf13 	b.w	8000720 <oqPutTimeout>
 80008fa:	bf00      	nop
 80008fc:	0000      	movs	r0, r0
	...

08000900 <_ctl>:
 8000900:	2000      	movs	r0, #0
 8000902:	4770      	bx	lr
	...

08000910 <sdInit>:
 *
 * @init
 */
void sdInit(void) {

  sd_lld_init();
 8000910:	f000 bc76 	b.w	8001200 <sd_lld_init>
	...

08000920 <sdObjectInit>:
  oqObjectInit(&sdp->oqueue, sdp->ob, SERIAL_BUFFERS_SIZE, onotify, sdp);
}
#else
void sdObjectInit(SerialDriver *sdp) {

  sdp->vmt = &vmt;
 8000920:	4603      	mov	r3, r0
 8000922:	4a03      	ldr	r2, [pc, #12]	; (8000930 <sdObjectInit+0x10>)
 8000924:	f843 2b04 	str.w	r2, [r3], #4
  osalEventObjectInit(&sdp->event);
  sdp->state = SD_STOP;
 8000928:	2201      	movs	r2, #1
 *
 * @init
 */
static inline void chEvtObjectInit(event_source_t *esp) {

  esp->next = (event_listener_t *)esp;
 800092a:	6043      	str	r3, [r0, #4]
 800092c:	7202      	strb	r2, [r0, #8]
}
 800092e:	4770      	bx	lr
 8000930:	0800a6c0 	.word	0x0800a6c0
	...

08000940 <sdStart>:
 *                      configuration is used.
 * @return              The operation status.
 *
 * @api
 */
msg_t sdStart(SerialDriver *sdp, const SerialConfig *config) {
 8000940:	b510      	push	{r4, lr}
 8000942:	2330      	movs	r3, #48	; 0x30
 8000944:	4604      	mov	r4, r0
 8000946:	f383 8811 	msr	BASEPRI, r3
                "invalid state");

#if defined(SD_LLD_ENHANCED_API)
  msg = sd_lld_start(sdp, config);
#else
  sd_lld_start(sdp, config);
 800094a:	f000 fc81 	bl	8001250 <sd_lld_start>
  msg = HAL_RET_SUCCESS;
#endif
  if (msg == HAL_RET_SUCCESS) {
    sdp->state = SD_READY;
 800094e:	2302      	movs	r3, #2
 8000950:	7223      	strb	r3, [r4, #8]
 8000952:	2000      	movs	r0, #0
 8000954:	f380 8811 	msr	BASEPRI, r0
  }

  osalSysUnlock();

  return msg;
}
 8000958:	bd10      	pop	{r4, pc}
 800095a:	bf00      	nop
 800095c:	0000      	movs	r0, r0
	...

08000960 <sdIncomingDataI>:
 * @param[in] sdp       pointer to a @p SerialDriver structure
 * @param[in] b         the byte to be written in the driver's Input Queue
 *
 * @iclass
 */
void sdIncomingDataI(SerialDriver *sdp, uint8_t b) {
 8000960:	b538      	push	{r3, r4, r5, lr}

  osalDbgCheckClassI();
  osalDbgCheck(sdp != NULL);

  if (iqIsEmptyI(&sdp->iqueue))
 8000962:	6943      	ldr	r3, [r0, #20]
void sdIncomingDataI(SerialDriver *sdp, uint8_t b) {
 8000964:	4604      	mov	r4, r0
 8000966:	460d      	mov	r5, r1
  if (iqIsEmptyI(&sdp->iqueue))
 8000968:	b13b      	cbz	r3, 800097a <sdIncomingDataI+0x1a>
    chnAddFlagsI(sdp, CHN_INPUT_AVAILABLE);
  if (iqPutI(&sdp->iqueue, b) < MSG_OK)
 800096a:	4629      	mov	r1, r5
 800096c:	f104 000c 	add.w	r0, r4, #12
 8000970:	f7ff fe3e 	bl	80005f0 <iqPutI>
 8000974:	2800      	cmp	r0, #0
 8000976:	db0b      	blt.n	8000990 <sdIncomingDataI+0x30>
    chnAddFlagsI(sdp, SD_QUEUE_FULL_ERROR);
}
 8000978:	bd38      	pop	{r3, r4, r5, pc}
  chEvtBroadcastFlagsI(esp, flags);
 800097a:	2104      	movs	r1, #4
 800097c:	4408      	add	r0, r1
 800097e:	f001 ff8f 	bl	80028a0 <chEvtBroadcastFlagsI>
  if (iqPutI(&sdp->iqueue, b) < MSG_OK)
 8000982:	4629      	mov	r1, r5
 8000984:	f104 000c 	add.w	r0, r4, #12
 8000988:	f7ff fe32 	bl	80005f0 <iqPutI>
 800098c:	2800      	cmp	r0, #0
 800098e:	daf3      	bge.n	8000978 <sdIncomingDataI+0x18>
 8000990:	1d20      	adds	r0, r4, #4
 8000992:	f44f 6180 	mov.w	r1, #1024	; 0x400
}
 8000996:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
 800099a:	f001 bf81 	b.w	80028a0 <chEvtBroadcastFlagsI>
 800099e:	bf00      	nop

080009a0 <nvicInit>:
void nvicInit(void) {
#if defined(__CORE_CM0_H_GENERIC) || defined(__CORE_CM0PLUS_H_GENERIC) ||   \
    defined(__CORE_CM23_H_GENERIC)
  uint32_t n = 0U;
#else
  uint32_t n = SCnSCB->ICTR;
 80009a0:	f04f 23e0 	mov.w	r3, #3758153728	; 0xe000e000
void nvicInit(void) {
 80009a4:	b410      	push	{r4}
  uint32_t n = SCnSCB->ICTR;
 80009a6:	685c      	ldr	r4, [r3, #4]
#endif

  for (uint32_t i = 0U; i <= n; i++) {
 80009a8:	2200      	movs	r2, #0
    NVIC->__ICER[i] = 0xFFFFFFFFU;
 80009aa:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
 80009ae:	0093      	lsls	r3, r2, #2
 80009b0:	f103 4360 	add.w	r3, r3, #3758096384	; 0xe0000000
 80009b4:	f503 4361 	add.w	r3, r3, #57600	; 0xe100
  for (uint32_t i = 0U; i <= n; i++) {
 80009b8:	4294      	cmp	r4, r2
    NVIC->__ICER[i] = 0xFFFFFFFFU;
 80009ba:	f8c3 0080 	str.w	r0, [r3, #128]	; 0x80
  for (uint32_t i = 0U; i <= n; i++) {
 80009be:	f102 0201 	add.w	r2, r2, #1
    NVIC->__ICPR[i] = 0xFFFFFFFFU;
 80009c2:	f8c3 0180 	str.w	r0, [r3, #384]	; 0x180
  for (uint32_t i = 0U; i <= n; i++) {
 80009c6:	d1f2      	bne.n	80009ae <nvicInit+0xe>
#if defined(__ARM_FEATURE_CMSE) && (__ARM_FEATURE_CMSE == 3)
    NVIC->__ITNS[i] = 0xFFFFFFFFU;
#endif
  }
}
 80009c8:	bc10      	pop	{r4}
 80009ca:	4770      	bx	lr
 80009cc:	0000      	movs	r0, r0
	...

080009d0 <nvicEnableVector>:
  NVIC->__IPR[_IP_IDX(n)] = (NVIC->__IPR[_IP_IDX(n)] & ~(0xFFU << _BIT_SHIFT(n))) |
                            (NVIC_PRIORITY_MASK(prio) << _BIT_SHIFT(n));
#else
  NVIC->__IPR[n] = NVIC_PRIORITY_MASK(prio);
#endif
  NVIC->__ICPR[n >> 5U] = 1U << (n & 0x1FU);
 80009d0:	0943      	lsrs	r3, r0, #5
 80009d2:	009b      	lsls	r3, r3, #2
  NVIC->__IPR[n] = NVIC_PRIORITY_MASK(prio);
 80009d4:	f100 4c60 	add.w	ip, r0, #3758096384	; 0xe0000000
 80009d8:	f103 4360 	add.w	r3, r3, #3758096384	; 0xe0000000
 80009dc:	f503 4361 	add.w	r3, r3, #57600	; 0xe100
 80009e0:	0109      	lsls	r1, r1, #4
 80009e2:	f50c 4c61 	add.w	ip, ip, #57600	; 0xe100
  NVIC->__ICPR[n >> 5U] = 1U << (n & 0x1FU);
 80009e6:	f000 001f 	and.w	r0, r0, #31
 80009ea:	2201      	movs	r2, #1
 80009ec:	fa02 f000 	lsl.w	r0, r2, r0
  NVIC->__IPR[n] = NVIC_PRIORITY_MASK(prio);
 80009f0:	b2c9      	uxtb	r1, r1
 80009f2:	f88c 1300 	strb.w	r1, [ip, #768]	; 0x300
  NVIC->__ICPR[n >> 5U] = 1U << (n & 0x1FU);
 80009f6:	f8c3 0180 	str.w	r0, [r3, #384]	; 0x180
  NVIC->__ISER[n >> 5U] = 1U << (n & 0x1FU);
 80009fa:	6018      	str	r0, [r3, #0]
#if defined(__ARM_FEATURE_CMSE) && (__ARM_FEATURE_CMSE == 3)
  /* If the IRQ is enabled from secure mode then it is marked as secure
     interrupt in ITNS.*/
  NVIC->__ITNS[n >> 5U] &= ~(1U << (n & 0x1FU));
#endif
}
 80009fc:	4770      	bx	lr
 80009fe:	bf00      	nop

08000a00 <VectorD8>:
/**
 * @brief   USART2 interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_USART2_HANDLER) {
 8000a00:	b508      	push	{r3, lr}

  OSAL_IRQ_PROLOGUE();

#if HAL_USE_SERIAL
#if STM32_SERIAL_USE_USART2
  sd_lld_serve_interrupt(&SD2);
 8000a02:	4803      	ldr	r0, [pc, #12]	; (8000a10 <VectorD8+0x10>)
 8000a04:	f000 fca4 	bl	8001350 <sd_lld_serve_interrupt>
  uart_lld_serve_interrupt(&UARTD2);
#endif
#endif

  OSAL_IRQ_EPILOGUE();
}
 8000a08:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  OSAL_IRQ_EPILOGUE();
 8000a0c:	f003 bb20 	b.w	8004050 <__port_irq_epilogue>
 8000a10:	200009c4 	.word	0x200009c4
	...

08000a20 <VectorB0>:
/**
 * @brief   TIM2 interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_TIM2_HANDLER) {
 8000a20:	b508      	push	{r3, lr}
  pwm_lld_serve_interrupt(&PWMD2);
#endif
#endif
#if 1
#if STM32_ST_USE_TIM2
  st_lld_serve_interrupt();
 8000a22:	f000 fbcd 	bl	80011c0 <st_lld_serve_interrupt>
#endif
#endif

  OSAL_IRQ_EPILOGUE();
}
 8000a26:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  OSAL_IRQ_EPILOGUE();
 8000a2a:	f003 bb11 	b.w	8004050 <__port_irq_epilogue>
 8000a2e:	bf00      	nop

08000a30 <irqInit>:
/**
 * @brief   Enables IRQ sources.
 *
 * @notapi
 */
void irqInit(void) {
 8000a30:	b508      	push	{r3, lr}
  nvicEnableVector(STM32_TIM2_NUMBER, STM32_IRQ_TIM2_PRIORITY);
 8000a32:	2107      	movs	r1, #7
 8000a34:	201c      	movs	r0, #28
 8000a36:	f7ff ffcb 	bl	80009d0 <nvicEnableVector>
  usart2_irq_init();
  usart3_irq_init();
  uart4_irq_init();
  uart5_irq_init();
  lpuart1_irq_init();
}
 8000a3a:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  nvicEnableVector(STM32_USART2_NUMBER, STM32_IRQ_USART2_PRIORITY);
 8000a3e:	210c      	movs	r1, #12
 8000a40:	2026      	movs	r0, #38	; 0x26
 8000a42:	f7ff bfc5 	b.w	80009d0 <nvicEnableVector>
 8000a46:	bf00      	nop
	...

08000a50 <hal_lld_init>:
/**
 * @brief   Low level HAL driver initialization.
 *
 * @notapi
 */
void hal_lld_init(void) {
 8000a50:	b508      	push	{r3, lr}

  /* DMA subsystems initialization.*/
#if defined(STM32_DMA_REQUIRED)
  dmaInit();
 8000a52:	f000 fb5d 	bl	8001110 <dmaInit>
#endif

  /* NVIC initialization.*/
  nvicInit();
 8000a56:	f7ff ffa3 	bl	80009a0 <nvicInit>

  /* IRQ subsystem initialization.*/
  irqInit();
}
 8000a5a:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  irqInit();
 8000a5e:	f7ff bfe7 	b.w	8000a30 <irqInit>
 8000a62:	bf00      	nop
	...

08000a70 <stm32_clock_init>:

#if !STM32_NO_INIT
  /* Reset of all peripherals.
     Note, GPIOs are not reset because initialized before this point in
     board files.*/
  rccResetAHB1(~0);
 8000a70:	4b68      	ldr	r3, [pc, #416]	; (8000c14 <stm32_clock_init+0x1a4>)
 8000a72:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
 8000a76:	6a9a      	ldr	r2, [r3, #40]	; 0x28
void stm32_clock_init(void) {
 8000a78:	b410      	push	{r4}
  rccResetAHB1(~0);
 8000a7a:	2200      	movs	r2, #0
 8000a7c:	6299      	str	r1, [r3, #40]	; 0x28
 8000a7e:	6a98      	ldr	r0, [r3, #40]	; 0x28
 8000a80:	629a      	str	r2, [r3, #40]	; 0x28
 8000a82:	6a98      	ldr	r0, [r3, #40]	; 0x28
  rccResetAHB2(~STM32_GPIO_EN_MASK);
 8000a84:	6ad8      	ldr	r0, [r3, #44]	; 0x2c
  rccResetAPB1R1(~0);
  rccResetAPB1R2(~0);
  rccResetAPB2(~0);

  /* Flash setup for selected MSI speed setting.*/
  FLASH->ACR = FLASH_ACR_DCEN | FLASH_ACR_ICEN | FLASH_ACR_PRFTEN |
 8000a86:	4c64      	ldr	r4, [pc, #400]	; (8000c18 <stm32_clock_init+0x1a8>)
  rccResetAHB2(~STM32_GPIO_EN_MASK);
 8000a88:	f060 0007 	orn	r0, r0, #7
 8000a8c:	62d8      	str	r0, [r3, #44]	; 0x2c
 8000a8e:	6ad8      	ldr	r0, [r3, #44]	; 0x2c
 8000a90:	f000 0007 	and.w	r0, r0, #7
 8000a94:	62d8      	str	r0, [r3, #44]	; 0x2c
 8000a96:	6ad8      	ldr	r0, [r3, #44]	; 0x2c
  rccResetAHB3(~0);
 8000a98:	6b18      	ldr	r0, [r3, #48]	; 0x30
 8000a9a:	6319      	str	r1, [r3, #48]	; 0x30
 8000a9c:	6b18      	ldr	r0, [r3, #48]	; 0x30
 8000a9e:	631a      	str	r2, [r3, #48]	; 0x30
 8000aa0:	6b18      	ldr	r0, [r3, #48]	; 0x30
  rccResetAPB1R1(~0);
 8000aa2:	6b98      	ldr	r0, [r3, #56]	; 0x38
 8000aa4:	6399      	str	r1, [r3, #56]	; 0x38
 8000aa6:	6b98      	ldr	r0, [r3, #56]	; 0x38
 8000aa8:	639a      	str	r2, [r3, #56]	; 0x38
 8000aaa:	6b98      	ldr	r0, [r3, #56]	; 0x38
  rccResetAPB1R2(~0);
 8000aac:	6bd8      	ldr	r0, [r3, #60]	; 0x3c
 8000aae:	63d9      	str	r1, [r3, #60]	; 0x3c
 8000ab0:	6bd8      	ldr	r0, [r3, #60]	; 0x3c
 8000ab2:	63da      	str	r2, [r3, #60]	; 0x3c
 8000ab4:	6bd8      	ldr	r0, [r3, #60]	; 0x3c
  rccResetAPB2(~0);
 8000ab6:	6c18      	ldr	r0, [r3, #64]	; 0x40
 8000ab8:	6419      	str	r1, [r3, #64]	; 0x40
 8000aba:	6c19      	ldr	r1, [r3, #64]	; 0x40
 8000abc:	641a      	str	r2, [r3, #64]	; 0x40
  FLASH->ACR = FLASH_ACR_DCEN | FLASH_ACR_ICEN | FLASH_ACR_PRFTEN |
 8000abe:	f44f 61e0 	mov.w	r1, #1792	; 0x700
  rccResetAPB2(~0);
 8000ac2:	6c1a      	ldr	r2, [r3, #64]	; 0x40
  FLASH->ACR = FLASH_ACR_DCEN | FLASH_ACR_ICEN | FLASH_ACR_PRFTEN |
 8000ac4:	6021      	str	r1, [r4, #0]
               STM32_MSI_FLASHBITS;

  /* SYSCFG clock enabled here because it is a multi-functional unit shared
     among multiple drivers.*/
  rccEnableAPB2(RCC_APB2ENR_SYSCFGEN, false);
 8000ac6:	6e1a      	ldr	r2, [r3, #96]	; 0x60
#if (HAL_USE_RTC == TRUE) && defined(RCC_APBENR1_RTCAPBEN)
  rccEnableAPB1R1(RCC_APB1ENR1_RTCAPBEN, true)
#endif

  /* Core voltage setup, backup domain access enabled and left open.*/
  PWR->CR1 = STM32_VOS | PWR_CR1_DBP;
 8000ac8:	4954      	ldr	r1, [pc, #336]	; (8000c1c <stm32_clock_init+0x1ac>)
  rccEnableAPB2(RCC_APB2ENR_SYSCFGEN, false);
 8000aca:	f042 0201 	orr.w	r2, r2, #1
 8000ace:	661a      	str	r2, [r3, #96]	; 0x60
 8000ad0:	f8d3 2080 	ldr.w	r2, [r3, #128]	; 0x80
 8000ad4:	f022 0201 	bic.w	r2, r2, #1
 8000ad8:	f8c3 2080 	str.w	r2, [r3, #128]	; 0x80
 8000adc:	f8d3 2080 	ldr.w	r2, [r3, #128]	; 0x80
  rccEnablePWRInterface(false);
 8000ae0:	6d9a      	ldr	r2, [r3, #88]	; 0x58
 8000ae2:	f042 5280 	orr.w	r2, r2, #268435456	; 0x10000000
 8000ae6:	659a      	str	r2, [r3, #88]	; 0x58
 8000ae8:	6f9a      	ldr	r2, [r3, #120]	; 0x78
 8000aea:	f022 5280 	bic.w	r2, r2, #268435456	; 0x10000000
 8000aee:	679a      	str	r2, [r3, #120]	; 0x78
  PWR->CR1 = STM32_VOS | PWR_CR1_DBP;
 8000af0:	f44f 7040 	mov.w	r0, #768	; 0x300
  rccEnablePWRInterface(false);
 8000af4:	6f9b      	ldr	r3, [r3, #120]	; 0x78
  PWR->CR1 = STM32_VOS | PWR_CR1_DBP;
 8000af6:	6008      	str	r0, [r1, #0]
  while ((PWR->SR2 & PWR_SR2_VOSF) != 0)    /* Wait until regulator is      */
 8000af8:	694b      	ldr	r3, [r1, #20]
 8000afa:	f413 6380 	ands.w	r3, r3, #1024	; 0x400
 8000afe:	d1fb      	bne.n	8000af8 <stm32_clock_init+0x88>

  /* Resetting MSI defaults.
     Note from RM0432: MSIRANGE can be modified when MSI is OFF (MSION=0)
     or when MSI is ready (MSIRDY=1). MSIRANGE must NOT be modified when
     MSI is ON and NOT ready (MSION=1 and MSIRDY=0).*/
  RCC->CR = (RCC->CR & ~RCC_CR_MSIRANGE_Msk) | RCC_CR_MSIRANGE_6;
 8000b00:	4a44      	ldr	r2, [pc, #272]	; (8000c14 <stm32_clock_init+0x1a4>)

  /* Programmable voltage detector enable.*/
#if STM32_PVD_ENABLE
  PWR->CR2 = PWR_CR2_PVDE | (STM32_PLS & STM32_PLS_MASK);
#else
  PWR->CR2 = 0;
 8000b02:	604b      	str	r3, [r1, #4]
 8000b04:	6813      	ldr	r3, [r2, #0]
 8000b06:	f023 03f0 	bic.w	r3, r3, #240	; 0xf0
 8000b0a:	f043 0360 	orr.w	r3, r3, #96	; 0x60
 8000b0e:	6013      	str	r3, [r2, #0]
  RCC->CR |= RCC_CR_MSION;
 8000b10:	6813      	ldr	r3, [r2, #0]
 8000b12:	f043 0301 	orr.w	r3, r3, #1
 8000b16:	6013      	str	r3, [r2, #0]
  while ((RCC->CR & RCC_CR_MSIRDY) == 0U) {
 8000b18:	6813      	ldr	r3, [r2, #0]
 8000b1a:	0799      	lsls	r1, r3, #30
 8000b1c:	d5fc      	bpl.n	8000b18 <stm32_clock_init+0xa8>

  /* Making sure MSI is active and ready.*/
  msi_enable();

  /* Clocking from MSI, in case MSI was not the default source.*/
  RCC->CFGR = RCC_CFGR_SW_MSI;
 8000b1e:	2300      	movs	r3, #0
  while ((RCC->CFGR & RCC_CFGR_SWS) != RCC_CFGR_SWS_MSI) {
 8000b20:	493c      	ldr	r1, [pc, #240]	; (8000c14 <stm32_clock_init+0x1a4>)
  RCC->CFGR = RCC_CFGR_SW_MSI;
 8000b22:	6093      	str	r3, [r2, #8]
  while ((RCC->CFGR & RCC_CFGR_SWS) != RCC_CFGR_SWS_MSI) {
 8000b24:	688b      	ldr	r3, [r1, #8]
 8000b26:	f013 030c 	ands.w	r3, r3, #12
 8000b2a:	d1fb      	bne.n	8000b24 <stm32_clock_init+0xb4>
 *          of the whole BKP domain.
 */
__STATIC_INLINE void bd_reset(void) {

  /* Reset BKP domain if different clock source selected.*/
  if ((RCC->BDCR & STM32_RTCSEL_MASK) != STM32_RTCSEL) {
 8000b2c:	f8d1 2090 	ldr.w	r2, [r1, #144]	; 0x90
 8000b30:	f402 7240 	and.w	r2, r2, #768	; 0x300
 8000b34:	f5b2 7f00 	cmp.w	r2, #512	; 0x200
 8000b38:	d005      	beq.n	8000b46 <stm32_clock_init+0xd6>
    /* Backup domain reset.*/
    RCC->BDCR = RCC_BDCR_BDRST;
 8000b3a:	f44f 3280 	mov.w	r2, #65536	; 0x10000
 8000b3e:	f8c1 2090 	str.w	r2, [r1, #144]	; 0x90
    RCC->BDCR = 0U;
 8000b42:	f8c1 3090 	str.w	r3, [r1, #144]	; 0x90
#if defined(STM32_LSE_BYPASS)
  /* LSE Bypass.*/
  RCC->BDCR |= STM32_LSEDRV | RCC_BDCR_LSEON | RCC_BDCR_LSESYSEN | RCC_BDCR_LSEBYP;
#else
  /* No LSE Bypass.*/
  RCC->BDCR |= STM32_LSEDRV | RCC_BDCR_LSEON | RCC_BDCR_LSESYSEN;
 8000b46:	4a33      	ldr	r2, [pc, #204]	; (8000c14 <stm32_clock_init+0x1a4>)
 8000b48:	f8d2 3090 	ldr.w	r3, [r2, #144]	; 0x90
 8000b4c:	f043 0311 	orr.w	r3, r3, #17
 8000b50:	f8c2 3090 	str.w	r3, [r2, #144]	; 0x90
#endif
  while ((RCC->BDCR & (RCC_BDCR_LSESYSRDY | RCC_BDCR_LSERDY)) !=
 8000b54:	f8d2 3090 	ldr.w	r3, [r2, #144]	; 0x90
 8000b58:	079b      	lsls	r3, r3, #30
 8000b5a:	d5fb      	bpl.n	8000b54 <stm32_clock_init+0xe4>

__STATIC_INLINE void lsi_init(void) {

#if STM32_LSI_ENABLED
  /* LSI activation.*/
  RCC->CSR |= STM32_LSIPRE | RCC_CSR_LSION;
 8000b5c:	f8d2 3094 	ldr.w	r3, [r2, #148]	; 0x94
  while ((RCC->CSR & RCC_CSR_LSIRDY) == 0U) {
 8000b60:	482c      	ldr	r0, [pc, #176]	; (8000c14 <stm32_clock_init+0x1a4>)
  RCC->CSR |= STM32_LSIPRE | RCC_CSR_LSION;
 8000b62:	f043 0301 	orr.w	r3, r3, #1
 8000b66:	f8c2 3094 	str.w	r3, [r2, #148]	; 0x94
  while ((RCC->CSR & RCC_CSR_LSIRDY) == 0U) {
 8000b6a:	f8d0 3094 	ldr.w	r3, [r0, #148]	; 0x94
 8000b6e:	079c      	lsls	r4, r3, #30
 8000b70:	d5fb      	bpl.n	8000b6a <stm32_clock_init+0xfa>
#if STM32_MSIPLL_ENABLED
  cr = STM32_MSIRANGE | RCC_CR_MSIPLLEN | RCC_CR_MSION;
#else
  cr = STM32_MSIRANGE | RCC_CR_MSION;
#endif
  RCC->CR = cr;
 8000b72:	2365      	movs	r3, #101	; 0x65
  while ((RCC->CR & RCC_CR_MSIRDY) == 0U) {
 8000b74:	4927      	ldr	r1, [pc, #156]	; (8000c14 <stm32_clock_init+0x1a4>)
  RCC->CR = cr;
 8000b76:	6003      	str	r3, [r0, #0]
  while ((RCC->CR & RCC_CR_MSIRDY) == 0U) {
 8000b78:	680b      	ldr	r3, [r1, #0]
 8000b7a:	0798      	lsls	r0, r3, #30
 8000b7c:	d5fc      	bpl.n	8000b78 <stm32_clock_init+0x108>
    /* Wait until MSI is stable.*/
  }

  /* Clocking from MSI, in case MSI was not the default source.*/
  RCC->CFGR = 0U;
 8000b7e:	2300      	movs	r3, #0
  while ((RCC->CFGR & RCC_CFGR_SWS) != RCC_CFGR_SWS_MSI)
 8000b80:	4a24      	ldr	r2, [pc, #144]	; (8000c14 <stm32_clock_init+0x1a4>)
  RCC->CFGR = 0U;
 8000b82:	608b      	str	r3, [r1, #8]
  while ((RCC->CFGR & RCC_CFGR_SWS) != RCC_CFGR_SWS_MSI)
 8000b84:	6893      	ldr	r3, [r2, #8]
 8000b86:	f013 0f0c 	tst.w	r3, #12
 8000b8a:	d1fb      	bne.n	8000b84 <stm32_clock_init+0x114>
    ;                                       /* Wait until MSI is selected.  */

  /* Updating MSISRANGE value. MSISRANGE can be set only when MSIRGSEL is high.
     This range is used exiting the Standby mode until MSIRGSEL is set.*/
  cr      |= RCC_CR_MSIRGSEL;
  RCC->CR  = cr;
 8000b8c:	236d      	movs	r3, #109	; 0x6d
 8000b8e:	6013      	str	r3, [r2, #0]

  csr      = RCC->CSR;
 8000b90:	f8d2 3094 	ldr.w	r3, [r2, #148]	; 0x94
__STATIC_INLINE void pll_init(void) {

#if STM32_RCC_HAS_PLL
#if STM32_ACTIVATE_PLL
  /* PLL activation.*/
  RCC->PLLCFGR = STM32_PLLPDIV | STM32_PLLR   |
 8000b94:	4822      	ldr	r0, [pc, #136]	; (8000c20 <stm32_clock_init+0x1b0>)
  return (bool)((RCC->CR & RCC_CR_PLLRDY) == 0U);
 8000b96:	491f      	ldr	r1, [pc, #124]	; (8000c14 <stm32_clock_init+0x1a4>)
  csr     &= ~STM32_MSISRANGE_MASK;
 8000b98:	f423 6370 	bic.w	r3, r3, #3840	; 0xf00
  csr     |= STM32_MSISRANGE;
 8000b9c:	f443 63c0 	orr.w	r3, r3, #1536	; 0x600
  RCC->CSR = csr;
 8000ba0:	f8c2 3094 	str.w	r3, [r2, #148]	; 0x94
  bdcr = RCC->BDCR;
 8000ba4:	f8d2 3090 	ldr.w	r3, [r2, #144]	; 0x90
  bdcr &= ~(STM32_RTCSEL_MASK | STM32_LSCOSEL_MASK);
 8000ba8:	f023 2303 	bic.w	r3, r3, #50332416	; 0x3000300
  bdcr |= STM32_RTCSEL | STM32_LSCOSEL;
 8000bac:	f443 7300 	orr.w	r3, r3, #512	; 0x200
  RCC->BDCR = bdcr;
 8000bb0:	f8c2 3090 	str.w	r3, [r2, #144]	; 0x90
  RCC->PLLCFGR = STM32_PLLPDIV | STM32_PLLR   |
 8000bb4:	60d0      	str	r0, [r2, #12]
                 STM32_PLLREN  | STM32_PLLQ   |
                 STM32_PLLQEN  | STM32_PLLP   |
                 STM32_PLLPEN  | STM32_PLLN   |
                 STM32_PLLM    | STM32_PLLSRC;
  RCC->CR |= RCC_CR_PLLON;
 8000bb6:	6813      	ldr	r3, [r2, #0]
 8000bb8:	f043 7380 	orr.w	r3, r3, #16777216	; 0x1000000
 8000bbc:	6013      	str	r3, [r2, #0]
  return (bool)((RCC->CR & RCC_CR_PLLRDY) == 0U);
 8000bbe:	680b      	ldr	r3, [r1, #0]
  while (pll_not_locked()) {
 8000bc0:	019a      	lsls	r2, r3, #6
 8000bc2:	d5fc      	bpl.n	8000bbe <stm32_clock_init+0x14e>
__STATIC_INLINE void pllsai1_init(void) {

#if STM32_RCC_HAS_PLLSAI1
#if STM32_ACTIVATE_PLLSAI1
  /* PLLSAI1 activation.*/
  RCC->PLLSAI1CFGR = STM32_PLLSAI1PDIV | STM32_PLLSAI1R   |
 8000bc4:	4b17      	ldr	r3, [pc, #92]	; (8000c24 <stm32_clock_init+0x1b4>)
 8000bc6:	610b      	str	r3, [r1, #16]
                     STM32_PLLSAI1REN  | STM32_PLLSAI1Q   |
                     STM32_PLLSAI1QEN  | STM32_PLLSAI1P   |
                     STM32_PLLSAI1PEN  | STM32_PLLSAI1N   |
                     STM32_PLLSAI1M;
  RCC->CR |= RCC_CR_PLLSAI1ON;
 8000bc8:	680b      	ldr	r3, [r1, #0]

  /* Waiting for PLL lock.*/
  while ((RCC->CR & RCC_CR_PLLSAI1RDY) == 0U)
 8000bca:	4812      	ldr	r0, [pc, #72]	; (8000c14 <stm32_clock_init+0x1a4>)
  RCC->CR |= RCC_CR_PLLSAI1ON;
 8000bcc:	f043 6380 	orr.w	r3, r3, #67108864	; 0x4000000
 8000bd0:	600b      	str	r3, [r1, #0]
  while ((RCC->CR & RCC_CR_PLLSAI1RDY) == 0U)
 8000bd2:	6803      	ldr	r3, [r0, #0]
 8000bd4:	011b      	lsls	r3, r3, #4
 8000bd6:	d5fc      	bpl.n	8000bd2 <stm32_clock_init+0x162>
  }
#endif

  /* Set flash WS's for SYSCLK source */
  if (STM32_FLASHBITS > STM32_MSI_FLASHBITS) {
    FLASH->ACR = (FLASH->ACR & ~FLASH_ACR_LATENCY_Msk) | STM32_FLASHBITS;
 8000bd8:	4a0f      	ldr	r2, [pc, #60]	; (8000c18 <stm32_clock_init+0x1a8>)
    RCC->CCIPR = ccipr;
 8000bda:	4b13      	ldr	r3, [pc, #76]	; (8000c28 <stm32_clock_init+0x1b8>)
  RCC->CFGR = STM32_MCOPRE | STM32_MCOSEL | STM32_STOPWUCK |
 8000bdc:	2100      	movs	r1, #0
 8000bde:	6081      	str	r1, [r0, #8]
    RCC->CCIPR = ccipr;
 8000be0:	f8c0 3088 	str.w	r3, [r0, #136]	; 0x88
    FLASH->ACR = (FLASH->ACR & ~FLASH_ACR_LATENCY_Msk) | STM32_FLASHBITS;
 8000be4:	6813      	ldr	r3, [r2, #0]
 8000be6:	f023 0307 	bic.w	r3, r3, #7
 8000bea:	f043 0304 	orr.w	r3, r3, #4
 8000bee:	6013      	str	r3, [r2, #0]
    while ((FLASH->ACR & FLASH_ACR_LATENCY_Msk) !=
 8000bf0:	6813      	ldr	r3, [r2, #0]
 8000bf2:	f003 0307 	and.w	r3, r3, #7
 8000bf6:	2b04      	cmp	r3, #4
 8000bf8:	d1fa      	bne.n	8000bf0 <stm32_clock_init+0x180>
    }
  }

  /* Switching to the configured SYSCLK source if it is different from MSI.*/
#if (STM32_SW != STM32_SW_MSI)
  RCC->CFGR |= STM32_SW;        /* Switches on the selected clock source.   */
 8000bfa:	4a06      	ldr	r2, [pc, #24]	; (8000c14 <stm32_clock_init+0x1a4>)
 8000bfc:	6893      	ldr	r3, [r2, #8]
 8000bfe:	f043 0303 	orr.w	r3, r3, #3
 8000c02:	6093      	str	r3, [r2, #8]
  /* Wait until SYSCLK is stable.*/
  while ((RCC->CFGR & RCC_CFGR_SWS) != (STM32_SW << 2))
 8000c04:	6893      	ldr	r3, [r2, #8]
 8000c06:	f003 030c 	and.w	r3, r3, #12
 8000c0a:	2b0c      	cmp	r3, #12
 8000c0c:	d1fa      	bne.n	8000c04 <stm32_clock_init+0x194>
    while ((FLASH->ACR & FLASH_ACR_LATENCY_Msk) !=
           (STM32_FLASHBITS & FLASH_ACR_LATENCY_Msk)) {
    }
  }
#endif /* STM32_NO_INIT */
}
 8000c0e:	bc10      	pop	{r4}
 8000c10:	4770      	bx	lr
 8000c12:	bf00      	nop
 8000c14:	40021000 	.word	0x40021000
 8000c18:	40022000 	.word	0x40022000
 8000c1c:	40007000 	.word	0x40007000
 8000c20:	03405001 	.word	0x03405001
 8000c24:	34504800 	.word	0x34504800
 8000c28:	34015555 	.word	0x34015555
 8000c2c:	00000000 	.word	0x00000000

08000c30 <adc_lld_init>:
/**
 * @brief   Low level ADC driver initialization.
 *
 * @notapi
 */
void adc_lld_init(void) {
 8000c30:	b570      	push	{r4, r5, r6, lr}

  clkmask = 0;

#if STM32_ADC_USE_ADC1
  /* Driver initialization.*/
  adcObjectInit(&ADCD1);
 8000c32:	4c19      	ldr	r4, [pc, #100]	; (8000c98 <adc_lld_init+0x68>)
  clkmask = 0;
 8000c34:	4b19      	ldr	r3, [pc, #100]	; (8000c9c <adc_lld_init+0x6c>)
#elif defined(ADC12_COMMON)
  ADCD1.adcc = ADC12_COMMON;
#elif defined(ADC123_COMMON)
  ADCD1.adcc = ADC123_COMMON;
#else
  ADCD1.adcc = ADC1_COMMON;
 8000c36:	4d1a      	ldr	r5, [pc, #104]	; (8000ca0 <adc_lld_init+0x70>)
  clkmask = 0;
 8000c38:	2600      	movs	r6, #0
  adcObjectInit(&ADCD1);
 8000c3a:	4620      	mov	r0, r4
  clkmask = 0;
 8000c3c:	601e      	str	r6, [r3, #0]
  adcObjectInit(&ADCD1);
 8000c3e:	f7ff fdff 	bl	8000840 <adcObjectInit>
#endif
  ADCD1.adcm    = ADC1;
 8000c42:	4a18      	ldr	r2, [pc, #96]	; (8000ca4 <adc_lld_init+0x74>)
#if STM32_ADC_DUAL_MODE
  ADCD1.adcs    = ADC2;
#endif
  ADCD1.dmastp  = NULL;
 8000c44:	6326      	str	r6, [r4, #48]	; 0x30
  ADCD1.dmamode = ADC_DMA_SIZE |
 8000c46:	f242 538a 	movw	r3, #9610	; 0x258a
  /* IRQs setup.*/
#if STM32_ADC_USE_ADC1 || STM32_ADC_USE_ADC2
#if defined(STM32_ADC_ADC1_IRQ_PRIORITY)
  nvicEnableVector(STM32_ADC1_NUMBER, STM32_ADC_ADC1_IRQ_PRIORITY);
#elif defined(STM32_ADC_ADC12_IRQ_PRIORITY)
  nvicEnableVector(STM32_ADC1_NUMBER, STM32_ADC_ADC12_IRQ_PRIORITY);
 8000c4a:	2105      	movs	r1, #5
 8000c4c:	2012      	movs	r0, #18
  ADCD1.adcm    = ADC1;
 8000c4e:	e9c4 250a 	strd	r2, r5, [r4, #40]	; 0x28
  ADCD1.dmamode = ADC_DMA_SIZE |
 8000c52:	6363      	str	r3, [r4, #52]	; 0x34
  nvicEnableVector(STM32_ADC1_NUMBER, STM32_ADC_ADC12_IRQ_PRIORITY);
 8000c54:	f7ff febc 	bl	80009d0 <nvicEnableVector>
  rccDisableADC34();
#endif
#endif

#if defined(STM32L4XX) || defined(STM32L4XXP)
  rccEnableADC123(true);
 8000c58:	4b13      	ldr	r3, [pc, #76]	; (8000ca8 <adc_lld_init+0x78>)
 8000c5a:	6cda      	ldr	r2, [r3, #76]	; 0x4c
 8000c5c:	f442 5200 	orr.w	r2, r2, #8192	; 0x2000
 8000c60:	64da      	str	r2, [r3, #76]	; 0x4c
 8000c62:	6eda      	ldr	r2, [r3, #108]	; 0x6c
 8000c64:	f442 5200 	orr.w	r2, r2, #8192	; 0x2000
 8000c68:	66da      	str	r2, [r3, #108]	; 0x6c
 8000c6a:	6eda      	ldr	r2, [r3, #108]	; 0x6c
  rccResetADC123();
 8000c6c:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 8000c6e:	f442 5200 	orr.w	r2, r2, #8192	; 0x2000
 8000c72:	62da      	str	r2, [r3, #44]	; 0x2c
 8000c74:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 8000c76:	f422 5200 	bic.w	r2, r2, #8192	; 0x2000
 8000c7a:	62da      	str	r2, [r3, #44]	; 0x2c
#elif defined(ADC12_COMMON)
  ADC12_COMMON->CCR = STM32_ADC_ADC123_PRESC | STM32_ADC_ADC123_CLOCK_MODE | ADC_DMA_MDMA;
#elif defined(ADC123_COMMON)
  ADC123_COMMON->CCR = STM32_ADC_ADC123_PRESC | STM32_ADC_ADC123_CLOCK_MODE | ADC_DMA_MDMA;
#else
  ADC1_COMMON->CCR   = STM32_ADC_ADC123_PRESC | STM32_ADC_ADC123_CLOCK_MODE | ADC_DMA_MDMA;
 8000c7c:	f44f 21a0 	mov.w	r1, #327680	; 0x50000
  rccResetADC123();
 8000c80:	6ada      	ldr	r2, [r3, #44]	; 0x2c
  ADC1_COMMON->CCR   = STM32_ADC_ADC123_PRESC | STM32_ADC_ADC123_CLOCK_MODE | ADC_DMA_MDMA;
 8000c82:	60a9      	str	r1, [r5, #8]
#endif
  rccDisableADC123();
 8000c84:	6cda      	ldr	r2, [r3, #76]	; 0x4c
 8000c86:	f422 5200 	bic.w	r2, r2, #8192	; 0x2000
 8000c8a:	64da      	str	r2, [r3, #76]	; 0x4c
 8000c8c:	6eda      	ldr	r2, [r3, #108]	; 0x6c
 8000c8e:	f422 5200 	bic.w	r2, r2, #8192	; 0x2000
 8000c92:	66da      	str	r2, [r3, #108]	; 0x6c
 8000c94:	6edb      	ldr	r3, [r3, #108]	; 0x6c
  rccResetADC1();
  ADC1_COMMON->CCR = STM32_ADC_ADC1_PRESC | STM32_ADC_ADC1_CLOCK_MODE;
  rccDisableADC1();
#endif
#endif
}
 8000c96:	bd70      	pop	{r4, r5, r6, pc}
 8000c98:	200008e0 	.word	0x200008e0
 8000c9c:	20000918 	.word	0x20000918
 8000ca0:	50040300 	.word	0x50040300
 8000ca4:	50040000 	.word	0x50040000
 8000ca8:	40021000 	.word	0x40021000
 8000cac:	00000000 	.word	0x00000000

08000cb0 <adc_lld_stop_conversion>:
 *
 * @notapi
 */
void adc_lld_stop_conversion(ADCDriver *adcp) {

  dmaStreamDisable(adcp->dmastp);
 8000cb0:	6b03      	ldr	r3, [r0, #48]	; 0x30
 8000cb2:	6a82      	ldr	r2, [r0, #40]	; 0x28
void adc_lld_stop_conversion(ADCDriver *adcp) {
 8000cb4:	b410      	push	{r4}
  dmaStreamDisable(adcp->dmastp);
 8000cb6:	e9d3 4000 	ldrd	r4, r0, [r3]
 8000cba:	6801      	ldr	r1, [r0, #0]
 8000cbc:	f021 010f 	bic.w	r1, r1, #15
 8000cc0:	6001      	str	r1, [r0, #0]
 8000cc2:	7c19      	ldrb	r1, [r3, #16]
 8000cc4:	230e      	movs	r3, #14
 8000cc6:	408b      	lsls	r3, r1
 8000cc8:	6063      	str	r3, [r4, #4]
  if (adcp->adcm->CR & ADC_CR_ADSTART) {
 8000cca:	6893      	ldr	r3, [r2, #8]
 8000ccc:	075b      	lsls	r3, r3, #29
 8000cce:	d508      	bpl.n	8000ce2 <adc_lld_stop_conversion+0x32>
    adcp->adcm->CR |= ADC_CR_ADSTP;
 8000cd0:	6893      	ldr	r3, [r2, #8]
 8000cd2:	f043 0310 	orr.w	r3, r3, #16
 8000cd6:	6093      	str	r3, [r2, #8]
    while (adcp->adcm->CR & ADC_CR_ADSTP)
 8000cd8:	6893      	ldr	r3, [r2, #8]
 8000cda:	f013 0310 	ands.w	r3, r3, #16
 8000cde:	d1fb      	bne.n	8000cd8 <adc_lld_stop_conversion+0x28>
    adcp->adcm->IER = 0;
 8000ce0:	6053      	str	r3, [r2, #4]
  adc_lld_stop_adc(adcp);
}
 8000ce2:	bc10      	pop	{r4}
 8000ce4:	4770      	bx	lr
 8000ce6:	bf00      	nop
	...

08000cf0 <Vector88>:
OSAL_IRQ_HANDLER(STM32_ADC1_HANDLER) {
 8000cf0:	b538      	push	{r3, r4, r5, lr}
  if (adcp->grpp != NULL) {
 8000cf2:	4d22      	ldr	r5, [pc, #136]	; (8000d7c <Vector88+0x8c>)
  isr  = ADC1->ISR;
 8000cf4:	4a22      	ldr	r2, [pc, #136]	; (8000d80 <Vector88+0x90>)
  if (adcp->grpp != NULL) {
 8000cf6:	6929      	ldr	r1, [r5, #16]
  isr  = ADC1->ISR;
 8000cf8:	6813      	ldr	r3, [r2, #0]
  ADC1->ISR = isr;
 8000cfa:	6013      	str	r3, [r2, #0]
  if (adcp->grpp != NULL) {
 8000cfc:	b361      	cbz	r1, 8000d58 <Vector88+0x68>
    if ((isr & ADC_ISR_OVR) && (adcp->state == ADC_ACTIVE)) {
 8000cfe:	f013 0410 	ands.w	r4, r3, #16
 8000d02:	d004      	beq.n	8000d0e <Vector88+0x1e>
 8000d04:	782a      	ldrb	r2, [r5, #0]
      emask |= ADC_ERR_OVERFLOW;
 8000d06:	2a03      	cmp	r2, #3
 8000d08:	bf14      	ite	ne
 8000d0a:	2400      	movne	r4, #0
 8000d0c:	2402      	moveq	r4, #2
    if (isr & ADC_ISR_AWD1) {
 8000d0e:	0618      	lsls	r0, r3, #24
      emask |= ADC_ERR_AWD1;
 8000d10:	bf48      	it	mi
 8000d12:	f044 0404 	orrmi.w	r4, r4, #4
    if (isr & ADC_ISR_AWD2) {
 8000d16:	05d9      	lsls	r1, r3, #23
 8000d18:	d522      	bpl.n	8000d60 <Vector88+0x70>
    if (isr & ADC_ISR_AWD3) {
 8000d1a:	059a      	lsls	r2, r3, #22
      emask |= ADC_ERR_AWD2;
 8000d1c:	f044 0408 	orr.w	r4, r4, #8
    if (isr & ADC_ISR_AWD3) {
 8000d20:	d501      	bpl.n	8000d26 <Vector88+0x36>
      emask |= ADC_ERR_AWD3;
 8000d22:	f044 0410 	orr.w	r4, r4, #16
      _adc_isr_error_code(adcp, emask);
 8000d26:	4815      	ldr	r0, [pc, #84]	; (8000d7c <Vector88+0x8c>)
 8000d28:	f7ff ffc2 	bl	8000cb0 <adc_lld_stop_conversion>
 8000d2c:	692b      	ldr	r3, [r5, #16]
 8000d2e:	689b      	ldr	r3, [r3, #8]
 8000d30:	b1f3      	cbz	r3, 8000d70 <Vector88+0x80>
 8000d32:	2205      	movs	r2, #5
 8000d34:	4811      	ldr	r0, [pc, #68]	; (8000d7c <Vector88+0x8c>)
 8000d36:	702a      	strb	r2, [r5, #0]
 8000d38:	4621      	mov	r1, r4
 8000d3a:	4798      	blx	r3
 8000d3c:	782b      	ldrb	r3, [r5, #0]
 8000d3e:	2b05      	cmp	r3, #5
 8000d40:	d016      	beq.n	8000d70 <Vector88+0x80>
 8000d42:	2330      	movs	r3, #48	; 0x30
 8000d44:	f383 8811 	msr	BASEPRI, r3
  chThdResumeI(trp, msg);
 8000d48:	480e      	ldr	r0, [pc, #56]	; (8000d84 <Vector88+0x94>)
 8000d4a:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
 8000d4e:	f001 f96f 	bl	8002030 <chThdResumeI>
 8000d52:	2300      	movs	r3, #0
 8000d54:	f383 8811 	msr	BASEPRI, r3
}
 8000d58:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
  OSAL_IRQ_EPILOGUE();
 8000d5c:	f003 b978 	b.w	8004050 <__port_irq_epilogue>
    if (isr & ADC_ISR_AWD3) {
 8000d60:	059b      	lsls	r3, r3, #22
 8000d62:	d4de      	bmi.n	8000d22 <Vector88+0x32>
    if (emask != 0U) {
 8000d64:	2c00      	cmp	r4, #0
 8000d66:	d1de      	bne.n	8000d26 <Vector88+0x36>
}
 8000d68:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
  OSAL_IRQ_EPILOGUE();
 8000d6c:	f003 b970 	b.w	8004050 <__port_irq_epilogue>
      _adc_isr_error_code(adcp, emask);
 8000d70:	2202      	movs	r2, #2
 8000d72:	2300      	movs	r3, #0
 8000d74:	702a      	strb	r2, [r5, #0]
 8000d76:	612b      	str	r3, [r5, #16]
 8000d78:	e7e3      	b.n	8000d42 <Vector88+0x52>
 8000d7a:	bf00      	nop
 8000d7c:	200008e0 	.word	0x200008e0
 8000d80:	50040000 	.word	0x50040000
 8000d84:	200008f4 	.word	0x200008f4
	...

08000d90 <dac_lld_init>:
/**
 * @brief   Low level DAC driver initialization.
 *
 * @notapi
 */
void dac_lld_init(void) {
 8000d90:	b510      	push	{r4, lr}

#if STM32_DAC_USE_DAC1_CH1
  dacObjectInit(&DACD1);
 8000d92:	4c04      	ldr	r4, [pc, #16]	; (8000da4 <dac_lld_init+0x14>)
 8000d94:	4620      	mov	r0, r4
 8000d96:	f7ff fd6b 	bl	8000870 <dacObjectInit>
  DACD1.params  = &dac1_ch1_params;
 8000d9a:	4a03      	ldr	r2, [pc, #12]	; (8000da8 <dac_lld_init+0x18>)
  DACD1.dma = NULL;
 8000d9c:	2300      	movs	r3, #0
 8000d9e:	e9c4 230a 	strd	r2, r3, [r4, #40]	; 0x28
#if STM32_DAC_USE_DAC4_CH2
  dacObjectInit(&DACD8);
  DACD8.params  = &dac4_ch2_params;
  DACD8.dma = NULL;
#endif
}
 8000da2:	bd10      	pop	{r4, pc}
 8000da4:	2000091c 	.word	0x2000091c
 8000da8:	0800a6e8 	.word	0x0800a6e8
 8000dac:	00000000 	.word	0x00000000

08000db0 <Vector6C>:
/**
 * @brief   DMA1 stream 1 shared ISR.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA1_CH1_HANDLER) {
 8000db0:	b508      	push	{r3, lr}
 */
void dmaServeInterrupt(const stm32_dma_stream_t *dmastp) {
  uint32_t flags;
  uint32_t selfindex = (uint32_t)dmastp->selfindex;

  flags = (dmastp->dma->ISR >> dmastp->shift) & STM32_DMA_ISR_MASK;
 8000db2:	4b08      	ldr	r3, [pc, #32]	; (8000dd4 <Vector6C+0x24>)
 8000db4:	6819      	ldr	r1, [r3, #0]
  if (flags & dmastp->channel->CCR) {
 8000db6:	689a      	ldr	r2, [r3, #8]
  flags = (dmastp->dma->ISR >> dmastp->shift) & STM32_DMA_ISR_MASK;
 8000db8:	f001 010e 	and.w	r1, r1, #14
  if (flags & dmastp->channel->CCR) {
 8000dbc:	4211      	tst	r1, r2
 8000dbe:	d005      	beq.n	8000dcc <Vector6C+0x1c>
    dmastp->dma->IFCR = flags << dmastp->shift;
    if (dma.streams[selfindex].func) {
 8000dc0:	4a05      	ldr	r2, [pc, #20]	; (8000dd8 <Vector6C+0x28>)
    dmastp->dma->IFCR = flags << dmastp->shift;
 8000dc2:	6059      	str	r1, [r3, #4]
    if (dma.streams[selfindex].func) {
 8000dc4:	6893      	ldr	r3, [r2, #8]
 8000dc6:	b10b      	cbz	r3, 8000dcc <Vector6C+0x1c>
      dma.streams[selfindex].func(dma.streams[selfindex].param, flags);
 8000dc8:	68d0      	ldr	r0, [r2, #12]
 8000dca:	4798      	blx	r3
}
 8000dcc:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  OSAL_IRQ_EPILOGUE();
 8000dd0:	f003 b93e 	b.w	8004050 <__port_irq_epilogue>
 8000dd4:	40020000 	.word	0x40020000
 8000dd8:	2000094c 	.word	0x2000094c
 8000ddc:	00000000 	.word	0x00000000

08000de0 <Vector70>:
  flags = (dmastp->dma->ISR >> dmastp->shift) & STM32_DMA_ISR_MASK;
 8000de0:	4b0a      	ldr	r3, [pc, #40]	; (8000e0c <Vector70+0x2c>)
 8000de2:	6819      	ldr	r1, [r3, #0]
  if (flags & dmastp->channel->CCR) {
 8000de4:	69da      	ldr	r2, [r3, #28]
  flags = (dmastp->dma->ISR >> dmastp->shift) & STM32_DMA_ISR_MASK;
 8000de6:	0909      	lsrs	r1, r1, #4
 8000de8:	f001 010e 	and.w	r1, r1, #14
  if (flags & dmastp->channel->CCR) {
 8000dec:	4211      	tst	r1, r2
 8000dee:	d00b      	beq.n	8000e08 <Vector70+0x28>
    if (dma.streams[selfindex].func) {
 8000df0:	4807      	ldr	r0, [pc, #28]	; (8000e10 <Vector70+0x30>)
OSAL_IRQ_HANDLER(STM32_DMA1_CH2_HANDLER) {
 8000df2:	b510      	push	{r4, lr}
    if (dma.streams[selfindex].func) {
 8000df4:	6904      	ldr	r4, [r0, #16]
    dmastp->dma->IFCR = flags << dmastp->shift;
 8000df6:	010a      	lsls	r2, r1, #4
 8000df8:	605a      	str	r2, [r3, #4]
    if (dma.streams[selfindex].func) {
 8000dfa:	b10c      	cbz	r4, 8000e00 <Vector70+0x20>
      dma.streams[selfindex].func(dma.streams[selfindex].param, flags);
 8000dfc:	6940      	ldr	r0, [r0, #20]
 8000dfe:	47a0      	blx	r4
}
 8000e00:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  OSAL_IRQ_EPILOGUE();
 8000e04:	f003 b924 	b.w	8004050 <__port_irq_epilogue>
 8000e08:	f003 b922 	b.w	8004050 <__port_irq_epilogue>
 8000e0c:	40020000 	.word	0x40020000
 8000e10:	2000094c 	.word	0x2000094c
	...

08000e20 <Vector74>:
  flags = (dmastp->dma->ISR >> dmastp->shift) & STM32_DMA_ISR_MASK;
 8000e20:	4b0a      	ldr	r3, [pc, #40]	; (8000e4c <Vector74+0x2c>)
 8000e22:	6819      	ldr	r1, [r3, #0]
  if (flags & dmastp->channel->CCR) {
 8000e24:	6b1a      	ldr	r2, [r3, #48]	; 0x30
  flags = (dmastp->dma->ISR >> dmastp->shift) & STM32_DMA_ISR_MASK;
 8000e26:	0a09      	lsrs	r1, r1, #8
 8000e28:	f001 010e 	and.w	r1, r1, #14
  if (flags & dmastp->channel->CCR) {
 8000e2c:	4211      	tst	r1, r2
 8000e2e:	d00b      	beq.n	8000e48 <Vector74+0x28>
    if (dma.streams[selfindex].func) {
 8000e30:	4807      	ldr	r0, [pc, #28]	; (8000e50 <Vector74+0x30>)
OSAL_IRQ_HANDLER(STM32_DMA1_CH3_HANDLER) {
 8000e32:	b510      	push	{r4, lr}
    if (dma.streams[selfindex].func) {
 8000e34:	6984      	ldr	r4, [r0, #24]
    dmastp->dma->IFCR = flags << dmastp->shift;
 8000e36:	020a      	lsls	r2, r1, #8
 8000e38:	605a      	str	r2, [r3, #4]
    if (dma.streams[selfindex].func) {
 8000e3a:	b10c      	cbz	r4, 8000e40 <Vector74+0x20>
      dma.streams[selfindex].func(dma.streams[selfindex].param, flags);
 8000e3c:	69c0      	ldr	r0, [r0, #28]
 8000e3e:	47a0      	blx	r4
}
 8000e40:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  OSAL_IRQ_EPILOGUE();
 8000e44:	f003 b904 	b.w	8004050 <__port_irq_epilogue>
 8000e48:	f003 b902 	b.w	8004050 <__port_irq_epilogue>
 8000e4c:	40020000 	.word	0x40020000
 8000e50:	2000094c 	.word	0x2000094c
	...

08000e60 <Vector78>:
  flags = (dmastp->dma->ISR >> dmastp->shift) & STM32_DMA_ISR_MASK;
 8000e60:	4b0a      	ldr	r3, [pc, #40]	; (8000e8c <Vector78+0x2c>)
 8000e62:	6819      	ldr	r1, [r3, #0]
  if (flags & dmastp->channel->CCR) {
 8000e64:	6c5a      	ldr	r2, [r3, #68]	; 0x44
  flags = (dmastp->dma->ISR >> dmastp->shift) & STM32_DMA_ISR_MASK;
 8000e66:	0b09      	lsrs	r1, r1, #12
 8000e68:	f001 010e 	and.w	r1, r1, #14
  if (flags & dmastp->channel->CCR) {
 8000e6c:	4211      	tst	r1, r2
 8000e6e:	d00b      	beq.n	8000e88 <Vector78+0x28>
    if (dma.streams[selfindex].func) {
 8000e70:	4807      	ldr	r0, [pc, #28]	; (8000e90 <Vector78+0x30>)
OSAL_IRQ_HANDLER(STM32_DMA1_CH4_HANDLER) {
 8000e72:	b510      	push	{r4, lr}
    if (dma.streams[selfindex].func) {
 8000e74:	6a04      	ldr	r4, [r0, #32]
    dmastp->dma->IFCR = flags << dmastp->shift;
 8000e76:	030a      	lsls	r2, r1, #12
 8000e78:	605a      	str	r2, [r3, #4]
    if (dma.streams[selfindex].func) {
 8000e7a:	b10c      	cbz	r4, 8000e80 <Vector78+0x20>
      dma.streams[selfindex].func(dma.streams[selfindex].param, flags);
 8000e7c:	6a40      	ldr	r0, [r0, #36]	; 0x24
 8000e7e:	47a0      	blx	r4
}
 8000e80:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  OSAL_IRQ_EPILOGUE();
 8000e84:	f003 b8e4 	b.w	8004050 <__port_irq_epilogue>
 8000e88:	f003 b8e2 	b.w	8004050 <__port_irq_epilogue>
 8000e8c:	40020000 	.word	0x40020000
 8000e90:	2000094c 	.word	0x2000094c
	...

08000ea0 <Vector7C>:
  flags = (dmastp->dma->ISR >> dmastp->shift) & STM32_DMA_ISR_MASK;
 8000ea0:	4b0a      	ldr	r3, [pc, #40]	; (8000ecc <Vector7C+0x2c>)
 8000ea2:	6819      	ldr	r1, [r3, #0]
  if (flags & dmastp->channel->CCR) {
 8000ea4:	6d9a      	ldr	r2, [r3, #88]	; 0x58
  flags = (dmastp->dma->ISR >> dmastp->shift) & STM32_DMA_ISR_MASK;
 8000ea6:	0c09      	lsrs	r1, r1, #16
 8000ea8:	f001 010e 	and.w	r1, r1, #14
  if (flags & dmastp->channel->CCR) {
 8000eac:	4211      	tst	r1, r2
 8000eae:	d00b      	beq.n	8000ec8 <Vector7C+0x28>
    if (dma.streams[selfindex].func) {
 8000eb0:	4807      	ldr	r0, [pc, #28]	; (8000ed0 <Vector7C+0x30>)
OSAL_IRQ_HANDLER(STM32_DMA1_CH5_HANDLER) {
 8000eb2:	b510      	push	{r4, lr}
    if (dma.streams[selfindex].func) {
 8000eb4:	6a84      	ldr	r4, [r0, #40]	; 0x28
    dmastp->dma->IFCR = flags << dmastp->shift;
 8000eb6:	040a      	lsls	r2, r1, #16
 8000eb8:	605a      	str	r2, [r3, #4]
    if (dma.streams[selfindex].func) {
 8000eba:	b10c      	cbz	r4, 8000ec0 <Vector7C+0x20>
      dma.streams[selfindex].func(dma.streams[selfindex].param, flags);
 8000ebc:	6ac0      	ldr	r0, [r0, #44]	; 0x2c
 8000ebe:	47a0      	blx	r4
}
 8000ec0:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  OSAL_IRQ_EPILOGUE();
 8000ec4:	f003 b8c4 	b.w	8004050 <__port_irq_epilogue>
 8000ec8:	f003 b8c2 	b.w	8004050 <__port_irq_epilogue>
 8000ecc:	40020000 	.word	0x40020000
 8000ed0:	2000094c 	.word	0x2000094c
	...

08000ee0 <Vector80>:
  flags = (dmastp->dma->ISR >> dmastp->shift) & STM32_DMA_ISR_MASK;
 8000ee0:	4b0a      	ldr	r3, [pc, #40]	; (8000f0c <Vector80+0x2c>)
 8000ee2:	6819      	ldr	r1, [r3, #0]
  if (flags & dmastp->channel->CCR) {
 8000ee4:	6eda      	ldr	r2, [r3, #108]	; 0x6c
  flags = (dmastp->dma->ISR >> dmastp->shift) & STM32_DMA_ISR_MASK;
 8000ee6:	0d09      	lsrs	r1, r1, #20
 8000ee8:	f001 010e 	and.w	r1, r1, #14
  if (flags & dmastp->channel->CCR) {
 8000eec:	4211      	tst	r1, r2
 8000eee:	d00b      	beq.n	8000f08 <Vector80+0x28>
    if (dma.streams[selfindex].func) {
 8000ef0:	4807      	ldr	r0, [pc, #28]	; (8000f10 <Vector80+0x30>)
OSAL_IRQ_HANDLER(STM32_DMA1_CH6_HANDLER) {
 8000ef2:	b510      	push	{r4, lr}
    if (dma.streams[selfindex].func) {
 8000ef4:	6b04      	ldr	r4, [r0, #48]	; 0x30
    dmastp->dma->IFCR = flags << dmastp->shift;
 8000ef6:	050a      	lsls	r2, r1, #20
 8000ef8:	605a      	str	r2, [r3, #4]
    if (dma.streams[selfindex].func) {
 8000efa:	b10c      	cbz	r4, 8000f00 <Vector80+0x20>
      dma.streams[selfindex].func(dma.streams[selfindex].param, flags);
 8000efc:	6b40      	ldr	r0, [r0, #52]	; 0x34
 8000efe:	47a0      	blx	r4
}
 8000f00:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  OSAL_IRQ_EPILOGUE();
 8000f04:	f003 b8a4 	b.w	8004050 <__port_irq_epilogue>
 8000f08:	f003 b8a2 	b.w	8004050 <__port_irq_epilogue>
 8000f0c:	40020000 	.word	0x40020000
 8000f10:	2000094c 	.word	0x2000094c
	...

08000f20 <Vector84>:
  flags = (dmastp->dma->ISR >> dmastp->shift) & STM32_DMA_ISR_MASK;
 8000f20:	4b0b      	ldr	r3, [pc, #44]	; (8000f50 <Vector84+0x30>)
 8000f22:	6819      	ldr	r1, [r3, #0]
  if (flags & dmastp->channel->CCR) {
 8000f24:	f8d3 2080 	ldr.w	r2, [r3, #128]	; 0x80
  flags = (dmastp->dma->ISR >> dmastp->shift) & STM32_DMA_ISR_MASK;
 8000f28:	0e09      	lsrs	r1, r1, #24
 8000f2a:	f001 010e 	and.w	r1, r1, #14
  if (flags & dmastp->channel->CCR) {
 8000f2e:	4211      	tst	r1, r2
 8000f30:	d00b      	beq.n	8000f4a <Vector84+0x2a>
    if (dma.streams[selfindex].func) {
 8000f32:	4808      	ldr	r0, [pc, #32]	; (8000f54 <Vector84+0x34>)
OSAL_IRQ_HANDLER(STM32_DMA1_CH7_HANDLER) {
 8000f34:	b510      	push	{r4, lr}
    if (dma.streams[selfindex].func) {
 8000f36:	6b84      	ldr	r4, [r0, #56]	; 0x38
    dmastp->dma->IFCR = flags << dmastp->shift;
 8000f38:	060a      	lsls	r2, r1, #24
 8000f3a:	605a      	str	r2, [r3, #4]
    if (dma.streams[selfindex].func) {
 8000f3c:	b10c      	cbz	r4, 8000f42 <Vector84+0x22>
      dma.streams[selfindex].func(dma.streams[selfindex].param, flags);
 8000f3e:	6bc0      	ldr	r0, [r0, #60]	; 0x3c
 8000f40:	47a0      	blx	r4
}
 8000f42:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  OSAL_IRQ_EPILOGUE();
 8000f46:	f003 b883 	b.w	8004050 <__port_irq_epilogue>
 8000f4a:	f003 b881 	b.w	8004050 <__port_irq_epilogue>
 8000f4e:	bf00      	nop
 8000f50:	40020000 	.word	0x40020000
 8000f54:	2000094c 	.word	0x2000094c
	...

08000f60 <Vector120>:
OSAL_IRQ_HANDLER(STM32_DMA2_CH1_HANDLER) {
 8000f60:	b508      	push	{r3, lr}
  flags = (dmastp->dma->ISR >> dmastp->shift) & STM32_DMA_ISR_MASK;
 8000f62:	4b08      	ldr	r3, [pc, #32]	; (8000f84 <Vector120+0x24>)
 8000f64:	6819      	ldr	r1, [r3, #0]
  if (flags & dmastp->channel->CCR) {
 8000f66:	689a      	ldr	r2, [r3, #8]
  flags = (dmastp->dma->ISR >> dmastp->shift) & STM32_DMA_ISR_MASK;
 8000f68:	f001 010e 	and.w	r1, r1, #14
  if (flags & dmastp->channel->CCR) {
 8000f6c:	4211      	tst	r1, r2
 8000f6e:	d005      	beq.n	8000f7c <Vector120+0x1c>
    if (dma.streams[selfindex].func) {
 8000f70:	4a05      	ldr	r2, [pc, #20]	; (8000f88 <Vector120+0x28>)
    dmastp->dma->IFCR = flags << dmastp->shift;
 8000f72:	6059      	str	r1, [r3, #4]
    if (dma.streams[selfindex].func) {
 8000f74:	6c13      	ldr	r3, [r2, #64]	; 0x40
 8000f76:	b10b      	cbz	r3, 8000f7c <Vector120+0x1c>
      dma.streams[selfindex].func(dma.streams[selfindex].param, flags);
 8000f78:	6c50      	ldr	r0, [r2, #68]	; 0x44
 8000f7a:	4798      	blx	r3
}
 8000f7c:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  OSAL_IRQ_EPILOGUE();
 8000f80:	f003 b866 	b.w	8004050 <__port_irq_epilogue>
 8000f84:	40020400 	.word	0x40020400
 8000f88:	2000094c 	.word	0x2000094c
 8000f8c:	00000000 	.word	0x00000000

08000f90 <Vector124>:
  flags = (dmastp->dma->ISR >> dmastp->shift) & STM32_DMA_ISR_MASK;
 8000f90:	4b0a      	ldr	r3, [pc, #40]	; (8000fbc <Vector124+0x2c>)
 8000f92:	6819      	ldr	r1, [r3, #0]
  if (flags & dmastp->channel->CCR) {
 8000f94:	69da      	ldr	r2, [r3, #28]
  flags = (dmastp->dma->ISR >> dmastp->shift) & STM32_DMA_ISR_MASK;
 8000f96:	0909      	lsrs	r1, r1, #4
 8000f98:	f001 010e 	and.w	r1, r1, #14
  if (flags & dmastp->channel->CCR) {
 8000f9c:	4211      	tst	r1, r2
 8000f9e:	d00b      	beq.n	8000fb8 <Vector124+0x28>
    if (dma.streams[selfindex].func) {
 8000fa0:	4807      	ldr	r0, [pc, #28]	; (8000fc0 <Vector124+0x30>)
OSAL_IRQ_HANDLER(STM32_DMA2_CH2_HANDLER) {
 8000fa2:	b510      	push	{r4, lr}
    if (dma.streams[selfindex].func) {
 8000fa4:	6c84      	ldr	r4, [r0, #72]	; 0x48
    dmastp->dma->IFCR = flags << dmastp->shift;
 8000fa6:	010a      	lsls	r2, r1, #4
 8000fa8:	605a      	str	r2, [r3, #4]
    if (dma.streams[selfindex].func) {
 8000faa:	b10c      	cbz	r4, 8000fb0 <Vector124+0x20>
      dma.streams[selfindex].func(dma.streams[selfindex].param, flags);
 8000fac:	6cc0      	ldr	r0, [r0, #76]	; 0x4c
 8000fae:	47a0      	blx	r4
}
 8000fb0:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  OSAL_IRQ_EPILOGUE();
 8000fb4:	f003 b84c 	b.w	8004050 <__port_irq_epilogue>
 8000fb8:	f003 b84a 	b.w	8004050 <__port_irq_epilogue>
 8000fbc:	40020400 	.word	0x40020400
 8000fc0:	2000094c 	.word	0x2000094c
	...

08000fd0 <Vector128>:
  flags = (dmastp->dma->ISR >> dmastp->shift) & STM32_DMA_ISR_MASK;
 8000fd0:	4b0a      	ldr	r3, [pc, #40]	; (8000ffc <Vector128+0x2c>)
 8000fd2:	6819      	ldr	r1, [r3, #0]
  if (flags & dmastp->channel->CCR) {
 8000fd4:	6b1a      	ldr	r2, [r3, #48]	; 0x30
  flags = (dmastp->dma->ISR >> dmastp->shift) & STM32_DMA_ISR_MASK;
 8000fd6:	0a09      	lsrs	r1, r1, #8
 8000fd8:	f001 010e 	and.w	r1, r1, #14
  if (flags & dmastp->channel->CCR) {
 8000fdc:	4211      	tst	r1, r2
 8000fde:	d00b      	beq.n	8000ff8 <Vector128+0x28>
    if (dma.streams[selfindex].func) {
 8000fe0:	4807      	ldr	r0, [pc, #28]	; (8001000 <Vector128+0x30>)
OSAL_IRQ_HANDLER(STM32_DMA2_CH3_HANDLER) {
 8000fe2:	b510      	push	{r4, lr}
    if (dma.streams[selfindex].func) {
 8000fe4:	6d04      	ldr	r4, [r0, #80]	; 0x50
    dmastp->dma->IFCR = flags << dmastp->shift;
 8000fe6:	020a      	lsls	r2, r1, #8
 8000fe8:	605a      	str	r2, [r3, #4]
    if (dma.streams[selfindex].func) {
 8000fea:	b10c      	cbz	r4, 8000ff0 <Vector128+0x20>
      dma.streams[selfindex].func(dma.streams[selfindex].param, flags);
 8000fec:	6d40      	ldr	r0, [r0, #84]	; 0x54
 8000fee:	47a0      	blx	r4
}
 8000ff0:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  OSAL_IRQ_EPILOGUE();
 8000ff4:	f003 b82c 	b.w	8004050 <__port_irq_epilogue>
 8000ff8:	f003 b82a 	b.w	8004050 <__port_irq_epilogue>
 8000ffc:	40020400 	.word	0x40020400
 8001000:	2000094c 	.word	0x2000094c
	...

08001010 <Vector12C>:
  flags = (dmastp->dma->ISR >> dmastp->shift) & STM32_DMA_ISR_MASK;
 8001010:	4b0a      	ldr	r3, [pc, #40]	; (800103c <Vector12C+0x2c>)
 8001012:	6819      	ldr	r1, [r3, #0]
  if (flags & dmastp->channel->CCR) {
 8001014:	6c5a      	ldr	r2, [r3, #68]	; 0x44
  flags = (dmastp->dma->ISR >> dmastp->shift) & STM32_DMA_ISR_MASK;
 8001016:	0b09      	lsrs	r1, r1, #12
 8001018:	f001 010e 	and.w	r1, r1, #14
  if (flags & dmastp->channel->CCR) {
 800101c:	4211      	tst	r1, r2
 800101e:	d00b      	beq.n	8001038 <Vector12C+0x28>
    if (dma.streams[selfindex].func) {
 8001020:	4807      	ldr	r0, [pc, #28]	; (8001040 <Vector12C+0x30>)
OSAL_IRQ_HANDLER(STM32_DMA2_CH4_HANDLER) {
 8001022:	b510      	push	{r4, lr}
    if (dma.streams[selfindex].func) {
 8001024:	6d84      	ldr	r4, [r0, #88]	; 0x58
    dmastp->dma->IFCR = flags << dmastp->shift;
 8001026:	030a      	lsls	r2, r1, #12
 8001028:	605a      	str	r2, [r3, #4]
    if (dma.streams[selfindex].func) {
 800102a:	b10c      	cbz	r4, 8001030 <Vector12C+0x20>
      dma.streams[selfindex].func(dma.streams[selfindex].param, flags);
 800102c:	6dc0      	ldr	r0, [r0, #92]	; 0x5c
 800102e:	47a0      	blx	r4
}
 8001030:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  OSAL_IRQ_EPILOGUE();
 8001034:	f003 b80c 	b.w	8004050 <__port_irq_epilogue>
 8001038:	f003 b80a 	b.w	8004050 <__port_irq_epilogue>
 800103c:	40020400 	.word	0x40020400
 8001040:	2000094c 	.word	0x2000094c
	...

08001050 <Vector130>:
  flags = (dmastp->dma->ISR >> dmastp->shift) & STM32_DMA_ISR_MASK;
 8001050:	4b0a      	ldr	r3, [pc, #40]	; (800107c <Vector130+0x2c>)
 8001052:	6819      	ldr	r1, [r3, #0]
  if (flags & dmastp->channel->CCR) {
 8001054:	6d9a      	ldr	r2, [r3, #88]	; 0x58
  flags = (dmastp->dma->ISR >> dmastp->shift) & STM32_DMA_ISR_MASK;
 8001056:	0c09      	lsrs	r1, r1, #16
 8001058:	f001 010e 	and.w	r1, r1, #14
  if (flags & dmastp->channel->CCR) {
 800105c:	4211      	tst	r1, r2
 800105e:	d00b      	beq.n	8001078 <Vector130+0x28>
    if (dma.streams[selfindex].func) {
 8001060:	4807      	ldr	r0, [pc, #28]	; (8001080 <Vector130+0x30>)
OSAL_IRQ_HANDLER(STM32_DMA2_CH5_HANDLER) {
 8001062:	b510      	push	{r4, lr}
    if (dma.streams[selfindex].func) {
 8001064:	6e04      	ldr	r4, [r0, #96]	; 0x60
    dmastp->dma->IFCR = flags << dmastp->shift;
 8001066:	040a      	lsls	r2, r1, #16
 8001068:	605a      	str	r2, [r3, #4]
    if (dma.streams[selfindex].func) {
 800106a:	b10c      	cbz	r4, 8001070 <Vector130+0x20>
      dma.streams[selfindex].func(dma.streams[selfindex].param, flags);
 800106c:	6e40      	ldr	r0, [r0, #100]	; 0x64
 800106e:	47a0      	blx	r4
}
 8001070:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  OSAL_IRQ_EPILOGUE();
 8001074:	f002 bfec 	b.w	8004050 <__port_irq_epilogue>
 8001078:	f002 bfea 	b.w	8004050 <__port_irq_epilogue>
 800107c:	40020400 	.word	0x40020400
 8001080:	2000094c 	.word	0x2000094c
	...

08001090 <Vector150>:
  flags = (dmastp->dma->ISR >> dmastp->shift) & STM32_DMA_ISR_MASK;
 8001090:	4b0a      	ldr	r3, [pc, #40]	; (80010bc <Vector150+0x2c>)
 8001092:	6819      	ldr	r1, [r3, #0]
  if (flags & dmastp->channel->CCR) {
 8001094:	6eda      	ldr	r2, [r3, #108]	; 0x6c
  flags = (dmastp->dma->ISR >> dmastp->shift) & STM32_DMA_ISR_MASK;
 8001096:	0d09      	lsrs	r1, r1, #20
 8001098:	f001 010e 	and.w	r1, r1, #14
  if (flags & dmastp->channel->CCR) {
 800109c:	4211      	tst	r1, r2
 800109e:	d00b      	beq.n	80010b8 <Vector150+0x28>
    if (dma.streams[selfindex].func) {
 80010a0:	4807      	ldr	r0, [pc, #28]	; (80010c0 <Vector150+0x30>)
OSAL_IRQ_HANDLER(STM32_DMA2_CH6_HANDLER) {
 80010a2:	b510      	push	{r4, lr}
    if (dma.streams[selfindex].func) {
 80010a4:	6e84      	ldr	r4, [r0, #104]	; 0x68
    dmastp->dma->IFCR = flags << dmastp->shift;
 80010a6:	050a      	lsls	r2, r1, #20
 80010a8:	605a      	str	r2, [r3, #4]
    if (dma.streams[selfindex].func) {
 80010aa:	b10c      	cbz	r4, 80010b0 <Vector150+0x20>
      dma.streams[selfindex].func(dma.streams[selfindex].param, flags);
 80010ac:	6ec0      	ldr	r0, [r0, #108]	; 0x6c
 80010ae:	47a0      	blx	r4
}
 80010b0:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  OSAL_IRQ_EPILOGUE();
 80010b4:	f002 bfcc 	b.w	8004050 <__port_irq_epilogue>
 80010b8:	f002 bfca 	b.w	8004050 <__port_irq_epilogue>
 80010bc:	40020400 	.word	0x40020400
 80010c0:	2000094c 	.word	0x2000094c
	...

080010d0 <Vector154>:
  flags = (dmastp->dma->ISR >> dmastp->shift) & STM32_DMA_ISR_MASK;
 80010d0:	4b0b      	ldr	r3, [pc, #44]	; (8001100 <Vector154+0x30>)
 80010d2:	6819      	ldr	r1, [r3, #0]
  if (flags & dmastp->channel->CCR) {
 80010d4:	f8d3 2080 	ldr.w	r2, [r3, #128]	; 0x80
  flags = (dmastp->dma->ISR >> dmastp->shift) & STM32_DMA_ISR_MASK;
 80010d8:	0e09      	lsrs	r1, r1, #24
 80010da:	f001 010e 	and.w	r1, r1, #14
  if (flags & dmastp->channel->CCR) {
 80010de:	4211      	tst	r1, r2
 80010e0:	d00b      	beq.n	80010fa <Vector154+0x2a>
    if (dma.streams[selfindex].func) {
 80010e2:	4808      	ldr	r0, [pc, #32]	; (8001104 <Vector154+0x34>)
OSAL_IRQ_HANDLER(STM32_DMA2_CH7_HANDLER) {
 80010e4:	b510      	push	{r4, lr}
    if (dma.streams[selfindex].func) {
 80010e6:	6f04      	ldr	r4, [r0, #112]	; 0x70
    dmastp->dma->IFCR = flags << dmastp->shift;
 80010e8:	060a      	lsls	r2, r1, #24
 80010ea:	605a      	str	r2, [r3, #4]
    if (dma.streams[selfindex].func) {
 80010ec:	b10c      	cbz	r4, 80010f2 <Vector154+0x22>
      dma.streams[selfindex].func(dma.streams[selfindex].param, flags);
 80010ee:	6f40      	ldr	r0, [r0, #116]	; 0x74
 80010f0:	47a0      	blx	r4
}
 80010f2:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  OSAL_IRQ_EPILOGUE();
 80010f6:	f002 bfab 	b.w	8004050 <__port_irq_epilogue>
 80010fa:	f002 bfa9 	b.w	8004050 <__port_irq_epilogue>
 80010fe:	bf00      	nop
 8001100:	40020400 	.word	0x40020400
 8001104:	2000094c 	.word	0x2000094c
	...

08001110 <dmaInit>:
  dma.allocated_mask = 0U;
 8001110:	4a0b      	ldr	r2, [pc, #44]	; (8001140 <dmaInit+0x30>)
 8001112:	4b0c      	ldr	r3, [pc, #48]	; (8001144 <dmaInit+0x34>)
  dma.isr_mask       = 0U;
 8001114:	480c      	ldr	r0, [pc, #48]	; (8001148 <dmaInit+0x38>)
  dma.allocated_mask = 0U;
 8001116:	2100      	movs	r1, #0
  dma.isr_mask       = 0U;
 8001118:	e9c2 1100 	strd	r1, r1, [r2]
  for (i = 0; i < STM32_DMA_STREAMS; i++) {
 800111c:	f503 7c8c 	add.w	ip, r3, #280	; 0x118
 8001120:	e001      	b.n	8001126 <dmaInit+0x16>
    _stm32_dma_streams[i].channel->CCR = STM32_DMA_CCR_RESET_VALUE;
 8001122:	f853 0c14 	ldr.w	r0, [r3, #-20]
 8001126:	6001      	str	r1, [r0, #0]
  for (i = 0; i < STM32_DMA_STREAMS; i++) {
 8001128:	3314      	adds	r3, #20
 800112a:	4563      	cmp	r3, ip
    dma.streams[i].func = NULL;
 800112c:	f842 1f08 	str.w	r1, [r2, #8]!
  for (i = 0; i < STM32_DMA_STREAMS; i++) {
 8001130:	d1f7      	bne.n	8001122 <dmaInit+0x12>
  DMA1->IFCR = 0xFFFFFFFFU;
 8001132:	4906      	ldr	r1, [pc, #24]	; (800114c <dmaInit+0x3c>)
  DMA2->IFCR = 0xFFFFFFFFU;
 8001134:	4a06      	ldr	r2, [pc, #24]	; (8001150 <dmaInit+0x40>)
  DMA1->IFCR = 0xFFFFFFFFU;
 8001136:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
 800113a:	604b      	str	r3, [r1, #4]
  DMA2->IFCR = 0xFFFFFFFFU;
 800113c:	6053      	str	r3, [r2, #4]
}
 800113e:	4770      	bx	lr
 8001140:	2000094c 	.word	0x2000094c
 8001144:	0800a71c 	.word	0x0800a71c
 8001148:	40020008 	.word	0x40020008
 800114c:	40020000 	.word	0x40020000
 8001150:	40020400 	.word	0x40020400
	...

08001160 <_pal_lld_init>:

  for (i = 0; i < 16; i++) {
    _pal_init_event(i);
  }
#endif
}
 8001160:	4770      	bx	lr
 8001162:	bf00      	nop
	...

08001170 <st_lld_init>:
                "clock rounding error");
  osalDbgAssert(((ST_CLOCK_SRC / OSAL_ST_FREQUENCY) - 1U) < 0x10000,
                "clock prescaler overflow");

  /* Enabling timer clock.*/
  ST_ENABLE_CLOCK();
 8001170:	4a10      	ldr	r2, [pc, #64]	; (80011b4 <st_lld_init+0x44>)

  /* Enabling the stop mode during debug for this timer.*/
  ST_ENABLE_STOP();
 8001172:	4811      	ldr	r0, [pc, #68]	; (80011b8 <st_lld_init+0x48>)
  ST_ENABLE_CLOCK();
 8001174:	6d91      	ldr	r1, [r2, #88]	; 0x58
 8001176:	f041 0101 	orr.w	r1, r1, #1
void st_lld_init(void) {
 800117a:	b410      	push	{r4}
  ST_ENABLE_CLOCK();
 800117c:	6591      	str	r1, [r2, #88]	; 0x58
 800117e:	6f91      	ldr	r1, [r2, #120]	; 0x78
 8001180:	f041 0101 	orr.w	r1, r1, #1
 8001184:	6791      	str	r1, [r2, #120]	; 0x78
 8001186:	6f92      	ldr	r2, [r2, #120]	; 0x78
  ST_ENABLE_STOP();
 8001188:	6882      	ldr	r2, [r0, #8]

  /* Initializing the counter in free running mode.*/
  STM32_ST_TIM->PSC    = (ST_CLOCK_SRC / OSAL_ST_FREQUENCY) - 1;
 800118a:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
  ST_ENABLE_STOP();
 800118e:	f042 0201 	orr.w	r2, r2, #1
 8001192:	6082      	str	r2, [r0, #8]
  STM32_ST_TIM->PSC    = (ST_CLOCK_SRC / OSAL_ST_FREQUENCY) - 1;
 8001194:	f641 743f 	movw	r4, #7999	; 0x1f3f
  STM32_ST_TIM->ARR    = ST_ARR_INIT;
  STM32_ST_TIM->CCMR1  = 0;
 8001198:	2200      	movs	r2, #0
#if ST_LLD_NUM_ALARMS > 3
  STM32_ST_TIM->CCR[3] = 0;
#endif
  STM32_ST_TIM->DIER   = 0;
  STM32_ST_TIM->CR2    = 0;
  STM32_ST_TIM->EGR    = TIM_EGR_UG;
 800119a:	2101      	movs	r1, #1
  STM32_ST_TIM->ARR    = ST_ARR_INIT;
 800119c:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
  STM32_ST_TIM->PSC    = (ST_CLOCK_SRC / OSAL_ST_FREQUENCY) - 1;
 80011a0:	629c      	str	r4, [r3, #40]	; 0x28
  STM32_ST_TIM->ARR    = ST_ARR_INIT;
 80011a2:	62d8      	str	r0, [r3, #44]	; 0x2c
                  SysTick_CTRL_TICKINT_Msk;

  /* IRQ enabled.*/
  nvicSetSystemHandlerPriority(HANDLER_SYSTICK, STM32_ST_IRQ_PRIORITY);
#endif /* OSAL_ST_MODE == OSAL_ST_MODE_PERIODIC */
}
 80011a4:	bc10      	pop	{r4}
  STM32_ST_TIM->CCMR1  = 0;
 80011a6:	619a      	str	r2, [r3, #24]
  STM32_ST_TIM->CCR[0] = 0;
 80011a8:	635a      	str	r2, [r3, #52]	; 0x34
  STM32_ST_TIM->DIER   = 0;
 80011aa:	60da      	str	r2, [r3, #12]
  STM32_ST_TIM->CR2    = 0;
 80011ac:	605a      	str	r2, [r3, #4]
  STM32_ST_TIM->EGR    = TIM_EGR_UG;
 80011ae:	6159      	str	r1, [r3, #20]
  STM32_ST_TIM->CR1    = TIM_CR1_CEN;
 80011b0:	6019      	str	r1, [r3, #0]
}
 80011b2:	4770      	bx	lr
 80011b4:	40021000 	.word	0x40021000
 80011b8:	e0042000 	.word	0xe0042000
 80011bc:	00000000 	.word	0x00000000

080011c0 <st_lld_serve_interrupt>:
void st_lld_serve_interrupt(void) {
#if OSAL_ST_MODE == OSAL_ST_MODE_FREERUNNING
  uint32_t sr;
  stm32_tim_t *timp = STM32_ST_TIM;

  sr  = timp->SR;
 80011c0:	f04f 4280 	mov.w	r2, #1073741824	; 0x40000000
void st_lld_serve_interrupt(void) {
 80011c4:	b508      	push	{r3, lr}
  sr  = timp->SR;
 80011c6:	6911      	ldr	r1, [r2, #16]
  sr &= timp->DIER & STM32_TIM_DIER_IRQ_MASK;
 80011c8:	68d3      	ldr	r3, [r2, #12]
 80011ca:	400b      	ands	r3, r1
 80011cc:	b2d9      	uxtb	r1, r3
  timp->SR = ~sr;
 80011ce:	43c9      	mvns	r1, r1

  if ((sr & TIM_SR_CC1IF) != 0U)
 80011d0:	079b      	lsls	r3, r3, #30
  timp->SR = ~sr;
 80011d2:	6111      	str	r1, [r2, #16]
  if ((sr & TIM_SR_CC1IF) != 0U)
 80011d4:	d400      	bmi.n	80011d8 <st_lld_serve_interrupt+0x18>
      st_callbacks[2](3U);
    }
  }
#endif
#endif
}
 80011d6:	bd08      	pop	{r3, pc}
 80011d8:	2330      	movs	r3, #48	; 0x30
 80011da:	f383 8811 	msr	BASEPRI, r3
  chSysTimerHandlerI();
 80011de:	f000 fa47 	bl	8001670 <chSysTimerHandlerI>
 80011e2:	2300      	movs	r3, #0
 80011e4:	f383 8811 	msr	BASEPRI, r3
 80011e8:	bd08      	pop	{r3, pc}
 80011ea:	bf00      	nop
 80011ec:	0000      	movs	r0, r0
	...

080011f0 <notify2>:

#if STM32_SERIAL_USE_USART2 || defined(__DOXYGEN__)
static void notify2(io_queue_t *qp) {

  (void)qp;
  USART2->CR1 |= USART_CR1_TXEIE | USART_CR1_TCIE;
 80011f0:	4a02      	ldr	r2, [pc, #8]	; (80011fc <notify2+0xc>)
 80011f2:	6813      	ldr	r3, [r2, #0]
 80011f4:	f043 03c0 	orr.w	r3, r3, #192	; 0xc0
 80011f8:	6013      	str	r3, [r2, #0]
}
 80011fa:	4770      	bx	lr
 80011fc:	40004400 	.word	0x40004400

08001200 <sd_lld_init>:
/**
 * @brief   Low level serial driver initialization.
 *
 * @notapi
 */
void sd_lld_init(void) {
 8001200:	b510      	push	{r4, lr}
  nvicEnableVector(STM32_USART1_NUMBER, STM32_SERIAL_USART1_PRIORITY);
#endif
#endif

#if STM32_SERIAL_USE_USART2
  sdObjectInit(&SD2);
 8001202:	4c0c      	ldr	r4, [pc, #48]	; (8001234 <sd_lld_init+0x34>)
void sd_lld_init(void) {
 8001204:	b082      	sub	sp, #8
  sdObjectInit(&SD2);
 8001206:	4620      	mov	r0, r4
 8001208:	f7ff fb8a 	bl	8000920 <sdObjectInit>
  iqObjectInit(&SD2.iqueue, sd_in_buf2, sizeof sd_in_buf2, NULL, &SD2);
 800120c:	f104 000c 	add.w	r0, r4, #12
 8001210:	4909      	ldr	r1, [pc, #36]	; (8001238 <sd_lld_init+0x38>)
 8001212:	9400      	str	r4, [sp, #0]
 8001214:	2300      	movs	r3, #0
 8001216:	2210      	movs	r2, #16
 8001218:	f7ff f9da 	bl	80005d0 <iqObjectInit>
  oqObjectInit(&SD2.oqueue, sd_out_buf2, sizeof sd_out_buf2, notify2, &SD2);
 800121c:	4b07      	ldr	r3, [pc, #28]	; (800123c <sd_lld_init+0x3c>)
 800121e:	4908      	ldr	r1, [pc, #32]	; (8001240 <sd_lld_init+0x40>)
 8001220:	9400      	str	r4, [sp, #0]
 8001222:	2210      	movs	r2, #16
 8001224:	f104 0030 	add.w	r0, r4, #48	; 0x30
 8001228:	f7ff fa6a 	bl	8000700 <oqObjectInit>
  SD2.usart = USART2;
 800122c:	4b05      	ldr	r3, [pc, #20]	; (8001244 <sd_lld_init+0x44>)
 800122e:	6563      	str	r3, [r4, #84]	; 0x54
  LPSD1.usart = LPUART1;
#if !defined(STM32_LPUART1_SUPPRESS_ISR) && defined(STM32_LPUART1_NUMBER)
  nvicEnableVector(STM32_LPUART1_NUMBER, STM32_SERIAL_LPUART1_PRIORITY);
#endif
#endif
}
 8001230:	b002      	add	sp, #8
 8001232:	bd10      	pop	{r4, pc}
 8001234:	200009c4 	.word	0x200009c4
 8001238:	20000a20 	.word	0x20000a20
 800123c:	080011f1 	.word	0x080011f1
 8001240:	20000a30 	.word	0x20000a30
 8001244:	40004400 	.word	0x40004400
	...

08001250 <sd_lld_start>:
 *                      If this parameter is set to @p NULL then a default
 *                      configuration is used.
 *
 * @notapi
 */
void sd_lld_start(SerialDriver *sdp, const SerialConfig *config) {
 8001250:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  uint32_t clock = 0U;

  if (config == NULL)
 8001254:	b391      	cbz	r1, 80012bc <sd_lld_start+0x6c>
    brr = (uint32_t)((clock + config->speed/2) / config->speed);
 8001256:	e9d1 4200 	ldrd	r4, r2, [r1]
  u->CR3 = config->cr3 | USART_CR3_EIE;
 800125a:	e9d1 6502 	ldrd	r6, r5, [r1, #8]
    config = &default_config;

  if (sdp->state == SD_STOP) {
 800125e:	7a03      	ldrb	r3, [r0, #8]
                         USART_CR1_RXNEIE | USART_CR1_TE |
 8001260:	f442 7796 	orr.w	r7, r2, #300	; 0x12c
  if (sdp->state == SD_STOP) {
 8001264:	2b01      	cmp	r3, #1
  u->CR2 = config->cr2 | USART_CR2_LBDIE;
 8001266:	f046 0c40 	orr.w	ip, r6, #64	; 0x40
    brr = (uint32_t)((clock + config->speed/2) / config->speed);
 800126a:	ea4f 0354 	mov.w	r3, r4, lsr #1
  u->CR3 = config->cr3 | USART_CR3_EIE;
 800126e:	f045 0501 	orr.w	r5, r5, #1
                         USART_CR1_RXNEIE | USART_CR1_TE |
 8001272:	f047 0701 	orr.w	r7, r7, #1
    if (config->cr1 & USART_CR1_OVER8)
 8001276:	f402 4600 	and.w	r6, r2, #32768	; 0x8000
  if ((config->cr1 & USART_CR1_PCE) != 0U) {
 800127a:	f402 6180 	and.w	r1, r2, #1024	; 0x400
  if (sdp->state == SD_STOP) {
 800127e:	d03b      	beq.n	80012f8 <sd_lld_start+0xa8>
    brr = (uint32_t)((clock + config->speed/2) / config->speed);
 8001280:	fbb3 f3f4 	udiv	r3, r3, r4
  USART_TypeDef *u = sdp->usart;
 8001284:	6d44      	ldr	r4, [r0, #84]	; 0x54
    if (config->cr1 & USART_CR1_OVER8)
 8001286:	b12e      	cbz	r6, 8001294 <sd_lld_start+0x44>
      brr = ((brr & ~7) * 2) | (brr & 7);
 8001288:	f023 0607 	bic.w	r6, r3, #7
 800128c:	f003 0307 	and.w	r3, r3, #7
 8001290:	ea43 0346 	orr.w	r3, r3, r6, lsl #1
  u->BRR = brr;
 8001294:	60e3      	str	r3, [r4, #12]
  u->ICR = 0xFFFFFFFFU;
 8001296:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
  u->CR2 = config->cr2 | USART_CR2_LBDIE;
 800129a:	f8c4 c004 	str.w	ip, [r4, #4]
  u->CR3 = config->cr3 | USART_CR3_EIE;
 800129e:	60a5      	str	r5, [r4, #8]
  u->CR1 = config->cr1 | USART_CR1_UE | USART_CR1_PEIE |
 80012a0:	6027      	str	r7, [r4, #0]
  u->ICR = 0xFFFFFFFFU;
 80012a2:	6223      	str	r3, [r4, #32]
  if ((config->cr1 & USART_CR1_PCE) != 0U) {
 80012a4:	b1c9      	cbz	r1, 80012da <sd_lld_start+0x8a>
    switch (config->cr1 & (USART_CR1_M_1 | USART_CR1_M_0)) {
 80012a6:	f012 2210 	ands.w	r2, r2, #268439552	; 0x10001000
 80012aa:	d045      	beq.n	8001338 <sd_lld_start+0xe8>
 80012ac:	f1b2 5f80 	cmp.w	r2, #268435456	; 0x10000000
 80012b0:	d114      	bne.n	80012dc <sd_lld_start+0x8c>
      sdp->rxmask = 0x3F;
 80012b2:	233f      	movs	r3, #63	; 0x3f
 80012b4:	f880 3058 	strb.w	r3, [r0, #88]	; 0x58
      rccEnableLPUART1(true);
    }
#endif
  }
  usart_init(sdp, config, clock);
}
 80012b8:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  if (sdp->state == SD_STOP) {
 80012bc:	7a05      	ldrb	r5, [r0, #8]
 80012be:	2d01      	cmp	r5, #1
 80012c0:	d010      	beq.n	80012e4 <sd_lld_start+0x94>
  USART_TypeDef *u = sdp->usart;
 80012c2:	6d43      	ldr	r3, [r0, #84]	; 0x54
  u->CR2 = config->cr2 | USART_CR2_LBDIE;
 80012c4:	2240      	movs	r2, #64	; 0x40
  u->BRR = brr;
 80012c6:	60d9      	str	r1, [r3, #12]
  u->CR3 = config->cr3 | USART_CR3_EIE;
 80012c8:	2401      	movs	r4, #1
  u->CR2 = config->cr2 | USART_CR2_LBDIE;
 80012ca:	605a      	str	r2, [r3, #4]
  u->CR1 = config->cr1 | USART_CR1_UE | USART_CR1_PEIE |
 80012cc:	f240 112d 	movw	r1, #301	; 0x12d
  u->ICR = 0xFFFFFFFFU;
 80012d0:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
  u->CR3 = config->cr3 | USART_CR3_EIE;
 80012d4:	609c      	str	r4, [r3, #8]
  u->CR1 = config->cr1 | USART_CR1_UE | USART_CR1_PEIE |
 80012d6:	6019      	str	r1, [r3, #0]
  u->ICR = 0xFFFFFFFFU;
 80012d8:	621a      	str	r2, [r3, #32]
    sdp->rxmask = 0xFF;
 80012da:	23ff      	movs	r3, #255	; 0xff
 80012dc:	f880 3058 	strb.w	r3, [r0, #88]	; 0x58
}
 80012e0:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  if (sdp->state == SD_STOP) {
 80012e4:	f240 172d 	movw	r7, #301	; 0x12d
 80012e8:	f04f 0c40 	mov.w	ip, #64	; 0x40
 80012ec:	460e      	mov	r6, r1
 80012ee:	460a      	mov	r2, r1
 80012f0:	f44f 4396 	mov.w	r3, #19200	; 0x4b00
 80012f4:	f44f 4416 	mov.w	r4, #38400	; 0x9600
    if (&SD2 == sdp) {
 80012f8:	f8df e048 	ldr.w	lr, [pc, #72]	; 8001344 <sd_lld_start+0xf4>
 80012fc:	4570      	cmp	r0, lr
 80012fe:	d1bf      	bne.n	8001280 <sd_lld_start+0x30>
      rccEnableUSART2(true);
 8001300:	f8df e044 	ldr.w	lr, [pc, #68]	; 8001348 <sd_lld_start+0xf8>
 8001304:	f8de 8058 	ldr.w	r8, [lr, #88]	; 0x58
 8001308:	f448 3800 	orr.w	r8, r8, #131072	; 0x20000
 800130c:	f8ce 8058 	str.w	r8, [lr, #88]	; 0x58
 8001310:	f8de 8078 	ldr.w	r8, [lr, #120]	; 0x78
    brr = (uint32_t)((clock + config->speed/2) / config->speed);
 8001314:	f103 6398 	add.w	r3, r3, #79691776	; 0x4c00000
      rccEnableUSART2(true);
 8001318:	f448 3800 	orr.w	r8, r8, #131072	; 0x20000
    brr = (uint32_t)((clock + config->speed/2) / config->speed);
 800131c:	f503 2396 	add.w	r3, r3, #307200	; 0x4b000
      rccEnableUSART2(true);
 8001320:	f8ce 8078 	str.w	r8, [lr, #120]	; 0x78
    brr = (uint32_t)((clock + config->speed/2) / config->speed);
 8001324:	f503 6380 	add.w	r3, r3, #1024	; 0x400
      rccEnableUSART2(true);
 8001328:	f8de e078 	ldr.w	lr, [lr, #120]	; 0x78
    brr = (uint32_t)((clock + config->speed/2) / config->speed);
 800132c:	fbb3 f3f4 	udiv	r3, r3, r4
  USART_TypeDef *u = sdp->usart;
 8001330:	6d44      	ldr	r4, [r0, #84]	; 0x54
    if (config->cr1 & USART_CR1_OVER8)
 8001332:	2e00      	cmp	r6, #0
 8001334:	d1a8      	bne.n	8001288 <sd_lld_start+0x38>
 8001336:	e7ad      	b.n	8001294 <sd_lld_start+0x44>
      sdp->rxmask = 0x7F;
 8001338:	237f      	movs	r3, #127	; 0x7f
 800133a:	f880 3058 	strb.w	r3, [r0, #88]	; 0x58
}
 800133e:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 8001342:	bf00      	nop
 8001344:	200009c4 	.word	0x200009c4
 8001348:	40021000 	.word	0x40021000
 800134c:	00000000 	.word	0x00000000

08001350 <sd_lld_serve_interrupt>:
/**
 * @brief   Common IRQ handler.
 *
 * @param[in] sdp       communication channel associated to the USART
 */
void sd_lld_serve_interrupt(SerialDriver *sdp) {
 8001350:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
  USART_TypeDef *u = sdp->usart;
 8001354:	f8d0 9054 	ldr.w	r9, [r0, #84]	; 0x54
  uint32_t cr1 = u->CR1;
 8001358:	f8d9 8000 	ldr.w	r8, [r9]
  uint32_t isr;

  /* Reading and clearing status.*/
  isr = u->ISR;
 800135c:	f8d9 401c 	ldr.w	r4, [r9, #28]
  u->ICR = isr;
 8001360:	f8c9 4020 	str.w	r4, [r9, #32]

  /* Error condition detection.*/
  if (isr & (USART_ISR_ORE | USART_ISR_NE | USART_ISR_FE  | USART_ISR_PE))
 8001364:	0721      	lsls	r1, r4, #28
void sd_lld_serve_interrupt(SerialDriver *sdp) {
 8001366:	4682      	mov	sl, r0
  if (isr & (USART_ISR_ORE | USART_ISR_NE | USART_ISR_FE  | USART_ISR_PE))
 8001368:	d159      	bne.n	800141e <sd_lld_serve_interrupt+0xce>
    set_error(sdp, isr);

  /* Special case, LIN break detection.*/
  if (isr & USART_ISR_LBDF) {
 800136a:	05e6      	lsls	r6, r4, #23
 800136c:	d44a      	bmi.n	8001404 <sd_lld_serve_interrupt+0xb4>
  /* Data available, note it is a while in order to handle two situations:
     1) Another byte arrived after removing the previous one, this would cause
        an extra interrupt to serve.
     2) FIFO mode is enabled on devices that support it, we need to empty
        the FIFO.*/
  while (isr & USART_ISR_RXNE) {
 800136e:	06a5      	lsls	r5, r4, #26
 8001370:	d511      	bpl.n	8001396 <sd_lld_serve_interrupt+0x46>
 8001372:	2630      	movs	r6, #48	; 0x30
 8001374:	2500      	movs	r5, #0
 8001376:	f386 8811 	msr	BASEPRI, r6
    osalSysLockFromISR();
    sdIncomingDataI(sdp, (uint8_t)u->RDR & sdp->rxmask);
 800137a:	f8b9 3024 	ldrh.w	r3, [r9, #36]	; 0x24
 800137e:	f89a 1058 	ldrb.w	r1, [sl, #88]	; 0x58
 8001382:	4650      	mov	r0, sl
 8001384:	4019      	ands	r1, r3
 8001386:	f7ff faeb 	bl	8000960 <sdIncomingDataI>
 800138a:	f385 8811 	msr	BASEPRI, r5
    osalSysUnlockFromISR();

    isr = u->ISR;
 800138e:	f8d9 401c 	ldr.w	r4, [r9, #28]
  while (isr & USART_ISR_RXNE) {
 8001392:	06a0      	lsls	r0, r4, #26
 8001394:	d4ef      	bmi.n	8001376 <sd_lld_serve_interrupt+0x26>
     situations:
     1) The data registers has been emptied immediately after writing it, this
        would cause an extra interrupt to serve.
     2) FIFO mode is enabled on devices that support it, we need to fill
        the FIFO.*/
  if (cr1 & USART_CR1_TXEIE) {
 8001396:	f018 0f80 	tst.w	r8, #128	; 0x80
 800139a:	d022      	beq.n	80013e2 <sd_lld_serve_interrupt+0x92>
    while (isr & USART_ISR_TXE) {
 800139c:	0621      	lsls	r1, r4, #24
 800139e:	d520      	bpl.n	80013e2 <sd_lld_serve_interrupt+0x92>
      msg_t b;

      osalSysLockFromISR();
      b = oqGetI(&sdp->oqueue);
 80013a0:	f10a 0630 	add.w	r6, sl, #48	; 0x30
 80013a4:	2530      	movs	r5, #48	; 0x30
 80013a6:	2700      	movs	r7, #0
 80013a8:	e007      	b.n	80013ba <sd_lld_serve_interrupt+0x6a>
        chnAddFlagsI(sdp, CHN_OUTPUT_EMPTY);
        u->CR1 = cr1 & ~USART_CR1_TXEIE;
        osalSysUnlockFromISR();
        break;
      }
      u->TDR = b;
 80013aa:	f8a9 0028 	strh.w	r0, [r9, #40]	; 0x28
 80013ae:	f387 8811 	msr	BASEPRI, r7
      osalSysUnlockFromISR();

      isr = u->ISR;
 80013b2:	f8d9 401c 	ldr.w	r4, [r9, #28]
    while (isr & USART_ISR_TXE) {
 80013b6:	0622      	lsls	r2, r4, #24
 80013b8:	d513      	bpl.n	80013e2 <sd_lld_serve_interrupt+0x92>
 80013ba:	f385 8811 	msr	BASEPRI, r5
      b = oqGetI(&sdp->oqueue);
 80013be:	4630      	mov	r0, r6
 80013c0:	f7ff f9d6 	bl	8000770 <oqGetI>
      if (b < MSG_OK) {
 80013c4:	2800      	cmp	r0, #0
      u->TDR = b;
 80013c6:	b280      	uxth	r0, r0
      if (b < MSG_OK) {
 80013c8:	daef      	bge.n	80013aa <sd_lld_serve_interrupt+0x5a>
  chEvtBroadcastFlagsI(esp, flags);
 80013ca:	2108      	movs	r1, #8
 80013cc:	f10a 0004 	add.w	r0, sl, #4
 80013d0:	f001 fa66 	bl	80028a0 <chEvtBroadcastFlagsI>
        u->CR1 = cr1 & ~USART_CR1_TXEIE;
 80013d4:	f028 0380 	bic.w	r3, r8, #128	; 0x80
 80013d8:	f8c9 3000 	str.w	r3, [r9]
 80013dc:	2300      	movs	r3, #0
 80013de:	f383 8811 	msr	BASEPRI, r3
    }
  }

  /* Physical transmission end.*/
  if ((cr1 & USART_CR1_TCIE) && (isr & USART_ISR_TC)) {
 80013e2:	f018 0f40 	tst.w	r8, #64	; 0x40
 80013e6:	d00b      	beq.n	8001400 <sd_lld_serve_interrupt+0xb0>
 80013e8:	0663      	lsls	r3, r4, #25
 80013ea:	d509      	bpl.n	8001400 <sd_lld_serve_interrupt+0xb0>
 80013ec:	2330      	movs	r3, #48	; 0x30
 80013ee:	f383 8811 	msr	BASEPRI, r3
    osalSysLockFromISR();
    if (oqIsEmptyI(&sdp->oqueue)) {
 80013f2:	e9da 2311 	ldrd	r2, r3, [sl, #68]	; 0x44
 80013f6:	429a      	cmp	r2, r3
 80013f8:	d02b      	beq.n	8001452 <sd_lld_serve_interrupt+0x102>
 80013fa:	2300      	movs	r3, #0
 80013fc:	f383 8811 	msr	BASEPRI, r3
      chnAddFlagsI(sdp, CHN_TRANSMISSION_END);
      u->CR1 = cr1 & ~USART_CR1_TCIE;
    }
    osalSysUnlockFromISR();
  }
}
 8001400:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 8001404:	2330      	movs	r3, #48	; 0x30
 8001406:	f383 8811 	msr	BASEPRI, r3
 800140a:	f44f 7100 	mov.w	r1, #512	; 0x200
 800140e:	f10a 0004 	add.w	r0, sl, #4
 8001412:	f001 fa45 	bl	80028a0 <chEvtBroadcastFlagsI>
 8001416:	2300      	movs	r3, #0
 8001418:	f383 8811 	msr	BASEPRI, r3
}
 800141c:	e7a7      	b.n	800136e <sd_lld_serve_interrupt+0x1e>
    sts |= SD_OVERRUN_ERROR;
 800141e:	f014 0108 	ands.w	r1, r4, #8
 8001422:	bf18      	it	ne
 8001424:	2180      	movne	r1, #128	; 0x80
  if (isr & USART_ISR_PE)
 8001426:	07e2      	lsls	r2, r4, #31
    sts |= SD_PARITY_ERROR;
 8001428:	bf48      	it	mi
 800142a:	f041 0120 	orrmi.w	r1, r1, #32
  if (isr & USART_ISR_FE)
 800142e:	07a3      	lsls	r3, r4, #30
    sts |= SD_FRAMING_ERROR;
 8001430:	bf48      	it	mi
 8001432:	f041 0140 	orrmi.w	r1, r1, #64	; 0x40
  if (isr & USART_ISR_NE)
 8001436:	0767      	lsls	r7, r4, #29
    sts |= SD_NOISE_ERROR;
 8001438:	bf48      	it	mi
 800143a:	f441 7180 	orrmi.w	r1, r1, #256	; 0x100
 800143e:	2330      	movs	r3, #48	; 0x30
 8001440:	f383 8811 	msr	BASEPRI, r3
  chEvtBroadcastFlagsI(esp, flags);
 8001444:	3004      	adds	r0, #4
 8001446:	f001 fa2b 	bl	80028a0 <chEvtBroadcastFlagsI>
 800144a:	2300      	movs	r3, #0
 800144c:	f383 8811 	msr	BASEPRI, r3
}
 8001450:	e78b      	b.n	800136a <sd_lld_serve_interrupt+0x1a>
    if (oqIsEmptyI(&sdp->oqueue)) {
 8001452:	f8da 3038 	ldr.w	r3, [sl, #56]	; 0x38
 8001456:	2b00      	cmp	r3, #0
 8001458:	d0cf      	beq.n	80013fa <sd_lld_serve_interrupt+0xaa>
 800145a:	2110      	movs	r1, #16
 800145c:	f10a 0004 	add.w	r0, sl, #4
 8001460:	f001 fa1e 	bl	80028a0 <chEvtBroadcastFlagsI>
      u->CR1 = cr1 & ~USART_CR1_TCIE;
 8001464:	f028 0340 	bic.w	r3, r8, #64	; 0x40
 8001468:	f8c9 3000 	str.w	r3, [r9]
 800146c:	e7c5      	b.n	80013fa <sd_lld_serve_interrupt+0xaa>
 800146e:	bf00      	nop

08001470 <__early_init>:

static void stm32_gpio_init(void) {

  /* Enabling GPIO-related clocks, the mask comes from the
     registry header file.*/
  rccResetAHB2(STM32_GPIO_EN_MASK);
 8001470:	4a2e      	ldr	r2, [pc, #184]	; (800152c <__early_init+0xbc>)
 8001472:	6ad1      	ldr	r1, [r2, #44]	; 0x2c
 8001474:	f041 0107 	orr.w	r1, r1, #7
/**
 * @brief   Early initialization code.
 * @details GPIO ports and system clocks are initialized before everything
 *          else.
 */
void __early_init(void) {
 8001478:	b4f0      	push	{r4, r5, r6, r7}
  rccResetAHB2(STM32_GPIO_EN_MASK);
 800147a:	62d1      	str	r1, [r2, #44]	; 0x2c
 800147c:	6ad1      	ldr	r1, [r2, #44]	; 0x2c
  gpiop->MODER   = config->moder;
 800147e:	4e2c      	ldr	r6, [pc, #176]	; (8001530 <__early_init+0xc0>)
  rccResetAHB2(STM32_GPIO_EN_MASK);
 8001480:	f021 0107 	bic.w	r1, r1, #7
 8001484:	62d1      	str	r1, [r2, #44]	; 0x2c
 8001486:	6ad1      	ldr	r1, [r2, #44]	; 0x2c
  rccEnableAHB2(STM32_GPIO_EN_MASK, true);
 8001488:	6cd1      	ldr	r1, [r2, #76]	; 0x4c
 800148a:	f041 0107 	orr.w	r1, r1, #7
 800148e:	64d1      	str	r1, [r2, #76]	; 0x4c
 8001490:	6ed1      	ldr	r1, [r2, #108]	; 0x6c
  gpiop->OTYPER  = config->otyper;
 8001492:	f04f 4c90 	mov.w	ip, #1207959552	; 0x48000000
  rccEnableAHB2(STM32_GPIO_EN_MASK, true);
 8001496:	f041 0107 	orr.w	r1, r1, #7
 800149a:	66d1      	str	r1, [r2, #108]	; 0x6c
  gpiop->OTYPER  = config->otyper;
 800149c:	2300      	movs	r3, #0
  gpiop->OSPEEDR = config->ospeedr;
 800149e:	f06f 0050 	mvn.w	r0, #80	; 0x50
  rccEnableAHB2(STM32_GPIO_EN_MASK, true);
 80014a2:	6ed2      	ldr	r2, [r2, #108]	; 0x6c
  gpiop->OTYPER  = config->otyper;
 80014a4:	f8cc 3004 	str.w	r3, [ip, #4]
  gpiop->ODR     = config->odr;
 80014a8:	f64f 75ff 	movw	r5, #65535	; 0xffff
  gpiop->ASCR    = config->ascr;
 80014ac:	f8cc 302c 	str.w	r3, [ip, #44]	; 0x2c
  gpiop->PUPDR   = config->pupdr;
 80014b0:	f04f 5110 	mov.w	r1, #603979776	; 0x24000000
  gpiop->OSPEEDR = config->ospeedr;
 80014b4:	f8cc 0008 	str.w	r0, [ip, #8]
  gpiop->AFRL    = config->afrl;
 80014b8:	f44f 62e0 	mov.w	r2, #1792	; 0x700
  gpiop->OTYPER  = config->otyper;
 80014bc:	481d      	ldr	r0, [pc, #116]	; (8001534 <__early_init+0xc4>)
  gpiop->PUPDR   = config->pupdr;
 80014be:	f8cc 100c 	str.w	r1, [ip, #12]
  gpiop->AFRH    = config->afrh;
 80014c2:	f04f 5740 	mov.w	r7, #805306368	; 0x30000000
  gpiop->ODR     = config->odr;
 80014c6:	f8cc 5014 	str.w	r5, [ip, #20]
  gpiop->OSPEEDR = config->ospeedr;
 80014ca:	f04f 34ff 	mov.w	r4, #4294967295	; 0xffffffff
  gpiop->AFRL    = config->afrl;
 80014ce:	f8cc 2020 	str.w	r2, [ip, #32]
  gpiop->AFRH    = config->afrh;
 80014d2:	f8cc 7024 	str.w	r7, [ip, #36]	; 0x24
  gpiop->MODER   = config->moder;
 80014d6:	f8cc 6000 	str.w	r6, [ip]
  gpiop->PUPDR   = config->pupdr;
 80014da:	2601      	movs	r6, #1
  gpiop->LOCKR   = config->lockr;
 80014dc:	f8cc 301c 	str.w	r3, [ip, #28]
  gpiop->OTYPER  = config->otyper;
 80014e0:	4915      	ldr	r1, [pc, #84]	; (8001538 <__early_init+0xc8>)
 80014e2:	6043      	str	r3, [r0, #4]
  gpiop->ASCR    = config->ascr;
 80014e4:	62c3      	str	r3, [r0, #44]	; 0x2c
  gpiop->OSPEEDR = config->ospeedr;
 80014e6:	6084      	str	r4, [r0, #8]
  gpiop->PUPDR   = config->pupdr;
 80014e8:	60c6      	str	r6, [r0, #12]
  gpiop->ODR     = config->odr;
 80014ea:	f64f 76f7 	movw	r6, #65527	; 0xfff7
  gpiop->OTYPER  = config->otyper;
 80014ee:	4a13      	ldr	r2, [pc, #76]	; (800153c <__early_init+0xcc>)
  gpiop->ODR     = config->odr;
 80014f0:	6146      	str	r6, [r0, #20]
  gpiop->MODER   = config->moder;
 80014f2:	f06f 0683 	mvn.w	r6, #131	; 0x83
  gpiop->AFRL    = config->afrl;
 80014f6:	6203      	str	r3, [r0, #32]
  gpiop->AFRH    = config->afrh;
 80014f8:	6243      	str	r3, [r0, #36]	; 0x24
  gpiop->MODER   = config->moder;
 80014fa:	6006      	str	r6, [r0, #0]
  gpiop->LOCKR   = config->lockr;
 80014fc:	61c3      	str	r3, [r0, #28]
  gpiop->OTYPER  = config->otyper;
 80014fe:	604b      	str	r3, [r1, #4]
  gpiop->ASCR    = config->ascr;
 8001500:	62cb      	str	r3, [r1, #44]	; 0x2c
  gpiop->OSPEEDR = config->ospeedr;
 8001502:	608c      	str	r4, [r1, #8]
  gpiop->PUPDR   = config->pupdr;
 8001504:	60cb      	str	r3, [r1, #12]
  gpiop->ODR     = config->odr;
 8001506:	614d      	str	r5, [r1, #20]
  gpiop->AFRL    = config->afrl;
 8001508:	620b      	str	r3, [r1, #32]
  gpiop->AFRH    = config->afrh;
 800150a:	624b      	str	r3, [r1, #36]	; 0x24
  gpiop->MODER   = config->moder;
 800150c:	600c      	str	r4, [r1, #0]
  gpiop->LOCKR   = config->lockr;
 800150e:	61cb      	str	r3, [r1, #28]
  gpiop->OSPEEDR = config->ospeedr;
 8001510:	210f      	movs	r1, #15
  gpiop->OTYPER  = config->otyper;
 8001512:	6053      	str	r3, [r2, #4]
  gpiop->ASCR    = config->ascr;
 8001514:	62d3      	str	r3, [r2, #44]	; 0x2c
  gpiop->OSPEEDR = config->ospeedr;
 8001516:	6091      	str	r1, [r2, #8]
  gpiop->PUPDR   = config->pupdr;
 8001518:	60d3      	str	r3, [r2, #12]
  gpiop->ODR     = config->odr;
 800151a:	6155      	str	r5, [r2, #20]
  gpiop->AFRL    = config->afrl;
 800151c:	6213      	str	r3, [r2, #32]
  gpiop->AFRH    = config->afrh;
 800151e:	6253      	str	r3, [r2, #36]	; 0x24
  gpiop->MODER   = config->moder;
 8001520:	6014      	str	r4, [r2, #0]

  stm32_gpio_init();
  stm32_clock_init();
}
 8001522:	bcf0      	pop	{r4, r5, r6, r7}
  gpiop->LOCKR   = config->lockr;
 8001524:	61d3      	str	r3, [r2, #28]
  stm32_clock_init();
 8001526:	f7ff baa3 	b.w	8000a70 <stm32_clock_init>
 800152a:	bf00      	nop
 800152c:	40021000 	.word	0x40021000
 8001530:	abffffef 	.word	0xabffffef
 8001534:	48000400 	.word	0x48000400
 8001538:	48000800 	.word	0x48000800
 800153c:	48001c00 	.word	0x48001c00

08001540 <boardInit>:
 * @brief   Board-specific initialization code.
 * @note    You can add your board-specific code here.
 */
void boardInit(void) {

}
 8001540:	4770      	bx	lr
 8001542:	bf00      	nop
	...

08001550 <chSysInit>:
 *          interrupts are enabled.
 * @post    the system is in @p ch_sys_running state.
 *
 * @special
 */
void chSysInit(void) {
 8001550:	b530      	push	{r4, r5, lr}
  unsigned i;

  /* System object initialization.*/
  ch_system.state = ch_sys_initializing;
 8001552:	4d12      	ldr	r5, [pc, #72]	; (800159c <chSysInit+0x4c>)
void chSysInit(void) {
 8001554:	b087      	sub	sp, #28
  for (i = 0U; i < (unsigned)PORT_CORES_NUMBER; i++) {
    ch_system.instances[i] = NULL;
 8001556:	2300      	movs	r3, #0
  ch_system.state = ch_sys_initializing;
 8001558:	2201      	movs	r2, #1

  /* Time Measurement subsystem calibration, it does a null measurement
     and calculates the call overhead which is subtracted to real
     measurements.*/
  tcp->offset = (rtcnt_t)0;
  chTMObjectInit(&tm);
 800155a:	4668      	mov	r0, sp
  tcp->offset = (rtcnt_t)0;
 800155c:	e9c5 3301 	strd	r3, r3, [r5, #4]
 8001560:	702a      	strb	r2, [r5, #0]
  chTMObjectInit(&tm);
 8001562:	f000 fdbd 	bl	80020e0 <chTMObjectInit>
 8001566:	2404      	movs	r4, #4
  i = TM_CALIBRATION_LOOP;
  do {
    chTMStartMeasurementX(&tm);
 8001568:	4668      	mov	r0, sp
 800156a:	f000 fdc9 	bl	8002100 <chTMStartMeasurementX>
    chTMStopMeasurementX(&tm);
 800156e:	4668      	mov	r0, sp
 8001570:	f000 fdce 	bl	8002110 <chTMStopMeasurementX>
    i--;
  } while (i > 0U);
 8001574:	3c01      	subs	r4, #1
 8001576:	d1f7      	bne.n	8001568 <chSysInit+0x18>
  tcp->offset = tm.best;
 8001578:	9b00      	ldr	r3, [sp, #0]
 800157a:	60ab      	str	r3, [r5, #8]
 * @notapi
 */
static inline void __oslib_init(void) {

#if CH_CFG_USE_MEMCORE == TRUE
  __core_init();
 800157c:	f001 fce0 	bl	8002f40 <__core_init>
#endif
#if CH_CFG_USE_HEAP == TRUE
  __heap_init();
 8001580:	f001 fd26 	bl	8002fd0 <__heap_init>
#endif
#if CH_CFG_USE_FACTORY == TRUE
  __factory_init();
 8001584:	f002 f9f4 	bl	8003970 <__factory_init>

  /* OS library modules.*/
  __oslib_init();

  /* Initializing default OS instance.*/
  chInstanceObjectInit(&ch0, &ch_core0_cfg);
 8001588:	4905      	ldr	r1, [pc, #20]	; (80015a0 <chSysInit+0x50>)
 800158a:	4806      	ldr	r0, [pc, #24]	; (80015a4 <chSysInit+0x54>)
 800158c:	f000 fb48 	bl	8001c20 <chInstanceObjectInit>

  /* It is alive now.*/
  ch_system.state = ch_sys_running;
 8001590:	2302      	movs	r3, #2
 8001592:	702b      	strb	r3, [r5, #0]
 8001594:	f384 8811 	msr	BASEPRI, r4
  chSysUnlock();
}
 8001598:	b007      	add	sp, #28
 800159a:	bd30      	pop	{r4, r5, pc}
 800159c:	20000bf8 	.word	0x20000bf8
 80015a0:	0800a820 	.word	0x0800a820
 80015a4:	20000a40 	.word	0x20000a40
	...

080015b0 <chSysIntegrityCheckI>:
  cnt_t n;

  chDbgCheckClassI();

  /* Ready List integrity check.*/
  if ((testmask & CH_INTEGRITY_RLIST) != 0U) {
 80015b0:	07c2      	lsls	r2, r0, #31
bool chSysIntegrityCheckI(unsigned testmask) {
 80015b2:	b410      	push	{r4}
  if ((testmask & CH_INTEGRITY_RLIST) != 0U) {
 80015b4:	d512      	bpl.n	80015dc <chSysIntegrityCheckI+0x2c>
    ch_priority_queue_t *pqp;

    /* Scanning the ready list forward.*/
    n = (cnt_t)0;
    pqp = oip->rlist.pqueue.next;
 80015b6:	4c2a      	ldr	r4, [pc, #168]	; (8001660 <chSysIntegrityCheckI+0xb0>)
 80015b8:	6822      	ldr	r2, [r4, #0]
    while (pqp != &oip->rlist.pqueue) {
 80015ba:	42a2      	cmp	r2, r4
 80015bc:	d044      	beq.n	8001648 <chSysIntegrityCheckI+0x98>
    n = (cnt_t)0;
 80015be:	2300      	movs	r3, #0
      n++;
      pqp = pqp->next;
 80015c0:	6812      	ldr	r2, [r2, #0]
    while (pqp != &oip->rlist.pqueue) {
 80015c2:	42a2      	cmp	r2, r4
      n++;
 80015c4:	f103 0301 	add.w	r3, r3, #1
    while (pqp != &oip->rlist.pqueue) {
 80015c8:	d1fa      	bne.n	80015c0 <chSysIntegrityCheckI+0x10>
    }

    /* Scanning the ready list backward.*/
    pqp = oip->rlist.pqueue.prev;
 80015ca:	6851      	ldr	r1, [r2, #4]
    while (pqp != &oip->rlist.pqueue) {
 80015cc:	4291      	cmp	r1, r2
 80015ce:	d038      	beq.n	8001642 <chSysIntegrityCheckI+0x92>
      n--;
      pqp = pqp->prev;
 80015d0:	6849      	ldr	r1, [r1, #4]
    while (pqp != &oip->rlist.pqueue) {
 80015d2:	42a1      	cmp	r1, r4
      n--;
 80015d4:	f103 33ff 	add.w	r3, r3, #4294967295	; 0xffffffff
    while (pqp != &oip->rlist.pqueue) {
 80015d8:	d1fa      	bne.n	80015d0 <chSysIntegrityCheckI+0x20>
    }

    /* The number of elements must match.*/
    if (n != (cnt_t)0) {
 80015da:	bb93      	cbnz	r3, 8001642 <chSysIntegrityCheckI+0x92>
      return true;
    }
  }

  /* Timers list integrity check.*/
  if ((testmask & CH_INTEGRITY_VTLIST) != 0U) {
 80015dc:	0783      	lsls	r3, r0, #30
 80015de:	d514      	bpl.n	800160a <chSysIntegrityCheckI+0x5a>
    ch_delta_list_t *dlp;

    /* Scanning the timers list forward.*/
    n = (cnt_t)0;
    dlp = oip->vtlist.dlist.next;
 80015e0:	4c1f      	ldr	r4, [pc, #124]	; (8001660 <chSysIntegrityCheckI+0xb0>)
 80015e2:	46a4      	mov	ip, r4
 80015e4:	f85c 2f10 	ldr.w	r2, [ip, #16]!
    while (dlp != &oip->vtlist.dlist) {
 80015e8:	4562      	cmp	r2, ip
 80015ea:	d033      	beq.n	8001654 <chSysIntegrityCheckI+0xa4>
    n = (cnt_t)0;
 80015ec:	2300      	movs	r3, #0
      n++;
      dlp = dlp->next;
 80015ee:	6812      	ldr	r2, [r2, #0]
    while (dlp != &oip->vtlist.dlist) {
 80015f0:	4562      	cmp	r2, ip
      n++;
 80015f2:	f103 0301 	add.w	r3, r3, #1
    while (dlp != &oip->vtlist.dlist) {
 80015f6:	d1fa      	bne.n	80015ee <chSysIntegrityCheckI+0x3e>
    }

    /* Scanning the timers list backward.*/
    dlp = oip->vtlist.dlist.prev;
 80015f8:	6961      	ldr	r1, [r4, #20]
    while (dlp != &oip->vtlist.dlist) {
 80015fa:	4291      	cmp	r1, r2
 80015fc:	d021      	beq.n	8001642 <chSysIntegrityCheckI+0x92>
      n--;
      dlp = dlp->prev;
 80015fe:	6849      	ldr	r1, [r1, #4]
    while (dlp != &oip->vtlist.dlist) {
 8001600:	4561      	cmp	r1, ip
      n--;
 8001602:	f103 33ff 	add.w	r3, r3, #4294967295	; 0xffffffff
    while (dlp != &oip->vtlist.dlist) {
 8001606:	d1fa      	bne.n	80015fe <chSysIntegrityCheckI+0x4e>
    }

    /* The number of elements must match.*/
    if (n != (cnt_t)0) {
 8001608:	b9db      	cbnz	r3, 8001642 <chSysIntegrityCheckI+0x92>
      return true;
    }
  }

#if CH_CFG_USE_REGISTRY == TRUE
  if ((testmask & CH_INTEGRITY_REGISTRY) != 0U) {
 800160a:	f010 0004 	ands.w	r0, r0, #4
 800160e:	d016      	beq.n	800163e <chSysIntegrityCheckI+0x8e>
       kernel configuration.*/
    rqp = REG_HEADER(oip);

    /* Scanning the ready list forward.*/
    n = (cnt_t)0;
    qp = rqp->next;
 8001610:	4c13      	ldr	r4, [pc, #76]	; (8001660 <chSysIntegrityCheckI+0xb0>)
 8001612:	4622      	mov	r2, r4
    n = (cnt_t)0;
 8001614:	2000      	movs	r0, #0
    qp = rqp->next;
 8001616:	f852 3f28 	ldr.w	r3, [r2, #40]!
    while (qp != rqp) {
 800161a:	4293      	cmp	r3, r2
 800161c:	d004      	beq.n	8001628 <chSysIntegrityCheckI+0x78>
      n++;
      qp = qp->next;
 800161e:	681b      	ldr	r3, [r3, #0]
    while (qp != rqp) {
 8001620:	4293      	cmp	r3, r2
      n++;
 8001622:	f100 0001 	add.w	r0, r0, #1
    while (qp != rqp) {
 8001626:	d1fa      	bne.n	800161e <chSysIntegrityCheckI+0x6e>
    }

    /* Scanning the ready list backward.*/
    qp = rqp->prev;
 8001628:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
    while (qp != rqp) {
 800162a:	4293      	cmp	r3, r2
 800162c:	d004      	beq.n	8001638 <chSysIntegrityCheckI+0x88>
      n--;
      qp = qp->prev;
 800162e:	685b      	ldr	r3, [r3, #4]
    while (qp != rqp) {
 8001630:	4293      	cmp	r3, r2
      n--;
 8001632:	f100 30ff 	add.w	r0, r0, #4294967295	; 0xffffffff
    while (qp != rqp) {
 8001636:	d1fa      	bne.n	800162e <chSysIntegrityCheckI+0x7e>
    }

    /* The number of elements must match.*/
    if (n != (cnt_t)0) {
 8001638:	3800      	subs	r0, #0
 800163a:	bf18      	it	ne
 800163c:	2001      	movne	r0, #1
    PORT_INTEGRITY_CHECK();
  }
#endif

  return false;
}
 800163e:	bc10      	pop	{r4}
 8001640:	4770      	bx	lr
      return true;
 8001642:	2001      	movs	r0, #1
}
 8001644:	bc10      	pop	{r4}
 8001646:	4770      	bx	lr
    pqp = oip->rlist.pqueue.prev;
 8001648:	6861      	ldr	r1, [r4, #4]
    while (pqp != &oip->rlist.pqueue) {
 800164a:	42a1      	cmp	r1, r4
    n = (cnt_t)0;
 800164c:	bf18      	it	ne
 800164e:	2300      	movne	r3, #0
    while (pqp != &oip->rlist.pqueue) {
 8001650:	d1be      	bne.n	80015d0 <chSysIntegrityCheckI+0x20>
 8001652:	e7c3      	b.n	80015dc <chSysIntegrityCheckI+0x2c>
    dlp = oip->vtlist.dlist.prev;
 8001654:	6961      	ldr	r1, [r4, #20]
    while (dlp != &oip->vtlist.dlist) {
 8001656:	4561      	cmp	r1, ip
    n = (cnt_t)0;
 8001658:	bf18      	it	ne
 800165a:	2300      	movne	r3, #0
    while (dlp != &oip->vtlist.dlist) {
 800165c:	d1cf      	bne.n	80015fe <chSysIntegrityCheckI+0x4e>
 800165e:	e7d4      	b.n	800160a <chSysIntegrityCheckI+0x5a>
 8001660:	20000a40 	.word	0x20000a40
	...

08001670 <chSysTimerHandlerI>:
  }
#endif
#if CH_DBG_THREADS_PROFILING == TRUE
  currtp->time++;
#endif
  chVTDoTickI();
 8001670:	f000 b90e 	b.w	8001890 <chVTDoTickI>
	...

08001680 <chSysGetStatusAndLockX>:
  __ASM volatile ("MRS %0, basepri" : "=r" (result) );
 8001680:	f3ef 8011 	mrs	r0, BASEPRI
 * @xclass
 */
syssts_t chSysGetStatusAndLockX(void) {

  syssts_t sts = port_get_irq_status();
  if (port_irq_enabled(sts)) {
 8001684:	b920      	cbnz	r0, 8001690 <chSysGetStatusAndLockX+0x10>
  __ASM volatile ("MRS %0, ipsr" : "=r" (result) );
 8001686:	f3ef 8305 	mrs	r3, IPSR
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 800168a:	2330      	movs	r3, #48	; 0x30
 800168c:	f383 8811 	msr	BASEPRI, r3
    else {
      chSysLock();
    }
  }
  return sts;
}
 8001690:	4770      	bx	lr
 8001692:	bf00      	nop
	...

080016a0 <chSysRestoreStatusX>:
 *
 * @xclass
 */
void chSysRestoreStatusX(syssts_t sts) {

  if (port_irq_enabled(sts)) {
 80016a0:	b940      	cbnz	r0, 80016b4 <chSysRestoreStatusX+0x14>
void chSysRestoreStatusX(syssts_t sts) {
 80016a2:	b510      	push	{r4, lr}
  __ASM volatile ("MRS %0, ipsr" : "=r" (result) );
 80016a4:	f3ef 8405 	mrs	r4, IPSR
 * @retval false        not running in ISR mode.
 * @retval true         running in ISR mode.
 */
__STATIC_FORCEINLINE bool port_is_isr_context(void) {

  return (bool)((__get_IPSR() & 0x1FFU) != 0U);
 80016a8:	f3c4 0408 	ubfx	r4, r4, #0, #9
    if (port_is_isr_context()) {
 80016ac:	b11c      	cbz	r4, 80016b6 <chSysRestoreStatusX+0x16>
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 80016ae:	f380 8811 	msr	BASEPRI, r0
    else {
      chSchRescheduleS();
      chSysUnlock();
    }
  }
}
 80016b2:	bd10      	pop	{r4, pc}
 80016b4:	4770      	bx	lr
      chSchRescheduleS();
 80016b6:	f000 fa73 	bl	8001ba0 <chSchRescheduleS>
 80016ba:	f384 8811 	msr	BASEPRI, r4
}
 80016be:	bd10      	pop	{r4, pc}

080016c0 <chRFCUCollectFaultsI>:
 * @param[in] mask      fault flags to be added
 */
void chRFCUCollectFaultsI(rfcu_mask_t mask) {

#if CH_CFG_SMP_MODE == FALSE
  currcore->rfcu.mask |= mask;
 80016c0:	4a02      	ldr	r2, [pc, #8]	; (80016cc <chRFCUCollectFaultsI+0xc>)
 80016c2:	6b53      	ldr	r3, [r2, #52]	; 0x34
 80016c4:	4303      	orrs	r3, r0
 80016c6:	6353      	str	r3, [r2, #52]	; 0x34
#else
  ch_system.rfcu.mask |= mask;
#endif

  CH_CFG_RUNTIME_FAULTS_HOOK(mask);
}
 80016c8:	4770      	bx	lr
 80016ca:	bf00      	nop
 80016cc:	20000a40 	.word	0x20000a40

080016d0 <vt_insert_first.constprop.0>:

/**
 * @brief   Inserts a timer as first element in a delta list.
 * @note    This is the special case when the delta list is initially empty.
 */
static void vt_insert_first(virtual_timers_list_t *vtlp,
 80016d0:	b570      	push	{r4, r5, r6, lr}
                            sysinterval_t delay) {
  sysinterval_t currdelta;

  /* The delta list is empty, the current time becomes the new
     delta list base time, the timer is inserted.*/
  vtlp->lasttime = now;
 80016d2:	4d13      	ldr	r5, [pc, #76]	; (8001720 <vt_insert_first.constprop.0+0x50>)
static void vt_insert_first(virtual_timers_list_t *vtlp,
 80016d4:	4614      	mov	r4, r2
static inline void ch_dlist_insert_after(ch_delta_list_t *dlhp,
                                         ch_delta_list_t *dlp,
                                         sysinterval_t delta) {

  dlp->delta      = delta;
  dlp->prev       = dlhp;
 80016d6:	f105 0210 	add.w	r2, r5, #16
  vtlp->lasttime = now;
 80016da:	61e9      	str	r1, [r5, #28]
  dlp->delta      = delta;
 80016dc:	2c02      	cmp	r4, #2
  dlp->prev       = dlhp;
 80016de:	6042      	str	r2, [r0, #4]
  dlp->next       = dlp->prev->next;
 80016e0:	692a      	ldr	r2, [r5, #16]
  dlp->delta      = delta;
 80016e2:	6084      	str	r4, [r0, #8]
static void vt_insert_first(virtual_timers_list_t *vtlp,
 80016e4:	4603      	mov	r3, r0
 80016e6:	bf38      	it	cc
 80016e8:	2402      	movcc	r4, #2
  dlp->next       = dlp->prev->next;
 80016ea:	6002      	str	r2, [r0, #0]
  dlp->next->prev = dlp;
 80016ec:	6050      	str	r0, [r2, #4]
  dlhp->next      = dlp;
 80016ee:	612b      	str	r3, [r5, #16]
 *
 * @notapi
 */
static inline void port_timer_start_alarm(systime_t time) {

  stStartAlarm(time);
 80016f0:	1908      	adds	r0, r1, r4
 80016f2:	460e      	mov	r6, r1
 80016f4:	f7fe feec 	bl	80004d0 <stStartAlarm>
  ch_dlist_insert_after(&vtlp->dlist, &vtp->dlist, delay);

  /* Initial delta is what is configured statically.*/
  currdelta = (sysinterval_t)CH_CFG_ST_TIMEDELTA;
 80016f8:	2502      	movs	r5, #2
 *
 * @notapi
 */
static inline systime_t port_timer_get_time(void) {

  return stGetCounter();
 80016fa:	f7fe fee1 	bl	80004c0 <stGetCounter>
 */
static inline sysinterval_t chTimeDiffX(systime_t start, systime_t end) {

  /*lint -save -e9033 [10.8] This cast is required by the operation, it is
    known that the destination type can be wider.*/
  return (sysinterval_t)((systime_t)(end - start));
 80016fe:	1b80      	subs	r0, r0, r6
       Note that the "<" condition is intentional, we want to make sure
       that the alarm is set before the deadline is reached because the
       comparison could happen on the transition depending on the timer
       architecture.*/
    newnow = chVTGetSystemTimeX();
    if (likely(chTimeDiffX(now, newnow) < delay)) {
 8001700:	4284      	cmp	r4, r0
 8001702:	d907      	bls.n	8001714 <vt_insert_first.constprop.0+0x44>
    port_timer_set_alarm(chTimeAddX(now, currdelta));
  }

#if !defined(CH_VT_RFCU_DISABLED)
  /* Checking if a skip occurred.*/
  if (currdelta > CH_CFG_ST_TIMEDELTA) {
 8001704:	2d02      	cmp	r5, #2
 8001706:	d800      	bhi.n	800170a <vt_insert_first.constprop.0+0x3a>
  }
#else
  /* Assertions as fallback.*/
  chDbgAssert(currdelta <= CH_CFG_ST_TIMEDELTA, "insufficient delta");
#endif
}
 8001708:	bd70      	pop	{r4, r5, r6, pc}
 800170a:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
    chRFCUCollectFaultsI(CH_RFCU_VT_INSUFFICIENT_DELTA);
 800170e:	2001      	movs	r0, #1
 8001710:	f7ff bfd6 	b.w	80016c0 <chRFCUCollectFaultsI>
    currdelta += (sysinterval_t)1;
 8001714:	3501      	adds	r5, #1
  stSetAlarm(time);
 8001716:	1970      	adds	r0, r6, r5
 8001718:	f7fe feea 	bl	80004f0 <stSetAlarm>
}
 800171c:	e7ed      	b.n	80016fa <vt_insert_first.constprop.0+0x2a>
 800171e:	bf00      	nop
 8001720:	20000a40 	.word	0x20000a40
	...

08001730 <vt_enqueue.constprop.0>:
#endif /* CH_CFG_ST_TIMEDELTA > 0 */

/**
 * @brief   Enqueues a virtual timer in a virtual timers list.
 */
static void vt_enqueue(virtual_timers_list_t *vtlp,
 8001730:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
  return (bool)(dlhp == dlhp->next);
 8001734:	f8df 9098 	ldr.w	r9, [pc, #152]	; 80017d0 <vt_enqueue.constprop.0+0xa0>
 8001738:	4607      	mov	r7, r0
 800173a:	460e      	mov	r6, r1
  return stGetCounter();
 800173c:	f7fe fec0 	bl	80004c0 <stGetCounter>
 8001740:	464b      	mov	r3, r9
 8001742:	4680      	mov	r8, r0
 8001744:	f853 5f10 	ldr.w	r5, [r3, #16]!
  {
    sysinterval_t nowdelta;
    systime_t now = chVTGetSystemTimeX();

    /* Special case where the timers list is empty.*/
    if (ch_dlist_isempty(&vtlp->dlist)) {
 8001748:	429d      	cmp	r5, r3
 800174a:	d036      	beq.n	80017ba <vt_enqueue.constprop.0+0x8a>
 800174c:	f8d9 401c 	ldr.w	r4, [r9, #28]
      delta = delay;
    }

    /* Checking if this timer would become the first in the delta list, this
       requires changing the current alarm setting.*/
    if (delta < vtlp->dlist.next->delta) {
 8001750:	68ab      	ldr	r3, [r5, #8]
 8001752:	1b04      	subs	r4, r0, r4
      delta = delay;
 8001754:	1934      	adds	r4, r6, r4
 8001756:	bf28      	it	cs
 8001758:	4634      	movcs	r4, r6
    if (delta < vtlp->dlist.next->delta) {
 800175a:	42a3      	cmp	r3, r4
 800175c:	d815      	bhi.n	800178a <vt_enqueue.constprop.0+0x5a>
  ch_delta_list_t *dlp;

  /* The delta list is scanned in order to find the correct position for
     this element. */
  dlp = dlhp->next;
  while (likely(dlp->delta < delta)) {
 800175e:	429c      	cmp	r4, r3
 8001760:	d904      	bls.n	800176c <vt_enqueue.constprop.0+0x3c>
    /* Debug assert if the element is already in the list.*/
    chDbgAssert(dlp != dlep, "element already in list");

    delta -= dlp->delta;
    dlp = dlp->next;
 8001762:	682d      	ldr	r5, [r5, #0]
    delta -= dlp->delta;
 8001764:	1ae4      	subs	r4, r4, r3
  while (likely(dlp->delta < delta)) {
 8001766:	68ab      	ldr	r3, [r5, #8]
 8001768:	42a3      	cmp	r3, r4
 800176a:	d3fa      	bcc.n	8001762 <vt_enqueue.constprop.0+0x32>
  dlp->prev       = dlp->next->prev;
 800176c:	686b      	ldr	r3, [r5, #4]
  dlp->delta      = delta;
 800176e:	60bc      	str	r4, [r7, #8]
  dlp->prev       = dlp->next->prev;
 8001770:	e9c7 5300 	strd	r5, r3, [r7]
  dlp->prev->next = dlp;
 8001774:	601f      	str	r7, [r3, #0]

  /* The timer is inserted in the delta list.*/
  ch_dlist_insert_before(dlp, dlep, delta);

  /* Adjusting delta for the following element.*/
  dlp->delta -= delta;
 8001776:	68ab      	ldr	r3, [r5, #8]
  dlhp->prev      = dlp;
 8001778:	606f      	str	r7, [r5, #4]
  dlp->delta -= delta;
 800177a:	1b1b      	subs	r3, r3, r4

  /* Special case when the inserted element is in last position in the list,
     the value in the header must be restored, just doing it is faster than
     checking then doing.*/
  dlhp->delta = (sysinterval_t)-1;
 800177c:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
  dlp->delta -= delta;
 8001780:	60ab      	str	r3, [r5, #8]
  dlhp->delta = (sysinterval_t)-1;
 8001782:	f8c9 2018 	str.w	r2, [r9, #24]
  /* Delta is initially equal to the specified delay.*/
  delta = delay;
#endif /* CH_CFG_ST_TIMEDELTA == 0 */

  ch_dlist_insert(&vtlp->dlist, &vtp->dlist, delta);
}
 8001786:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
  if (delay < currdelta) {
 800178a:	2e02      	cmp	r6, #2
 800178c:	bf38      	it	cc
 800178e:	2602      	movcc	r6, #2
    if (delta < vtlp->dlist.next->delta) {
 8001790:	2502      	movs	r5, #2
  stSetAlarm(time);
 8001792:	eb08 0006 	add.w	r0, r8, r6
 8001796:	f7fe feab 	bl	80004f0 <stSetAlarm>
  return stGetCounter();
 800179a:	f7fe fe91 	bl	80004c0 <stGetCounter>
 800179e:	eba0 0808 	sub.w	r8, r0, r8
    if (likely(nowdelta < delay)) {
 80017a2:	4546      	cmp	r6, r8
 80017a4:	d910      	bls.n	80017c8 <vt_enqueue.constprop.0+0x98>
  if (currdelta > CH_CFG_ST_TIMEDELTA) {
 80017a6:	2d02      	cmp	r5, #2
 80017a8:	d803      	bhi.n	80017b2 <vt_enqueue.constprop.0+0x82>
  dlp = dlhp->next;
 80017aa:	f8d9 5010 	ldr.w	r5, [r9, #16]
  while (likely(dlp->delta < delta)) {
 80017ae:	68ab      	ldr	r3, [r5, #8]
 80017b0:	e7d5      	b.n	800175e <vt_enqueue.constprop.0+0x2e>
    chRFCUCollectFaultsI(CH_RFCU_VT_INSUFFICIENT_DELTA);
 80017b2:	2001      	movs	r0, #1
 80017b4:	f7ff ff84 	bl	80016c0 <chRFCUCollectFaultsI>
 80017b8:	e7f7      	b.n	80017aa <vt_enqueue.constprop.0+0x7a>
      vt_insert_first(vtlp, vtp, now, delay);
 80017ba:	4632      	mov	r2, r6
 80017bc:	4601      	mov	r1, r0
 80017be:	4638      	mov	r0, r7
}
 80017c0:	e8bd 43f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
      vt_insert_first(vtlp, vtp, now, delay);
 80017c4:	f7ff bf84 	b.w	80016d0 <vt_insert_first.constprop.0>
    currdelta += (sysinterval_t)1;
 80017c8:	3501      	adds	r5, #1
 80017ca:	462e      	mov	r6, r5
    now = newnow;
 80017cc:	4680      	mov	r8, r0
  while (true) {
 80017ce:	e7e0      	b.n	8001792 <vt_enqueue.constprop.0+0x62>
 80017d0:	20000a40 	.word	0x20000a40
	...

080017e0 <chVTDoSetI>:

  chDbgCheckClassI();
  chDbgCheck((vtp != NULL) && (vtfunc != NULL) && (delay != TIME_IMMEDIATE));

  /* Timer initialization.*/
  vtp->par     = par;
 80017e0:	6103      	str	r3, [r0, #16]
  vtp->func    = vtfunc;
  vtp->reload  = (sysinterval_t)0;
 80017e2:	2300      	movs	r3, #0
  vtp->func    = vtfunc;
 80017e4:	60c2      	str	r2, [r0, #12]
  vtp->reload  = (sysinterval_t)0;
 80017e6:	6143      	str	r3, [r0, #20]

  /* Inserting the timer in the delta list.*/
  vt_enqueue(vtlp, vtp, delay);
 80017e8:	f7ff bfa2 	b.w	8001730 <vt_enqueue.constprop.0>
 80017ec:	0000      	movs	r0, r0
	...

080017f0 <chVTDoResetI>:
 *
 * @param[in] vtp       the @p virtual_timer_t structure pointer
 *
 * @iclass
 */
void chVTDoResetI(virtual_timer_t *vtp) {
 80017f0:	b570      	push	{r4, r5, r6, lr}
  return (bool)(dlhp->next == dlp);
 80017f2:	4c23      	ldr	r4, [pc, #140]	; (8001880 <chVTDoResetI+0x90>)
 80017f4:	6923      	ldr	r3, [r4, #16]
  systime_t now;
  sysinterval_t nowdelta, delta;

  /* If the timer is not the first of the list then it is simply unlinked
     else the operation is more complex.*/
  if (!ch_dlist_isfirst(&vtlp->dlist, &vtp->dlist)) {
 80017f6:	4298      	cmp	r0, r3
 80017f8:	d00d      	beq.n	8001816 <chVTDoResetI+0x26>
 *
 * @notapi
 */
static inline ch_delta_list_t *ch_dlist_dequeue(ch_delta_list_t *dlp) {

  dlp->prev->next = dlp->next;
 80017fa:	6803      	ldr	r3, [r0, #0]

    /* Removing the element from the delta list.*/
    (void) ch_dlist_dequeue(&vtp->dlist);

    /* Adding delta to the next element, if it is not the last one.*/
    vtp->dlist.next->delta += vtp->dlist.delta;
 80017fc:	6885      	ldr	r5, [r0, #8]
 80017fe:	689a      	ldr	r2, [r3, #8]
 8001800:	6841      	ldr	r1, [r0, #4]
 8001802:	442a      	add	r2, r5
 8001804:	600b      	str	r3, [r1, #0]
 8001806:	e9c3 1201 	strd	r1, r2, [r3, #4]

    /* Marking timer as not armed.*/
    vtp->dlist.next = NULL;
 800180a:	2200      	movs	r2, #0

    /* Special case when the removed element from the last position in the list,
       the value in the header must be restored, just doing it is faster than
       checking then doing.*/
    vtlp->dlist.delta = (sysinterval_t)-1;
 800180c:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
    vtp->dlist.next = NULL;
 8001810:	6002      	str	r2, [r0, #0]
    vtlp->dlist.delta = (sysinterval_t)-1;
 8001812:	61a3      	str	r3, [r4, #24]
  delta = vtlp->dlist.next->delta - nowdelta;

  /* Setting up the alarm.*/
  vt_set_alarm(now, delta);
#endif /* CH_CFG_ST_TIMEDELTA > 0 */
}
 8001814:	bd70      	pop	{r4, r5, r6, pc}
  dlhp->next       = dlp->next;
 8001816:	4623      	mov	r3, r4
 8001818:	6802      	ldr	r2, [r0, #0]
 800181a:	f843 2f10 	str.w	r2, [r3, #16]!
  vtp->dlist.next = NULL;
 800181e:	2100      	movs	r1, #0
  dlhp->next->prev = dlhp;
 8001820:	6053      	str	r3, [r2, #4]
 8001822:	6001      	str	r1, [r0, #0]
  return (bool)(dlhp == dlhp->next);
 8001824:	6922      	ldr	r2, [r4, #16]
  if (ch_dlist_isempty(&vtlp->dlist)) {
 8001826:	429a      	cmp	r2, r3
 8001828:	d021      	beq.n	800186e <chVTDoResetI+0x7e>
  vtlp->dlist.next->delta += vtp->dlist.delta;
 800182a:	6893      	ldr	r3, [r2, #8]
 800182c:	6881      	ldr	r1, [r0, #8]
 800182e:	440b      	add	r3, r1
 8001830:	6093      	str	r3, [r2, #8]
 8001832:	f7fe fe45 	bl	80004c0 <stGetCounter>
  if (nowdelta >= vtlp->dlist.next->delta) {
 8001836:	6923      	ldr	r3, [r4, #16]
  nowdelta = chTimeDiffX(vtlp->lasttime, now);
 8001838:	69e5      	ldr	r5, [r4, #28]
  if (nowdelta >= vtlp->dlist.next->delta) {
 800183a:	689b      	ldr	r3, [r3, #8]
 800183c:	1b42      	subs	r2, r0, r5
 800183e:	4293      	cmp	r3, r2
 8001840:	4604      	mov	r4, r0
 8001842:	d9e7      	bls.n	8001814 <chVTDoResetI+0x24>
  delta = vtlp->dlist.next->delta - nowdelta;
 8001844:	441d      	add	r5, r3
 8001846:	1a2d      	subs	r5, r5, r0
 8001848:	2d02      	cmp	r5, #2
 800184a:	bf38      	it	cc
 800184c:	2502      	movcc	r5, #2
 800184e:	2602      	movs	r6, #2
  stSetAlarm(time);
 8001850:	1960      	adds	r0, r4, r5
 8001852:	f7fe fe4d 	bl	80004f0 <stSetAlarm>
  return stGetCounter();
 8001856:	f7fe fe33 	bl	80004c0 <stGetCounter>
 800185a:	1b04      	subs	r4, r0, r4
    if (likely(nowdelta < delay)) {
 800185c:	42a5      	cmp	r5, r4
 800185e:	d90a      	bls.n	8001876 <chVTDoResetI+0x86>
  if (currdelta > CH_CFG_ST_TIMEDELTA) {
 8001860:	2e02      	cmp	r6, #2
 8001862:	d9d7      	bls.n	8001814 <chVTDoResetI+0x24>
}
 8001864:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
    chRFCUCollectFaultsI(CH_RFCU_VT_INSUFFICIENT_DELTA);
 8001868:	2001      	movs	r0, #1
 800186a:	f7ff bf29 	b.w	80016c0 <chRFCUCollectFaultsI>
}
 800186e:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
  stStopAlarm();
 8001872:	f7fe be35 	b.w	80004e0 <stStopAlarm>
    currdelta += (sysinterval_t)1;
 8001876:	3601      	adds	r6, #1
 8001878:	4635      	mov	r5, r6
    now = newnow;
 800187a:	4604      	mov	r4, r0
  while (true) {
 800187c:	e7e8      	b.n	8001850 <chVTDoResetI+0x60>
 800187e:	bf00      	nop
 8001880:	20000a40 	.word	0x20000a40
	...

08001890 <chVTDoTickI>:
 *          to acquire the lock if needed. This is done in order to reduce
 *          interrupts jitter when many timers are in use.
 *
 * @iclass
 */
void chVTDoTickI(void) {
 8001890:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8001894:	4e3c      	ldr	r6, [pc, #240]	; (8001988 <chVTDoTickI+0xf8>)
    lasttime = chTimeAddX(vtlp->lasttime, vtp->dlist.delta);
    vtlp->lasttime = lasttime;

    /* Removing the timer from the list, marking it as not armed.*/
    (void) ch_dlist_dequeue(&vtp->dlist);
    vtp->dlist.next = NULL;
 8001896:	2700      	movs	r7, #0
 8001898:	f106 0810 	add.w	r8, r6, #16
 800189c:	f04f 0930 	mov.w	r9, #48	; 0x30
 80018a0:	e009      	b.n	80018b6 <chVTDoTickI+0x26>
 80018a2:	f387 8811 	msr	BASEPRI, r7
    /* The callback is invoked outside the kernel critical section, it
       is re-entered on the callback return. Note that "lasttime" can be
       modified within the callback if some timer function is called.*/
    chSysUnlockFromISR();

    vtp->func(vtp, vtp->par);
 80018a6:	e9d4 3103 	ldrd	r3, r1, [r4, #12]
 80018aa:	4620      	mov	r0, r4
 80018ac:	4798      	blx	r3
 80018ae:	f389 8811 	msr	BASEPRI, r9

    chSysLockFromISR();

    /* If a reload is defined the timer needs to be restarted.*/
    if (unlikely(vtp->reload > (sysinterval_t)0)) {
 80018b2:	6963      	ldr	r3, [r4, #20]
 80018b4:	b9ab      	cbnz	r3, 80018e2 <chVTDoTickI+0x52>
    vtp = (virtual_timer_t *)vtlp->dlist.next;
 80018b6:	6934      	ldr	r4, [r6, #16]
  return stGetCounter();
 80018b8:	f7fe fe02 	bl	80004c0 <stGetCounter>
    nowdelta = chTimeDiffX(vtlp->lasttime, now);
 80018bc:	69f3      	ldr	r3, [r6, #28]
    if (nowdelta < vtp->dlist.delta) {
 80018be:	68a5      	ldr	r5, [r4, #8]
 80018c0:	1ac2      	subs	r2, r0, r3
 80018c2:	4295      	cmp	r5, r2
 80018c4:	4682      	mov	sl, r0
 80018c6:	d82c      	bhi.n	8001922 <chVTDoTickI+0x92>
  dlp->prev->next = dlp->next;
 80018c8:	e9d4 2100 	ldrd	r2, r1, [r4]
  return systime + (systime_t)interval;
 80018cc:	441d      	add	r5, r3
    vtlp->lasttime = lasttime;
 80018ce:	61f5      	str	r5, [r6, #28]
 80018d0:	600a      	str	r2, [r1, #0]
  dlp->next->prev = dlp->prev;
 80018d2:	6051      	str	r1, [r2, #4]
    vtp->dlist.next = NULL;
 80018d4:	6027      	str	r7, [r4, #0]
    if (ch_dlist_isempty(&vtlp->dlist)) {
 80018d6:	6933      	ldr	r3, [r6, #16]
 80018d8:	4543      	cmp	r3, r8
 80018da:	d1e2      	bne.n	80018a2 <chVTDoTickI+0x12>
  stStopAlarm();
 80018dc:	f7fe fe00 	bl	80004e0 <stStopAlarm>
}
 80018e0:	e7df      	b.n	80018a2 <chVTDoTickI+0x12>
  return stGetCounter();
 80018e2:	f7fe fded 	bl	80004c0 <stGetCounter>
      now = chVTGetSystemTimeX();
      nowdelta = chTimeDiffX(lasttime, now);

#if !defined(CH_VT_RFCU_DISABLED)
      /* Checking if the required reload is feasible.*/
      if (nowdelta > vtp->reload) {
 80018e6:	6963      	ldr	r3, [r4, #20]
  return (sysinterval_t)((systime_t)(end - start));
 80018e8:	eba0 0b05 	sub.w	fp, r0, r5
 80018ec:	455b      	cmp	r3, fp
 80018ee:	4682      	mov	sl, r0
 80018f0:	d32e      	bcc.n	8001950 <chVTDoTickI+0xc0>
  return (bool)(dlhp == dlhp->next);
 80018f2:	6931      	ldr	r1, [r6, #16]
      /* Enqueuing the timer again using the calculated delta.*/
      delay = vtp->reload - nowdelta;
#endif

      /* Special case where the timers list is empty.*/
      if (ch_dlist_isempty(&vtlp->dlist)) {
 80018f4:	4541      	cmp	r1, r8
 80018f6:	d03c      	beq.n	8001972 <chVTDoTickI+0xe2>
  while (likely(dlp->delta < delta)) {
 80018f8:	688a      	ldr	r2, [r1, #8]
 80018fa:	4293      	cmp	r3, r2
 80018fc:	d904      	bls.n	8001908 <chVTDoTickI+0x78>
    dlp = dlp->next;
 80018fe:	6809      	ldr	r1, [r1, #0]
    delta -= dlp->delta;
 8001900:	1a9b      	subs	r3, r3, r2
  while (likely(dlp->delta < delta)) {
 8001902:	688a      	ldr	r2, [r1, #8]
 8001904:	429a      	cmp	r2, r3
 8001906:	d3fa      	bcc.n	80018fe <chVTDoTickI+0x6e>
  dlp->prev       = dlp->next->prev;
 8001908:	684a      	ldr	r2, [r1, #4]
  dlp->delta      = delta;
 800190a:	60a3      	str	r3, [r4, #8]
  dlp->prev       = dlp->next->prev;
 800190c:	e9c4 1200 	strd	r1, r2, [r4]
  dlp->prev->next = dlp;
 8001910:	6014      	str	r4, [r2, #0]
  dlp->delta -= delta;
 8001912:	688a      	ldr	r2, [r1, #8]
  dlhp->prev      = dlp;
 8001914:	604c      	str	r4, [r1, #4]
  dlp->delta -= delta;
 8001916:	1ad3      	subs	r3, r2, r3
  dlhp->delta = (sysinterval_t)-1;
 8001918:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
  dlp->delta -= delta;
 800191c:	608b      	str	r3, [r1, #8]
  dlhp->delta = (sysinterval_t)-1;
 800191e:	61b2      	str	r2, [r6, #24]
}
 8001920:	e7c9      	b.n	80018b6 <chVTDoTickI+0x26>
      ch_dlist_insert(&vtlp->dlist, &vtp->dlist, delta);
    }
  }

  /* If the list is empty, nothing else to do.*/
  if (ch_dlist_isempty(&vtlp->dlist)) {
 8001922:	6932      	ldr	r2, [r6, #16]
 8001924:	4542      	cmp	r2, r8
 8001926:	d011      	beq.n	800194c <chVTDoTickI+0xbc>
    return;
  }

  /* Calculating the delta to the next alarm time.*/
  delta = vtp->dlist.delta - nowdelta;
 8001928:	442b      	add	r3, r5
 800192a:	1a1c      	subs	r4, r3, r0
 800192c:	2c02      	cmp	r4, #2
 800192e:	bf38      	it	cc
 8001930:	2402      	movcc	r4, #2
 8001932:	2502      	movs	r5, #2
  stSetAlarm(time);
 8001934:	eb0a 0004 	add.w	r0, sl, r4
 8001938:	f7fe fdda 	bl	80004f0 <stSetAlarm>
  return stGetCounter();
 800193c:	f7fe fdc0 	bl	80004c0 <stGetCounter>
 8001940:	eba0 0a0a 	sub.w	sl, r0, sl
    if (likely(nowdelta < delay)) {
 8001944:	4554      	cmp	r4, sl
 8001946:	d910      	bls.n	800196a <chVTDoTickI+0xda>
  if (currdelta > CH_CFG_ST_TIMEDELTA) {
 8001948:	2d02      	cmp	r5, #2
 800194a:	d809      	bhi.n	8001960 <chVTDoTickI+0xd0>

  /* Update alarm time to next timer.*/
  vt_set_alarm(now, delta);
#endif /* CH_CFG_ST_TIMEDELTA > 0 */
}
 800194c:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
        chRFCUCollectFaultsI(CH_RFCU_VT_SKIPPED_DEADLINE);
 8001950:	2002      	movs	r0, #2
 8001952:	f7ff feb5 	bl	80016c0 <chRFCUCollectFaultsI>
  return (bool)(dlhp == dlhp->next);
 8001956:	6931      	ldr	r1, [r6, #16]
      if (ch_dlist_isempty(&vtlp->dlist)) {
 8001958:	4541      	cmp	r1, r8
 800195a:	d012      	beq.n	8001982 <chVTDoTickI+0xf2>
 800195c:	465b      	mov	r3, fp
 800195e:	e7cb      	b.n	80018f8 <chVTDoTickI+0x68>
}
 8001960:	e8bd 4ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
    chRFCUCollectFaultsI(CH_RFCU_VT_INSUFFICIENT_DELTA);
 8001964:	2001      	movs	r0, #1
 8001966:	f7ff beab 	b.w	80016c0 <chRFCUCollectFaultsI>
    currdelta += (sysinterval_t)1;
 800196a:	3501      	adds	r5, #1
 800196c:	462c      	mov	r4, r5
    now = newnow;
 800196e:	4682      	mov	sl, r0
  while (true) {
 8001970:	e7e0      	b.n	8001934 <chVTDoTickI+0xa4>
        delay = vtp->reload - nowdelta;
 8001972:	442b      	add	r3, r5
 8001974:	1a1a      	subs	r2, r3, r0
        vt_insert_first(vtlp, vtp, now, delay);
 8001976:	4651      	mov	r1, sl
 8001978:	4620      	mov	r0, r4
}
 800197a:	e8bd 4ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
        vt_insert_first(vtlp, vtp, now, delay);
 800197e:	f7ff bea7 	b.w	80016d0 <vt_insert_first.constprop.0>
        delay = (sysinterval_t)0;
 8001982:	2200      	movs	r2, #0
 8001984:	e7f7      	b.n	8001976 <chVTDoTickI+0xe6>
 8001986:	bf00      	nop
 8001988:	20000a40 	.word	0x20000a40
 800198c:	00000000 	.word	0x00000000

08001990 <chVTGetTimeStampI>:
 *
 * @return              The time stamp.
 *
 * @iclass
 */
systimestamp_t chVTGetTimeStampI(void) {
 8001990:	b538      	push	{r3, r4, r5, lr}
 8001992:	f7fe fd95 	bl	80004c0 <stGetCounter>

  /* Current system time.*/
  now = chVTGetSystemTimeX();

  /* Last time stamp generated.*/
  last = oip->vtlist.laststamp;
 8001996:	4a05      	ldr	r2, [pc, #20]	; (80019ac <chVTGetTimeStampI+0x1c>)
 8001998:	e9d2 4508 	ldrd	r4, r5, [r2, #32]
 800199c:	1b03      	subs	r3, r0, r4

  /* Interval between the last time stamp and current time used for a new
     time stamp. Note that this fails if the interval is larger than a
     systime_t type.*/
  stamp = last + (systimestamp_t)chTimeDiffX((systime_t)last, now);
 800199e:	1918      	adds	r0, r3, r4
 80019a0:	f145 0100 	adc.w	r1, r5, #0

  chDbgAssert(oip->vtlist.laststamp <= stamp, "wrapped");

  /* Storing the new stamp.*/
  oip->vtlist.laststamp = stamp;
 80019a4:	e9c2 0108 	strd	r0, r1, [r2, #32]

  return stamp;
}
 80019a8:	bd38      	pop	{r3, r4, r5, pc}
 80019aa:	bf00      	nop
 80019ac:	20000a40 	.word	0x20000a40

080019b0 <__sch_wakeup>:
 80019b0:	2330      	movs	r3, #48	; 0x30
 80019b2:	f383 8811 	msr	BASEPRI, r3
  thread_t *tp = threadref(p);

  (void)vtp;

  chSysLockFromISR();
  switch (tp->state) {
 80019b6:	f891 3024 	ldrb.w	r3, [r1, #36]	; 0x24
 80019ba:	2b0c      	cmp	r3, #12
 80019bc:	d810      	bhi.n	80019e0 <__sch_wakeup+0x30>
 80019be:	e8df f003 	tbb	[pc, r3]
 80019c2:	0f2a      	.short	0x0f2a
 80019c4:	070b260f 	.word	0x070b260f
 80019c8:	0f0f0b0f 	.word	0x0f0f0b0f
 80019cc:	0f0f      	.short	0x0f0f
 80019ce:	0b          	.byte	0x0b
 80019cf:	00          	.byte	0x00
  case CH_STATE_SUSPENDED:
    *tp->u.wttrp = NULL;
    break;
#if CH_CFG_USE_SEMAPHORES == TRUE
  case CH_STATE_WTSEM:
    chSemFastSignalI(tp->u.wtsemp);
 80019d0:	6a8a      	ldr	r2, [r1, #40]	; 0x28
 */
static inline void chSemFastSignalI(semaphore_t *sp) {

  chDbgCheckClassI();

  sp->cnt++;
 80019d2:	6893      	ldr	r3, [r2, #8]
 80019d4:	3301      	adds	r3, #1
 80019d6:	6093      	str	r3, [r2, #8]
  p->prev->next = p->next;
 80019d8:	e9d1 3200 	ldrd	r3, r2, [r1]
 80019dc:	6013      	str	r3, [r2, #0]
  p->next->prev = p->prev;
 80019de:	605a      	str	r2, [r3, #4]
static void __sch_wakeup(virtual_timer_t *vtp, void *p) {
 80019e0:	b410      	push	{r4}
  tp->state = CH_STATE_READY;
 80019e2:	2200      	movs	r2, #0
    /* Any other state, nothing to do.*/
    break;
  }

  /* Standard message for timeout conditions.*/
  tp->u.rdymsg = MSG_TIMEOUT;
 80019e4:	f04f 34ff 	mov.w	r4, #4294967295	; 0xffffffff
  return threadref(ch_pqueue_insert_behind(&tp->owner->rlist.pqueue,
 80019e8:	698b      	ldr	r3, [r1, #24]
  } while (unlikely(pqp->prio >= p->prio));
 80019ea:	6888      	ldr	r0, [r1, #8]
  tp->u.rdymsg = MSG_TIMEOUT;
 80019ec:	628c      	str	r4, [r1, #40]	; 0x28
  tp->state = CH_STATE_READY;
 80019ee:	f881 2024 	strb.w	r2, [r1, #36]	; 0x24
    pqp = pqp->next;
 80019f2:	681b      	ldr	r3, [r3, #0]
  } while (unlikely(pqp->prio >= p->prio));
 80019f4:	689a      	ldr	r2, [r3, #8]
 80019f6:	4282      	cmp	r2, r0
 80019f8:	d2fb      	bcs.n	80019f2 <__sch_wakeup+0x42>
  p->prev       = pqp->prev;
 80019fa:	685a      	ldr	r2, [r3, #4]
 80019fc:	2000      	movs	r0, #0
 80019fe:	e9c1 3200 	strd	r3, r2, [r1]
  p->prev->next = p;
 8001a02:	6011      	str	r1, [r2, #0]
  pqp->prev     = p;
 8001a04:	6059      	str	r1, [r3, #4]
 8001a06:	f380 8811 	msr	BASEPRI, r0
  /* Goes behind peers because it went to sleep voluntarily.*/
  (void) __sch_ready_behind(tp);
  chSysUnlockFromISR();

  return;
}
 8001a0a:	bc10      	pop	{r4}
 8001a0c:	4770      	bx	lr
    *tp->u.wttrp = NULL;
 8001a0e:	6a8b      	ldr	r3, [r1, #40]	; 0x28
 8001a10:	2200      	movs	r2, #0
 8001a12:	601a      	str	r2, [r3, #0]
    break;
 8001a14:	e7e4      	b.n	80019e0 <__sch_wakeup+0x30>
 8001a16:	2300      	movs	r3, #0
 8001a18:	f383 8811 	msr	BASEPRI, r3
 8001a1c:	4770      	bx	lr
 8001a1e:	bf00      	nop

08001a20 <chSchReadyI>:
  tp->state = CH_STATE_READY;
 8001a20:	2200      	movs	r2, #0
  return threadref(ch_pqueue_insert_behind(&tp->owner->rlist.pqueue,
 8001a22:	6983      	ldr	r3, [r0, #24]
  } while (unlikely(pqp->prio >= p->prio));
 8001a24:	6881      	ldr	r1, [r0, #8]
  tp->state = CH_STATE_READY;
 8001a26:	f880 2024 	strb.w	r2, [r0, #36]	; 0x24
    pqp = pqp->next;
 8001a2a:	681b      	ldr	r3, [r3, #0]
  } while (unlikely(pqp->prio >= p->prio));
 8001a2c:	689a      	ldr	r2, [r3, #8]
 8001a2e:	428a      	cmp	r2, r1
 8001a30:	d2fb      	bcs.n	8001a2a <chSchReadyI+0xa>
  p->prev       = pqp->prev;
 8001a32:	685a      	ldr	r2, [r3, #4]
 8001a34:	e9c0 3200 	strd	r3, r2, [r0]
  p->prev->next = p;
 8001a38:	6010      	str	r0, [r2, #0]
  pqp->prev     = p;
 8001a3a:	6058      	str	r0, [r3, #4]
    chSysNotifyInstance(tp->owner);
  }
#endif

  return __sch_ready_behind(tp);
}
 8001a3c:	4770      	bx	lr
 8001a3e:	bf00      	nop

08001a40 <chSchGoSleepS>:
 *
 * @sclass
 */
void chSchGoSleepS(tstate_t newstate) {
  os_instance_t *oip = currcore;
  thread_t *otp = __instance_get_currthread(oip);
 8001a40:	4b08      	ldr	r3, [pc, #32]	; (8001a64 <chSchGoSleepS+0x24>)
 8001a42:	68d9      	ldr	r1, [r3, #12]
  ch_priority_queue_t *p = pqp->next;
 8001a44:	681a      	ldr	r2, [r3, #0]
void chSchGoSleepS(tstate_t newstate) {
 8001a46:	b410      	push	{r4}

  chDbgAssert(otp != chSysGetIdleThreadX(), "sleeping in idle thread");
  chDbgAssert(otp->owner == oip, "invalid core");

  /* New state.*/
  otp->state = newstate;
 8001a48:	f881 0024 	strb.w	r0, [r1, #36]	; 0x24
  pqp->next       = p->next;
 8001a4c:	6814      	ldr	r4, [r2, #0]
 8001a4e:	601c      	str	r4, [r3, #0]
  otp->ticks = (tslices_t)CH_CFG_TIME_QUANTUM;
#endif

  /* Next thread in ready list becomes current.*/
  ntp = threadref(ch_pqueue_remove_highest(&oip->rlist.pqueue));
  ntp->state = CH_STATE_CURRENT;
 8001a50:	2001      	movs	r0, #1
  pqp->next->prev = pqp;
 8001a52:	6063      	str	r3, [r4, #4]
 8001a54:	f882 0024 	strb.w	r0, [r2, #36]	; 0x24
    CH_CFG_IDLE_ENTER_HOOK();
  }

  /* Swap operation as tail call.*/
  chSysSwitch(ntp, otp);
}
 8001a58:	bc10      	pop	{r4}
  __instance_set_currthread(oip, ntp);
 8001a5a:	60da      	str	r2, [r3, #12]
  chSysSwitch(ntp, otp);
 8001a5c:	4610      	mov	r0, r2
 8001a5e:	f7fe bc0f 	b.w	8000280 <__port_switch>
 8001a62:	bf00      	nop
 8001a64:	20000a40 	.word	0x20000a40
	...

08001a70 <chSchGoSleepTimeoutS>:
 * @return              The wakeup message.
 * @retval MSG_TIMEOUT  if a timeout occurs.
 *
 * @sclass
 */
msg_t chSchGoSleepTimeoutS(tstate_t newstate, sysinterval_t timeout) {
 8001a70:	b570      	push	{r4, r5, r6, lr}
  thread_t *tp = __instance_get_currthread(currcore);
 8001a72:	4c18      	ldr	r4, [pc, #96]	; (8001ad4 <chSchGoSleepTimeoutS+0x64>)

  chDbgCheckClassS();

  if (TIME_INFINITE != timeout) {
 8001a74:	1c4b      	adds	r3, r1, #1
  thread_t *tp = __instance_get_currthread(currcore);
 8001a76:	68e6      	ldr	r6, [r4, #12]
msg_t chSchGoSleepTimeoutS(tstate_t newstate, sysinterval_t timeout) {
 8001a78:	b086      	sub	sp, #24
 8001a7a:	4605      	mov	r5, r0
  if (TIME_INFINITE != timeout) {
 8001a7c:	d019      	beq.n	8001ab2 <chSchGoSleepTimeoutS+0x42>
    virtual_timer_t vt;

    chVTDoSetI(&vt, timeout, __sch_wakeup, (void *)tp);
 8001a7e:	4a16      	ldr	r2, [pc, #88]	; (8001ad8 <chSchGoSleepTimeoutS+0x68>)
 8001a80:	4633      	mov	r3, r6
 8001a82:	4668      	mov	r0, sp
 8001a84:	f7ff feac 	bl	80017e0 <chVTDoSetI>
  thread_t *otp = __instance_get_currthread(oip);
 8001a88:	68e1      	ldr	r1, [r4, #12]
  ch_priority_queue_t *p = pqp->next;
 8001a8a:	6820      	ldr	r0, [r4, #0]
  otp->state = newstate;
 8001a8c:	f881 5024 	strb.w	r5, [r1, #36]	; 0x24
  pqp->next       = p->next;
 8001a90:	6803      	ldr	r3, [r0, #0]
 8001a92:	6023      	str	r3, [r4, #0]
  pqp->next->prev = pqp;
 8001a94:	605c      	str	r4, [r3, #4]
  ntp->state = CH_STATE_CURRENT;
 8001a96:	2301      	movs	r3, #1
 8001a98:	f880 3024 	strb.w	r3, [r0, #36]	; 0x24
  __instance_set_currthread(oip, ntp);
 8001a9c:	60e0      	str	r0, [r4, #12]
  chSysSwitch(ntp, otp);
 8001a9e:	f7fe fbef 	bl	8000280 <__port_switch>
    chSchGoSleepS(newstate);
    if (chVTIsArmedI(&vt)) {
 8001aa2:	9b00      	ldr	r3, [sp, #0]
 8001aa4:	b113      	cbz	r3, 8001aac <chSchGoSleepTimeoutS+0x3c>
      chVTDoResetI(&vt);
 8001aa6:	4668      	mov	r0, sp
 8001aa8:	f7ff fea2 	bl	80017f0 <chVTDoResetI>
  else {
    chSchGoSleepS(newstate);
  }

  return tp->u.rdymsg;
}
 8001aac:	6ab0      	ldr	r0, [r6, #40]	; 0x28
 8001aae:	b006      	add	sp, #24
 8001ab0:	bd70      	pop	{r4, r5, r6, pc}
  ch_priority_queue_t *p = pqp->next;
 8001ab2:	6820      	ldr	r0, [r4, #0]
  otp->state = newstate;
 8001ab4:	f886 5024 	strb.w	r5, [r6, #36]	; 0x24
  pqp->next       = p->next;
 8001ab8:	6803      	ldr	r3, [r0, #0]
 8001aba:	6023      	str	r3, [r4, #0]
  ntp->state = CH_STATE_CURRENT;
 8001abc:	2201      	movs	r2, #1
  pqp->next->prev = pqp;
 8001abe:	605c      	str	r4, [r3, #4]
  chSysSwitch(ntp, otp);
 8001ac0:	4631      	mov	r1, r6
  ntp->state = CH_STATE_CURRENT;
 8001ac2:	f880 2024 	strb.w	r2, [r0, #36]	; 0x24
  __instance_set_currthread(oip, ntp);
 8001ac6:	60e0      	str	r0, [r4, #12]
  chSysSwitch(ntp, otp);
 8001ac8:	f7fe fbda 	bl	8000280 <__port_switch>
}
 8001acc:	6ab0      	ldr	r0, [r6, #40]	; 0x28
 8001ace:	b006      	add	sp, #24
 8001ad0:	bd70      	pop	{r4, r5, r6, pc}
 8001ad2:	bf00      	nop
 8001ad4:	20000a40 	.word	0x20000a40
 8001ad8:	080019b1 	.word	0x080019b1
 8001adc:	00000000 	.word	0x00000000

08001ae0 <chSchWakeupS>:
 * @param[in] ntp       the thread to be made ready
 * @param[in] msg       the wakeup message
 *
 * @sclass
 */
void chSchWakeupS(thread_t *ntp, msg_t msg) {
 8001ae0:	b410      	push	{r4}
  os_instance_t *oip = currcore;
  thread_t *otp = __instance_get_currthread(oip);
 8001ae2:	4c16      	ldr	r4, [pc, #88]	; (8001b3c <chSchWakeupS+0x5c>)
     one then it is just inserted in the ready list else it made
     running immediately and the invoking thread goes in the ready
     list instead.
     Note, we are favoring the path where the woken thread has higher
     priority.*/
  if (unlikely(ntp->hdr.pqueue.prio <= otp->hdr.pqueue.prio)) {
 8001ae4:	6882      	ldr	r2, [r0, #8]
  thread_t *otp = __instance_get_currthread(oip);
 8001ae6:	68e3      	ldr	r3, [r4, #12]
  ntp->u.rdymsg = msg;
 8001ae8:	6281      	str	r1, [r0, #40]	; 0x28
  if (unlikely(ntp->hdr.pqueue.prio <= otp->hdr.pqueue.prio)) {
 8001aea:	6899      	ldr	r1, [r3, #8]
 8001aec:	428a      	cmp	r2, r1
 8001aee:	d916      	bls.n	8001b1e <chSchWakeupS+0x3e>
  tp->state = CH_STATE_READY;
 8001af0:	2200      	movs	r2, #0
 8001af2:	f883 2024 	strb.w	r2, [r3, #36]	; 0x24
  return threadref(ch_pqueue_insert_ahead(&tp->owner->rlist.pqueue,
 8001af6:	699a      	ldr	r2, [r3, #24]
    pqp = pqp->next;
 8001af8:	6812      	ldr	r2, [r2, #0]
  } while (unlikely(pqp->prio > p->prio));
 8001afa:	f8d2 c008 	ldr.w	ip, [r2, #8]
 8001afe:	4561      	cmp	r1, ip
 8001b00:	d3fa      	bcc.n	8001af8 <chSchWakeupS+0x18>
  p->prev       = pqp->prev;
 8001b02:	6851      	ldr	r1, [r2, #4]
    if (otp->hdr.pqueue.prio == IDLEPRIO) {
      CH_CFG_IDLE_LEAVE_HOOK();
    }

    /* The extracted thread is marked as current.*/
    ntp->state = CH_STATE_CURRENT;
 8001b04:	f04f 0c01 	mov.w	ip, #1
 8001b08:	e9c3 2100 	strd	r2, r1, [r3]
  p->prev->next = p;
 8001b0c:	600b      	str	r3, [r1, #0]
  pqp->prev     = p;
 8001b0e:	6053      	str	r3, [r2, #4]
    __instance_set_currthread(oip, ntp);

    /* Swap operation as tail call.*/
    chSysSwitch(ntp, otp);
 8001b10:	4619      	mov	r1, r3
    __instance_set_currthread(oip, ntp);
 8001b12:	60e0      	str	r0, [r4, #12]
    ntp->state = CH_STATE_CURRENT;
 8001b14:	f880 c024 	strb.w	ip, [r0, #36]	; 0x24
  }
}
 8001b18:	bc10      	pop	{r4}
    chSysSwitch(ntp, otp);
 8001b1a:	f7fe bbb1 	b.w	8000280 <__port_switch>
  tp->state = CH_STATE_READY;
 8001b1e:	2100      	movs	r1, #0
  return threadref(ch_pqueue_insert_behind(&tp->owner->rlist.pqueue,
 8001b20:	6983      	ldr	r3, [r0, #24]
  tp->state = CH_STATE_READY;
 8001b22:	f880 1024 	strb.w	r1, [r0, #36]	; 0x24
    pqp = pqp->next;
 8001b26:	681b      	ldr	r3, [r3, #0]
  } while (unlikely(pqp->prio >= p->prio));
 8001b28:	6899      	ldr	r1, [r3, #8]
 8001b2a:	428a      	cmp	r2, r1
 8001b2c:	d9fb      	bls.n	8001b26 <chSchWakeupS+0x46>
  p->prev       = pqp->prev;
 8001b2e:	685a      	ldr	r2, [r3, #4]
}
 8001b30:	bc10      	pop	{r4}
 8001b32:	e9c0 3200 	strd	r3, r2, [r0]
  p->prev->next = p;
 8001b36:	6010      	str	r0, [r2, #0]
  pqp->prev     = p;
 8001b38:	6058      	str	r0, [r3, #4]
 8001b3a:	4770      	bx	lr
 8001b3c:	20000a40 	.word	0x20000a40

08001b40 <chSchIsPreemptionRequired>:
 */
bool chSchIsPreemptionRequired(void) {
  os_instance_t *oip = currcore;
  thread_t *tp = __instance_get_currthread(oip);

  tprio_t p1 = firstprio(&oip->rlist.pqueue);
 8001b40:	4b04      	ldr	r3, [pc, #16]	; (8001b54 <chSchIsPreemptionRequired+0x14>)
 8001b42:	681a      	ldr	r2, [r3, #0]
  tprio_t p2 = tp->hdr.pqueue.prio;
 8001b44:	68db      	ldr	r3, [r3, #12]
     if the first thread on the ready queue has equal or higher priority.*/
  return (tp->ticks > (tslices_t)0) ? (p1 > p2) : (p1 >= p2);
#else
  /* If the round robin preemption feature is not enabled then performs a
     simpler comparison.*/
  return p1 > p2;
 8001b46:	6890      	ldr	r0, [r2, #8]
 8001b48:	689b      	ldr	r3, [r3, #8]
#endif
}
 8001b4a:	4298      	cmp	r0, r3
 8001b4c:	bf94      	ite	ls
 8001b4e:	2000      	movls	r0, #0
 8001b50:	2001      	movhi	r0, #1
 8001b52:	4770      	bx	lr
 8001b54:	20000a40 	.word	0x20000a40
	...

08001b60 <chSchDoPreemption>:
 *
 * @special
 */
void chSchDoPreemption(void) {
  os_instance_t *oip = currcore;
  thread_t *otp = __instance_get_currthread(oip);
 8001b60:	4a0d      	ldr	r2, [pc, #52]	; (8001b98 <chSchDoPreemption+0x38>)
  ch_priority_queue_t *p = pqp->next;
 8001b62:	6810      	ldr	r0, [r2, #0]
 8001b64:	68d1      	ldr	r1, [r2, #12]
  pqp->next       = p->next;
 8001b66:	6803      	ldr	r3, [r0, #0]
void chSchDoPreemption(void) {
 8001b68:	b410      	push	{r4}
  thread_t *ntp;

  /* Picks the first thread from the ready queue and makes it current.*/
  ntp = threadref(ch_pqueue_remove_highest(&oip->rlist.pqueue));
  ntp->state = CH_STATE_CURRENT;
 8001b6a:	2401      	movs	r4, #1
  pqp->next->prev = pqp;
 8001b6c:	605a      	str	r2, [r3, #4]
 8001b6e:	f880 4024 	strb.w	r4, [r0, #36]	; 0x24
  tp->state = CH_STATE_READY;
 8001b72:	2400      	movs	r4, #0
  pqp->next       = p->next;
 8001b74:	6013      	str	r3, [r2, #0]
 8001b76:	f881 4024 	strb.w	r4, [r1, #36]	; 0x24
  return threadref(ch_pqueue_insert_ahead(&tp->owner->rlist.pqueue,
 8001b7a:	698b      	ldr	r3, [r1, #24]
  } while (unlikely(pqp->prio > p->prio));
 8001b7c:	688c      	ldr	r4, [r1, #8]
  __instance_set_currthread(oip, ntp);
 8001b7e:	60d0      	str	r0, [r2, #12]
    pqp = pqp->next;
 8001b80:	681b      	ldr	r3, [r3, #0]
  } while (unlikely(pqp->prio > p->prio));
 8001b82:	689a      	ldr	r2, [r3, #8]
 8001b84:	42a2      	cmp	r2, r4
 8001b86:	d8fb      	bhi.n	8001b80 <chSchDoPreemption+0x20>
  p->prev       = pqp->prev;
 8001b88:	685a      	ldr	r2, [r3, #4]
  otp = __sch_ready_ahead(otp);
#endif /* !(CH_CFG_TIME_QUANTUM > 0) */

  /* Swap operation as tail call.*/
  chSysSwitch(ntp, otp);
}
 8001b8a:	bc10      	pop	{r4}
 8001b8c:	e9c1 3200 	strd	r3, r2, [r1]
  p->prev->next = p;
 8001b90:	6011      	str	r1, [r2, #0]
  pqp->prev     = p;
 8001b92:	6059      	str	r1, [r3, #4]
  chSysSwitch(ntp, otp);
 8001b94:	f7fe bb74 	b.w	8000280 <__port_switch>
 8001b98:	20000a40 	.word	0x20000a40
 8001b9c:	00000000 	.word	0x00000000

08001ba0 <chSchRescheduleS>:
  if (likely(firstprio(&oip->rlist.pqueue) > tp->hdr.pqueue.prio)) {
 8001ba0:	4b04      	ldr	r3, [pc, #16]	; (8001bb4 <chSchRescheduleS+0x14>)
 8001ba2:	681a      	ldr	r2, [r3, #0]
 8001ba4:	68db      	ldr	r3, [r3, #12]
 8001ba6:	6892      	ldr	r2, [r2, #8]
 8001ba8:	689b      	ldr	r3, [r3, #8]
 8001baa:	429a      	cmp	r2, r3
 8001bac:	d901      	bls.n	8001bb2 <chSchRescheduleS+0x12>
    __sch_reschedule_ahead();
 8001bae:	f7ff bfd7 	b.w	8001b60 <chSchDoPreemption>
}
 8001bb2:	4770      	bx	lr
 8001bb4:	20000a40 	.word	0x20000a40
	...

08001bc0 <chSchDoYieldS>:
 *
 * @sclass
 */
void chSchDoYieldS(void) {
  os_instance_t *oip = currcore;
  thread_t *tp = __instance_get_currthread(oip);
 8001bc0:	4b10      	ldr	r3, [pc, #64]	; (8001c04 <chSchDoYieldS+0x44>)
 8001bc2:	68d9      	ldr	r1, [r3, #12]

  chDbgCheckClassS();

  /* If this function has been called then it is likely there are threads
     at same priority level.*/
  if (likely(firstprio(&oip->rlist.pqueue) >= tp->hdr.pqueue.prio)) {
 8001bc4:	6818      	ldr	r0, [r3, #0]
 8001bc6:	688a      	ldr	r2, [r1, #8]
void chSchDoYieldS(void) {
 8001bc8:	b410      	push	{r4}
  if (likely(firstprio(&oip->rlist.pqueue) >= tp->hdr.pqueue.prio)) {
 8001bca:	6884      	ldr	r4, [r0, #8]
 8001bcc:	4294      	cmp	r4, r2
 8001bce:	d316      	bcc.n	8001bfe <chSchDoYieldS+0x3e>
  pqp->next       = p->next;
 8001bd0:	6804      	ldr	r4, [r0, #0]
 8001bd2:	601c      	str	r4, [r3, #0]
  pqp->next->prev = pqp;
 8001bd4:	6063      	str	r3, [r4, #4]
  ntp->state = CH_STATE_CURRENT;
 8001bd6:	2401      	movs	r4, #1
 8001bd8:	f880 4024 	strb.w	r4, [r0, #36]	; 0x24
  __instance_set_currthread(oip, ntp);
 8001bdc:	60d8      	str	r0, [r3, #12]
  tp->state = CH_STATE_READY;
 8001bde:	2400      	movs	r4, #0
  return threadref(ch_pqueue_insert_behind(&tp->owner->rlist.pqueue,
 8001be0:	698b      	ldr	r3, [r1, #24]
  tp->state = CH_STATE_READY;
 8001be2:	f881 4024 	strb.w	r4, [r1, #36]	; 0x24
    pqp = pqp->next;
 8001be6:	681b      	ldr	r3, [r3, #0]
  } while (unlikely(pqp->prio >= p->prio));
 8001be8:	689c      	ldr	r4, [r3, #8]
 8001bea:	42a2      	cmp	r2, r4
 8001bec:	d9fb      	bls.n	8001be6 <chSchDoYieldS+0x26>
  p->prev       = pqp->prev;
 8001bee:	685a      	ldr	r2, [r3, #4]
    __sch_reschedule_behind();
  }
}
 8001bf0:	bc10      	pop	{r4}
 8001bf2:	e9c1 3200 	strd	r3, r2, [r1]
  p->prev->next = p;
 8001bf6:	6011      	str	r1, [r2, #0]
  pqp->prev     = p;
 8001bf8:	6059      	str	r1, [r3, #4]
  chSysSwitch(ntp, otp);
 8001bfa:	f7fe bb41 	b.w	8000280 <__port_switch>
}
 8001bfe:	bc10      	pop	{r4}
 8001c00:	4770      	bx	lr
 8001c02:	bf00      	nop
 8001c04:	20000a40 	.word	0x20000a40
	...

08001c10 <__idle_thread>:
__STATIC_FORCEINLINE void port_wait_for_interrupt(void) {

#if CORTEX_ENABLE_WFI_IDLE == TRUE
  __WFI();
#endif
}
 8001c10:	e7fe      	b.n	8001c10 <__idle_thread>
 8001c12:	bf00      	nop
	...

08001c20 <chInstanceObjectInit>:
 * @param[in] oicp      pointer to the @p os_instance_config_t structure
 *
 * @special
 */
void chInstanceObjectInit(os_instance_t *oip,
                          const os_instance_config_t *oicp) {
 8001c20:	b570      	push	{r4, r5, r6, lr}
  core_id = port_get_core_id();
#else
  core_id = 0U;
#endif
  chDbgAssert(ch_system.instances[core_id] == NULL, "instance already registered");
  ch_system.instances[core_id] = oip;
 8001c22:	4b1f      	ldr	r3, [pc, #124]	; (8001ca0 <chInstanceObjectInit+0x80>)

  /* Core associated to this instance.*/
  oip->core_id = core_id;

  /* Keeping a reference to the configuration data.*/
  oip->config = oicp;
 8001c24:	6381      	str	r1, [r0, #56]	; 0x38
  oip->core_id = core_id;
 8001c26:	2500      	movs	r5, #0
                          const os_instance_config_t *oicp) {
 8001c28:	4604      	mov	r4, r0
 8001c2a:	b086      	sub	sp, #24
  oip->core_id = core_id;
 8001c2c:	6305      	str	r5, [r0, #48]	; 0x30
  ch_system.instances[core_id] = oip;
 8001c2e:	6058      	str	r0, [r3, #4]
                          const os_instance_config_t *oicp) {
 8001c30:	460e      	mov	r6, r1

  /* Port initialization for the current instance.*/
  port_init(oip);
 8001c32:	f002 f9e5 	bl	8004000 <port_init>
 *
 * @notapi
 */
static inline void __vt_object_init(virtual_timers_list_t *vtlp) {

  ch_dlist_init(&vtlp->dlist);
 8001c36:	f104 0310 	add.w	r3, r4, #16
 *
 * @init
 */
static inline void __reg_object_init(registry_t *rp) {

  ch_queue_init(&rp->queue);
 8001c3a:	f104 0228 	add.w	r2, r4, #40	; 0x28
  dlhp->prev  = dlhp;
 8001c3e:	e9c4 3304 	strd	r3, r3, [r4, #16]
  dlhp->delta = (sysinterval_t)-1;
 8001c42:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
#if CH_CFG_ST_TIMEDELTA == 0
  vtlp->systime = (systime_t)0;
#else /* CH_CFG_ST_TIMEDELTA > 0 */
  vtlp->lasttime = (systime_t)0;
 8001c46:	e9c4 3506 	strd	r3, r5, [r4, #24]
  qp->prev = qp;
 8001c4a:	e9c4 220a 	strd	r2, r2, [r4, #40]	; 0x28
  pqp->prio = (tprio_t)0;
 8001c4e:	60a5      	str	r5, [r4, #8]
 *
 * @notapi
 */
static inline void __rfcu_object_init(rfcu_t *rfcup) {

  rfcup->mask = (rfcu_mask_t)0;
 8001c50:	6365      	str	r5, [r4, #52]	; 0x34
  pqp->prev = pqp;
 8001c52:	e9c4 4400 	strd	r4, r4, [r4]
 8001c56:	f7fe fc33 	bl	80004c0 <stGetCounter>
#endif /* CH_CFG_ST_TIMEDELTA > 0 */
#if CH_CFG_USE_TIMESTAMP == TRUE
  vtlp->laststamp = (systimestamp_t)chVTGetSystemTimeX();
 8001c5a:	462b      	mov	r3, r5
 8001c5c:	4602      	mov	r2, r0
 8001c5e:	e9c4 2308 	strd	r2, r3, [r4, #32]
#endif

#if CH_CFG_NO_IDLE_THREAD == FALSE
  /* Now this instructions flow becomes the main thread.*/
#if CH_CFG_USE_REGISTRY == TRUE
  oip->rlist.current = __thd_object_init(oip, &oip->mainthread,
 8001c62:	f104 013c 	add.w	r1, r4, #60	; 0x3c
 *
 * @notapi
 */
static inline void __dbg_object_init(system_debug_t *sdp) {

  sdp->panic_msg = NULL;
 8001c66:	f8c4 5084 	str.w	r5, [r4, #132]	; 0x84
 8001c6a:	4a0e      	ldr	r2, [pc, #56]	; (8001ca4 <chInstanceObjectInit+0x84>)
 8001c6c:	2380      	movs	r3, #128	; 0x80
 8001c6e:	4620      	mov	r0, r4
 8001c70:	f000 f81e 	bl	8001cb0 <__thd_object_init>
#if (CH_DBG_ENABLE_STACK_CHECK == TRUE) || (CH_CFG_USE_DYNAMIC == TRUE)
  oip->rlist.current->wabase = oicp->mainthread_base;
#endif

  /* Setting up the caller as current thread.*/
  oip->rlist.current->state = CH_STATE_CURRENT;
 8001c74:	2301      	movs	r3, #1
  oip->rlist.current->wabase = oicp->mainthread_base;
 8001c76:	6872      	ldr	r2, [r6, #4]
  oip->rlist.current = __thd_object_init(oip, &oip->mainthread,
 8001c78:	60e0      	str	r0, [r4, #12]
  oip->rlist.current->state = CH_STATE_CURRENT;
 8001c7a:	f880 3024 	strb.w	r3, [r0, #36]	; 0x24
  oip->rlist.current->wabase = oicp->mainthread_base;
 8001c7e:	6202      	str	r2, [r0, #32]
  /* User instance initialization hook.*/
  CH_CFG_OS_INSTANCE_INIT_HOOK(oip);

#if CH_CFG_NO_IDLE_THREAD == FALSE
  {
    thread_descriptor_t idle_descriptor = {
 8001c80:	e9d6 1203 	ldrd	r1, r2, [r6, #12]
 8001c84:	4c08      	ldr	r4, [pc, #32]	; (8001ca8 <chInstanceObjectInit+0x88>)
 8001c86:	9303      	str	r3, [sp, #12]
#endif

    /* This thread has the lowest priority in the system, its role is just to
       serve interrupts in its context while keeping the lowest energy saving
       mode compatible with the system status.*/
    (void) chThdCreateI(&idle_descriptor);
 8001c88:	4668      	mov	r0, sp
    thread_descriptor_t idle_descriptor = {
 8001c8a:	4b08      	ldr	r3, [pc, #32]	; (8001cac <chInstanceObjectInit+0x8c>)
 8001c8c:	9505      	str	r5, [sp, #20]
 8001c8e:	e9cd 4100 	strd	r4, r1, [sp]
 8001c92:	9202      	str	r2, [sp, #8]
 8001c94:	9304      	str	r3, [sp, #16]
    (void) chThdCreateI(&idle_descriptor);
 8001c96:	f000 f873 	bl	8001d80 <chThdCreateI>
  }
#endif
}
 8001c9a:	b006      	add	sp, #24
 8001c9c:	bd70      	pop	{r4, r5, r6, pc}
 8001c9e:	bf00      	nop
 8001ca0:	20000bf8 	.word	0x20000bf8
 8001ca4:	0800a844 	.word	0x0800a844
 8001ca8:	0800a834 	.word	0x0800a834
 8001cac:	08001c11 	.word	0x08001c11

08001cb0 <__thd_object_init>:
 * @notapi
 */
thread_t *__thd_object_init(os_instance_t *oip,
                            thread_t *tp,
                            const char *name,
                            tprio_t prio) {
 8001cb0:	b430      	push	{r4, r5}
#if CH_CFG_TIME_QUANTUM > 0
  tp->ticks             = (tslices_t)CH_CFG_TIME_QUANTUM;
#endif
#if CH_CFG_USE_MUTEXES == TRUE
  tp->realprio          = prio;
  tp->mtxlist           = NULL;
 8001cb2:	2400      	movs	r4, #0
 8001cb4:	e9c1 430f 	strd	r4, r3, [r1, #60]	; 0x3c
  tp->hdr.pqueue.prio   = prio;
 8001cb8:	608b      	str	r3, [r1, #8]
#endif
#if CH_CFG_USE_EVENTS == TRUE
  tp->epending          = (eventmask_t)0;
 8001cba:	638c      	str	r4, [r1, #56]	; 0x38
#endif
#if CH_DBG_THREADS_PROFILING == TRUE
  tp->time              = (systime_t)0;
#endif
#if CH_CFG_USE_REGISTRY == TRUE
  tp->refs              = (trefs_t)1;
 8001cbc:	2301      	movs	r3, #1
  tp->state             = CH_STATE_WTSTART;
 8001cbe:	2402      	movs	r4, #2
  tp->refs              = (trefs_t)1;
 8001cc0:	f881 3026 	strb.w	r3, [r1, #38]	; 0x26
  tp->state             = CH_STATE_WTSTART;
 8001cc4:	848c      	strh	r4, [r1, #36]	; 0x24
  p->prev       = qp->prev;
 8001cc6:	6ac4      	ldr	r4, [r0, #44]	; 0x2c
  tp->name              = name;
 8001cc8:	61ca      	str	r2, [r1, #28]
  REG_INSERT(oip, tp);
 8001cca:	f100 0328 	add.w	r3, r0, #40	; 0x28
  p->next       = qp;
 8001cce:	610b      	str	r3, [r1, #16]
 8001cd0:	f101 0210 	add.w	r2, r1, #16
#endif
#if CH_CFG_USE_WAITEXIT == TRUE
  ch_list_init(&tp->waiting);
#endif
#if CH_CFG_USE_MESSAGES == TRUE
  ch_queue_init(&tp->msgqueue);
 8001cd4:	f101 0330 	add.w	r3, r1, #48	; 0x30
  ch_list_init(&tp->waiting);
 8001cd8:	f101 052c 	add.w	r5, r1, #44	; 0x2c
  tp->owner             = oip;
 8001cdc:	6188      	str	r0, [r1, #24]
  p->prev       = qp->prev;
 8001cde:	614c      	str	r4, [r1, #20]
  p->prev->next = p;
 8001ce0:	6022      	str	r2, [r4, #0]
  qp->prev      = p;
 8001ce2:	62c2      	str	r2, [r0, #44]	; 0x2c
  qp->next = qp;
 8001ce4:	e9c1 530b 	strd	r5, r3, [r1, #44]	; 0x2c
#if CH_DBG_STATISTICS == TRUE
  chTMObjectInit(&tp->stats);
#endif
  CH_CFG_THREAD_INIT_HOOK(tp);
  return tp;
}
 8001ce8:	4608      	mov	r0, r1
 8001cea:	bc30      	pop	{r4, r5}
  qp->prev = qp;
 8001cec:	634b      	str	r3, [r1, #52]	; 0x34
 8001cee:	4770      	bx	lr

08001cf0 <chThdCreateSuspendedI>:
 * @return              The pointer to the @p thread_t structure allocated for
 *                      the thread into the working space area.
 *
 * @iclass
 */
thread_t *chThdCreateSuspendedI(const thread_descriptor_t *tdp) {
 8001cf0:	b530      	push	{r4, r5, lr}
  if (tdp->instance != NULL) {
    return __thd_object_init(tdp->instance, tp, tdp->name, tdp->prio);
  }
#endif

  return __thd_object_init(currcore, tp, tdp->name, tdp->prio);
 8001cf2:	e9d0 3402 	ldrd	r3, r4, [r0, #8]
  tp->wabase = tdp->wbase;
 8001cf6:	6845      	ldr	r5, [r0, #4]
 8001cf8:	f843 5c28 	str.w	r5, [r3, #-40]
  PORT_SETUP_CONTEXT(tp, tdp->wbase, tp, tdp->funcp, tdp->arg);
 8001cfc:	6905      	ldr	r5, [r0, #16]
  tp->owner             = oip;
 8001cfe:	4a1c      	ldr	r2, [pc, #112]	; (8001d70 <chThdCreateSuspendedI+0x80>)
  PORT_SETUP_CONTEXT(tp, tdp->wbase, tp, tdp->funcp, tdp->arg);
 8001d00:	f843 5c6c 	str.w	r5, [r3, #-108]
  tp->flags             = CH_FLAG_MODE_STATIC;
 8001d04:	2100      	movs	r1, #0
  PORT_SETUP_CONTEXT(tp, tdp->wbase, tp, tdp->funcp, tdp->arg);
 8001d06:	6945      	ldr	r5, [r0, #20]
 8001d08:	f843 5c68 	str.w	r5, [r3, #-104]
  tp->state             = CH_STATE_WTSTART;
 8001d0c:	f04f 0e02 	mov.w	lr, #2
  tp->refs              = (trefs_t)1;
 8001d10:	f04f 0c01 	mov.w	ip, #1
  return __thd_object_init(currcore, tp, tdp->name, tdp->prio);
 8001d14:	6805      	ldr	r5, [r0, #0]
  tp->flags             = CH_FLAG_MODE_STATIC;
 8001d16:	f803 1c23 	strb.w	r1, [r3, #-35]
  tp->state             = CH_STATE_WTSTART;
 8001d1a:	f803 ec24 	strb.w	lr, [r3, #-36]
  tp->refs              = (trefs_t)1;
 8001d1e:	f803 cc22 	strb.w	ip, [r3, #-34]
  tp->hdr.pqueue.prio   = prio;
 8001d22:	f843 4c40 	str.w	r4, [r3, #-64]
  tp->realprio          = prio;
 8001d26:	f843 4c08 	str.w	r4, [r3, #-8]
  p->prev       = qp->prev;
 8001d2a:	6ad4      	ldr	r4, [r2, #44]	; 0x2c
  tp->name              = name;
 8001d2c:	f843 5c2c 	str.w	r5, [r3, #-44]
  PORT_SETUP_CONTEXT(tp, tdp->wbase, tp, tdp->funcp, tdp->arg);
 8001d30:	4d10      	ldr	r5, [pc, #64]	; (8001d74 <chThdCreateSuspendedI+0x84>)
 8001d32:	f843 5c4c 	str.w	r5, [r3, #-76]
 8001d36:	f1a3 056c 	sub.w	r5, r3, #108	; 0x6c
  REG_INSERT(oip, tp);
 8001d3a:	f1a3 0038 	sub.w	r0, r3, #56	; 0x38
  PORT_SETUP_CONTEXT(tp, tdp->wbase, tp, tdp->funcp, tdp->arg);
 8001d3e:	f843 5c3c 	str.w	r5, [r3, #-60]
  p->next       = qp;
 8001d42:	f102 0528 	add.w	r5, r2, #40	; 0x28
  tp->epending          = (eventmask_t)0;
 8001d46:	e943 1104 	strd	r1, r1, [r3, #-16]
  p->prev       = qp->prev;
 8001d4a:	f843 4c34 	str.w	r4, [r3, #-52]
  tp->owner             = oip;
 8001d4e:	f843 2c30 	str.w	r2, [r3, #-48]
  ch_queue_init(&tp->msgqueue);
 8001d52:	f1a3 0118 	sub.w	r1, r3, #24
  p->next       = qp;
 8001d56:	f843 5c38 	str.w	r5, [r3, #-56]
  p->prev->next = p;
 8001d5a:	6020      	str	r0, [r4, #0]
  ch_list_init(&tp->waiting);
 8001d5c:	f1a3 041c 	sub.w	r4, r3, #28
  qp->prev      = p;
 8001d60:	62d0      	str	r0, [r2, #44]	; 0x2c
  qp->next = qp;
 8001d62:	e943 4107 	strd	r4, r1, [r3, #-28]
}
 8001d66:	f1a3 0048 	sub.w	r0, r3, #72	; 0x48
  qp->prev = qp;
 8001d6a:	f843 1c14 	str.w	r1, [r3, #-20]
 8001d6e:	bd30      	pop	{r4, r5, pc}
 8001d70:	20000a40 	.word	0x20000a40
 8001d74:	08000291 	.word	0x08000291
	...

08001d80 <chThdCreateI>:
 * @return              The pointer to the @p thread_t structure allocated for
 *                      the thread into the working space area.
 *
 * @iclass
 */
thread_t *chThdCreateI(const thread_descriptor_t *tdp) {
 8001d80:	b508      	push	{r3, lr}

  return chSchReadyI(chThdCreateSuspendedI(tdp));
 8001d82:	f7ff ffb5 	bl	8001cf0 <chThdCreateSuspendedI>
}
 8001d86:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  return chSchReadyI(chThdCreateSuspendedI(tdp));
 8001d8a:	f7ff be49 	b.w	8001a20 <chSchReadyI>
 8001d8e:	bf00      	nop

08001d90 <chThdCreate>:
 * @return              The pointer to the @p thread_t structure allocated for
 *                      the thread into the working space area.
 *
 * @iclass
 */
thread_t *chThdCreate(const thread_descriptor_t *tdp) {
 8001d90:	b510      	push	{r4, lr}
 8001d92:	2330      	movs	r3, #48	; 0x30
 8001d94:	f383 8811 	msr	BASEPRI, r3
#if CH_DBG_FILL_THREADS == TRUE
  __thd_stackfill((uint8_t *)tdp->wbase, (uint8_t *)tdp->wend);
#endif

  chSysLock();
  tp = chThdCreateSuspendedI(tdp);
 8001d98:	f7ff ffaa 	bl	8001cf0 <chThdCreateSuspendedI>
  chSchWakeupS(tp, MSG_OK);
 8001d9c:	2100      	movs	r1, #0
  tp = chThdCreateSuspendedI(tdp);
 8001d9e:	4604      	mov	r4, r0
  chSchWakeupS(tp, MSG_OK);
 8001da0:	f7ff fe9e 	bl	8001ae0 <chSchWakeupS>
 8001da4:	2300      	movs	r3, #0
 8001da6:	f383 8811 	msr	BASEPRI, r3
  chSysUnlock();

  return tp;
}
 8001daa:	4620      	mov	r0, r4
 8001dac:	bd10      	pop	{r4, pc}
 8001dae:	bf00      	nop

08001db0 <chThdCreateStatic>:
 *                      the thread into the working space area.
 *
 * @api
 */
thread_t *chThdCreateStatic(void *wsp, size_t size,
                            tprio_t prio, tfunc_t pf, void *arg) {
 8001db0:	b538      	push	{r3, r4, r5, lr}
 8001db2:	2430      	movs	r4, #48	; 0x30
 8001db4:	f384 8811 	msr	BASEPRI, r4
  chSysLock();

  /* The thread structure is laid out in the upper part of the thread
     workspace. The thread position structure is aligned to the required
     stack alignment because it represents the stack top.*/
  tp = threadref(((uint8_t *)wsp + size -
 8001db8:	3948      	subs	r1, #72	; 0x48
 8001dba:	1844      	adds	r4, r0, r1
  /* Stack boundary.*/
  tp->wabase = (stkalign_t *)wsp;
#endif

  /* Setting up the port-dependent part of the working area.*/
  PORT_SETUP_CONTEXT(tp, wsp, tp, pf, arg);
 8001dbc:	4918      	ldr	r1, [pc, #96]	; (8001e20 <chThdCreateStatic+0x70>)
 8001dbe:	f844 1c04 	str.w	r1, [r4, #-4]
 8001dc2:	f1a4 0124 	sub.w	r1, r4, #36	; 0x24
 8001dc6:	f844 3c24 	str.w	r3, [r4, #-36]
 8001dca:	60e1      	str	r1, [r4, #12]
  tp->owner             = oip;
 8001dcc:	4b15      	ldr	r3, [pc, #84]	; (8001e24 <chThdCreateStatic+0x74>)
  tp->hdr.pqueue.prio   = prio;
 8001dce:	60a2      	str	r2, [r4, #8]
  tp->state             = CH_STATE_WTSTART;
 8001dd0:	2102      	movs	r1, #2
 8001dd2:	84a1      	strh	r1, [r4, #36]	; 0x24
  tp->refs              = (trefs_t)1;
 8001dd4:	2101      	movs	r1, #1
 8001dd6:	f884 1026 	strb.w	r1, [r4, #38]	; 0x26
  tp->realprio          = prio;
 8001dda:	6422      	str	r2, [r4, #64]	; 0x40
  p->next       = qp;
 8001ddc:	f103 0228 	add.w	r2, r3, #40	; 0x28
 8001de0:	6122      	str	r2, [r4, #16]
  PORT_SETUP_CONTEXT(tp, wsp, tp, pf, arg);
 8001de2:	9904      	ldr	r1, [sp, #16]
  p->prev       = qp->prev;
 8001de4:	6ada      	ldr	r2, [r3, #44]	; 0x2c
  tp->wabase = (stkalign_t *)wsp;
 8001de6:	6220      	str	r0, [r4, #32]
  PORT_SETUP_CONTEXT(tp, wsp, tp, pf, arg);
 8001de8:	f844 1c20 	str.w	r1, [r4, #-32]
  tp->mtxlist           = NULL;
 8001dec:	2500      	movs	r5, #0
  REG_INSERT(oip, tp);
 8001dee:	f104 0110 	add.w	r1, r4, #16
  tp->name              = name;
 8001df2:	480d      	ldr	r0, [pc, #52]	; (8001e28 <chThdCreateStatic+0x78>)
 8001df4:	61e0      	str	r0, [r4, #28]
 8001df6:	6162      	str	r2, [r4, #20]
  tp->owner             = oip;
 8001df8:	61a3      	str	r3, [r4, #24]
  tp->epending          = (eventmask_t)0;
 8001dfa:	e9c4 550e 	strd	r5, r5, [r4, #56]	; 0x38
  ch_list_init(&tp->waiting);
 8001dfe:	f104 002c 	add.w	r0, r4, #44	; 0x2c
  p->prev->next = p;
 8001e02:	6011      	str	r1, [r2, #0]
  ch_queue_init(&tp->msgqueue);
 8001e04:	f104 0230 	add.w	r2, r4, #48	; 0x30
  qp->prev      = p;
 8001e08:	62d9      	str	r1, [r3, #44]	; 0x2c
  qp->prev = qp;
 8001e0a:	6362      	str	r2, [r4, #52]	; 0x34
  qp->next = qp;
 8001e0c:	e9c4 020b 	strd	r0, r2, [r4, #44]	; 0x2c

  tp = __thd_object_init(currcore, tp, "noname", prio);

  /* Starting the thread immediately.*/
  chSchWakeupS(tp, MSG_OK);
 8001e10:	4629      	mov	r1, r5
 8001e12:	4620      	mov	r0, r4
 8001e14:	f7ff fe64 	bl	8001ae0 <chSchWakeupS>
 8001e18:	f385 8811 	msr	BASEPRI, r5
  chSysUnlock();

  return tp;
}
 8001e1c:	4620      	mov	r0, r4
 8001e1e:	bd38      	pop	{r3, r4, r5, pc}
 8001e20:	08000291 	.word	0x08000291
 8001e24:	20000a40 	.word	0x20000a40
 8001e28:	0800a83c 	.word	0x0800a83c
 8001e2c:	00000000 	.word	0x00000000

08001e30 <chThdRelease>:
 8001e30:	2330      	movs	r3, #48	; 0x30
 8001e32:	f383 8811 	msr	BASEPRI, r3
 */
void chThdRelease(thread_t *tp) {

  chSysLock();
  chDbgAssert(tp->refs > (trefs_t)0, "not referenced");
  tp->refs--;
 8001e36:	f890 3026 	ldrb.w	r3, [r0, #38]	; 0x26
 8001e3a:	3b01      	subs	r3, #1
 8001e3c:	f880 3026 	strb.w	r3, [r0, #38]	; 0x26

  /* If the references counter reaches zero and the thread is in its
     terminated state then the memory can be returned to the proper
     allocator.*/
  if ((tp->refs == (trefs_t)0) && (tp->state == CH_STATE_FINAL)) {
 8001e40:	6a43      	ldr	r3, [r0, #36]	; 0x24
 8001e42:	f003 13ff 	and.w	r3, r3, #16711935	; 0xff00ff
 8001e46:	2b0f      	cmp	r3, #15
 8001e48:	d003      	beq.n	8001e52 <chThdRelease+0x22>
 8001e4a:	2300      	movs	r3, #0
 8001e4c:	f383 8811 	msr	BASEPRI, r3
    }
#endif /* CH_CFG_USE_DYNAMIC == TRUE */
    return;
  }
  chSysUnlock();
}
 8001e50:	4770      	bx	lr
  p->prev->next = p->next;
 8001e52:	e9d0 3204 	ldrd	r3, r2, [r0, #16]
 8001e56:	2100      	movs	r1, #0
 8001e58:	6013      	str	r3, [r2, #0]
  p->next->prev = p->prev;
 8001e5a:	605a      	str	r2, [r3, #4]
 8001e5c:	f381 8811 	msr	BASEPRI, r1
    switch (tp->flags & CH_FLAG_MODE_MASK) {
 8001e60:	f890 3025 	ldrb.w	r3, [r0, #37]	; 0x25
 8001e64:	f003 0303 	and.w	r3, r3, #3
 8001e68:	2b01      	cmp	r3, #1
 8001e6a:	d006      	beq.n	8001e7a <chThdRelease+0x4a>
 8001e6c:	2b02      	cmp	r3, #2
 8001e6e:	d000      	beq.n	8001e72 <chThdRelease+0x42>
 8001e70:	4770      	bx	lr
      chPoolFree(tp->mpool, chThdGetWorkingAreaX(tp));
 8001e72:	6a01      	ldr	r1, [r0, #32]
 8001e74:	6c40      	ldr	r0, [r0, #68]	; 0x44
 8001e76:	f001 ba13 	b.w	80032a0 <chPoolFree>
      chHeapFree(chThdGetWorkingAreaX(tp));
 8001e7a:	6a00      	ldr	r0, [r0, #32]
 8001e7c:	f001 b950 	b.w	8003120 <chHeapFree>

08001e80 <chThdExit>:
 *
 * @param[in] msg       thread exit code
 *
 * @api
 */
void chThdExit(msg_t msg) {
 8001e80:	b538      	push	{r3, r4, r5, lr}
 8001e82:	2330      	movs	r3, #48	; 0x30
 8001e84:	f383 8811 	msr	BASEPRI, r3
 *
 * @xclass
 */
static inline thread_t *chThdGetSelfX(void) {

  return __sch_get_currthread();
 8001e88:	4b12      	ldr	r3, [pc, #72]	; (8001ed4 <chThdExit+0x54>)
 8001e8a:	68dc      	ldr	r4, [r3, #12]
  return (bool)(lp->next != lp);
 8001e8c:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
 */
void chThdExitS(msg_t msg) {
  thread_t *currtp = chThdGetSelfX();

  /* Storing exit message.*/
  currtp->u.exitcode = msg;
 8001e8e:	62a0      	str	r0, [r4, #40]	; 0x28
  /* Exit handler hook.*/
  CH_CFG_THREAD_EXIT_HOOK(tp);

#if CH_CFG_USE_WAITEXIT == TRUE
  /* Waking up any waiting thread.*/
  while (unlikely(ch_list_notempty(&currtp->waiting))) {
 8001e90:	f104 052c 	add.w	r5, r4, #44	; 0x2c
 8001e94:	429d      	cmp	r5, r3
 8001e96:	d107      	bne.n	8001ea8 <chThdExit+0x28>
    (void) chSchReadyI(threadref(ch_list_unlink(&currtp->waiting)));
  }
#endif

#if CH_CFG_USE_REGISTRY == TRUE
  if (unlikely(currtp->refs == (trefs_t)0)) {
 8001e98:	f894 3026 	ldrb.w	r3, [r4, #38]	; 0x26
 8001e9c:	b183      	cbz	r3, 8001ec0 <chThdExit+0x40>
}
 8001e9e:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
#endif
  }
#endif

  /* Going into final state.*/
  chSchGoSleepS(CH_STATE_FINAL);
 8001ea2:	200f      	movs	r0, #15
 8001ea4:	f7ff bdcc 	b.w	8001a40 <chSchGoSleepS>
  lp->next = p->next;
 8001ea8:	681a      	ldr	r2, [r3, #0]
 8001eaa:	62e2      	str	r2, [r4, #44]	; 0x2c
    (void) chSchReadyI(threadref(ch_list_unlink(&currtp->waiting)));
 8001eac:	4618      	mov	r0, r3
 8001eae:	f7ff fdb7 	bl	8001a20 <chSchReadyI>
  return (bool)(lp->next != lp);
 8001eb2:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
  while (unlikely(ch_list_notempty(&currtp->waiting))) {
 8001eb4:	42ab      	cmp	r3, r5
 8001eb6:	d1f7      	bne.n	8001ea8 <chThdExit+0x28>
  if (unlikely(currtp->refs == (trefs_t)0)) {
 8001eb8:	f894 3026 	ldrb.w	r3, [r4, #38]	; 0x26
 8001ebc:	2b00      	cmp	r3, #0
 8001ebe:	d1ee      	bne.n	8001e9e <chThdExit+0x1e>
    if (unlikely(((currtp->flags & CH_FLAG_MODE_MASK) == CH_FLAG_MODE_STATIC))) {
 8001ec0:	f894 3025 	ldrb.w	r3, [r4, #37]	; 0x25
 8001ec4:	079b      	lsls	r3, r3, #30
 8001ec6:	d1ea      	bne.n	8001e9e <chThdExit+0x1e>
  p->prev->next = p->next;
 8001ec8:	e9d4 3204 	ldrd	r3, r2, [r4, #16]
 8001ecc:	6013      	str	r3, [r2, #0]
  p->next->prev = p->prev;
 8001ece:	605a      	str	r2, [r3, #4]
  return p;
 8001ed0:	e7e5      	b.n	8001e9e <chThdExit+0x1e>
 8001ed2:	bf00      	nop
 8001ed4:	20000a40 	.word	0x20000a40
	...

08001ee0 <chThdWait>:
 * @param[in] tp        pointer to the thread
 * @return              The exit code from the terminated thread.
 *
 * @api
 */
msg_t chThdWait(thread_t *tp) {
 8001ee0:	b538      	push	{r3, r4, r5, lr}
 8001ee2:	4b1e      	ldr	r3, [pc, #120]	; (8001f5c <chThdWait+0x7c>)
 8001ee4:	4604      	mov	r4, r0
 8001ee6:	68db      	ldr	r3, [r3, #12]
 8001ee8:	2230      	movs	r2, #48	; 0x30
 8001eea:	f382 8811 	msr	BASEPRI, r2
  chDbgAssert(tp != currtp, "waiting self");
#if CH_CFG_USE_REGISTRY == TRUE
  chDbgAssert(tp->refs > (trefs_t)0, "no references");
#endif

  if (likely(tp->state != CH_STATE_FINAL)) {
 8001eee:	f890 2024 	ldrb.w	r2, [r0, #36]	; 0x24
 8001ef2:	2a0f      	cmp	r2, #15
 8001ef4:	d005      	beq.n	8001f02 <chThdWait+0x22>
  p->next = lp->next;
 8001ef6:	6ac2      	ldr	r2, [r0, #44]	; 0x2c
 8001ef8:	601a      	str	r2, [r3, #0]
    ch_list_link(&tp->waiting, &currtp->hdr.list);
    chSchGoSleepS(CH_STATE_WTEXIT);
 8001efa:	2009      	movs	r0, #9
  lp->next = p;
 8001efc:	62e3      	str	r3, [r4, #44]	; 0x2c
 8001efe:	f7ff fd9f 	bl	8001a40 <chSchGoSleepS>
  }
  msg = tp->u.exitcode;
 8001f02:	6aa5      	ldr	r5, [r4, #40]	; 0x28
 8001f04:	2200      	movs	r2, #0
 8001f06:	f382 8811 	msr	BASEPRI, r2
 8001f0a:	2330      	movs	r3, #48	; 0x30
 8001f0c:	f383 8811 	msr	BASEPRI, r3
  tp->refs--;
 8001f10:	f894 3026 	ldrb.w	r3, [r4, #38]	; 0x26
 8001f14:	3b01      	subs	r3, #1
 8001f16:	f884 3026 	strb.w	r3, [r4, #38]	; 0x26
  if ((tp->refs == (trefs_t)0) && (tp->state == CH_STATE_FINAL)) {
 8001f1a:	6a63      	ldr	r3, [r4, #36]	; 0x24
 8001f1c:	f003 13ff 	and.w	r3, r3, #16711935	; 0xff00ff
 8001f20:	2b0f      	cmp	r3, #15
 8001f22:	d003      	beq.n	8001f2c <chThdWait+0x4c>
 8001f24:	f382 8811 	msr	BASEPRI, r2
  /* Releasing a reference to the thread.*/
  chThdRelease(tp);
#endif

  return msg;
}
 8001f28:	4628      	mov	r0, r5
 8001f2a:	bd38      	pop	{r3, r4, r5, pc}
  p->prev->next = p->next;
 8001f2c:	e9d4 3104 	ldrd	r3, r1, [r4, #16]
 8001f30:	600b      	str	r3, [r1, #0]
  p->next->prev = p->prev;
 8001f32:	6059      	str	r1, [r3, #4]
 8001f34:	f382 8811 	msr	BASEPRI, r2
    switch (tp->flags & CH_FLAG_MODE_MASK) {
 8001f38:	f894 3025 	ldrb.w	r3, [r4, #37]	; 0x25
 8001f3c:	f003 0303 	and.w	r3, r3, #3
 8001f40:	2b01      	cmp	r3, #1
 8001f42:	d006      	beq.n	8001f52 <chThdWait+0x72>
 8001f44:	2b02      	cmp	r3, #2
 8001f46:	d1ef      	bne.n	8001f28 <chThdWait+0x48>
      chPoolFree(tp->mpool, chThdGetWorkingAreaX(tp));
 8001f48:	6a21      	ldr	r1, [r4, #32]
 8001f4a:	6c60      	ldr	r0, [r4, #68]	; 0x44
 8001f4c:	f001 f9a8 	bl	80032a0 <chPoolFree>
      break;
 8001f50:	e7ea      	b.n	8001f28 <chThdWait+0x48>
      chHeapFree(chThdGetWorkingAreaX(tp));
 8001f52:	6a20      	ldr	r0, [r4, #32]
 8001f54:	f001 f8e4 	bl	8003120 <chHeapFree>
      break;
 8001f58:	e7e6      	b.n	8001f28 <chThdWait+0x48>
 8001f5a:	bf00      	nop
 8001f5c:	20000a40 	.word	0x20000a40

08001f60 <chThdSetPriority>:
 8001f60:	4b0a      	ldr	r3, [pc, #40]	; (8001f8c <chThdSetPriority+0x2c>)
 * @param[in] newprio   the new priority level of the running thread
 * @return              The old priority level.
 *
 * @api
 */
tprio_t chThdSetPriority(tprio_t newprio) {
 8001f62:	b510      	push	{r4, lr}
 8001f64:	68da      	ldr	r2, [r3, #12]
 8001f66:	2130      	movs	r1, #48	; 0x30
 8001f68:	f381 8811 	msr	BASEPRI, r1

  chDbgCheck(newprio <= HIGHPRIO);

  chSysLock();
#if CH_CFG_USE_MUTEXES == TRUE
  oldprio = currtp->realprio;
 8001f6c:	6c14      	ldr	r4, [r2, #64]	; 0x40
  if ((currtp->hdr.pqueue.prio == currtp->realprio) ||
 8001f6e:	6891      	ldr	r1, [r2, #8]
 8001f70:	42a1      	cmp	r1, r4
 8001f72:	d001      	beq.n	8001f78 <chThdSetPriority+0x18>
 8001f74:	4281      	cmp	r1, r0
 8001f76:	d200      	bcs.n	8001f7a <chThdSetPriority+0x1a>
      (newprio > currtp->hdr.pqueue.prio)) {
    currtp->hdr.pqueue.prio = newprio;
 8001f78:	6090      	str	r0, [r2, #8]
  }
  currtp->realprio = newprio;
 8001f7a:	6410      	str	r0, [r2, #64]	; 0x40
#else
  oldprio = currtp->hdr.pqueue.prio;
  currtp->hdr.pqueue.prio = newprio;
#endif
  chSchRescheduleS();
 8001f7c:	f7ff fe10 	bl	8001ba0 <chSchRescheduleS>
 8001f80:	2300      	movs	r3, #0
 8001f82:	f383 8811 	msr	BASEPRI, r3
  chSysUnlock();

  return oldprio;
}
 8001f86:	4620      	mov	r0, r4
 8001f88:	bd10      	pop	{r4, pc}
 8001f8a:	bf00      	nop
 8001f8c:	20000a40 	.word	0x20000a40

08001f90 <chThdTerminate>:
 8001f90:	2330      	movs	r3, #48	; 0x30
 8001f92:	f383 8811 	msr	BASEPRI, r3
 * @api
 */
void chThdTerminate(thread_t *tp) {

  chSysLock();
  tp->flags |= CH_FLAG_TERMINATE;
 8001f96:	f890 3025 	ldrb.w	r3, [r0, #37]	; 0x25
 8001f9a:	f043 0304 	orr.w	r3, r3, #4
 8001f9e:	2200      	movs	r2, #0
 8001fa0:	f880 3025 	strb.w	r3, [r0, #37]	; 0x25
 8001fa4:	f382 8811 	msr	BASEPRI, r2
  chSysUnlock();
}
 8001fa8:	4770      	bx	lr
 8001faa:	bf00      	nop
 8001fac:	0000      	movs	r0, r0
	...

08001fb0 <chThdSleep>:
 *                      - @a TIME_IMMEDIATE this value is not allowed.
 *                      .
 *
 * @api
 */
void chThdSleep(sysinterval_t time) {
 8001fb0:	b508      	push	{r3, lr}
 8001fb2:	4601      	mov	r1, r0
 8001fb4:	2330      	movs	r3, #48	; 0x30
 8001fb6:	f383 8811 	msr	BASEPRI, r3
 */
static inline void chThdSleepS(sysinterval_t ticks) {

  chDbgCheck(ticks != TIME_IMMEDIATE);

  (void) chSchGoSleepTimeoutS(CH_STATE_SLEEPING, ticks);
 8001fba:	2008      	movs	r0, #8
 8001fbc:	f7ff fd58 	bl	8001a70 <chSchGoSleepTimeoutS>
 8001fc0:	2300      	movs	r3, #0
 8001fc2:	f383 8811 	msr	BASEPRI, r3

  chSysLock();
  chThdSleepS(time);
  chSysUnlock();
}
 8001fc6:	bd08      	pop	{r3, pc}
	...

08001fd0 <chThdSleepUntil>:
 *
 * @param[in] time      absolute system time
 *
 * @api
 */
void chThdSleepUntil(systime_t time) {
 8001fd0:	b510      	push	{r4, lr}
 8001fd2:	2330      	movs	r3, #48	; 0x30
 8001fd4:	4604      	mov	r4, r0
 8001fd6:	f383 8811 	msr	BASEPRI, r3
 8001fda:	f7fe fa71 	bl	80004c0 <stGetCounter>
  sysinterval_t interval;

  chSysLock();
  interval = chTimeDiffX(chVTGetSystemTimeX(), time);
  if (likely(interval > (sysinterval_t)0)) {
 8001fde:	1a21      	subs	r1, r4, r0
 8001fe0:	d002      	beq.n	8001fe8 <chThdSleepUntil+0x18>
 8001fe2:	2008      	movs	r0, #8
 8001fe4:	f7ff fd44 	bl	8001a70 <chSchGoSleepTimeoutS>
 8001fe8:	2300      	movs	r3, #0
 8001fea:	f383 8811 	msr	BASEPRI, r3
    chThdSleepS(interval);
  }
  chSysUnlock();
}
 8001fee:	bd10      	pop	{r4, pc}

08001ff0 <chThdYield>:
 * @details Yields the CPU control to the next thread in the ready list with
 *          equal priority, if any.
 *
 * @api
 */
void chThdYield(void) {
 8001ff0:	b508      	push	{r3, lr}
 8001ff2:	2330      	movs	r3, #48	; 0x30
 8001ff4:	f383 8811 	msr	BASEPRI, r3

  chSysLock();
  chSchDoYieldS();
 8001ff8:	f7ff fde2 	bl	8001bc0 <chSchDoYieldS>
 8001ffc:	2300      	movs	r3, #0
 8001ffe:	f383 8811 	msr	BASEPRI, r3
  chSysUnlock();
}
 8002002:	bd08      	pop	{r3, pc}
	...

08002010 <chThdSuspendTimeoutS>:
  return __sch_get_currthread();
 8002010:	4b05      	ldr	r3, [pc, #20]	; (8002028 <chThdSuspendTimeoutS+0x18>)
 8002012:	68da      	ldr	r2, [r3, #12]
 * @return              The wake up message.
 * @retval MSG_TIMEOUT  if the operation timed out.
 *
 * @sclass
 */
msg_t chThdSuspendTimeoutS(thread_reference_t *trp, sysinterval_t timeout) {
 8002014:	4603      	mov	r3, r0
  thread_t *tp = chThdGetSelfX();

  chDbgAssert(*trp == NULL, "not NULL");

  if (unlikely(TIME_IMMEDIATE == timeout)) {
 8002016:	b121      	cbz	r1, 8002022 <chThdSuspendTimeoutS+0x12>
    return MSG_TIMEOUT;
  }

  *trp = tp;
 8002018:	6002      	str	r2, [r0, #0]
  tp->u.wttrp = trp;

  return chSchGoSleepTimeoutS(CH_STATE_SUSPENDED, timeout);
 800201a:	2003      	movs	r0, #3
  tp->u.wttrp = trp;
 800201c:	6293      	str	r3, [r2, #40]	; 0x28
  return chSchGoSleepTimeoutS(CH_STATE_SUSPENDED, timeout);
 800201e:	f7ff bd27 	b.w	8001a70 <chSchGoSleepTimeoutS>
}
 8002022:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
 8002026:	4770      	bx	lr
 8002028:	20000a40 	.word	0x20000a40
 800202c:	00000000 	.word	0x00000000

08002030 <chThdResumeI>:
 * @param[in] trp       a pointer to a thread reference object
 * @param[in] msg       the message code
 *
 * @iclass
 */
void chThdResumeI(thread_reference_t *trp, msg_t msg) {
 8002030:	4603      	mov	r3, r0

  if (*trp != NULL) {
 8002032:	6800      	ldr	r0, [r0, #0]
 8002034:	b120      	cbz	r0, 8002040 <chThdResumeI+0x10>
    thread_t *tp = *trp;

    chDbgAssert(tp->state == CH_STATE_SUSPENDED, "not CH_STATE_SUSPENDED");

    *trp = NULL;
 8002036:	2200      	movs	r2, #0
 8002038:	601a      	str	r2, [r3, #0]
    tp->u.rdymsg = msg;
 800203a:	6281      	str	r1, [r0, #40]	; 0x28
    (void) chSchReadyI(tp);
 800203c:	f7ff bcf0 	b.w	8001a20 <chSchReadyI>
  }
}
 8002040:	4770      	bx	lr
 8002042:	bf00      	nop
	...

08002050 <chThdResume>:
 * @param[in] trp       a pointer to a thread reference object
 * @param[in] msg       the message code
 *
 * @api
 */
void chThdResume(thread_reference_t *trp, msg_t msg) {
 8002050:	b508      	push	{r3, lr}
 8002052:	2230      	movs	r2, #48	; 0x30
 8002054:	4603      	mov	r3, r0
 8002056:	f382 8811 	msr	BASEPRI, r2
  if (*trp != NULL) {
 800205a:	6800      	ldr	r0, [r0, #0]
 800205c:	b118      	cbz	r0, 8002066 <chThdResume+0x16>
    *trp = NULL;
 800205e:	2200      	movs	r2, #0
 8002060:	601a      	str	r2, [r3, #0]
    chSchWakeupS(tp, msg);
 8002062:	f7ff fd3d 	bl	8001ae0 <chSchWakeupS>
 8002066:	2300      	movs	r3, #0
 8002068:	f383 8811 	msr	BASEPRI, r3

  chSysLock();
  chThdResumeS(trp, msg);
  chSysUnlock();
}
 800206c:	bd08      	pop	{r3, pc}
 800206e:	bf00      	nop

08002070 <chThdEnqueueTimeoutS>:
 8002070:	4b08      	ldr	r3, [pc, #32]	; (8002094 <chThdEnqueueTimeoutS+0x24>)
 8002072:	68da      	ldr	r2, [r3, #12]
 * @sclass
 */
msg_t chThdEnqueueTimeoutS(threads_queue_t *tqp, sysinterval_t timeout) {
  thread_t *currtp = chThdGetSelfX();

  if (unlikely(TIME_IMMEDIATE == timeout)) {
 8002074:	b151      	cbz	r1, 800208c <chThdEnqueueTimeoutS+0x1c>
msg_t chThdEnqueueTimeoutS(threads_queue_t *tqp, sysinterval_t timeout) {
 8002076:	b410      	push	{r4}
 8002078:	4603      	mov	r3, r0
  p->prev       = qp->prev;
 800207a:	6844      	ldr	r4, [r0, #4]
 800207c:	e9c2 0400 	strd	r0, r4, [r2]
  p->prev->next = p;
 8002080:	6022      	str	r2, [r4, #0]
    return MSG_TIMEOUT;
  }

  ch_queue_insert(&tqp->queue, (ch_queue_t *)currtp);

  return chSchGoSleepTimeoutS(CH_STATE_QUEUED, timeout);
 8002082:	2004      	movs	r0, #4
}
 8002084:	bc10      	pop	{r4}
  qp->prev      = p;
 8002086:	605a      	str	r2, [r3, #4]
  return chSchGoSleepTimeoutS(CH_STATE_QUEUED, timeout);
 8002088:	f7ff bcf2 	b.w	8001a70 <chSchGoSleepTimeoutS>
}
 800208c:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
 8002090:	4770      	bx	lr
 8002092:	bf00      	nop
 8002094:	20000a40 	.word	0x20000a40
	...

080020a0 <chThdDequeueNextI>:
 * @param[in] tqp       pointer to the threads queue object
 * @param[in] msg       the message code
 *
 * @iclass
 */
void chThdDequeueNextI(threads_queue_t *tqp, msg_t msg) {
 80020a0:	4603      	mov	r3, r0
  return (bool)(qp->next != qp);
 80020a2:	6800      	ldr	r0, [r0, #0]

  if (ch_queue_notempty(&tqp->queue)) {
 80020a4:	4283      	cmp	r3, r0
 80020a6:	d005      	beq.n	80020b4 <chThdDequeueNextI+0x14>
  qp->next       = p->next;
 80020a8:	6802      	ldr	r2, [r0, #0]
 80020aa:	601a      	str	r2, [r3, #0]
  qp->next->prev = qp;
 80020ac:	6053      	str	r3, [r2, #4]

  tp = threadref(ch_queue_fifo_remove(&tqp->queue));

  chDbgAssert(tp->state == CH_STATE_QUEUED, "invalid state");

  tp->u.rdymsg = msg;
 80020ae:	6281      	str	r1, [r0, #40]	; 0x28
  (void) chSchReadyI(tp);
 80020b0:	f7ff bcb6 	b.w	8001a20 <chSchReadyI>
    chThdDoDequeueNextI(tqp, msg);
  }
}
 80020b4:	4770      	bx	lr
 80020b6:	bf00      	nop
	...

080020c0 <chThdDequeueAllI>:
 * @param[in] tqp       pointer to the threads queue object
 * @param[in] msg       the message code
 *
 * @iclass
 */
void chThdDequeueAllI(threads_queue_t *tqp, msg_t msg) {
 80020c0:	b538      	push	{r3, r4, r5, lr}
 80020c2:	4604      	mov	r4, r0
  return (bool)(qp->next != qp);
 80020c4:	6800      	ldr	r0, [r0, #0]

  while (ch_queue_notempty(&tqp->queue)) {
 80020c6:	42a0      	cmp	r0, r4
 80020c8:	d009      	beq.n	80020de <chThdDequeueAllI+0x1e>
 80020ca:	460d      	mov	r5, r1
  qp->next       = p->next;
 80020cc:	6803      	ldr	r3, [r0, #0]
 80020ce:	6023      	str	r3, [r4, #0]
  qp->next->prev = qp;
 80020d0:	605c      	str	r4, [r3, #4]
  tp->u.rdymsg = msg;
 80020d2:	6285      	str	r5, [r0, #40]	; 0x28
  (void) chSchReadyI(tp);
 80020d4:	f7ff fca4 	bl	8001a20 <chSchReadyI>
  return (bool)(qp->next != qp);
 80020d8:	6820      	ldr	r0, [r4, #0]
 80020da:	42a0      	cmp	r0, r4
 80020dc:	d1f6      	bne.n	80020cc <chThdDequeueAllI+0xc>
    chThdDoDequeueNextI(tqp, msg);
  }
}
 80020de:	bd38      	pop	{r3, r4, r5, pc}

080020e0 <chTMObjectInit>:

  tmp->best       = (rtcnt_t)-1;
  tmp->worst      = (rtcnt_t)0;
  tmp->last       = (rtcnt_t)0;
  tmp->n          = (ucnt_t)0;
  tmp->cumulative = (rttime_t)0;
 80020e0:	2200      	movs	r2, #0
 80020e2:	2300      	movs	r3, #0
 80020e4:	e9c0 2304 	strd	r2, r3, [r0, #16]
  tmp->worst      = (rtcnt_t)0;
 80020e8:	2300      	movs	r3, #0
  tmp->best       = (rtcnt_t)-1;
 80020ea:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
  tmp->worst      = (rtcnt_t)0;
 80020ee:	e9c0 2300 	strd	r2, r3, [r0]
  tmp->n          = (ucnt_t)0;
 80020f2:	e9c0 3302 	strd	r3, r3, [r0, #8]
}
 80020f6:	4770      	bx	lr
	...

08002100 <chTMStartMeasurementX>:
 *
 * @return              The realtime counter value.
 */
__STATIC_FORCEINLINE rtcnt_t port_rt_get_counter_value(void) {

  return DWT->CYCCNT;
 8002100:	4b01      	ldr	r3, [pc, #4]	; (8002108 <chTMStartMeasurementX+0x8>)
 8002102:	685b      	ldr	r3, [r3, #4]
 *
 * @xclass
 */
NOINLINE void chTMStartMeasurementX(time_measurement_t *tmp) {

  tmp->last = chSysGetRealtimeCounterX();
 8002104:	6083      	str	r3, [r0, #8]
}
 8002106:	4770      	bx	lr
 8002108:	e0001000 	.word	0xe0001000
 800210c:	00000000 	.word	0x00000000

08002110 <chTMStopMeasurementX>:
 *
 * @xclass
 */
NOINLINE void chTMStopMeasurementX(time_measurement_t *tmp) {

  tm_stop(tmp, chSysGetRealtimeCounterX(), ch_system.tmc.offset);
 8002110:	4a0e      	ldr	r2, [pc, #56]	; (800214c <chTMStopMeasurementX+0x3c>)
 8002112:	4b0f      	ldr	r3, [pc, #60]	; (8002150 <chTMStopMeasurementX+0x40>)
  tmp->last = (now - tmp->last) - offset;
 8002114:	6881      	ldr	r1, [r0, #8]
 8002116:	685b      	ldr	r3, [r3, #4]
NOINLINE void chTMStopMeasurementX(time_measurement_t *tmp) {
 8002118:	b410      	push	{r4}
  tm_stop(tmp, chSysGetRealtimeCounterX(), ch_system.tmc.offset);
 800211a:	6894      	ldr	r4, [r2, #8]
  tmp->cumulative += (rttime_t)tmp->last;
 800211c:	6902      	ldr	r2, [r0, #16]
  tmp->last = (now - tmp->last) - offset;
 800211e:	1b1b      	subs	r3, r3, r4
 8002120:	1a5b      	subs	r3, r3, r1
  tmp->cumulative += (rttime_t)tmp->last;
 8002122:	18d2      	adds	r2, r2, r3
 8002124:	6941      	ldr	r1, [r0, #20]
 8002126:	6102      	str	r2, [r0, #16]
  if (tmp->last > tmp->worst) {
 8002128:	6842      	ldr	r2, [r0, #4]
  tmp->n++;
 800212a:	68c4      	ldr	r4, [r0, #12]
  tmp->cumulative += (rttime_t)tmp->last;
 800212c:	f141 0100 	adc.w	r1, r1, #0
  if (tmp->last > tmp->worst) {
 8002130:	4293      	cmp	r3, r2
  if (tmp->last < tmp->best) {
 8002132:	6802      	ldr	r2, [r0, #0]
    tmp->worst = tmp->last;
 8002134:	bf88      	it	hi
 8002136:	6043      	strhi	r3, [r0, #4]
  tmp->n++;
 8002138:	3401      	adds	r4, #1
  if (tmp->last < tmp->best) {
 800213a:	4293      	cmp	r3, r2
  tmp->last = (now - tmp->last) - offset;
 800213c:	e9c0 3402 	strd	r3, r4, [r0, #8]
  tmp->cumulative += (rttime_t)tmp->last;
 8002140:	6141      	str	r1, [r0, #20]
}
 8002142:	bc10      	pop	{r4}
    tmp->best = tmp->last;
 8002144:	bf38      	it	cc
 8002146:	6003      	strcc	r3, [r0, #0]
}
 8002148:	4770      	bx	lr
 800214a:	bf00      	nop
 800214c:	20000bf8 	.word	0x20000bf8
 8002150:	e0001000 	.word	0xe0001000
	...

08002160 <chSemObjectInit>:
  qp->prev = qp;
 8002160:	e9c0 0000 	strd	r0, r0, [r0]
void chSemObjectInit(semaphore_t *sp, cnt_t n) {

  chDbgCheck((sp != NULL) && (n >= (cnt_t)0));

  ch_queue_init(&sp->queue);
  sp->cnt = n;
 8002164:	6081      	str	r1, [r0, #8]
}
 8002166:	4770      	bx	lr
	...

08002170 <chSemResetWithMessage>:
 *                      be non-negative.
 * @param[in] msg       message to be sent
 *
 * @api
 */
void chSemResetWithMessage(semaphore_t *sp, cnt_t n, msg_t msg) {
 8002170:	b538      	push	{r3, r4, r5, lr}
 8002172:	2330      	movs	r3, #48	; 0x30
 8002174:	f383 8811 	msr	BASEPRI, r3
  chDbgAssert(((sp->cnt >= (cnt_t)0) && ch_queue_isempty(&sp->queue)) ||
              ((sp->cnt < (cnt_t)0) && ch_queue_notempty(&sp->queue)),
              "inconsistent semaphore");

  sp->cnt = n;
  while (ch_queue_notempty(&sp->queue)) {
 8002178:	6803      	ldr	r3, [r0, #0]
  sp->cnt = n;
 800217a:	6081      	str	r1, [r0, #8]
  while (ch_queue_notempty(&sp->queue)) {
 800217c:	4283      	cmp	r3, r0
 800217e:	d00b      	beq.n	8002198 <chSemResetWithMessage+0x28>
 8002180:	4604      	mov	r4, r0
 8002182:	4615      	mov	r5, r2
  ch_queue_t *p = qp->prev;
 8002184:	6860      	ldr	r0, [r4, #4]
  qp->prev       = p->prev;
 8002186:	6843      	ldr	r3, [r0, #4]
 8002188:	6063      	str	r3, [r4, #4]
  qp->prev->next = qp;
 800218a:	601c      	str	r4, [r3, #0]
    chSchReadyI(threadref(ch_queue_lifo_remove(&sp->queue)))->u.rdymsg = msg;
 800218c:	f7ff fc48 	bl	8001a20 <chSchReadyI>
  while (ch_queue_notempty(&sp->queue)) {
 8002190:	6823      	ldr	r3, [r4, #0]
    chSchReadyI(threadref(ch_queue_lifo_remove(&sp->queue)))->u.rdymsg = msg;
 8002192:	6285      	str	r5, [r0, #40]	; 0x28
  while (ch_queue_notempty(&sp->queue)) {
 8002194:	42a3      	cmp	r3, r4
 8002196:	d1f5      	bne.n	8002184 <chSemResetWithMessage+0x14>
  chSchRescheduleS();
 8002198:	f7ff fd02 	bl	8001ba0 <chSchRescheduleS>
 800219c:	2300      	movs	r3, #0
 800219e:	f383 8811 	msr	BASEPRI, r3
}
 80021a2:	bd38      	pop	{r3, r4, r5, pc}
	...

080021b0 <chSemWait>:
 80021b0:	2230      	movs	r2, #48	; 0x30
 80021b2:	f382 8811 	msr	BASEPRI, r2
  chDbgCheck(sp != NULL);
  chDbgAssert(((sp->cnt >= (cnt_t)0) && ch_queue_isempty(&sp->queue)) ||
              ((sp->cnt < (cnt_t)0) && ch_queue_notempty(&sp->queue)),
              "inconsistent semaphore");

  if (--sp->cnt < (cnt_t)0) {
 80021b6:	6882      	ldr	r2, [r0, #8]
 80021b8:	3a01      	subs	r2, #1
 80021ba:	2a00      	cmp	r2, #0
 80021bc:	6082      	str	r2, [r0, #8]
 80021be:	db04      	blt.n	80021ca <chSemWait+0x1a>
    chSchGoSleepS(CH_STATE_WTSEM);

    return currtp->u.rdymsg;
  }

  return MSG_OK;
 80021c0:	2000      	movs	r0, #0
 80021c2:	2300      	movs	r3, #0
 80021c4:	f383 8811 	msr	BASEPRI, r3
}
 80021c8:	4770      	bx	lr
  return __sch_get_currthread();
 80021ca:	4909      	ldr	r1, [pc, #36]	; (80021f0 <chSemWait+0x40>)
  p->prev       = qp->prev;
 80021cc:	6842      	ldr	r2, [r0, #4]
msg_t chSemWait(semaphore_t *sp) {
 80021ce:	b510      	push	{r4, lr}
 80021d0:	4603      	mov	r3, r0
 80021d2:	68cc      	ldr	r4, [r1, #12]
    chSchGoSleepS(CH_STATE_WTSEM);
 80021d4:	2005      	movs	r0, #5
 80021d6:	e9c4 3200 	strd	r3, r2, [r4]
    currtp->u.wtsemp = sp;
 80021da:	62a3      	str	r3, [r4, #40]	; 0x28
  p->prev->next = p;
 80021dc:	6014      	str	r4, [r2, #0]
  qp->prev      = p;
 80021de:	605c      	str	r4, [r3, #4]
    chSchGoSleepS(CH_STATE_WTSEM);
 80021e0:	f7ff fc2e 	bl	8001a40 <chSchGoSleepS>
    return currtp->u.rdymsg;
 80021e4:	6aa0      	ldr	r0, [r4, #40]	; 0x28
 80021e6:	2300      	movs	r3, #0
 80021e8:	f383 8811 	msr	BASEPRI, r3
}
 80021ec:	bd10      	pop	{r4, pc}
 80021ee:	bf00      	nop
 80021f0:	20000a40 	.word	0x20000a40
	...

08002200 <chSemWaitS>:
  if (--sp->cnt < (cnt_t)0) {
 8002200:	6882      	ldr	r2, [r0, #8]
 8002202:	3a01      	subs	r2, #1
 8002204:	2a00      	cmp	r2, #0
 8002206:	6082      	str	r2, [r0, #8]
 8002208:	db01      	blt.n	800220e <chSemWaitS+0xe>
  return MSG_OK;
 800220a:	2000      	movs	r0, #0
}
 800220c:	4770      	bx	lr
msg_t chSemWaitS(semaphore_t *sp) {
 800220e:	b510      	push	{r4, lr}
 8002210:	4906      	ldr	r1, [pc, #24]	; (800222c <chSemWaitS+0x2c>)
  p->prev       = qp->prev;
 8002212:	6842      	ldr	r2, [r0, #4]
 8002214:	68cc      	ldr	r4, [r1, #12]
 8002216:	4603      	mov	r3, r0
 8002218:	e9c4 3200 	strd	r3, r2, [r4]
    currtp->u.wtsemp = sp;
 800221c:	62a3      	str	r3, [r4, #40]	; 0x28
    chSchGoSleepS(CH_STATE_WTSEM);
 800221e:	2005      	movs	r0, #5
  p->prev->next = p;
 8002220:	6014      	str	r4, [r2, #0]
  qp->prev      = p;
 8002222:	605c      	str	r4, [r3, #4]
 8002224:	f7ff fc0c 	bl	8001a40 <chSchGoSleepS>
    return currtp->u.rdymsg;
 8002228:	6aa0      	ldr	r0, [r4, #40]	; 0x28
}
 800222a:	bd10      	pop	{r4, pc}
 800222c:	20000a40 	.word	0x20000a40

08002230 <chSemWaitTimeout>:
 * @retval MSG_TIMEOUT  if the semaphore has not been signaled or reset within
 *                      the specified timeout.
 *
 * @api
 */
msg_t chSemWaitTimeout(semaphore_t *sp, sysinterval_t timeout) {
 8002230:	4603      	mov	r3, r0
 8002232:	b510      	push	{r4, lr}
 8002234:	2030      	movs	r0, #48	; 0x30
 8002236:	f380 8811 	msr	BASEPRI, r0
  chDbgCheck(sp != NULL);
  chDbgAssert(((sp->cnt >= (cnt_t)0) && ch_queue_isempty(&sp->queue)) ||
              ((sp->cnt < (cnt_t)0) && ch_queue_notempty(&sp->queue)),
              "inconsistent semaphore");

  if (--sp->cnt < (cnt_t)0) {
 800223a:	689c      	ldr	r4, [r3, #8]
 800223c:	1e60      	subs	r0, r4, #1
 800223e:	2800      	cmp	r0, #0
 8002240:	6098      	str	r0, [r3, #8]
 8002242:	db04      	blt.n	800224e <chSemWaitTimeout+0x1e>
    sem_insert(&sp->queue, currtp);

    return chSchGoSleepTimeoutS(CH_STATE_WTSEM, timeout);
  }

  return MSG_OK;
 8002244:	2000      	movs	r0, #0
 8002246:	2300      	movs	r3, #0
 8002248:	f383 8811 	msr	BASEPRI, r3
}
 800224c:	bd10      	pop	{r4, pc}
    if (unlikely(TIME_IMMEDIATE == timeout)) {
 800224e:	b171      	cbz	r1, 800226e <chSemWaitTimeout+0x3e>
 8002250:	4a09      	ldr	r2, [pc, #36]	; (8002278 <chSemWaitTimeout+0x48>)
  p->prev       = qp->prev;
 8002252:	685c      	ldr	r4, [r3, #4]
 8002254:	68d2      	ldr	r2, [r2, #12]
    return chSchGoSleepTimeoutS(CH_STATE_WTSEM, timeout);
 8002256:	2005      	movs	r0, #5
 8002258:	e9c2 3400 	strd	r3, r4, [r2]
    currtp->u.wtsemp = sp;
 800225c:	6293      	str	r3, [r2, #40]	; 0x28
  p->prev->next = p;
 800225e:	6022      	str	r2, [r4, #0]
  qp->prev      = p;
 8002260:	605a      	str	r2, [r3, #4]
    return chSchGoSleepTimeoutS(CH_STATE_WTSEM, timeout);
 8002262:	f7ff fc05 	bl	8001a70 <chSchGoSleepTimeoutS>
 8002266:	2300      	movs	r3, #0
 8002268:	f383 8811 	msr	BASEPRI, r3
}
 800226c:	bd10      	pop	{r4, pc}
      sp->cnt++;
 800226e:	609c      	str	r4, [r3, #8]
      return MSG_TIMEOUT;
 8002270:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
 8002274:	e7e7      	b.n	8002246 <chSemWaitTimeout+0x16>
 8002276:	bf00      	nop
 8002278:	20000a40 	.word	0x20000a40
 800227c:	00000000 	.word	0x00000000

08002280 <chSemWaitTimeoutS>:
msg_t chSemWaitTimeoutS(semaphore_t *sp, sysinterval_t timeout) {
 8002280:	b410      	push	{r4}
  if (--sp->cnt < (cnt_t)0) {
 8002282:	6884      	ldr	r4, [r0, #8]
msg_t chSemWaitTimeoutS(semaphore_t *sp, sysinterval_t timeout) {
 8002284:	4603      	mov	r3, r0
  if (--sp->cnt < (cnt_t)0) {
 8002286:	1e60      	subs	r0, r4, #1
 8002288:	2800      	cmp	r0, #0
 800228a:	6098      	str	r0, [r3, #8]
 800228c:	db02      	blt.n	8002294 <chSemWaitTimeoutS+0x14>
  return MSG_OK;
 800228e:	2000      	movs	r0, #0
}
 8002290:	bc10      	pop	{r4}
 8002292:	4770      	bx	lr
    if (unlikely(TIME_IMMEDIATE == timeout)) {
 8002294:	b159      	cbz	r1, 80022ae <chSemWaitTimeoutS+0x2e>
 8002296:	4a08      	ldr	r2, [pc, #32]	; (80022b8 <chSemWaitTimeoutS+0x38>)
  p->prev       = qp->prev;
 8002298:	685c      	ldr	r4, [r3, #4]
 800229a:	68d2      	ldr	r2, [r2, #12]
    return chSchGoSleepTimeoutS(CH_STATE_WTSEM, timeout);
 800229c:	2005      	movs	r0, #5
 800229e:	e9c2 3400 	strd	r3, r4, [r2]
    currtp->u.wtsemp = sp;
 80022a2:	6293      	str	r3, [r2, #40]	; 0x28
  p->prev->next = p;
 80022a4:	6022      	str	r2, [r4, #0]
}
 80022a6:	bc10      	pop	{r4}
  qp->prev      = p;
 80022a8:	605a      	str	r2, [r3, #4]
    return chSchGoSleepTimeoutS(CH_STATE_WTSEM, timeout);
 80022aa:	f7ff bbe1 	b.w	8001a70 <chSchGoSleepTimeoutS>
      sp->cnt++;
 80022ae:	609c      	str	r4, [r3, #8]
      return MSG_TIMEOUT;
 80022b0:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
 80022b4:	e7ec      	b.n	8002290 <chSemWaitTimeoutS+0x10>
 80022b6:	bf00      	nop
 80022b8:	20000a40 	.word	0x20000a40
 80022bc:	00000000 	.word	0x00000000

080022c0 <chSemSignal>:
 *
 * @param[in] sp        pointer to a @p semaphore_t structure
 *
 * @api
 */
void chSemSignal(semaphore_t *sp) {
 80022c0:	b508      	push	{r3, lr}
 80022c2:	2230      	movs	r2, #48	; 0x30
 80022c4:	f382 8811 	msr	BASEPRI, r2

  chSysLock();
  chDbgAssert(((sp->cnt >= (cnt_t)0) && ch_queue_isempty(&sp->queue)) ||
              ((sp->cnt < (cnt_t)0) && ch_queue_notempty(&sp->queue)),
              "inconsistent semaphore");
  if (++sp->cnt <= (cnt_t)0) {
 80022c8:	6882      	ldr	r2, [r0, #8]
 80022ca:	3201      	adds	r2, #1
 80022cc:	2a00      	cmp	r2, #0
 80022ce:	6082      	str	r2, [r0, #8]
 80022d0:	dd03      	ble.n	80022da <chSemSignal+0x1a>
 80022d2:	2300      	movs	r3, #0
 80022d4:	f383 8811 	msr	BASEPRI, r3
    chSchWakeupS(threadref(ch_queue_fifo_remove(&sp->queue)), MSG_OK);
  }
  chSysUnlock();
}
 80022d8:	bd08      	pop	{r3, pc}
 80022da:	4603      	mov	r3, r0
  ch_queue_t *p = qp->next;
 80022dc:	6800      	ldr	r0, [r0, #0]
  qp->next       = p->next;
 80022de:	6802      	ldr	r2, [r0, #0]
 80022e0:	601a      	str	r2, [r3, #0]
    chSchWakeupS(threadref(ch_queue_fifo_remove(&sp->queue)), MSG_OK);
 80022e2:	2100      	movs	r1, #0
  qp->next->prev = qp;
 80022e4:	6053      	str	r3, [r2, #4]
 80022e6:	f7ff fbfb 	bl	8001ae0 <chSchWakeupS>
 80022ea:	2300      	movs	r3, #0
 80022ec:	f383 8811 	msr	BASEPRI, r3
}
 80022f0:	bd08      	pop	{r3, pc}
 80022f2:	bf00      	nop
	...

08002300 <chSemSignalI>:
  chDbgCheck(sp != NULL);
  chDbgAssert(((sp->cnt >= (cnt_t)0) && ch_queue_isempty(&sp->queue)) ||
              ((sp->cnt < (cnt_t)0) && ch_queue_notempty(&sp->queue)),
              "inconsistent semaphore");

  if (++sp->cnt <= (cnt_t)0) {
 8002300:	6882      	ldr	r2, [r0, #8]
 8002302:	3201      	adds	r2, #1
 8002304:	2a00      	cmp	r2, #0
void chSemSignalI(semaphore_t *sp) {
 8002306:	4603      	mov	r3, r0
  if (++sp->cnt <= (cnt_t)0) {
 8002308:	6082      	str	r2, [r0, #8]
 800230a:	dd00      	ble.n	800230e <chSemSignalI+0xe>
             chSchReadyI().*/
    thread_t *tp = threadref(ch_queue_fifo_remove(&sp->queue));
    tp->u.rdymsg = MSG_OK;
    (void) chSchReadyI(tp);
  }
}
 800230c:	4770      	bx	lr
  ch_queue_t *p = qp->next;
 800230e:	6800      	ldr	r0, [r0, #0]
  qp->next       = p->next;
 8002310:	6802      	ldr	r2, [r0, #0]
 8002312:	601a      	str	r2, [r3, #0]
    tp->u.rdymsg = MSG_OK;
 8002314:	2100      	movs	r1, #0
  qp->next->prev = qp;
 8002316:	6053      	str	r3, [r2, #4]
 8002318:	6281      	str	r1, [r0, #40]	; 0x28
    (void) chSchReadyI(tp);
 800231a:	f7ff bb81 	b.w	8001a20 <chSchReadyI>
 800231e:	bf00      	nop

08002320 <chSemAddCounterI>:
 * @param[in] n         value to be added to the semaphore counter. The value
 *                      must be positive.
 *
 * @iclass
 */
void chSemAddCounterI(semaphore_t *sp, cnt_t n) {
 8002320:	b570      	push	{r4, r5, r6, lr}
  chDbgCheck((sp != NULL) && (n > (cnt_t)0));
  chDbgAssert(((sp->cnt >= (cnt_t)0) && ch_queue_isempty(&sp->queue)) ||
              ((sp->cnt < (cnt_t)0) && ch_queue_notempty(&sp->queue)),
              "inconsistent semaphore");

  while (n > (cnt_t)0) {
 8002322:	1e0c      	subs	r4, r1, #0
 8002324:	dd12      	ble.n	800234c <chSemAddCounterI+0x2c>
 8002326:	4605      	mov	r5, r0
    if (++sp->cnt <= (cnt_t)0) {
      chSchReadyI(threadref(ch_queue_fifo_remove(&sp->queue)))->u.rdymsg = MSG_OK;
 8002328:	2600      	movs	r6, #0
 800232a:	e001      	b.n	8002330 <chSemAddCounterI+0x10>
  while (n > (cnt_t)0) {
 800232c:	3c01      	subs	r4, #1
 800232e:	d00d      	beq.n	800234c <chSemAddCounterI+0x2c>
    if (++sp->cnt <= (cnt_t)0) {
 8002330:	68ab      	ldr	r3, [r5, #8]
 8002332:	3301      	adds	r3, #1
 8002334:	2b00      	cmp	r3, #0
 8002336:	60ab      	str	r3, [r5, #8]
 8002338:	dcf8      	bgt.n	800232c <chSemAddCounterI+0xc>
  ch_queue_t *p = qp->next;
 800233a:	6828      	ldr	r0, [r5, #0]
  qp->next       = p->next;
 800233c:	6803      	ldr	r3, [r0, #0]
 800233e:	602b      	str	r3, [r5, #0]
  qp->next->prev = qp;
 8002340:	605d      	str	r5, [r3, #4]
      chSchReadyI(threadref(ch_queue_fifo_remove(&sp->queue)))->u.rdymsg = MSG_OK;
 8002342:	f7ff fb6d 	bl	8001a20 <chSchReadyI>
  while (n > (cnt_t)0) {
 8002346:	3c01      	subs	r4, #1
      chSchReadyI(threadref(ch_queue_fifo_remove(&sp->queue)))->u.rdymsg = MSG_OK;
 8002348:	6286      	str	r6, [r0, #40]	; 0x28
  while (n > (cnt_t)0) {
 800234a:	d1f1      	bne.n	8002330 <chSemAddCounterI+0x10>
    }
    n--;
  }
}
 800234c:	bd70      	pop	{r4, r5, r6, pc}
 800234e:	bf00      	nop

08002350 <chSemSignalWait>:
 *                      semaphore has been signaled.
 * @retval MSG_RESET    if the semaphore has been reset using @p chSemReset().
 *
 * @api
 */
msg_t chSemSignalWait(semaphore_t *sps, semaphore_t *spw) {
 8002350:	b538      	push	{r3, r4, r5, lr}
 8002352:	2230      	movs	r2, #48	; 0x30
 8002354:	460c      	mov	r4, r1
 8002356:	f382 8811 	msr	BASEPRI, r2
              ((sps->cnt < (cnt_t)0) && ch_queue_notempty(&sps->queue)),
              "inconsistent semaphore");
  chDbgAssert(((spw->cnt >= (cnt_t)0) && ch_queue_isempty(&spw->queue)) ||
              ((spw->cnt < (cnt_t)0) && ch_queue_notempty(&spw->queue)),
              "inconsistent semaphore");
  if (++sps->cnt <= (cnt_t)0) {
 800235a:	6882      	ldr	r2, [r0, #8]
 800235c:	3201      	adds	r2, #1
 800235e:	2a00      	cmp	r2, #0
 8002360:	6082      	str	r2, [r0, #8]
 8002362:	dd1b      	ble.n	800239c <chSemSignalWait+0x4c>
    chSchReadyI(threadref(ch_queue_fifo_remove(&sps->queue)))->u.rdymsg = MSG_OK;
  }
  if (--spw->cnt < (cnt_t)0) {
 8002364:	68a3      	ldr	r3, [r4, #8]
 8002366:	3b01      	subs	r3, #1
 8002368:	2b00      	cmp	r3, #0
 800236a:	60a3      	str	r3, [r4, #8]
 800236c:	db06      	blt.n	800237c <chSemSignalWait+0x2c>
    currtp->u.wtsemp = spw;
    chSchGoSleepS(CH_STATE_WTSEM);
    msg = currtp->u.rdymsg;
  }
  else {
    chSchRescheduleS();
 800236e:	f7ff fc17 	bl	8001ba0 <chSchRescheduleS>
    msg = MSG_OK;
 8002372:	2000      	movs	r0, #0
 8002374:	2300      	movs	r3, #0
 8002376:	f383 8811 	msr	BASEPRI, r3
  }
  chSysUnlock();

  return msg;
}
 800237a:	bd38      	pop	{r3, r4, r5, pc}
 800237c:	4a0c      	ldr	r2, [pc, #48]	; (80023b0 <chSemSignalWait+0x60>)
  p->prev       = qp->prev;
 800237e:	6863      	ldr	r3, [r4, #4]
 8002380:	68d5      	ldr	r5, [r2, #12]
    chSchGoSleepS(CH_STATE_WTSEM);
 8002382:	2005      	movs	r0, #5
 8002384:	e9c5 4300 	strd	r4, r3, [r5]
  p->prev->next = p;
 8002388:	601d      	str	r5, [r3, #0]
  qp->prev      = p;
 800238a:	6065      	str	r5, [r4, #4]
    currtp->u.wtsemp = spw;
 800238c:	62ac      	str	r4, [r5, #40]	; 0x28
    chSchGoSleepS(CH_STATE_WTSEM);
 800238e:	f7ff fb57 	bl	8001a40 <chSchGoSleepS>
    msg = currtp->u.rdymsg;
 8002392:	6aa8      	ldr	r0, [r5, #40]	; 0x28
 8002394:	2300      	movs	r3, #0
 8002396:	f383 8811 	msr	BASEPRI, r3
}
 800239a:	bd38      	pop	{r3, r4, r5, pc}
 800239c:	4603      	mov	r3, r0
  ch_queue_t *p = qp->next;
 800239e:	6800      	ldr	r0, [r0, #0]
  qp->next       = p->next;
 80023a0:	6802      	ldr	r2, [r0, #0]
 80023a2:	601a      	str	r2, [r3, #0]
  qp->next->prev = qp;
 80023a4:	6053      	str	r3, [r2, #4]
    chSchReadyI(threadref(ch_queue_fifo_remove(&sps->queue)))->u.rdymsg = MSG_OK;
 80023a6:	f7ff fb3b 	bl	8001a20 <chSchReadyI>
 80023aa:	2300      	movs	r3, #0
 80023ac:	6283      	str	r3, [r0, #40]	; 0x28
 80023ae:	e7d9      	b.n	8002364 <chSemSignalWait+0x14>
 80023b0:	20000a40 	.word	0x20000a40
	...

080023c0 <chMtxObjectInit>:
void chMtxObjectInit(mutex_t *mp) {

  chDbgCheck(mp != NULL);

  ch_queue_init(&mp->queue);
  mp->owner = NULL;
 80023c0:	2300      	movs	r3, #0
  qp->prev = qp;
 80023c2:	e9c0 0000 	strd	r0, r0, [r0]
 80023c6:	6083      	str	r3, [r0, #8]
#if CH_CFG_USE_MUTEXES_RECURSIVE == TRUE
  mp->cnt = (cnt_t)0;
#endif
}
 80023c8:	4770      	bx	lr
 80023ca:	bf00      	nop
 80023cc:	0000      	movs	r0, r0
	...

080023d0 <chMtxLockS>:
 *
 * @param[in] mp        pointer to the @p mutex_t structure
 *
 * @sclass
 */
void chMtxLockS(mutex_t *mp) {
 80023d0:	b570      	push	{r4, r5, r6, lr}
 80023d2:	4b2f      	ldr	r3, [pc, #188]	; (8002490 <chMtxLockS+0xc0>)
 80023d4:	4604      	mov	r4, r0

  chDbgCheckClassS();
  chDbgCheck(mp != NULL);

  /* Is the mutex already locked? */
  if (mp->owner != NULL) {
 80023d6:	6880      	ldr	r0, [r0, #8]
 80023d8:	68dd      	ldr	r5, [r3, #12]
 80023da:	b330      	cbz	r0, 800242a <chMtxLockS+0x5a>
         priority of the running thread requesting the mutex.*/
      thread_t *tp = mp->owner;

      /* Does the running thread have higher priority than the mutex
         owning thread? */
      while (tp->hdr.pqueue.prio < currtp->hdr.pqueue.prio) {
 80023dc:	68aa      	ldr	r2, [r5, #8]
 80023de:	6883      	ldr	r3, [r0, #8]
 80023e0:	4293      	cmp	r3, r2
 80023e2:	d207      	bcs.n	80023f4 <chMtxLockS+0x24>
        /* Make priority of thread tp match the running thread's priority.*/
        tp->hdr.pqueue.prio = currtp->hdr.pqueue.prio;

        /* The following states need priority queues reordering.*/
        switch (tp->state) {
 80023e4:	f890 3024 	ldrb.w	r3, [r0, #36]	; 0x24
        tp->hdr.pqueue.prio = currtp->hdr.pqueue.prio;
 80023e8:	6082      	str	r2, [r0, #8]
        switch (tp->state) {
 80023ea:	2b06      	cmp	r3, #6
 80023ec:	d036      	beq.n	800245c <chMtxLockS+0x8c>
 80023ee:	2b07      	cmp	r3, #7
 80023f0:	d020      	beq.n	8002434 <chMtxLockS+0x64>
 80023f2:	b19b      	cbz	r3, 800241c <chMtxLockS+0x4c>
/* If the performance code path has been chosen then all the following
   functions are inlined into the various kernel modules.*/
#if CH_CFG_OPTIMIZE_SPEED == TRUE
static inline void ch_sch_prio_insert(ch_queue_t *qp, ch_queue_t *tp) {

  ch_queue_t *cp = qp;
 80023f4:	4623      	mov	r3, r4
 80023f6:	e003      	b.n	8002400 <chMtxLockS+0x30>
  do {
    cp = cp->next;
  } while ((cp != qp) &&
 80023f8:	6899      	ldr	r1, [r3, #8]
 80023fa:	68aa      	ldr	r2, [r5, #8]
 80023fc:	4291      	cmp	r1, r2
 80023fe:	d302      	bcc.n	8002406 <chMtxLockS+0x36>
    cp = cp->next;
 8002400:	681b      	ldr	r3, [r3, #0]
           (threadref(cp)->hdr.pqueue.prio >= threadref(tp)->hdr.pqueue.prio));
 8002402:	429c      	cmp	r4, r3
 8002404:	d1f8      	bne.n	80023f8 <chMtxLockS+0x28>
  tp->next       = cp;
  tp->prev       = cp->prev;
 8002406:	685a      	ldr	r2, [r3, #4]
      }

      /* Sleep on the mutex.*/
      ch_sch_prio_insert(&mp->queue, &currtp->hdr.queue);
      currtp->u.wtmtxp = mp;
      chSchGoSleepS(CH_STATE_WTMTX);
 8002408:	2006      	movs	r0, #6
 800240a:	e9c5 3200 	strd	r3, r2, [r5]
  tp->prev->next = tp;
 800240e:	6015      	str	r5, [r2, #0]
  cp->prev       = tp;
 8002410:	605d      	str	r5, [r3, #4]
      currtp->u.wtmtxp = mp;
 8002412:	62ac      	str	r4, [r5, #40]	; 0x28
    /* It was not owned, inserted in the owned mutexes list.*/
    mp->owner = currtp;
    mp->next = currtp->mtxlist;
    currtp->mtxlist = mp;
  }
}
 8002414:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
      chSchGoSleepS(CH_STATE_WTMTX);
 8002418:	f7ff bb12 	b.w	8001a40 <chSchGoSleepS>
  p->prev->next = p->next;
 800241c:	e9d0 3200 	ldrd	r3, r2, [r0]
 8002420:	6013      	str	r3, [r2, #0]
  p->next->prev = p->prev;
 8002422:	605a      	str	r2, [r3, #4]
          (void) chSchReadyI(threadref(ch_queue_dequeue(&tp->hdr.queue)));
 8002424:	f7ff fafc 	bl	8001a20 <chSchReadyI>
          break;
 8002428:	e7e4      	b.n	80023f4 <chMtxLockS+0x24>
    mp->next = currtp->mtxlist;
 800242a:	6beb      	ldr	r3, [r5, #60]	; 0x3c
 800242c:	e9c4 5302 	strd	r5, r3, [r4, #8]
    currtp->mtxlist = mp;
 8002430:	63ec      	str	r4, [r5, #60]	; 0x3c
}
 8002432:	bd70      	pop	{r4, r5, r6, pc}
  p->prev->next = p->next;
 8002434:	e9d0 3200 	ldrd	r3, r2, [r0]
          ch_sch_prio_insert(&tp->u.wtmtxp->queue,
 8002438:	6a86      	ldr	r6, [r0, #40]	; 0x28
 800243a:	6013      	str	r3, [r2, #0]
  p->next->prev = p->prev;
 800243c:	605a      	str	r2, [r3, #4]
  ch_queue_t *cp = qp;
 800243e:	4633      	mov	r3, r6
 8002440:	e003      	b.n	800244a <chMtxLockS+0x7a>
  } while ((cp != qp) &&
 8002442:	6899      	ldr	r1, [r3, #8]
 8002444:	6882      	ldr	r2, [r0, #8]
 8002446:	4291      	cmp	r1, r2
 8002448:	d302      	bcc.n	8002450 <chMtxLockS+0x80>
    cp = cp->next;
 800244a:	681b      	ldr	r3, [r3, #0]
           (threadref(cp)->hdr.pqueue.prio >= threadref(tp)->hdr.pqueue.prio));
 800244c:	429e      	cmp	r6, r3
 800244e:	d1f8      	bne.n	8002442 <chMtxLockS+0x72>
  tp->prev       = cp->prev;
 8002450:	685a      	ldr	r2, [r3, #4]
 8002452:	e9c0 3200 	strd	r3, r2, [r0]
  tp->prev->next = tp;
 8002456:	6010      	str	r0, [r2, #0]
  cp->prev       = tp;
 8002458:	6058      	str	r0, [r3, #4]
}
 800245a:	e7cb      	b.n	80023f4 <chMtxLockS+0x24>
  p->prev->next = p->next;
 800245c:	e9d0 3200 	ldrd	r3, r2, [r0]
          ch_sch_prio_insert(&tp->u.wtmtxp->queue,
 8002460:	6a86      	ldr	r6, [r0, #40]	; 0x28
 8002462:	6013      	str	r3, [r2, #0]
  p->next->prev = p->prev;
 8002464:	605a      	str	r2, [r3, #4]
  ch_queue_t *cp = qp;
 8002466:	4633      	mov	r3, r6
 8002468:	e003      	b.n	8002472 <chMtxLockS+0xa2>
  } while ((cp != qp) &&
 800246a:	6899      	ldr	r1, [r3, #8]
 800246c:	6882      	ldr	r2, [r0, #8]
 800246e:	4291      	cmp	r1, r2
 8002470:	d302      	bcc.n	8002478 <chMtxLockS+0xa8>
    cp = cp->next;
 8002472:	681b      	ldr	r3, [r3, #0]
           (threadref(cp)->hdr.pqueue.prio >= threadref(tp)->hdr.pqueue.prio));
 8002474:	429e      	cmp	r6, r3
 8002476:	d1f8      	bne.n	800246a <chMtxLockS+0x9a>
  tp->prev       = cp->prev;
 8002478:	685a      	ldr	r2, [r3, #4]
  tp->next       = cp;
 800247a:	6003      	str	r3, [r0, #0]
  tp->prev       = cp->prev;
 800247c:	6042      	str	r2, [r0, #4]
  tp->prev->next = tp;
 800247e:	6010      	str	r0, [r2, #0]
  cp->prev       = tp;
 8002480:	6058      	str	r0, [r3, #4]
          tp = tp->u.wtmtxp->owner;
 8002482:	68b0      	ldr	r0, [r6, #8]
      while (tp->hdr.pqueue.prio < currtp->hdr.pqueue.prio) {
 8002484:	68aa      	ldr	r2, [r5, #8]
 8002486:	6883      	ldr	r3, [r0, #8]
 8002488:	4293      	cmp	r3, r2
 800248a:	d3ab      	bcc.n	80023e4 <chMtxLockS+0x14>
 800248c:	e7b2      	b.n	80023f4 <chMtxLockS+0x24>
 800248e:	bf00      	nop
 8002490:	20000a40 	.word	0x20000a40
	...

080024a0 <chMtxLock>:
void chMtxLock(mutex_t *mp) {
 80024a0:	b508      	push	{r3, lr}
 80024a2:	2330      	movs	r3, #48	; 0x30
 80024a4:	f383 8811 	msr	BASEPRI, r3
  chMtxLockS(mp);
 80024a8:	f7ff ff92 	bl	80023d0 <chMtxLockS>
 80024ac:	2300      	movs	r3, #0
 80024ae:	f383 8811 	msr	BASEPRI, r3
}
 80024b2:	bd08      	pop	{r3, pc}
	...

080024c0 <chMtxTryLock>:
 * @retval true         if the mutex has been successfully acquired
 * @retval false        if the lock attempt failed.
 *
 * @api
 */
bool chMtxTryLock(mutex_t *mp) {
 80024c0:	4603      	mov	r3, r0
 80024c2:	2230      	movs	r2, #48	; 0x30
 80024c4:	f382 8811 	msr	BASEPRI, r2
  thread_t *currtp = chThdGetSelfX();

  chDbgCheckClassS();
  chDbgCheck(mp != NULL);

  if (mp->owner != NULL) {
 80024c8:	6882      	ldr	r2, [r0, #8]
 80024ca:	b122      	cbz	r2, 80024d6 <chMtxTryLock+0x16>
    if (mp->owner == currtp) {
      mp->cnt++;
      return true;
    }
#endif
    return false;
 80024cc:	2000      	movs	r0, #0
 80024ce:	2300      	movs	r3, #0
 80024d0:	f383 8811 	msr	BASEPRI, r3
}
 80024d4:	4770      	bx	lr
 80024d6:	4a05      	ldr	r2, [pc, #20]	; (80024ec <chMtxTryLock+0x2c>)
 80024d8:	68d2      	ldr	r2, [r2, #12]

  chDbgAssert(mp->cnt == (cnt_t)0, "counter is not zero");

  mp->cnt++;
#endif
  mp->owner = currtp;
 80024da:	609a      	str	r2, [r3, #8]
  mp->next = currtp->mtxlist;
 80024dc:	6bd1      	ldr	r1, [r2, #60]	; 0x3c
 80024de:	60d9      	str	r1, [r3, #12]
  currtp->mtxlist = mp;
  return true;
 80024e0:	2001      	movs	r0, #1
  currtp->mtxlist = mp;
 80024e2:	63d3      	str	r3, [r2, #60]	; 0x3c
 80024e4:	2300      	movs	r3, #0
 80024e6:	f383 8811 	msr	BASEPRI, r3
}
 80024ea:	4770      	bx	lr
 80024ec:	20000a40 	.word	0x20000a40

080024f0 <chMtxUnlock>:
 80024f0:	4b17      	ldr	r3, [pc, #92]	; (8002550 <chMtxUnlock+0x60>)
 *
 * @param[in] mp        pointer to the @p mutex_t structure
 *
 * @api
 */
void chMtxUnlock(mutex_t *mp) {
 80024f2:	b510      	push	{r4, lr}
 80024f4:	68dc      	ldr	r4, [r3, #12]
 80024f6:	2330      	movs	r3, #48	; 0x30
 80024f8:	f383 8811 	msr	BASEPRI, r3
       it as not owned. Note, it is assumed to be the same mutex passed as
       parameter of this function.*/
    currtp->mtxlist = mp->next;

    /* If a thread is waiting on the mutex then the fun part begins.*/
    if (chMtxQueueNotEmptyS(mp)) {
 80024fc:	6802      	ldr	r2, [r0, #0]
    currtp->mtxlist = mp->next;
 80024fe:	68c3      	ldr	r3, [r0, #12]
 8002500:	63e3      	str	r3, [r4, #60]	; 0x3c
    if (chMtxQueueNotEmptyS(mp)) {
 8002502:	4282      	cmp	r2, r0
 8002504:	d01d      	beq.n	8002542 <chMtxUnlock+0x52>
      thread_t *tp;

      /* Recalculates the optimal thread priority by scanning the owned
         mutexes list.*/
      tprio_t newprio = currtp->realprio;
 8002506:	4601      	mov	r1, r0
 8002508:	6c20      	ldr	r0, [r4, #64]	; 0x40
      lmp = currtp->mtxlist;
      while (lmp != NULL) {
 800250a:	b14b      	cbz	r3, 8002520 <chMtxUnlock+0x30>
  return (bool)(qp->next != qp);
 800250c:	681a      	ldr	r2, [r3, #0]
        /* If the highest priority thread waiting in the mutexes list has a
           greater priority than the current thread base priority then the
           final priority will have at least that priority.*/
        if (chMtxQueueNotEmptyS(lmp) &&
 800250e:	4293      	cmp	r3, r2
 8002510:	d003      	beq.n	800251a <chMtxUnlock+0x2a>
 8002512:	6892      	ldr	r2, [r2, #8]
 8002514:	4290      	cmp	r0, r2
 8002516:	bf38      	it	cc
 8002518:	4610      	movcc	r0, r2
            ((threadref(lmp->queue.next))->hdr.pqueue.prio > newprio)) {
          newprio = (threadref(lmp->queue.next))->hdr.pqueue.prio;
        }
        lmp = lmp->next;
 800251a:	68db      	ldr	r3, [r3, #12]
      while (lmp != NULL) {
 800251c:	2b00      	cmp	r3, #0
 800251e:	d1f5      	bne.n	800250c <chMtxUnlock+0x1c>
      }

      /* Assigns to the current thread the highest priority among all the
         waiting threads.*/
      currtp->hdr.pqueue.prio = newprio;
 8002520:	60a0      	str	r0, [r4, #8]
  ch_queue_t *p = qp->next;
 8002522:	6808      	ldr	r0, [r1, #0]
#if CH_CFG_USE_MUTEXES_RECURSIVE == TRUE
      mp->cnt = (cnt_t)1;
#endif
      tp = threadref(ch_queue_fifo_remove(&mp->queue));
      mp->owner = tp;
      mp->next = tp->mtxlist;
 8002524:	6bc2      	ldr	r2, [r0, #60]	; 0x3c
  qp->next       = p->next;
 8002526:	6803      	ldr	r3, [r0, #0]
 8002528:	600b      	str	r3, [r1, #0]
  qp->next->prev = qp;
 800252a:	6059      	str	r1, [r3, #4]
 800252c:	e9c1 0202 	strd	r0, r2, [r1, #8]
      tp->mtxlist = mp;
 8002530:	63c1      	str	r1, [r0, #60]	; 0x3c

      /* Note, not using chSchWakeupS() because that function expects the
         current thread to have the higher or equal priority than the ones
         in the ready list. This is not necessarily true here because we
         just changed priority.*/
      (void) chSchReadyI(tp);
 8002532:	f7ff fa75 	bl	8001a20 <chSchReadyI>
      chSchRescheduleS();
 8002536:	f7ff fb33 	bl	8001ba0 <chSchRescheduleS>
 800253a:	2300      	movs	r3, #0
 800253c:	f383 8811 	msr	BASEPRI, r3
#if CH_CFG_USE_MUTEXES_RECURSIVE == TRUE
  }
#endif

  chSysUnlock();
}
 8002540:	bd10      	pop	{r4, pc}
      mp->owner = NULL;
 8002542:	2300      	movs	r3, #0
 8002544:	6093      	str	r3, [r2, #8]
 8002546:	2300      	movs	r3, #0
 8002548:	f383 8811 	msr	BASEPRI, r3
}
 800254c:	bd10      	pop	{r4, pc}
 800254e:	bf00      	nop
 8002550:	20000a40 	.word	0x20000a40
	...

08002560 <chMtxUnlockS>:
 8002560:	4b12      	ldr	r3, [pc, #72]	; (80025ac <chMtxUnlockS+0x4c>)
       it as not owned. Note, it is assumed to be the same mutex passed as
       parameter of this function.*/
    currtp->mtxlist = mp->next;

    /* If a thread is waiting on the mutex then the fun part begins.*/
    if (chMtxQueueNotEmptyS(mp)) {
 8002562:	6802      	ldr	r2, [r0, #0]
void chMtxUnlockS(mutex_t *mp) {
 8002564:	b410      	push	{r4}
 8002566:	68dc      	ldr	r4, [r3, #12]
    currtp->mtxlist = mp->next;
 8002568:	68c3      	ldr	r3, [r0, #12]
 800256a:	63e3      	str	r3, [r4, #60]	; 0x3c
    if (chMtxQueueNotEmptyS(mp)) {
 800256c:	4282      	cmp	r2, r0
 800256e:	d018      	beq.n	80025a2 <chMtxUnlockS+0x42>
      thread_t *tp;

      /* Recalculates the optimal thread priority by scanning the owned
         mutexes list.*/
      tprio_t newprio = currtp->realprio;
 8002570:	4601      	mov	r1, r0
 8002572:	6c20      	ldr	r0, [r4, #64]	; 0x40
      lmp = currtp->mtxlist;
      while (lmp != NULL) {
 8002574:	b14b      	cbz	r3, 800258a <chMtxUnlockS+0x2a>
  return (bool)(qp->next != qp);
 8002576:	681a      	ldr	r2, [r3, #0]
        /* If the highest priority thread waiting in the mutexes list has a
           greater priority than the current thread base priority then the
           final priority will have at least that priority.*/
        if (chMtxQueueNotEmptyS(lmp) &&
 8002578:	4293      	cmp	r3, r2
 800257a:	d003      	beq.n	8002584 <chMtxUnlockS+0x24>
 800257c:	6892      	ldr	r2, [r2, #8]
 800257e:	4290      	cmp	r0, r2
 8002580:	bf38      	it	cc
 8002582:	4610      	movcc	r0, r2
            ((threadref(lmp->queue.next))->hdr.pqueue.prio > newprio)) {
          newprio = threadref(lmp->queue.next)->hdr.pqueue.prio;
        }
        lmp = lmp->next;
 8002584:	68db      	ldr	r3, [r3, #12]
      while (lmp != NULL) {
 8002586:	2b00      	cmp	r3, #0
 8002588:	d1f5      	bne.n	8002576 <chMtxUnlockS+0x16>
      }

      /* Assigns to the current thread the highest priority among all the
         waiting threads.*/
      currtp->hdr.pqueue.prio = newprio;
 800258a:	60a0      	str	r0, [r4, #8]
  ch_queue_t *p = qp->next;
 800258c:	6808      	ldr	r0, [r1, #0]
      mp->owner = NULL;
    }
#if CH_CFG_USE_MUTEXES_RECURSIVE == TRUE
  }
#endif
}
 800258e:	bc10      	pop	{r4}
      mp->next = tp->mtxlist;
 8002590:	6bc2      	ldr	r2, [r0, #60]	; 0x3c
  qp->next       = p->next;
 8002592:	6803      	ldr	r3, [r0, #0]
 8002594:	600b      	str	r3, [r1, #0]
  qp->next->prev = qp;
 8002596:	6059      	str	r1, [r3, #4]
 8002598:	e9c1 0202 	strd	r0, r2, [r1, #8]
      tp->mtxlist = mp;
 800259c:	63c1      	str	r1, [r0, #60]	; 0x3c
      (void) chSchReadyI(tp);
 800259e:	f7ff ba3f 	b.w	8001a20 <chSchReadyI>
      mp->owner = NULL;
 80025a2:	2300      	movs	r3, #0
}
 80025a4:	bc10      	pop	{r4}
      mp->owner = NULL;
 80025a6:	6093      	str	r3, [r2, #8]
}
 80025a8:	4770      	bx	lr
 80025aa:	bf00      	nop
 80025ac:	20000a40 	.word	0x20000a40

080025b0 <chMtxUnlockAllS>:
 80025b0:	4b11      	ldr	r3, [pc, #68]	; (80025f8 <chMtxUnlockAllS+0x48>)
 *          this function does not have any overhead related to the priority
 *          inheritance mechanism.
 *
 * @sclass
 */
void chMtxUnlockAllS(void) {
 80025b2:	b570      	push	{r4, r5, r6, lr}
 80025b4:	68dc      	ldr	r4, [r3, #12]
  thread_t *currtp = chThdGetSelfX();

  if (currtp->mtxlist != NULL) {
 80025b6:	6be3      	ldr	r3, [r4, #60]	; 0x3c
 80025b8:	b1eb      	cbz	r3, 80025f6 <chMtxUnlockAllS+0x46>
      }
      else {
#if CH_CFG_USE_MUTEXES_RECURSIVE == TRUE
        mp->cnt = (cnt_t)0;
#endif
        mp->owner = NULL;
 80025ba:	2600      	movs	r6, #0
  return (bool)(qp->next != qp);
 80025bc:	681a      	ldr	r2, [r3, #0]
      currtp->mtxlist = mp->next;
 80025be:	68d9      	ldr	r1, [r3, #12]
 80025c0:	63e1      	str	r1, [r4, #60]	; 0x3c
      if (chMtxQueueNotEmptyS(mp)) {
 80025c2:	4293      	cmp	r3, r2
        (void) chSchReadyI(tp);
 80025c4:	4610      	mov	r0, r2
      if (chMtxQueueNotEmptyS(mp)) {
 80025c6:	d011      	beq.n	80025ec <chMtxUnlockAllS+0x3c>
        mp->next    = tp->mtxlist;
 80025c8:	6bd5      	ldr	r5, [r2, #60]	; 0x3c
  qp->next       = p->next;
 80025ca:	6811      	ldr	r1, [r2, #0]
 80025cc:	6019      	str	r1, [r3, #0]
  qp->next->prev = qp;
 80025ce:	604b      	str	r3, [r1, #4]
 80025d0:	e9c3 2502 	strd	r2, r5, [r3, #8]
        tp->mtxlist = mp;
 80025d4:	63d3      	str	r3, [r2, #60]	; 0x3c
        (void) chSchReadyI(tp);
 80025d6:	f7ff fa23 	bl	8001a20 <chSchReadyI>
      }
    } while (currtp->mtxlist != NULL);
 80025da:	6be3      	ldr	r3, [r4, #60]	; 0x3c
 80025dc:	2b00      	cmp	r3, #0
 80025de:	d1ed      	bne.n	80025bc <chMtxUnlockAllS+0xc>
    currtp->hdr.pqueue.prio = currtp->realprio;
 80025e0:	6c23      	ldr	r3, [r4, #64]	; 0x40
 80025e2:	60a3      	str	r3, [r4, #8]
    chSchRescheduleS();
  }
}
 80025e4:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
    chSchRescheduleS();
 80025e8:	f7ff bada 	b.w	8001ba0 <chSchRescheduleS>
        mp->owner = NULL;
 80025ec:	609e      	str	r6, [r3, #8]
 80025ee:	460b      	mov	r3, r1
    } while (currtp->mtxlist != NULL);
 80025f0:	2b00      	cmp	r3, #0
 80025f2:	d1e3      	bne.n	80025bc <chMtxUnlockAllS+0xc>
 80025f4:	e7f4      	b.n	80025e0 <chMtxUnlockAllS+0x30>
}
 80025f6:	bd70      	pop	{r4, r5, r6, pc}
 80025f8:	20000a40 	.word	0x20000a40
 80025fc:	00000000 	.word	0x00000000

08002600 <chMtxUnlockAll>:
 *          this function does not have any overhead related to the priority
 *          inheritance mechanism.
 *
 * @api
 */
void chMtxUnlockAll(void) {
 8002600:	b508      	push	{r3, lr}
 8002602:	2330      	movs	r3, #48	; 0x30
 8002604:	f383 8811 	msr	BASEPRI, r3

  chSysLock();
  chMtxUnlockAllS();
 8002608:	f7ff ffd2 	bl	80025b0 <chMtxUnlockAllS>
 800260c:	2300      	movs	r3, #0
 800260e:	f383 8811 	msr	BASEPRI, r3
  chSysUnlock();
}
 8002612:	bd08      	pop	{r3, pc}
	...

08002620 <chCondObjectInit>:
  qp->prev = qp;
 8002620:	e9c0 0000 	strd	r0, r0, [r0]
void chCondObjectInit(condition_variable_t *cp) {

  chDbgCheck(cp != NULL);

  ch_queue_init(&cp->queue);
}
 8002624:	4770      	bx	lr
 8002626:	bf00      	nop
	...

08002630 <chCondSignal>:
 *
 * @param[in] cp        pointer to the @p condition_variable_t structure
 *
 * @api
 */
void chCondSignal(condition_variable_t *cp) {
 8002630:	b508      	push	{r3, lr}
 8002632:	2230      	movs	r2, #48	; 0x30
 8002634:	4603      	mov	r3, r0
 8002636:	f382 8811 	msr	BASEPRI, r2
  return (bool)(qp->next != qp);
 800263a:	6800      	ldr	r0, [r0, #0]

  chDbgCheck(cp != NULL);

  chSysLock();
  if (ch_queue_notempty(&cp->queue)) {
 800263c:	4283      	cmp	r3, r0
 800263e:	d005      	beq.n	800264c <chCondSignal+0x1c>
  qp->next       = p->next;
 8002640:	6802      	ldr	r2, [r0, #0]
 8002642:	601a      	str	r2, [r3, #0]
    chSchWakeupS(threadref(ch_queue_fifo_remove(&cp->queue)), MSG_OK);
 8002644:	2100      	movs	r1, #0
  qp->next->prev = qp;
 8002646:	6053      	str	r3, [r2, #4]
 8002648:	f7ff fa4a 	bl	8001ae0 <chSchWakeupS>
 800264c:	2300      	movs	r3, #0
 800264e:	f383 8811 	msr	BASEPRI, r3
  }
  chSysUnlock();
}
 8002652:	bd08      	pop	{r3, pc}
	...

08002660 <chCondSignalI>:
 *
 * @param[in] cp        pointer to the @p condition_variable_t structure
 *
 * @iclass
 */
void chCondSignalI(condition_variable_t *cp) {
 8002660:	4603      	mov	r3, r0
  return (bool)(qp->next != qp);
 8002662:	6800      	ldr	r0, [r0, #0]

  chDbgCheckClassI();
  chDbgCheck(cp != NULL);

  if (ch_queue_notempty(&cp->queue)) {
 8002664:	4283      	cmp	r3, r0
 8002666:	d006      	beq.n	8002676 <chCondSignalI+0x16>
  qp->next       = p->next;
 8002668:	6802      	ldr	r2, [r0, #0]
 800266a:	601a      	str	r2, [r3, #0]
    thread_t *tp = threadref(ch_queue_fifo_remove(&cp->queue));
    tp->u.rdymsg = MSG_OK;
 800266c:	2100      	movs	r1, #0
  qp->next->prev = qp;
 800266e:	6053      	str	r3, [r2, #4]
 8002670:	6281      	str	r1, [r0, #40]	; 0x28
    (void) chSchReadyI(tp);
 8002672:	f7ff b9d5 	b.w	8001a20 <chSchReadyI>
  }
}
 8002676:	4770      	bx	lr
	...

08002680 <chCondBroadcast>:
 *
 * @param[in] cp        pointer to the @p condition_variable_t structure
 *
 * @api
 */
void chCondBroadcast(condition_variable_t *cp) {
 8002680:	b538      	push	{r3, r4, r5, lr}
 8002682:	2330      	movs	r3, #48	; 0x30
 8002684:	f383 8811 	msr	BASEPRI, r3
  return (bool)(qp->next != qp);
 8002688:	6803      	ldr	r3, [r0, #0]
  chDbgCheck(cp != NULL);

  /* Empties the condition variable queue and inserts all the threads into the
     ready list in FIFO order. The wakeup message is set to @p MSG_RESET in
     order to make a chCondBroadcast() detectable from a chCondSignal().*/
  while (ch_queue_notempty(&cp->queue)) {
 800268a:	4298      	cmp	r0, r3
 800268c:	d00c      	beq.n	80026a8 <chCondBroadcast+0x28>
 800268e:	4604      	mov	r4, r0
    chSchReadyI(threadref(ch_queue_fifo_remove(&cp->queue)))->u.rdymsg = MSG_RESET;
 8002690:	f06f 0501 	mvn.w	r5, #1
  qp->next       = p->next;
 8002694:	681a      	ldr	r2, [r3, #0]
 8002696:	6022      	str	r2, [r4, #0]
 8002698:	4618      	mov	r0, r3
  qp->next->prev = qp;
 800269a:	6054      	str	r4, [r2, #4]
 800269c:	f7ff f9c0 	bl	8001a20 <chSchReadyI>
  return (bool)(qp->next != qp);
 80026a0:	6823      	ldr	r3, [r4, #0]
 80026a2:	6285      	str	r5, [r0, #40]	; 0x28
  while (ch_queue_notempty(&cp->queue)) {
 80026a4:	42a3      	cmp	r3, r4
 80026a6:	d1f5      	bne.n	8002694 <chCondBroadcast+0x14>
  chSchRescheduleS();
 80026a8:	f7ff fa7a 	bl	8001ba0 <chSchRescheduleS>
 80026ac:	2300      	movs	r3, #0
 80026ae:	f383 8811 	msr	BASEPRI, r3
}
 80026b2:	bd38      	pop	{r3, r4, r5, pc}
	...

080026c0 <chCondWaitS>:
 80026c0:	4b0f      	ldr	r3, [pc, #60]	; (8002700 <chCondWaitS+0x40>)
 * @retval MSG_RESET    if the condition variable has been signaled using
 *                      @p chCondBroadcast().
 *
 * @sclass
 */
msg_t chCondWaitS(condition_variable_t *cp) {
 80026c2:	b570      	push	{r4, r5, r6, lr}
 80026c4:	68dc      	ldr	r4, [r3, #12]
 *
 * @xclass
 */
static inline mutex_t *chMtxGetNextMutexX(void) {

  return chThdGetSelfX()->mtxlist;
 80026c6:	6be6      	ldr	r6, [r4, #60]	; 0x3c
 80026c8:	4605      	mov	r5, r0
  chDbgCheckClassS();
  chDbgCheck(cp != NULL);
  chDbgAssert(mp != NULL, "not owning a mutex");

  /* Releasing "current" mutex.*/
  chMtxUnlockS(mp);
 80026ca:	4630      	mov	r0, r6
 80026cc:	f7ff ff48 	bl	8002560 <chMtxUnlockS>

  /* Start waiting on the condition variable, on exit the mutex is taken
     again.*/
  currtp->u.wtobjp = cp;
 80026d0:	62a5      	str	r5, [r4, #40]	; 0x28
  ch_queue_t *cp = qp;
 80026d2:	462b      	mov	r3, r5
 80026d4:	e003      	b.n	80026de <chCondWaitS+0x1e>
  } while ((cp != qp) &&
 80026d6:	6899      	ldr	r1, [r3, #8]
 80026d8:	68a2      	ldr	r2, [r4, #8]
 80026da:	4291      	cmp	r1, r2
 80026dc:	d302      	bcc.n	80026e4 <chCondWaitS+0x24>
    cp = cp->next;
 80026de:	681b      	ldr	r3, [r3, #0]
           (threadref(cp)->hdr.pqueue.prio >= threadref(tp)->hdr.pqueue.prio));
 80026e0:	429d      	cmp	r5, r3
 80026e2:	d1f8      	bne.n	80026d6 <chCondWaitS+0x16>
  tp->prev       = cp->prev;
 80026e4:	685a      	ldr	r2, [r3, #4]
  ch_sch_prio_insert(&cp->queue, &currtp->hdr.queue);
  chSchGoSleepS(CH_STATE_WTCOND);
 80026e6:	2007      	movs	r0, #7
 80026e8:	e9c4 3200 	strd	r3, r2, [r4]
  tp->prev->next = tp;
 80026ec:	6014      	str	r4, [r2, #0]
  cp->prev       = tp;
 80026ee:	605c      	str	r4, [r3, #4]
 80026f0:	f7ff f9a6 	bl	8001a40 <chSchGoSleepS>
  msg = currtp->u.rdymsg;
 80026f4:	6aa4      	ldr	r4, [r4, #40]	; 0x28
  chMtxLockS(mp);
 80026f6:	4630      	mov	r0, r6
 80026f8:	f7ff fe6a 	bl	80023d0 <chMtxLockS>

  return msg;
}
 80026fc:	4620      	mov	r0, r4
 80026fe:	bd70      	pop	{r4, r5, r6, pc}
 8002700:	20000a40 	.word	0x20000a40
	...

08002710 <chCondWait>:
msg_t chCondWait(condition_variable_t *cp) {
 8002710:	b508      	push	{r3, lr}
 8002712:	2330      	movs	r3, #48	; 0x30
 8002714:	f383 8811 	msr	BASEPRI, r3
  msg = chCondWaitS(cp);
 8002718:	f7ff ffd2 	bl	80026c0 <chCondWaitS>
 800271c:	2300      	movs	r3, #0
 800271e:	f383 8811 	msr	BASEPRI, r3
}
 8002722:	bd08      	pop	{r3, pc}
	...

08002730 <chCondWaitTimeoutS>:
 * @retval MSG_TIMEOUT  if the condition variable has not been signaled within
 *                      the specified timeout.
 *
 * @sclass
 */
msg_t chCondWaitTimeoutS(condition_variable_t *cp, sysinterval_t timeout) {
 8002730:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8002732:	4b11      	ldr	r3, [pc, #68]	; (8002778 <chCondWaitTimeoutS+0x48>)
 8002734:	68dc      	ldr	r4, [r3, #12]
 8002736:	6be6      	ldr	r6, [r4, #60]	; 0x3c
 8002738:	4605      	mov	r5, r0
  chDbgCheckClassS();
  chDbgCheck((cp != NULL) && (timeout != TIME_IMMEDIATE));
  chDbgAssert(mp != NULL, "not owning a mutex");

  /* Releasing "current" mutex.*/
  chMtxUnlockS(mp);
 800273a:	4630      	mov	r0, r6
msg_t chCondWaitTimeoutS(condition_variable_t *cp, sysinterval_t timeout) {
 800273c:	460f      	mov	r7, r1
  chMtxUnlockS(mp);
 800273e:	f7ff ff0f 	bl	8002560 <chMtxUnlockS>

  /* Start waiting on the condition variable, on exit the mutex is taken
     again.*/
  currtp->u.wtobjp = cp;
 8002742:	62a5      	str	r5, [r4, #40]	; 0x28
  ch_queue_t *cp = qp;
 8002744:	462b      	mov	r3, r5
 8002746:	e003      	b.n	8002750 <chCondWaitTimeoutS+0x20>
  } while ((cp != qp) &&
 8002748:	68a2      	ldr	r2, [r4, #8]
 800274a:	6899      	ldr	r1, [r3, #8]
 800274c:	4291      	cmp	r1, r2
 800274e:	d302      	bcc.n	8002756 <chCondWaitTimeoutS+0x26>
    cp = cp->next;
 8002750:	681b      	ldr	r3, [r3, #0]
           (threadref(cp)->hdr.pqueue.prio >= threadref(tp)->hdr.pqueue.prio));
 8002752:	429d      	cmp	r5, r3
 8002754:	d1f8      	bne.n	8002748 <chCondWaitTimeoutS+0x18>
  tp->prev       = cp->prev;
 8002756:	685a      	ldr	r2, [r3, #4]
  ch_sch_prio_insert(&cp->queue, &currtp->hdr.queue);
  msg = chSchGoSleepTimeoutS(CH_STATE_WTCOND, timeout);
 8002758:	4639      	mov	r1, r7
 800275a:	e9c4 3200 	strd	r3, r2, [r4]
 800275e:	2007      	movs	r0, #7
  tp->prev->next = tp;
 8002760:	6014      	str	r4, [r2, #0]
  cp->prev       = tp;
 8002762:	605c      	str	r4, [r3, #4]
 8002764:	f7ff f984 	bl	8001a70 <chSchGoSleepTimeoutS>
  if (msg != MSG_TIMEOUT) {
 8002768:	1c43      	adds	r3, r0, #1
  msg = chSchGoSleepTimeoutS(CH_STATE_WTCOND, timeout);
 800276a:	4604      	mov	r4, r0
  if (msg != MSG_TIMEOUT) {
 800276c:	d002      	beq.n	8002774 <chCondWaitTimeoutS+0x44>
    chMtxLockS(mp);
 800276e:	4630      	mov	r0, r6
 8002770:	f7ff fe2e 	bl	80023d0 <chMtxLockS>
  }

  return msg;
}
 8002774:	4620      	mov	r0, r4
 8002776:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8002778:	20000a40 	.word	0x20000a40
 800277c:	00000000 	.word	0x00000000

08002780 <chCondWaitTimeout>:
msg_t chCondWaitTimeout(condition_variable_t *cp, sysinterval_t timeout) {
 8002780:	b508      	push	{r3, lr}
 8002782:	2330      	movs	r3, #48	; 0x30
 8002784:	f383 8811 	msr	BASEPRI, r3
  msg = chCondWaitTimeoutS(cp, timeout);
 8002788:	f7ff ffd2 	bl	8002730 <chCondWaitTimeoutS>
 800278c:	2300      	movs	r3, #0
 800278e:	f383 8811 	msr	BASEPRI, r3
}
 8002792:	bd08      	pop	{r3, pc}
	...

080027a0 <chEvtRegisterMaskWithFlags>:
 * @api
 */
void chEvtRegisterMaskWithFlags(event_source_t *esp,
                                event_listener_t *elp,
                                eventmask_t events,
                                eventflags_t wflags) {
 80027a0:	b410      	push	{r4}
 80027a2:	2430      	movs	r4, #48	; 0x30
 80027a4:	f384 8811 	msr	BASEPRI, r4
 80027a8:	4c07      	ldr	r4, [pc, #28]	; (80027c8 <chEvtRegisterMaskWithFlags+0x28>)
  elp->next     = esp->next;
 80027aa:	f8d0 c000 	ldr.w	ip, [r0]
 80027ae:	68e4      	ldr	r4, [r4, #12]
 80027b0:	f8c1 c000 	str.w	ip, [r1]
  esp->next     = elp;
 80027b4:	6001      	str	r1, [r0, #0]
  elp->flags    = (eventflags_t)0;
 80027b6:	2000      	movs	r0, #0
  elp->events   = events;
 80027b8:	e9c1 4201 	strd	r4, r2, [r1, #4]
  elp->wflags   = wflags;
 80027bc:	e9c1 0303 	strd	r0, r3, [r1, #12]
 80027c0:	f380 8811 	msr	BASEPRI, r0

  chSysLock();
  chEvtRegisterMaskWithFlagsI(esp, elp, events, wflags);
  chSysUnlock();
}
 80027c4:	bc10      	pop	{r4}
 80027c6:	4770      	bx	lr
 80027c8:	20000a40 	.word	0x20000a40
 80027cc:	00000000 	.word	0x00000000

080027d0 <chEvtUnregister>:
 80027d0:	2330      	movs	r3, #48	; 0x30
 80027d2:	f383 8811 	msr	BASEPRI, r3
  event_listener_t *p;

  chDbgCheck((esp != NULL) && (elp != NULL));

  /*lint -save -e9087 -e740 [11.3, 1.3] Cast required by list handling.*/
  p = (event_listener_t *)esp;
 80027d6:	4603      	mov	r3, r0
static inline void chSysLock(void) {

  port_lock();
  __stats_start_measure_crit_thd();
  __dbg_check_lock();
}
 80027d8:	e001      	b.n	80027de <chEvtUnregister+0xe>
  /*lint -restore*/
  chSysLock();
  /*lint -save -e9087 -e740 [11.3, 1.3] Cast required by list handling.*/
  while (p->next != (event_listener_t *)esp) {
  /*lint -restore*/
    if (p->next == elp) {
 80027da:	428b      	cmp	r3, r1
 80027dc:	d007      	beq.n	80027ee <chEvtUnregister+0x1e>
  while (p->next != (event_listener_t *)esp) {
 80027de:	461a      	mov	r2, r3
 80027e0:	681b      	ldr	r3, [r3, #0]
 80027e2:	4298      	cmp	r0, r3
 80027e4:	d1f9      	bne.n	80027da <chEvtUnregister+0xa>
 80027e6:	2300      	movs	r3, #0
 80027e8:	f383 8811 	msr	BASEPRI, r3
      break;
    }
    p = p->next;
  }
  chSysUnlock();
}
 80027ec:	4770      	bx	lr
      p->next = elp->next;
 80027ee:	681b      	ldr	r3, [r3, #0]
 80027f0:	6013      	str	r3, [r2, #0]
 80027f2:	2300      	movs	r3, #0
 80027f4:	f383 8811 	msr	BASEPRI, r3
}
 80027f8:	4770      	bx	lr
 80027fa:	bf00      	nop
 80027fc:	0000      	movs	r0, r0
	...

08002800 <chEvtGetAndClearEvents>:
 * @param[in] events    the events to be cleared
 * @return              The mask of pending events that were cleared.
 *
 * @api
 */
eventmask_t chEvtGetAndClearEvents(eventmask_t events) {
 8002800:	b410      	push	{r4}
 8002802:	2330      	movs	r3, #48	; 0x30
 8002804:	f383 8811 	msr	BASEPRI, r3
 8002808:	4b05      	ldr	r3, [pc, #20]	; (8002820 <chEvtGetAndClearEvents+0x20>)
 800280a:	68da      	ldr	r2, [r3, #12]
  m = currtp->epending & events;
 800280c:	6b93      	ldr	r3, [r2, #56]	; 0x38
  currtp->epending &= ~events;
 800280e:	ea23 0400 	bic.w	r4, r3, r0
 8002812:	2100      	movs	r1, #0
 8002814:	6394      	str	r4, [r2, #56]	; 0x38
 8002816:	f381 8811 	msr	BASEPRI, r1
  chSysLock();
  m = chEvtGetAndClearEventsI(events);
  chSysUnlock();

  return m;
}
 800281a:	4018      	ands	r0, r3
 800281c:	bc10      	pop	{r4}
 800281e:	4770      	bx	lr
 8002820:	20000a40 	.word	0x20000a40
	...

08002830 <chEvtAddEvents>:
 8002830:	2330      	movs	r3, #48	; 0x30
 8002832:	f383 8811 	msr	BASEPRI, r3
 *
 * @iclass
 */
static inline eventmask_t chEvtAddEventsI(eventmask_t events) {

  return __sch_get_currthread()->epending |= events;
 8002836:	4b04      	ldr	r3, [pc, #16]	; (8002848 <chEvtAddEvents+0x18>)
 8002838:	68db      	ldr	r3, [r3, #12]
 800283a:	6b99      	ldr	r1, [r3, #56]	; 0x38
 800283c:	4308      	orrs	r0, r1
 800283e:	2200      	movs	r2, #0
 8002840:	6398      	str	r0, [r3, #56]	; 0x38
 8002842:	f382 8811 	msr	BASEPRI, r2
  chSysLock();
  newevt = chEvtAddEventsI(events);
  chSysUnlock();

  return newevt;
}
 8002846:	4770      	bx	lr
 8002848:	20000a40 	.word	0x20000a40
 800284c:	00000000 	.word	0x00000000

08002850 <chEvtSignal>:
 * @param[in] tp        the thread to be signaled
 * @param[in] events    the events set to be ORed
 *
 * @api
 */
void chEvtSignal(thread_t *tp, eventmask_t events) {
 8002850:	b508      	push	{r3, lr}
 8002852:	2330      	movs	r3, #48	; 0x30
 8002854:	f383 8811 	msr	BASEPRI, r3
  tp->epending |= events;
 8002858:	6b82      	ldr	r2, [r0, #56]	; 0x38
  if (((tp->state == CH_STATE_WTOREVT) &&
 800285a:	f890 3024 	ldrb.w	r3, [r0, #36]	; 0x24
  tp->epending |= events;
 800285e:	4311      	orrs	r1, r2
  if (((tp->state == CH_STATE_WTOREVT) &&
 8002860:	2b0a      	cmp	r3, #10
  tp->epending |= events;
 8002862:	6381      	str	r1, [r0, #56]	; 0x38
  if (((tp->state == CH_STATE_WTOREVT) &&
 8002864:	d014      	beq.n	8002890 <chEvtSignal+0x40>
       ((tp->epending & tp->u.ewmask) != (eventmask_t)0)) ||
 8002866:	2b0b      	cmp	r3, #11
 8002868:	d005      	beq.n	8002876 <chEvtSignal+0x26>

  chDbgCheck(tp != NULL);

  chSysLock();
  chEvtSignalI(tp, events);
  chSchRescheduleS();
 800286a:	f7ff f999 	bl	8001ba0 <chSchRescheduleS>
 800286e:	2300      	movs	r3, #0
 8002870:	f383 8811 	msr	BASEPRI, r3
  chSysUnlock();
}
 8002874:	bd08      	pop	{r3, pc}
       ((tp->epending & tp->u.ewmask) == tp->u.ewmask))) {
 8002876:	6a83      	ldr	r3, [r0, #40]	; 0x28
      ((tp->state == CH_STATE_WTANDEVT) &&
 8002878:	438b      	bics	r3, r1
 800287a:	d1f6      	bne.n	800286a <chEvtSignal+0x1a>
    tp->u.rdymsg = MSG_OK;
 800287c:	2300      	movs	r3, #0
 800287e:	6283      	str	r3, [r0, #40]	; 0x28
    (void) chSchReadyI(tp);
 8002880:	f7ff f8ce 	bl	8001a20 <chSchReadyI>
  chSchRescheduleS();
 8002884:	f7ff f98c 	bl	8001ba0 <chSchRescheduleS>
 8002888:	2300      	movs	r3, #0
 800288a:	f383 8811 	msr	BASEPRI, r3
}
 800288e:	bd08      	pop	{r3, pc}
       ((tp->epending & tp->u.ewmask) != (eventmask_t)0)) ||
 8002890:	6a83      	ldr	r3, [r0, #40]	; 0x28
  if (((tp->state == CH_STATE_WTOREVT) &&
 8002892:	4219      	tst	r1, r3
 8002894:	d0e9      	beq.n	800286a <chEvtSignal+0x1a>
    tp->u.rdymsg = MSG_OK;
 8002896:	2300      	movs	r3, #0
 8002898:	6283      	str	r3, [r0, #40]	; 0x28
    (void) chSchReadyI(tp);
 800289a:	f7ff f8c1 	bl	8001a20 <chSchReadyI>
 800289e:	e7f1      	b.n	8002884 <chEvtSignal+0x34>

080028a0 <chEvtBroadcastFlagsI>:
 * @param[in] esp       pointer to the @p event_source_t structure
 * @param[in] flags     the flags set to be added to the listener flags mask
 *
 * @iclass
 */
void chEvtBroadcastFlagsI(event_source_t *esp, eventflags_t flags) {
 80028a0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  event_listener_t *elp;

  chDbgCheckClassI();
  chDbgCheck(esp != NULL);

  elp = esp->next;
 80028a2:	6804      	ldr	r4, [r0, #0]
  /*lint -save -e9087 -e740 [11.3, 1.3] Cast required by list handling.*/
  while (elp != (event_listener_t *)esp) {
 80028a4:	42a0      	cmp	r0, r4
 80028a6:	d021      	beq.n	80028ec <chEvtBroadcastFlagsI+0x4c>
 80028a8:	4607      	mov	r7, r0
 80028aa:	460d      	mov	r5, r1
    tp->u.rdymsg = MSG_OK;
 80028ac:	2600      	movs	r6, #0
 80028ae:	e004      	b.n	80028ba <chEvtBroadcastFlagsI+0x1a>
       ((tp->epending & tp->u.ewmask) != (eventmask_t)0)) ||
 80028b0:	2a0b      	cmp	r2, #11
 80028b2:	d01c      	beq.n	80028ee <chEvtBroadcastFlagsI+0x4e>
       source does not emit any flag.*/
    if ((flags == (eventflags_t)0) ||
        ((flags & elp->wflags) != (eventflags_t)0)) {
      chEvtSignalI(elp->listener, elp->events);
    }
    elp = elp->next;
 80028b4:	6824      	ldr	r4, [r4, #0]
  while (elp != (event_listener_t *)esp) {
 80028b6:	42a7      	cmp	r7, r4
 80028b8:	d018      	beq.n	80028ec <chEvtBroadcastFlagsI+0x4c>
    elp->flags |= flags;
 80028ba:	68e3      	ldr	r3, [r4, #12]
 80028bc:	432b      	orrs	r3, r5
 80028be:	60e3      	str	r3, [r4, #12]
    if ((flags == (eventflags_t)0) ||
 80028c0:	b115      	cbz	r5, 80028c8 <chEvtBroadcastFlagsI+0x28>
        ((flags & elp->wflags) != (eventflags_t)0)) {
 80028c2:	6923      	ldr	r3, [r4, #16]
    if ((flags == (eventflags_t)0) ||
 80028c4:	421d      	tst	r5, r3
 80028c6:	d0f5      	beq.n	80028b4 <chEvtBroadcastFlagsI+0x14>
  tp->epending |= events;
 80028c8:	e9d4 0301 	ldrd	r0, r3, [r4, #4]
 80028cc:	6b81      	ldr	r1, [r0, #56]	; 0x38
  if (((tp->state == CH_STATE_WTOREVT) &&
 80028ce:	f890 2024 	ldrb.w	r2, [r0, #36]	; 0x24
  tp->epending |= events;
 80028d2:	430b      	orrs	r3, r1
  if (((tp->state == CH_STATE_WTOREVT) &&
 80028d4:	2a0a      	cmp	r2, #10
  tp->epending |= events;
 80028d6:	6383      	str	r3, [r0, #56]	; 0x38
  if (((tp->state == CH_STATE_WTOREVT) &&
 80028d8:	d1ea      	bne.n	80028b0 <chEvtBroadcastFlagsI+0x10>
       ((tp->epending & tp->u.ewmask) != (eventmask_t)0)) ||
 80028da:	6a82      	ldr	r2, [r0, #40]	; 0x28
  if (((tp->state == CH_STATE_WTOREVT) &&
 80028dc:	4213      	tst	r3, r2
 80028de:	d0e9      	beq.n	80028b4 <chEvtBroadcastFlagsI+0x14>
    tp->u.rdymsg = MSG_OK;
 80028e0:	6286      	str	r6, [r0, #40]	; 0x28
    (void) chSchReadyI(tp);
 80028e2:	f7ff f89d 	bl	8001a20 <chSchReadyI>
    elp = elp->next;
 80028e6:	6824      	ldr	r4, [r4, #0]
  while (elp != (event_listener_t *)esp) {
 80028e8:	42a7      	cmp	r7, r4
 80028ea:	d1e6      	bne.n	80028ba <chEvtBroadcastFlagsI+0x1a>
  }
}
 80028ec:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
       ((tp->epending & tp->u.ewmask) == tp->u.ewmask))) {
 80028ee:	6a82      	ldr	r2, [r0, #40]	; 0x28
      ((tp->state == CH_STATE_WTANDEVT) &&
 80028f0:	ea32 0303 	bics.w	r3, r2, r3
 80028f4:	d1de      	bne.n	80028b4 <chEvtBroadcastFlagsI+0x14>
 80028f6:	e7f3      	b.n	80028e0 <chEvtBroadcastFlagsI+0x40>
	...

08002900 <chEvtBroadcastFlags>:
 * @param[in] esp       pointer to the @p event_source_t structure
 * @param[in] flags     the flags set to be added to the listener flags mask
 *
 * @api
 */
void chEvtBroadcastFlags(event_source_t *esp, eventflags_t flags) {
 8002900:	b508      	push	{r3, lr}
 8002902:	2330      	movs	r3, #48	; 0x30
 8002904:	f383 8811 	msr	BASEPRI, r3

  chSysLock();
  chEvtBroadcastFlagsI(esp, flags);
 8002908:	f7ff ffca 	bl	80028a0 <chEvtBroadcastFlagsI>
  chSchRescheduleS();
 800290c:	f7ff f948 	bl	8001ba0 <chSchRescheduleS>
 8002910:	2300      	movs	r3, #0
 8002912:	f383 8811 	msr	BASEPRI, r3
  chSysUnlock();
}
 8002916:	bd08      	pop	{r3, pc}
	...

08002920 <chEvtDispatch>:
  eventid_t eid;

  chDbgCheck(handlers != NULL);

  eid = (eventid_t)0;
  while (events != (eventmask_t)0) {
 8002920:	b1b9      	cbz	r1, 8002952 <chEvtDispatch+0x32>
void chEvtDispatch(const evhandler_t *handlers, eventmask_t events) {
 8002922:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8002924:	4607      	mov	r7, r0
 8002926:	460d      	mov	r5, r1
  eid = (eventid_t)0;
 8002928:	2400      	movs	r4, #0
    if ((events & EVENT_MASK(eid)) != (eventmask_t)0) {
      chDbgAssert(handlers[eid] != NULL, "null handler");
      events &= ~EVENT_MASK(eid);
 800292a:	2601      	movs	r6, #1
    if ((events & EVENT_MASK(eid)) != (eventmask_t)0) {
 800292c:	fa25 f304 	lsr.w	r3, r5, r4
 8002930:	f013 0f01 	tst.w	r3, #1
      events &= ~EVENT_MASK(eid);
 8002934:	fa06 f204 	lsl.w	r2, r6, r4
      handlers[eid](eid);
 8002938:	4620      	mov	r0, r4
    if ((events & EVENT_MASK(eid)) != (eventmask_t)0) {
 800293a:	d008      	beq.n	800294e <chEvtDispatch+0x2e>
      handlers[eid](eid);
 800293c:	f857 3024 	ldr.w	r3, [r7, r4, lsl #2]
      events &= ~EVENT_MASK(eid);
 8002940:	ea25 0502 	bic.w	r5, r5, r2
    }
    eid++;
 8002944:	3401      	adds	r4, #1
      handlers[eid](eid);
 8002946:	4798      	blx	r3
  while (events != (eventmask_t)0) {
 8002948:	2d00      	cmp	r5, #0
 800294a:	d1ef      	bne.n	800292c <chEvtDispatch+0xc>
  }
}
 800294c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    eid++;
 800294e:	3401      	adds	r4, #1
  while (events != (eventmask_t)0) {
 8002950:	e7ec      	b.n	800292c <chEvtDispatch+0xc>
 8002952:	4770      	bx	lr
	...

08002960 <chEvtWaitOne>:
 *                      for, @p ALL_EVENTS enables all the events
 * @return              The mask of the lowest event id served and cleared.
 *
 * @api
 */
eventmask_t chEvtWaitOne(eventmask_t events) {
 8002960:	b538      	push	{r3, r4, r5, lr}
 8002962:	4b0d      	ldr	r3, [pc, #52]	; (8002998 <chEvtWaitOne+0x38>)
 8002964:	68dd      	ldr	r5, [r3, #12]
 8002966:	2330      	movs	r3, #48	; 0x30
 8002968:	f383 8811 	msr	BASEPRI, r3
  thread_t *currtp = chThdGetSelfX();
  eventmask_t m;

  chSysLock();
  m = currtp->epending & events;
 800296c:	6bab      	ldr	r3, [r5, #56]	; 0x38
  if (m == (eventmask_t)0) {
 800296e:	ea13 0200 	ands.w	r2, r3, r0
 8002972:	d008      	beq.n	8002986 <chEvtWaitOne+0x26>
    currtp->u.ewmask = events;
    chSchGoSleepS(CH_STATE_WTOREVT);
    m = currtp->epending & events;
  }
  m ^= m & (m - (eventmask_t)1);
 8002974:	4250      	negs	r0, r2
 8002976:	4010      	ands	r0, r2
  currtp->epending &= ~m;
 8002978:	ea23 0300 	bic.w	r3, r3, r0
 800297c:	63ab      	str	r3, [r5, #56]	; 0x38
 800297e:	2300      	movs	r3, #0
 8002980:	f383 8811 	msr	BASEPRI, r3
  chSysUnlock();

  return m;
}
 8002984:	bd38      	pop	{r3, r4, r5, pc}
 8002986:	4604      	mov	r4, r0
    currtp->u.ewmask = events;
 8002988:	62a8      	str	r0, [r5, #40]	; 0x28
    chSchGoSleepS(CH_STATE_WTOREVT);
 800298a:	200a      	movs	r0, #10
 800298c:	f7ff f858 	bl	8001a40 <chSchGoSleepS>
    m = currtp->epending & events;
 8002990:	6bab      	ldr	r3, [r5, #56]	; 0x38
 8002992:	ea03 0204 	and.w	r2, r3, r4
 8002996:	e7ed      	b.n	8002974 <chEvtWaitOne+0x14>
 8002998:	20000a40 	.word	0x20000a40
 800299c:	00000000 	.word	0x00000000

080029a0 <chEvtWaitAny>:
 *                      for, @p ALL_EVENTS enables all the events
 * @return              The mask of the served and cleared events.
 *
 * @api
 */
eventmask_t chEvtWaitAny(eventmask_t events) {
 80029a0:	b538      	push	{r3, r4, r5, lr}
 80029a2:	4b0c      	ldr	r3, [pc, #48]	; (80029d4 <chEvtWaitAny+0x34>)
 80029a4:	4604      	mov	r4, r0
 80029a6:	68dd      	ldr	r5, [r3, #12]
 80029a8:	2330      	movs	r3, #48	; 0x30
 80029aa:	f383 8811 	msr	BASEPRI, r3
  thread_t *currtp = chThdGetSelfX();
  eventmask_t m;

  chSysLock();
  m = currtp->epending & events;
 80029ae:	6bab      	ldr	r3, [r5, #56]	; 0x38
  if (m == (eventmask_t)0) {
 80029b0:	4018      	ands	r0, r3
 80029b2:	d006      	beq.n	80029c2 <chEvtWaitAny+0x22>
    currtp->u.ewmask = events;
    chSchGoSleepS(CH_STATE_WTOREVT);
    m = currtp->epending & events;
  }
  currtp->epending &= ~m;
 80029b4:	ea23 0300 	bic.w	r3, r3, r0
 80029b8:	63ab      	str	r3, [r5, #56]	; 0x38
 80029ba:	2300      	movs	r3, #0
 80029bc:	f383 8811 	msr	BASEPRI, r3
  chSysUnlock();

  return m;
}
 80029c0:	bd38      	pop	{r3, r4, r5, pc}
    chSchGoSleepS(CH_STATE_WTOREVT);
 80029c2:	200a      	movs	r0, #10
    currtp->u.ewmask = events;
 80029c4:	62ac      	str	r4, [r5, #40]	; 0x28
    chSchGoSleepS(CH_STATE_WTOREVT);
 80029c6:	f7ff f83b 	bl	8001a40 <chSchGoSleepS>
    m = currtp->epending & events;
 80029ca:	6bab      	ldr	r3, [r5, #56]	; 0x38
 80029cc:	ea03 0004 	and.w	r0, r3, r4
 80029d0:	e7f0      	b.n	80029b4 <chEvtWaitAny+0x14>
 80029d2:	bf00      	nop
 80029d4:	20000a40 	.word	0x20000a40
	...

080029e0 <chEvtWaitAll>:
 *                      for, @p ALL_EVENTS requires all the events
 * @return              The mask of the served and cleared events.
 *
 * @api
 */
eventmask_t chEvtWaitAll(eventmask_t events) {
 80029e0:	b538      	push	{r3, r4, r5, lr}
 80029e2:	4b0b      	ldr	r3, [pc, #44]	; (8002a10 <chEvtWaitAll+0x30>)
 80029e4:	4604      	mov	r4, r0
 80029e6:	68dd      	ldr	r5, [r3, #12]
 80029e8:	2330      	movs	r3, #48	; 0x30
 80029ea:	f383 8811 	msr	BASEPRI, r3
  thread_t *currtp = chThdGetSelfX();

  chSysLock();
  if ((currtp->epending & events) != events) {
 80029ee:	6bab      	ldr	r3, [r5, #56]	; 0x38
 80029f0:	ea30 0203 	bics.w	r2, r0, r3
 80029f4:	d004      	beq.n	8002a00 <chEvtWaitAll+0x20>
    currtp->u.ewmask = events;
 80029f6:	62a8      	str	r0, [r5, #40]	; 0x28
    chSchGoSleepS(CH_STATE_WTANDEVT);
 80029f8:	200b      	movs	r0, #11
 80029fa:	f7ff f821 	bl	8001a40 <chSchGoSleepS>
  }
  currtp->epending &= ~events;
 80029fe:	6bab      	ldr	r3, [r5, #56]	; 0x38
 8002a00:	ea23 0304 	bic.w	r3, r3, r4
 8002a04:	63ab      	str	r3, [r5, #56]	; 0x38
 8002a06:	2300      	movs	r3, #0
 8002a08:	f383 8811 	msr	BASEPRI, r3
  chSysUnlock();

  return events;
}
 8002a0c:	4620      	mov	r0, r4
 8002a0e:	bd38      	pop	{r3, r4, r5, pc}
 8002a10:	20000a40 	.word	0x20000a40
	...

08002a20 <chEvtWaitOneTimeout>:
 8002a20:	4b11      	ldr	r3, [pc, #68]	; (8002a68 <chEvtWaitOneTimeout+0x48>)
 * @return              The mask of the lowest event id served and cleared.
 * @retval 0            if the operation has timed out.
 *
 * @api
 */
eventmask_t chEvtWaitOneTimeout(eventmask_t events, sysinterval_t timeout) {
 8002a22:	b570      	push	{r4, r5, r6, lr}
 8002a24:	68de      	ldr	r6, [r3, #12]
 8002a26:	2330      	movs	r3, #48	; 0x30
 8002a28:	f383 8811 	msr	BASEPRI, r3
  thread_t *currtp = chThdGetSelfX();
  eventmask_t m;

  chSysLock();
  m = currtp->epending & events;
 8002a2c:	6bb3      	ldr	r3, [r6, #56]	; 0x38
  if (m == (eventmask_t)0) {
 8002a2e:	ea13 0500 	ands.w	r5, r3, r0
 8002a32:	d10e      	bne.n	8002a52 <chEvtWaitOneTimeout+0x32>
    if (TIME_IMMEDIATE == timeout) {
 8002a34:	b919      	cbnz	r1, 8002a3e <chEvtWaitOneTimeout+0x1e>
 8002a36:	f385 8811 	msr	BASEPRI, r5
  m ^= m & (m - (eventmask_t)1);
  currtp->epending &= ~m;
  chSysUnlock();

  return m;
}
 8002a3a:	4628      	mov	r0, r5
 8002a3c:	bd70      	pop	{r4, r5, r6, pc}
    currtp->u.ewmask = events;
 8002a3e:	62b0      	str	r0, [r6, #40]	; 0x28
    if (chSchGoSleepTimeoutS(CH_STATE_WTOREVT, timeout) < MSG_OK) {
 8002a40:	4604      	mov	r4, r0
 8002a42:	200a      	movs	r0, #10
 8002a44:	f7ff f814 	bl	8001a70 <chSchGoSleepTimeoutS>
 8002a48:	2800      	cmp	r0, #0
 8002a4a:	dbf4      	blt.n	8002a36 <chEvtWaitOneTimeout+0x16>
    m = currtp->epending & events;
 8002a4c:	6bb3      	ldr	r3, [r6, #56]	; 0x38
 8002a4e:	ea03 0504 	and.w	r5, r3, r4
  m ^= m & (m - (eventmask_t)1);
 8002a52:	426a      	negs	r2, r5
 8002a54:	4015      	ands	r5, r2
  currtp->epending &= ~m;
 8002a56:	ea23 0305 	bic.w	r3, r3, r5
 8002a5a:	63b3      	str	r3, [r6, #56]	; 0x38
 8002a5c:	2300      	movs	r3, #0
 8002a5e:	f383 8811 	msr	BASEPRI, r3
}
 8002a62:	4628      	mov	r0, r5
 8002a64:	bd70      	pop	{r4, r5, r6, pc}
 8002a66:	bf00      	nop
 8002a68:	20000a40 	.word	0x20000a40
 8002a6c:	00000000 	.word	0x00000000

08002a70 <chEvtWaitAnyTimeout>:
 8002a70:	4b10      	ldr	r3, [pc, #64]	; (8002ab4 <chEvtWaitAnyTimeout+0x44>)
 * @return              The mask of the served and cleared events.
 * @retval 0            if the operation has timed out.
 *
 * @api
 */
eventmask_t chEvtWaitAnyTimeout(eventmask_t events, sysinterval_t timeout) {
 8002a72:	b570      	push	{r4, r5, r6, lr}
 8002a74:	68de      	ldr	r6, [r3, #12]
 8002a76:	2330      	movs	r3, #48	; 0x30
 8002a78:	f383 8811 	msr	BASEPRI, r3
  thread_t *currtp = chThdGetSelfX();
  eventmask_t m;

  chSysLock();
  m = currtp->epending & events;
 8002a7c:	6bb3      	ldr	r3, [r6, #56]	; 0x38
  if (m == (eventmask_t)0) {
 8002a7e:	ea13 0500 	ands.w	r5, r3, r0
 8002a82:	d10e      	bne.n	8002aa2 <chEvtWaitAnyTimeout+0x32>
    if (TIME_IMMEDIATE == timeout) {
 8002a84:	b919      	cbnz	r1, 8002a8e <chEvtWaitAnyTimeout+0x1e>
 8002a86:	f385 8811 	msr	BASEPRI, r5
  }
  currtp->epending &= ~m;
  chSysUnlock();

  return m;
}
 8002a8a:	4628      	mov	r0, r5
 8002a8c:	bd70      	pop	{r4, r5, r6, pc}
    currtp->u.ewmask = events;
 8002a8e:	62b0      	str	r0, [r6, #40]	; 0x28
    if (chSchGoSleepTimeoutS(CH_STATE_WTOREVT, timeout) < MSG_OK) {
 8002a90:	4604      	mov	r4, r0
 8002a92:	200a      	movs	r0, #10
 8002a94:	f7fe ffec 	bl	8001a70 <chSchGoSleepTimeoutS>
 8002a98:	2800      	cmp	r0, #0
 8002a9a:	dbf4      	blt.n	8002a86 <chEvtWaitAnyTimeout+0x16>
    m = currtp->epending & events;
 8002a9c:	6bb3      	ldr	r3, [r6, #56]	; 0x38
 8002a9e:	ea03 0504 	and.w	r5, r3, r4
  currtp->epending &= ~m;
 8002aa2:	ea23 0305 	bic.w	r3, r3, r5
 8002aa6:	63b3      	str	r3, [r6, #56]	; 0x38
 8002aa8:	2300      	movs	r3, #0
 8002aaa:	f383 8811 	msr	BASEPRI, r3
}
 8002aae:	4628      	mov	r0, r5
 8002ab0:	bd70      	pop	{r4, r5, r6, pc}
 8002ab2:	bf00      	nop
 8002ab4:	20000a40 	.word	0x20000a40
	...

08002ac0 <chEvtWaitAllTimeout>:
 * @return              The mask of the served and cleared events.
 * @retval 0            if the operation has timed out.
 *
 * @api
 */
eventmask_t chEvtWaitAllTimeout(eventmask_t events, sysinterval_t timeout) {
 8002ac0:	b538      	push	{r3, r4, r5, lr}
 8002ac2:	4b10      	ldr	r3, [pc, #64]	; (8002b04 <chEvtWaitAllTimeout+0x44>)
 8002ac4:	4604      	mov	r4, r0
 8002ac6:	68dd      	ldr	r5, [r3, #12]
 8002ac8:	2330      	movs	r3, #48	; 0x30
 8002aca:	f383 8811 	msr	BASEPRI, r3
  thread_t *currtp = chThdGetSelfX();

  chSysLock();
  if ((currtp->epending & events) != events) {
 8002ace:	6bab      	ldr	r3, [r5, #56]	; 0x38
 8002ad0:	ea30 0203 	bics.w	r2, r0, r3
 8002ad4:	d00b      	beq.n	8002aee <chEvtWaitAllTimeout+0x2e>
    if (TIME_IMMEDIATE == timeout) {
 8002ad6:	4608      	mov	r0, r1
 8002ad8:	b911      	cbnz	r1, 8002ae0 <chEvtWaitAllTimeout+0x20>
 8002ada:	f380 8811 	msr	BASEPRI, r0
  }
  currtp->epending &= ~events;
  chSysUnlock();

  return events;
}
 8002ade:	bd38      	pop	{r3, r4, r5, pc}
    currtp->u.ewmask = events;
 8002ae0:	62ac      	str	r4, [r5, #40]	; 0x28
    if (chSchGoSleepTimeoutS(CH_STATE_WTANDEVT, timeout) < MSG_OK) {
 8002ae2:	200b      	movs	r0, #11
 8002ae4:	f7fe ffc4 	bl	8001a70 <chSchGoSleepTimeoutS>
 8002ae8:	2800      	cmp	r0, #0
 8002aea:	db08      	blt.n	8002afe <chEvtWaitAllTimeout+0x3e>
  currtp->epending &= ~events;
 8002aec:	6bab      	ldr	r3, [r5, #56]	; 0x38
 8002aee:	ea23 0304 	bic.w	r3, r3, r4
 8002af2:	63ab      	str	r3, [r5, #56]	; 0x38
 8002af4:	2300      	movs	r3, #0
 8002af6:	f383 8811 	msr	BASEPRI, r3
  return events;
 8002afa:	4620      	mov	r0, r4
}
 8002afc:	bd38      	pop	{r3, r4, r5, pc}
 8002afe:	2000      	movs	r0, #0
 8002b00:	e7eb      	b.n	8002ada <chEvtWaitAllTimeout+0x1a>
 8002b02:	bf00      	nop
 8002b04:	20000a40 	.word	0x20000a40
	...

08002b10 <chMsgSend>:
 * @param[in] msg       the message
 * @return              The answer message from @p chMsgRelease().
 *
 * @api
 */
msg_t chMsgSend(thread_t *tp, msg_t msg) {
 8002b10:	b538      	push	{r3, r4, r5, lr}
 8002b12:	4b0e      	ldr	r3, [pc, #56]	; (8002b4c <chMsgSend+0x3c>)
 8002b14:	2230      	movs	r2, #48	; 0x30
 8002b16:	68dc      	ldr	r4, [r3, #12]
 8002b18:	f382 8811 	msr	BASEPRI, r2
  p->prev       = qp->prev;
 8002b1c:	6b42      	ldr	r2, [r0, #52]	; 0x34
 8002b1e:	6062      	str	r2, [r4, #4]

  chDbgCheck(tp != NULL);

  chSysLock();
  currtp->u.sentmsg = msg;
  __ch_msg_insert(&tp->msgqueue, currtp);
 8002b20:	f100 0530 	add.w	r5, r0, #48	; 0x30
  p->next       = qp;
 8002b24:	6025      	str	r5, [r4, #0]
  currtp->u.sentmsg = msg;
 8002b26:	62a1      	str	r1, [r4, #40]	; 0x28
  p->prev->next = p;
 8002b28:	6014      	str	r4, [r2, #0]
  if (tp->state == CH_STATE_WTMSG) {
 8002b2a:	f890 2024 	ldrb.w	r2, [r0, #36]	; 0x24
  qp->prev      = p;
 8002b2e:	6344      	str	r4, [r0, #52]	; 0x34
 8002b30:	2a0e      	cmp	r2, #14
 8002b32:	d007      	beq.n	8002b44 <chMsgSend+0x34>
    (void) chSchReadyI(tp);
  }
  chSchGoSleepS(CH_STATE_SNDMSGQ);
 8002b34:	200c      	movs	r0, #12
 8002b36:	f7fe ff83 	bl	8001a40 <chSchGoSleepS>
  msg = currtp->u.rdymsg;
 8002b3a:	6aa0      	ldr	r0, [r4, #40]	; 0x28
 8002b3c:	2300      	movs	r3, #0
 8002b3e:	f383 8811 	msr	BASEPRI, r3
  chSysUnlock();

  return msg;
}
 8002b42:	bd38      	pop	{r3, r4, r5, pc}
    (void) chSchReadyI(tp);
 8002b44:	f7fe ff6c 	bl	8001a20 <chSchReadyI>
 8002b48:	e7f4      	b.n	8002b34 <chMsgSend+0x24>
 8002b4a:	bf00      	nop
 8002b4c:	20000a40 	.word	0x20000a40

08002b50 <chMsgWaitS>:
 *
 * @return              A pointer to the thread carrying the message.
 *
 * @sclass
 */
thread_t *chMsgWaitS(void) {
 8002b50:	b538      	push	{r3, r4, r5, lr}
 8002b52:	4b09      	ldr	r3, [pc, #36]	; (8002b78 <chMsgWaitS+0x28>)
 8002b54:	68dd      	ldr	r5, [r3, #12]
 */
static inline bool chMsgIsPendingI(thread_t *tp) {

  chDbgCheckClassI();

  return (bool)(tp->msgqueue.next != &tp->msgqueue);
 8002b56:	462c      	mov	r4, r5
 8002b58:	f854 0f30 	ldr.w	r0, [r4, #48]!
  thread_t *currtp = chThdGetSelfX();
  thread_t *tp;

  chDbgCheckClassS();

  if (!chMsgIsPendingI(currtp)) {
 8002b5c:	4284      	cmp	r4, r0
 8002b5e:	d006      	beq.n	8002b6e <chMsgWaitS+0x1e>
  qp->next       = p->next;
 8002b60:	6803      	ldr	r3, [r0, #0]
 8002b62:	632b      	str	r3, [r5, #48]	; 0x30
    chSchGoSleepS(CH_STATE_WTMSG);
  }
  tp = threadref(ch_queue_fifo_remove(&currtp->msgqueue));
  tp->state = CH_STATE_SNDMSG;
 8002b64:	220d      	movs	r2, #13
  qp->next->prev = qp;
 8002b66:	605c      	str	r4, [r3, #4]
 8002b68:	f880 2024 	strb.w	r2, [r0, #36]	; 0x24

  return tp;
}
 8002b6c:	bd38      	pop	{r3, r4, r5, pc}
    chSchGoSleepS(CH_STATE_WTMSG);
 8002b6e:	200e      	movs	r0, #14
 8002b70:	f7fe ff66 	bl	8001a40 <chSchGoSleepS>
  ch_queue_t *p = qp->next;
 8002b74:	6b28      	ldr	r0, [r5, #48]	; 0x30
 8002b76:	e7f3      	b.n	8002b60 <chMsgWaitS+0x10>
 8002b78:	20000a40 	.word	0x20000a40
 8002b7c:	00000000 	.word	0x00000000

08002b80 <chMsgRelease>:
 * @param[in] tp        pointer to the thread
 * @param[in] msg       message to be returned to the sender
 *
 * @api
 */
void chMsgRelease(thread_t *tp, msg_t msg) {
 8002b80:	b508      	push	{r3, lr}
 8002b82:	2330      	movs	r3, #48	; 0x30
 8002b84:	f383 8811 	msr	BASEPRI, r3
 */
static inline void chMsgReleaseS(thread_t *tp, msg_t msg) {

  chDbgCheckClassS();

  chSchWakeupS(tp, msg);
 8002b88:	f7fe ffaa 	bl	8001ae0 <chSchWakeupS>
 8002b8c:	2300      	movs	r3, #0
 8002b8e:	f383 8811 	msr	BASEPRI, r3

  chSysLock();
  chDbgAssert(tp->state == CH_STATE_SNDMSG, "invalid state");
  chMsgReleaseS(tp, msg);
  chSysUnlock();
}
 8002b92:	bd08      	pop	{r3, pc}
	...

08002ba0 <chThdCreateFromHeap>:
 *
 * @api
 */
thread_t *chThdCreateFromHeap(memory_heap_t *heapp, size_t size,
                              const char *name, tprio_t prio,
                              tfunc_t pf, void *arg) {
 8002ba0:	b5f0      	push	{r4, r5, r6, r7, lr}
 8002ba2:	4617      	mov	r7, r2
 8002ba4:	b087      	sub	sp, #28
  thread_t *tp;
  void *wbase, *wend;

  wbase = chHeapAllocAligned(heapp, size, PORT_WORKING_AREA_ALIGN);
 8002ba6:	2208      	movs	r2, #8
                              tfunc_t pf, void *arg) {
 8002ba8:	460d      	mov	r5, r1
 8002baa:	461e      	mov	r6, r3
  wbase = chHeapAllocAligned(heapp, size, PORT_WORKING_AREA_ALIGN);
 8002bac:	f000 fa30 	bl	8003010 <chHeapAllocAligned>
  if (wbase == NULL) {
 8002bb0:	4604      	mov	r4, r0
 8002bb2:	b1c0      	cbz	r0, 8002be6 <chThdCreateFromHeap+0x46>
    return NULL;
  }
  wend = (void *)((uint8_t *)wbase + size);

  thread_descriptor_t td = THD_DESCRIPTOR(name, wbase, wend, prio, pf, arg);
 8002bb4:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 8002bb6:	9304      	str	r3, [sp, #16]
  wend = (void *)((uint8_t *)wbase + size);
 8002bb8:	4405      	add	r5, r0
  thread_descriptor_t td = THD_DESCRIPTOR(name, wbase, wend, prio, pf, arg);
 8002bba:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 8002bbc:	9305      	str	r3, [sp, #20]
 8002bbe:	9502      	str	r5, [sp, #8]
 8002bc0:	e9cd 7000 	strd	r7, r0, [sp]
 8002bc4:	9603      	str	r6, [sp, #12]
 8002bc6:	2330      	movs	r3, #48	; 0x30
 8002bc8:	f383 8811 	msr	BASEPRI, r3
#if CH_DBG_FILL_THREADS == TRUE
  __thd_stackfill((uint8_t *)wbase, (uint8_t *)wend);
#endif

  chSysLock();
  tp = chThdCreateSuspendedI(&td);
 8002bcc:	4668      	mov	r0, sp
 8002bce:	f7ff f88f 	bl	8001cf0 <chThdCreateSuspendedI>
  tp->flags = CH_FLAG_MODE_HEAP;
 8002bd2:	2301      	movs	r3, #1
 8002bd4:	f880 3025 	strb.w	r3, [r0, #37]	; 0x25
  chSchWakeupS(tp, MSG_OK);
 8002bd8:	2100      	movs	r1, #0
  tp = chThdCreateSuspendedI(&td);
 8002bda:	4604      	mov	r4, r0
  chSchWakeupS(tp, MSG_OK);
 8002bdc:	f7fe ff80 	bl	8001ae0 <chSchWakeupS>
 8002be0:	2300      	movs	r3, #0
 8002be2:	f383 8811 	msr	BASEPRI, r3
  chSysUnlock();

  return tp;
}
 8002be6:	4620      	mov	r0, r4
 8002be8:	b007      	add	sp, #28
 8002bea:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8002bec:	0000      	movs	r0, r0
	...

08002bf0 <chThdCreateFromMemoryPool>:
 * @retval  NULL        if the memory pool is empty.
 *
 * @api
 */
thread_t *chThdCreateFromMemoryPool(memory_pool_t *mp, const char *name,
                                    tprio_t prio, tfunc_t pf, void *arg) {
 8002bf0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8002bf4:	b086      	sub	sp, #24
 8002bf6:	4605      	mov	r5, r0
 8002bf8:	4688      	mov	r8, r1
 8002bfa:	4617      	mov	r7, r2
 8002bfc:	461e      	mov	r6, r3
  thread_t *tp;
  void *wbase, *wend;

  chDbgCheck(mp != NULL);

  wbase = chPoolAlloc(mp);
 8002bfe:	f000 fb37 	bl	8003270 <chPoolAlloc>
  if (wbase == NULL) {
 8002c02:	4604      	mov	r4, r0
 8002c04:	b1c8      	cbz	r0, 8002c3a <chThdCreateFromMemoryPool+0x4a>
    return NULL;
  }
  wend = (void *)((uint8_t *)wbase + mp->object_size);

  thread_descriptor_t td = THD_DESCRIPTOR(name, wbase, wend, prio, pf, arg);
 8002c06:	e9cd 8000 	strd	r8, r0, [sp]
  wend = (void *)((uint8_t *)wbase + mp->object_size);
 8002c0a:	6868      	ldr	r0, [r5, #4]
  thread_descriptor_t td = THD_DESCRIPTOR(name, wbase, wend, prio, pf, arg);
 8002c0c:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 8002c0e:	9305      	str	r3, [sp, #20]
  wend = (void *)((uint8_t *)wbase + mp->object_size);
 8002c10:	4404      	add	r4, r0
  thread_descriptor_t td = THD_DESCRIPTOR(name, wbase, wend, prio, pf, arg);
 8002c12:	e9cd 7603 	strd	r7, r6, [sp, #12]
 8002c16:	2330      	movs	r3, #48	; 0x30
 8002c18:	9402      	str	r4, [sp, #8]
 8002c1a:	f383 8811 	msr	BASEPRI, r3
#if CH_DBG_FILL_THREADS == TRUE
  __thd_stackfill((uint8_t *)wbase, (uint8_t *)wend);
#endif

  chSysLock();
  tp = chThdCreateSuspendedI(&td);
 8002c1e:	4668      	mov	r0, sp
 8002c20:	f7ff f866 	bl	8001cf0 <chThdCreateSuspendedI>
  tp->flags = CH_FLAG_MODE_MPOOL;
 8002c24:	2302      	movs	r3, #2
 8002c26:	f880 3025 	strb.w	r3, [r0, #37]	; 0x25
  tp->mpool = mp;
 8002c2a:	6445      	str	r5, [r0, #68]	; 0x44
  chSchWakeupS(tp, MSG_OK);
 8002c2c:	2100      	movs	r1, #0
  tp = chThdCreateSuspendedI(&td);
 8002c2e:	4604      	mov	r4, r0
  chSchWakeupS(tp, MSG_OK);
 8002c30:	f7fe ff56 	bl	8001ae0 <chSchWakeupS>
 8002c34:	2300      	movs	r3, #0
 8002c36:	f383 8811 	msr	BASEPRI, r3
  chSysUnlock();

  return tp;
}
 8002c3a:	4620      	mov	r0, r4
 8002c3c:	b006      	add	sp, #24
 8002c3e:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 8002c42:	bf00      	nop
	...

08002c50 <chMBObjectInit>:
 * @param[in] buf       pointer to the messages buffer as an array of @p msg_t
 * @param[in] n         number of elements in the buffer array
 *
 * @init
 */
void chMBObjectInit(mailbox_t *mbp, msg_t *buf, size_t n) {
 8002c50:	b430      	push	{r4, r5}
  chDbgCheck((mbp != NULL) && (buf != NULL) && (n > (size_t)0));

  mbp->buffer = buf;
  mbp->rdptr  = buf;
  mbp->wrptr  = buf;
  mbp->top    = &buf[n];
 8002c52:	eb01 0282 	add.w	r2, r1, r2, lsl #2
  mbp->cnt    = (size_t)0;
 8002c56:	2500      	movs	r5, #0
  ch_queue_init(&tqp->queue);
 8002c58:	f100 0418 	add.w	r4, r0, #24
 8002c5c:	f100 0320 	add.w	r3, r0, #32
  qp->prev = qp;
 8002c60:	e9c0 4406 	strd	r4, r4, [r0, #24]
 8002c64:	6105      	str	r5, [r0, #16]
  mbp->reset  = false;
 8002c66:	7505      	strb	r5, [r0, #20]
  mbp->wrptr  = buf;
 8002c68:	e9c0 1102 	strd	r1, r1, [r0, #8]
  chThdQueueObjectInit(&mbp->qw);
  chThdQueueObjectInit(&mbp->qr);
}
 8002c6c:	bc30      	pop	{r4, r5}
 8002c6e:	e9c0 3308 	strd	r3, r3, [r0, #32]
  mbp->buffer = buf;
 8002c72:	6001      	str	r1, [r0, #0]
  mbp->top    = &buf[n];
 8002c74:	6042      	str	r2, [r0, #4]
}
 8002c76:	4770      	bx	lr
	...

08002c80 <chMBReset>:
 *
 * @param[in] mbp       the pointer to an initialized @p mailbox_t object
 *
 * @api
 */
void chMBReset(mailbox_t *mbp) {
 8002c80:	b538      	push	{r3, r4, r5, lr}
 8002c82:	4604      	mov	r4, r0
 8002c84:	2330      	movs	r3, #48	; 0x30
 8002c86:	f383 8811 	msr	BASEPRI, r3
void chMBResetI(mailbox_t *mbp) {

  chDbgCheckClassI();
  chDbgCheck(mbp != NULL);

  mbp->wrptr = mbp->buffer;
 8002c8a:	6803      	ldr	r3, [r0, #0]
  mbp->rdptr = mbp->buffer;
  mbp->cnt   = (size_t)0;
  mbp->reset = true;
 8002c8c:	2201      	movs	r2, #1
  mbp->cnt   = (size_t)0;
 8002c8e:	2500      	movs	r5, #0
  mbp->rdptr = mbp->buffer;
 8002c90:	e9c4 3302 	strd	r3, r3, [r4, #8]
  mbp->reset = true;
 8002c94:	7522      	strb	r2, [r4, #20]
  chThdDequeueAllI(&mbp->qw, MSG_RESET);
 8002c96:	3018      	adds	r0, #24
  mbp->cnt   = (size_t)0;
 8002c98:	6125      	str	r5, [r4, #16]
  chThdDequeueAllI(&mbp->qw, MSG_RESET);
 8002c9a:	f06f 0101 	mvn.w	r1, #1
 8002c9e:	f7ff fa0f 	bl	80020c0 <chThdDequeueAllI>
  chThdDequeueAllI(&mbp->qr, MSG_RESET);
 8002ca2:	f06f 0101 	mvn.w	r1, #1
 8002ca6:	f104 0020 	add.w	r0, r4, #32
 8002caa:	f7ff fa09 	bl	80020c0 <chThdDequeueAllI>
  chSchRescheduleS();
 8002cae:	f7fe ff77 	bl	8001ba0 <chSchRescheduleS>
 8002cb2:	f385 8811 	msr	BASEPRI, r5
}
 8002cb6:	bd38      	pop	{r3, r4, r5, pc}
	...

08002cc0 <chMBResetI>:
void chMBResetI(mailbox_t *mbp) {
 8002cc0:	b510      	push	{r4, lr}
 8002cc2:	4604      	mov	r4, r0
  mbp->reset = true;
 8002cc4:	2201      	movs	r2, #1
  mbp->wrptr = mbp->buffer;
 8002cc6:	6823      	ldr	r3, [r4, #0]
  mbp->reset = true;
 8002cc8:	7522      	strb	r2, [r4, #20]
  mbp->cnt   = (size_t)0;
 8002cca:	2000      	movs	r0, #0
 8002ccc:	6120      	str	r0, [r4, #16]
  mbp->rdptr = mbp->buffer;
 8002cce:	e9c4 3302 	strd	r3, r3, [r4, #8]
  chThdDequeueAllI(&mbp->qw, MSG_RESET);
 8002cd2:	f104 0018 	add.w	r0, r4, #24
 8002cd6:	f06f 0101 	mvn.w	r1, #1
 8002cda:	f7ff f9f1 	bl	80020c0 <chThdDequeueAllI>
  chThdDequeueAllI(&mbp->qr, MSG_RESET);
 8002cde:	f104 0020 	add.w	r0, r4, #32
 8002ce2:	f06f 0101 	mvn.w	r1, #1
}
 8002ce6:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  chThdDequeueAllI(&mbp->qr, MSG_RESET);
 8002cea:	f7ff b9e9 	b.w	80020c0 <chThdDequeueAllI>
 8002cee:	bf00      	nop

08002cf0 <chMBPostTimeoutS>:
 * @retval MSG_RESET    if the mailbox has been reset.
 * @retval MSG_TIMEOUT  if the operation has timed out.
 *
 * @sclass
 */
msg_t chMBPostTimeoutS(mailbox_t *mbp, msg_t msg, sysinterval_t timeout) {
 8002cf0:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 8002cf4:	4604      	mov	r4, r0
 8002cf6:	460f      	mov	r7, r1
 8002cf8:	4690      	mov	r8, r2

      return MSG_OK;
    }

    /* No space in the queue, waiting for a slot to become available.*/
    rdymsg = chThdEnqueueTimeoutS(&mbp->qw, timeout);
 8002cfa:	f100 0918 	add.w	r9, r0, #24
 8002cfe:	e009      	b.n	8002d14 <chMBPostTimeoutS+0x24>
 */
static inline size_t chMBGetSizeI(const mailbox_t *mbp) {

  /*lint -save -e9033 [10.8] Perfectly safe pointers
    arithmetic.*/
  return (size_t)(mbp->top - mbp->buffer);
 8002d00:	e9d4 6500 	ldrd	r6, r5, [r4]
 */
static inline size_t chMBGetUsedCountI(const mailbox_t *mbp) {

  chDbgCheckClassI();

  return mbp->cnt;
 8002d04:	6923      	ldr	r3, [r4, #16]
  return (size_t)(mbp->top - mbp->buffer);
 8002d06:	1baa      	subs	r2, r5, r6
    if (chMBGetFreeCountI(mbp) > (size_t)0) {
 8002d08:	ebb3 0fa2 	cmp.w	r3, r2, asr #2
 8002d0c:	d10b      	bne.n	8002d26 <chMBPostTimeoutS+0x36>
    rdymsg = chThdEnqueueTimeoutS(&mbp->qw, timeout);
 8002d0e:	f7ff f9af 	bl	8002070 <chThdEnqueueTimeoutS>
  } while (rdymsg == MSG_OK);
 8002d12:	b930      	cbnz	r0, 8002d22 <chMBPostTimeoutS+0x32>
    if (mbp->reset) {
 8002d14:	7d23      	ldrb	r3, [r4, #20]
    rdymsg = chThdEnqueueTimeoutS(&mbp->qw, timeout);
 8002d16:	4641      	mov	r1, r8
 8002d18:	4648      	mov	r0, r9
    if (mbp->reset) {
 8002d1a:	2b00      	cmp	r3, #0
 8002d1c:	d0f0      	beq.n	8002d00 <chMBPostTimeoutS+0x10>
      return MSG_RESET;
 8002d1e:	f06f 0001 	mvn.w	r0, #1

  return rdymsg;
}
 8002d22:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
      *mbp->wrptr++ = msg;
 8002d26:	68a1      	ldr	r1, [r4, #8]
 8002d28:	1d0a      	adds	r2, r1, #4
      if (mbp->wrptr >= mbp->top) {
 8002d2a:	42aa      	cmp	r2, r5
      mbp->cnt++;
 8002d2c:	f103 0301 	add.w	r3, r3, #1
      *mbp->wrptr++ = msg;
 8002d30:	60a2      	str	r2, [r4, #8]
      chThdDequeueNextI(&mbp->qr, MSG_OK);
 8002d32:	f104 0020 	add.w	r0, r4, #32
      *mbp->wrptr++ = msg;
 8002d36:	600f      	str	r7, [r1, #0]
        mbp->wrptr = mbp->buffer;
 8002d38:	bf28      	it	cs
 8002d3a:	60a6      	strcs	r6, [r4, #8]
      chThdDequeueNextI(&mbp->qr, MSG_OK);
 8002d3c:	2100      	movs	r1, #0
      mbp->cnt++;
 8002d3e:	6123      	str	r3, [r4, #16]
      chThdDequeueNextI(&mbp->qr, MSG_OK);
 8002d40:	f7ff f9ae 	bl	80020a0 <chThdDequeueNextI>
      chSchRescheduleS();
 8002d44:	f7fe ff2c 	bl	8001ba0 <chSchRescheduleS>
      return MSG_OK;
 8002d48:	2000      	movs	r0, #0
}
 8002d4a:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
 8002d4e:	bf00      	nop

08002d50 <chMBPostTimeout>:
msg_t chMBPostTimeout(mailbox_t *mbp, msg_t msg, sysinterval_t timeout) {
 8002d50:	b508      	push	{r3, lr}
 8002d52:	2330      	movs	r3, #48	; 0x30
 8002d54:	f383 8811 	msr	BASEPRI, r3
  rdymsg = chMBPostTimeoutS(mbp, msg, timeout);
 8002d58:	f7ff ffca 	bl	8002cf0 <chMBPostTimeoutS>
 8002d5c:	2300      	movs	r3, #0
 8002d5e:	f383 8811 	msr	BASEPRI, r3
}
 8002d62:	bd08      	pop	{r3, pc}
	...

08002d70 <chMBPostI>:

  chDbgCheckClassI();
  chDbgCheck(mbp != NULL);

  /* If the mailbox is in reset state then returns immediately.*/
  if (mbp->reset) {
 8002d70:	7d03      	ldrb	r3, [r0, #20]
 8002d72:	b9eb      	cbnz	r3, 8002db0 <chMBPostI+0x40>
msg_t chMBPostI(mailbox_t *mbp, msg_t msg) {
 8002d74:	b570      	push	{r4, r5, r6, lr}
 8002d76:	e9d0 6200 	ldrd	r6, r2, [r0]
  return mbp->cnt;
 8002d7a:	6903      	ldr	r3, [r0, #16]
  return (size_t)(mbp->top - mbp->buffer);
 8002d7c:	1b94      	subs	r4, r2, r6
    return MSG_RESET;
  }

  /* Is there a free message slot in queue? if so then post.*/
  if (chMBGetFreeCountI(mbp) > (size_t)0) {
 8002d7e:	ebb3 0fa4 	cmp.w	r3, r4, asr #2
 8002d82:	d012      	beq.n	8002daa <chMBPostI+0x3a>
    *mbp->wrptr++ = msg;
 8002d84:	6885      	ldr	r5, [r0, #8]
 8002d86:	1d2c      	adds	r4, r5, #4
    if (mbp->wrptr >= mbp->top) {
 8002d88:	4294      	cmp	r4, r2
      mbp->wrptr = mbp->buffer;
    }
    mbp->cnt++;
 8002d8a:	f103 0301 	add.w	r3, r3, #1
    *mbp->wrptr++ = msg;
 8002d8e:	6084      	str	r4, [r0, #8]
 8002d90:	6029      	str	r1, [r5, #0]

    /* If there is a reader waiting then makes it ready.*/
    chThdDequeueNextI(&mbp->qr, MSG_OK);
 8002d92:	f100 0020 	add.w	r0, r0, #32
      mbp->wrptr = mbp->buffer;
 8002d96:	bf28      	it	cs
 8002d98:	f840 6c18 	strcs.w	r6, [r0, #-24]
    mbp->cnt++;
 8002d9c:	f840 3c10 	str.w	r3, [r0, #-16]
    chThdDequeueNextI(&mbp->qr, MSG_OK);
 8002da0:	2100      	movs	r1, #0
 8002da2:	f7ff f97d 	bl	80020a0 <chThdDequeueNextI>

    return MSG_OK;
 8002da6:	2000      	movs	r0, #0
  }

  /* No space, immediate timeout.*/
  return MSG_TIMEOUT;
}
 8002da8:	bd70      	pop	{r4, r5, r6, pc}
  return MSG_TIMEOUT;
 8002daa:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
}
 8002dae:	bd70      	pop	{r4, r5, r6, pc}
    return MSG_RESET;
 8002db0:	f06f 0001 	mvn.w	r0, #1
}
 8002db4:	4770      	bx	lr
 8002db6:	bf00      	nop
	...

08002dc0 <chMBPostAheadTimeoutS>:
 * @retval MSG_RESET    if the mailbox has been reset.
 * @retval MSG_TIMEOUT  if the operation has timed out.
 *
 * @sclass
 */
msg_t chMBPostAheadTimeoutS(mailbox_t *mbp, msg_t msg, sysinterval_t timeout) {
 8002dc0:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 8002dc4:	4604      	mov	r4, r0
 8002dc6:	460e      	mov	r6, r1
 8002dc8:	4690      	mov	r8, r2

      return MSG_OK;
    }

    /* No space in the queue, waiting for a slot to become available.*/
    rdymsg = chThdEnqueueTimeoutS(&mbp->qw, timeout);
 8002dca:	f100 0918 	add.w	r9, r0, #24
 8002dce:	e009      	b.n	8002de4 <chMBPostAheadTimeoutS+0x24>
 8002dd0:	e9d4 5700 	ldrd	r5, r7, [r4]
  return mbp->cnt;
 8002dd4:	6923      	ldr	r3, [r4, #16]
  return (size_t)(mbp->top - mbp->buffer);
 8002dd6:	1b7a      	subs	r2, r7, r5
    if (chMBGetFreeCountI(mbp) > (size_t)0) {
 8002dd8:	ebb3 0fa2 	cmp.w	r3, r2, asr #2
 8002ddc:	d10b      	bne.n	8002df6 <chMBPostAheadTimeoutS+0x36>
    rdymsg = chThdEnqueueTimeoutS(&mbp->qw, timeout);
 8002dde:	f7ff f947 	bl	8002070 <chThdEnqueueTimeoutS>
  } while (rdymsg == MSG_OK);
 8002de2:	b930      	cbnz	r0, 8002df2 <chMBPostAheadTimeoutS+0x32>
    if (mbp->reset) {
 8002de4:	7d23      	ldrb	r3, [r4, #20]
    rdymsg = chThdEnqueueTimeoutS(&mbp->qw, timeout);
 8002de6:	4641      	mov	r1, r8
 8002de8:	4648      	mov	r0, r9
    if (mbp->reset) {
 8002dea:	2b00      	cmp	r3, #0
 8002dec:	d0f0      	beq.n	8002dd0 <chMBPostAheadTimeoutS+0x10>
      return MSG_RESET;
 8002dee:	f06f 0001 	mvn.w	r0, #1

  return rdymsg;
}
 8002df2:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
      if (--mbp->rdptr < mbp->buffer) {
 8002df6:	68e2      	ldr	r2, [r4, #12]
 8002df8:	3a04      	subs	r2, #4
 8002dfa:	42aa      	cmp	r2, r5
        mbp->rdptr = mbp->top - 1;
 8002dfc:	bf38      	it	cc
 8002dfe:	1f3a      	subcc	r2, r7, #4
      mbp->cnt++;
 8002e00:	3301      	adds	r3, #1
        mbp->rdptr = mbp->top - 1;
 8002e02:	60e2      	str	r2, [r4, #12]
      chThdDequeueNextI(&mbp->qr, MSG_OK);
 8002e04:	f104 0020 	add.w	r0, r4, #32
      *mbp->rdptr = msg;
 8002e08:	6016      	str	r6, [r2, #0]
      chThdDequeueNextI(&mbp->qr, MSG_OK);
 8002e0a:	2100      	movs	r1, #0
      mbp->cnt++;
 8002e0c:	6123      	str	r3, [r4, #16]
      chThdDequeueNextI(&mbp->qr, MSG_OK);
 8002e0e:	f7ff f947 	bl	80020a0 <chThdDequeueNextI>
      chSchRescheduleS();
 8002e12:	f7fe fec5 	bl	8001ba0 <chSchRescheduleS>
      return MSG_OK;
 8002e16:	2000      	movs	r0, #0
}
 8002e18:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
 8002e1c:	0000      	movs	r0, r0
	...

08002e20 <chMBPostAheadTimeout>:
msg_t chMBPostAheadTimeout(mailbox_t *mbp, msg_t msg, sysinterval_t timeout) {
 8002e20:	b508      	push	{r3, lr}
 8002e22:	2330      	movs	r3, #48	; 0x30
 8002e24:	f383 8811 	msr	BASEPRI, r3
  rdymsg = chMBPostAheadTimeoutS(mbp, msg, timeout);
 8002e28:	f7ff ffca 	bl	8002dc0 <chMBPostAheadTimeoutS>
 8002e2c:	2300      	movs	r3, #0
 8002e2e:	f383 8811 	msr	BASEPRI, r3
}
 8002e32:	bd08      	pop	{r3, pc}
	...

08002e40 <chMBPostAheadI>:
 * @retval MSG_TIMEOUT  if the mailbox is full and the message cannot be
 *                      posted.
 *
 * @iclass
 */
msg_t chMBPostAheadI(mailbox_t *mbp, msg_t msg) {
 8002e40:	b538      	push	{r3, r4, r5, lr}

  chDbgCheckClassI();
  chDbgCheck(mbp != NULL);

  /* If the mailbox is in reset state then returns immediately.*/
  if (mbp->reset) {
 8002e42:	7d03      	ldrb	r3, [r0, #20]
 8002e44:	b9cb      	cbnz	r3, 8002e7a <chMBPostAheadI+0x3a>
 8002e46:	e9d0 4500 	ldrd	r4, r5, [r0]
  return mbp->cnt;
 8002e4a:	6902      	ldr	r2, [r0, #16]
  return (size_t)(mbp->top - mbp->buffer);
 8002e4c:	1b2b      	subs	r3, r5, r4
    return MSG_RESET;
  }

  /* Is there a free message slot in queue? if so then post.*/
  if (chMBGetFreeCountI(mbp) > (size_t)0) {
 8002e4e:	ebb2 0fa3 	cmp.w	r2, r3, asr #2
 8002e52:	d00f      	beq.n	8002e74 <chMBPostAheadI+0x34>
    if (--mbp->rdptr < mbp->buffer) {
 8002e54:	68c3      	ldr	r3, [r0, #12]
 8002e56:	3b04      	subs	r3, #4
 8002e58:	42a3      	cmp	r3, r4
      mbp->rdptr = mbp->top - 1;
 8002e5a:	bf38      	it	cc
 8002e5c:	1f2b      	subcc	r3, r5, #4
    }
    *mbp->rdptr = msg;
    mbp->cnt++;
 8002e5e:	3201      	adds	r2, #1
      mbp->rdptr = mbp->top - 1;
 8002e60:	60c3      	str	r3, [r0, #12]
    *mbp->rdptr = msg;
 8002e62:	6019      	str	r1, [r3, #0]

    /* If there is a reader waiting then makes it ready.*/
    chThdDequeueNextI(&mbp->qr, MSG_OK);
 8002e64:	3020      	adds	r0, #32
    mbp->cnt++;
 8002e66:	f840 2c10 	str.w	r2, [r0, #-16]
    chThdDequeueNextI(&mbp->qr, MSG_OK);
 8002e6a:	2100      	movs	r1, #0
 8002e6c:	f7ff f918 	bl	80020a0 <chThdDequeueNextI>

    return MSG_OK;
 8002e70:	2000      	movs	r0, #0
  }

  /* No space, immediate timeout.*/
  return MSG_TIMEOUT;
}
 8002e72:	bd38      	pop	{r3, r4, r5, pc}
  return MSG_TIMEOUT;
 8002e74:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
}
 8002e78:	bd38      	pop	{r3, r4, r5, pc}
    return MSG_RESET;
 8002e7a:	f06f 0001 	mvn.w	r0, #1
}
 8002e7e:	bd38      	pop	{r3, r4, r5, pc}

08002e80 <chMBFetchTimeoutS>:
 * @retval MSG_RESET    if the mailbox has been reset.
 * @retval MSG_TIMEOUT  if the operation has timed out.
 *
 * @sclass
 */
msg_t chMBFetchTimeoutS(mailbox_t *mbp, msg_t *msgp, sysinterval_t timeout) {
 8002e80:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8002e82:	4604      	mov	r4, r0
 8002e84:	460e      	mov	r6, r1
 8002e86:	4615      	mov	r5, r2

      return MSG_OK;
    }

    /* No message in the queue, waiting for a message to become available.*/
    rdymsg = chThdEnqueueTimeoutS(&mbp->qr, timeout);
 8002e88:	f100 0720 	add.w	r7, r0, #32
 8002e8c:	e004      	b.n	8002e98 <chMBFetchTimeoutS+0x18>
  return mbp->cnt;
 8002e8e:	6923      	ldr	r3, [r4, #16]
    if (chMBGetUsedCountI(mbp) > (size_t)0) {
 8002e90:	b953      	cbnz	r3, 8002ea8 <chMBFetchTimeoutS+0x28>
    rdymsg = chThdEnqueueTimeoutS(&mbp->qr, timeout);
 8002e92:	f7ff f8ed 	bl	8002070 <chThdEnqueueTimeoutS>
  } while (rdymsg == MSG_OK);
 8002e96:	b930      	cbnz	r0, 8002ea6 <chMBFetchTimeoutS+0x26>
    if (mbp->reset) {
 8002e98:	7d23      	ldrb	r3, [r4, #20]
    rdymsg = chThdEnqueueTimeoutS(&mbp->qr, timeout);
 8002e9a:	4629      	mov	r1, r5
 8002e9c:	4638      	mov	r0, r7
    if (mbp->reset) {
 8002e9e:	2b00      	cmp	r3, #0
 8002ea0:	d0f5      	beq.n	8002e8e <chMBFetchTimeoutS+0xe>
      return MSG_RESET;
 8002ea2:	f06f 0001 	mvn.w	r0, #1

  return rdymsg;
}
 8002ea6:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
      *msgp = *mbp->rdptr++;
 8002ea8:	68e1      	ldr	r1, [r4, #12]
 8002eaa:	1d0a      	adds	r2, r1, #4
 8002eac:	6809      	ldr	r1, [r1, #0]
 8002eae:	60e2      	str	r2, [r4, #12]
 8002eb0:	6031      	str	r1, [r6, #0]
      if (mbp->rdptr >= mbp->top) {
 8002eb2:	6861      	ldr	r1, [r4, #4]
 8002eb4:	428a      	cmp	r2, r1
        mbp->rdptr = mbp->buffer;
 8002eb6:	bf24      	itt	cs
 8002eb8:	6822      	ldrcs	r2, [r4, #0]
 8002eba:	60e2      	strcs	r2, [r4, #12]
      mbp->cnt--;
 8002ebc:	3b01      	subs	r3, #1
      chThdDequeueNextI(&mbp->qw, MSG_OK);
 8002ebe:	f104 0018 	add.w	r0, r4, #24
 8002ec2:	2100      	movs	r1, #0
      mbp->cnt--;
 8002ec4:	6123      	str	r3, [r4, #16]
      chThdDequeueNextI(&mbp->qw, MSG_OK);
 8002ec6:	f7ff f8eb 	bl	80020a0 <chThdDequeueNextI>
      chSchRescheduleS();
 8002eca:	f7fe fe69 	bl	8001ba0 <chSchRescheduleS>
      return MSG_OK;
 8002ece:	2000      	movs	r0, #0
}
 8002ed0:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8002ed2:	bf00      	nop
	...

08002ee0 <chMBFetchTimeout>:
msg_t chMBFetchTimeout(mailbox_t *mbp, msg_t *msgp, sysinterval_t timeout) {
 8002ee0:	b508      	push	{r3, lr}
 8002ee2:	2330      	movs	r3, #48	; 0x30
 8002ee4:	f383 8811 	msr	BASEPRI, r3
  rdymsg = chMBFetchTimeoutS(mbp, msgp, timeout);
 8002ee8:	f7ff ffca 	bl	8002e80 <chMBFetchTimeoutS>
 8002eec:	2300      	movs	r3, #0
 8002eee:	f383 8811 	msr	BASEPRI, r3
}
 8002ef2:	bd08      	pop	{r3, pc}
	...

08002f00 <chMBFetchI>:

  chDbgCheckClassI();
  chDbgCheck((mbp != NULL) && (msgp != NULL));

  /* If the mailbox is in reset state then returns immediately.*/
  if (mbp->reset) {
 8002f00:	7d03      	ldrb	r3, [r0, #20]
 8002f02:	b9bb      	cbnz	r3, 8002f34 <chMBFetchI+0x34>
 8002f04:	6903      	ldr	r3, [r0, #16]
    return MSG_RESET;
  }

  /* Is there a message in queue? if so then fetch.*/
  if (chMBGetUsedCountI(mbp) > (size_t)0) {
 8002f06:	b193      	cbz	r3, 8002f2e <chMBFetchI+0x2e>
msg_t chMBFetchI(mailbox_t *mbp, msg_t *msgp) {
 8002f08:	b510      	push	{r4, lr}
    *msgp = *mbp->rdptr++;
 8002f0a:	68c4      	ldr	r4, [r0, #12]
 8002f0c:	1d22      	adds	r2, r4, #4
 8002f0e:	6824      	ldr	r4, [r4, #0]
 8002f10:	60c2      	str	r2, [r0, #12]
 8002f12:	600c      	str	r4, [r1, #0]
    if (mbp->rdptr >= mbp->top) {
 8002f14:	6841      	ldr	r1, [r0, #4]
 8002f16:	428a      	cmp	r2, r1
      mbp->rdptr = mbp->buffer;
 8002f18:	bf24      	itt	cs
 8002f1a:	6802      	ldrcs	r2, [r0, #0]
 8002f1c:	60c2      	strcs	r2, [r0, #12]
    }
    mbp->cnt--;
 8002f1e:	3b01      	subs	r3, #1
 8002f20:	6103      	str	r3, [r0, #16]

    /* If there is a writer waiting then makes it ready.*/
    chThdDequeueNextI(&mbp->qw, MSG_OK);
 8002f22:	2100      	movs	r1, #0
 8002f24:	3018      	adds	r0, #24
 8002f26:	f7ff f8bb 	bl	80020a0 <chThdDequeueNextI>

    return MSG_OK;
 8002f2a:	2000      	movs	r0, #0
  }

  /* No message, immediate timeout.*/
  return MSG_TIMEOUT;
}
 8002f2c:	bd10      	pop	{r4, pc}
  return MSG_TIMEOUT;
 8002f2e:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
}
 8002f32:	4770      	bx	lr
    return MSG_RESET;
 8002f34:	f06f 0001 	mvn.w	r0, #1
 8002f38:	4770      	bx	lr
 8002f3a:	bf00      	nop
 8002f3c:	0000      	movs	r0, r0
	...

08002f40 <__core_init>:
#if CH_CFG_MEMCORE_SIZE == 0
  extern uint8_t __heap_base__[];
  extern uint8_t __heap_end__[];

  /*lint -save -e9033 [10.8] Required cast operations.*/
  ch_memcore.basemem = __heap_base__;
 8002f40:	4b02      	ldr	r3, [pc, #8]	; (8002f4c <__core_init+0xc>)
 8002f42:	4903      	ldr	r1, [pc, #12]	; (8002f50 <__core_init+0x10>)
  ch_memcore.topmem  = __heap_end__;
 8002f44:	4a03      	ldr	r2, [pc, #12]	; (8002f54 <__core_init+0x14>)
 8002f46:	e9c3 1200 	strd	r1, r2, [r3]
  static uint8_t static_heap[CH_CFG_MEMCORE_SIZE];

  ch_memcore.basemem = &static_heap[0];
  ch_memcore.topmem  = &static_heap[CH_CFG_MEMCORE_SIZE];
#endif
}
 8002f4a:	4770      	bx	lr
 8002f4c:	20000c04 	.word	0x20000c04
 8002f50:	20001e60 	.word	0x20001e60
 8002f54:	20010000 	.word	0x20010000
	...

08002f60 <chCoreAllocFromTopI>:
  uint8_t *p, *prev;

  chDbgCheckClassI();
  chDbgCheck(MEM_IS_VALID_ALIGNMENT(align));

  p = (uint8_t *)MEM_ALIGN_PREV(ch_memcore.topmem - size, align);
 8002f60:	4b08      	ldr	r3, [pc, #32]	; (8002f84 <chCoreAllocFromTopI+0x24>)
void *chCoreAllocFromTopI(size_t size, unsigned align, size_t offset) {
 8002f62:	b410      	push	{r4}
  p = (uint8_t *)MEM_ALIGN_PREV(ch_memcore.topmem - size, align);
 8002f64:	685c      	ldr	r4, [r3, #4]
 8002f66:	4249      	negs	r1, r1
 8002f68:	1a20      	subs	r0, r4, r0
 8002f6a:	4008      	ands	r0, r1
  prev = p - offset;

  /* Considering also the case where there is numeric overflow.*/
  if ((prev < ch_memcore.basemem) || (prev > ch_memcore.topmem)) {
 8002f6c:	6819      	ldr	r1, [r3, #0]
  prev = p - offset;
 8002f6e:	1a82      	subs	r2, r0, r2
  if ((prev < ch_memcore.basemem) || (prev > ch_memcore.topmem)) {
 8002f70:	428a      	cmp	r2, r1
 8002f72:	d304      	bcc.n	8002f7e <chCoreAllocFromTopI+0x1e>
 8002f74:	42a2      	cmp	r2, r4
 8002f76:	d802      	bhi.n	8002f7e <chCoreAllocFromTopI+0x1e>
  }

  ch_memcore.topmem = prev;

  return p;
}
 8002f78:	bc10      	pop	{r4}
  ch_memcore.topmem = prev;
 8002f7a:	605a      	str	r2, [r3, #4]
}
 8002f7c:	4770      	bx	lr
    return NULL;
 8002f7e:	2000      	movs	r0, #0
}
 8002f80:	bc10      	pop	{r4}
 8002f82:	4770      	bx	lr
 8002f84:	20000c04 	.word	0x20000c04
	...

08002f90 <chCoreAllocFromTop>:
 * @return              A pointer to the allocated memory block.
 * @retval NULL         allocation failed, core memory exhausted.
 *
 * @api
 */
void *chCoreAllocFromTop(size_t size, unsigned align, size_t offset) {
 8002f90:	b410      	push	{r4}
 8002f92:	2330      	movs	r3, #48	; 0x30
 8002f94:	f383 8811 	msr	BASEPRI, r3
  p = (uint8_t *)MEM_ALIGN_PREV(ch_memcore.topmem - size, align);
 8002f98:	4b0b      	ldr	r3, [pc, #44]	; (8002fc8 <chCoreAllocFromTop+0x38>)
 8002f9a:	685c      	ldr	r4, [r3, #4]
 8002f9c:	4249      	negs	r1, r1
 8002f9e:	1a20      	subs	r0, r4, r0
 8002fa0:	4008      	ands	r0, r1
  if ((prev < ch_memcore.basemem) || (prev > ch_memcore.topmem)) {
 8002fa2:	6819      	ldr	r1, [r3, #0]
  prev = p - offset;
 8002fa4:	1a82      	subs	r2, r0, r2
  if ((prev < ch_memcore.basemem) || (prev > ch_memcore.topmem)) {
 8002fa6:	428a      	cmp	r2, r1
 8002fa8:	d307      	bcc.n	8002fba <chCoreAllocFromTop+0x2a>
 8002faa:	4294      	cmp	r4, r2
 8002fac:	d305      	bcc.n	8002fba <chCoreAllocFromTop+0x2a>
  ch_memcore.topmem = prev;
 8002fae:	605a      	str	r2, [r3, #4]
 8002fb0:	2300      	movs	r3, #0
 8002fb2:	f383 8811 	msr	BASEPRI, r3
  chSysLock();
  p = chCoreAllocFromTopI(size, align, offset);
  chSysUnlock();

  return p;
}
 8002fb6:	bc10      	pop	{r4}
 8002fb8:	4770      	bx	lr
    return NULL;
 8002fba:	2000      	movs	r0, #0
 8002fbc:	2300      	movs	r3, #0
 8002fbe:	f383 8811 	msr	BASEPRI, r3
}
 8002fc2:	bc10      	pop	{r4}
 8002fc4:	4770      	bx	lr
 8002fc6:	bf00      	nop
 8002fc8:	20000c04 	.word	0x20000c04
 8002fcc:	00000000 	.word	0x00000000

08002fd0 <__heap_init>:
 *
 * @notapi
 */
void __heap_init(void) {

  default_heap.provider = chCoreAllocAlignedWithOffset;
 8002fd0:	4b04      	ldr	r3, [pc, #16]	; (8002fe4 <__heap_init+0x14>)
 8002fd2:	4905      	ldr	r1, [pc, #20]	; (8002fe8 <__heap_init+0x18>)
  H_NEXT(&default_heap.header) = NULL;
 8002fd4:	2200      	movs	r2, #0
  H_PAGES(&default_heap.header) = 0;
#if (CH_CFG_USE_MUTEXES == TRUE) || defined(__DOXYGEN__)
  chMtxObjectInit(&default_heap.mtx);
 8002fd6:	f103 000c 	add.w	r0, r3, #12
  H_NEXT(&default_heap.header) = NULL;
 8002fda:	e9c3 1200 	strd	r1, r2, [r3]
  H_PAGES(&default_heap.header) = 0;
 8002fde:	609a      	str	r2, [r3, #8]
  chMtxObjectInit(&default_heap.mtx);
 8002fe0:	f7ff b9ee 	b.w	80023c0 <chMtxObjectInit>
 8002fe4:	20000c0c 	.word	0x20000c0c
 8002fe8:	08002f91 	.word	0x08002f91
 8002fec:	00000000 	.word	0x00000000

08002ff0 <chHeapObjectInit>:
 * @param[in] size      heap size
 *
 * @init
 */
void chHeapObjectInit(memory_heap_t *heapp, void *buf, size_t size) {
  heap_header_t *hp = (heap_header_t *)MEM_ALIGN_NEXT(buf, CH_HEAP_ALIGNMENT);
 8002ff0:	1dcb      	adds	r3, r1, #7
 8002ff2:	f023 0307 	bic.w	r3, r3, #7
  chDbgCheck((heapp != NULL) && (size > 0U));

  /* Adjusting the size in case the initial block was not correctly
     aligned.*/
  /*lint -save -e9033 [10.8] Required cast operations.*/
  size -= (size_t)((uint8_t *)hp - (uint8_t *)buf);
 8002ff6:	1a59      	subs	r1, r3, r1
  /* Initializing the heap header.*/
  heapp->provider = NULL;
  H_NEXT(&heapp->header) = hp;
  H_PAGES(&heapp->header) = 0;
  H_NEXT(hp) = NULL;
  H_PAGES(hp) = (size - sizeof (heap_header_t)) / CH_HEAP_ALIGNMENT;
 8002ff8:	3a08      	subs	r2, #8
 8002ffa:	1a52      	subs	r2, r2, r1
 8002ffc:	08d2      	lsrs	r2, r2, #3
  heapp->provider = NULL;
 8002ffe:	2100      	movs	r1, #0
  H_NEXT(&heapp->header) = hp;
 8003000:	e9c0 1300 	strd	r1, r3, [r0]
  H_PAGES(&heapp->header) = 0;
 8003004:	6081      	str	r1, [r0, #8]
  H_PAGES(hp) = (size - sizeof (heap_header_t)) / CH_HEAP_ALIGNMENT;
 8003006:	e9c3 1200 	strd	r1, r2, [r3]
#if (CH_CFG_USE_MUTEXES == TRUE) || defined(__DOXYGEN__)
  chMtxObjectInit(&heapp->mtx);
 800300a:	300c      	adds	r0, #12
 800300c:	f7ff b9d8 	b.w	80023c0 <chMtxObjectInit>

08003010 <chHeapAllocAligned>:
 * @return              A pointer to the aligned allocated block.
 * @retval NULL         if the block cannot be allocated.
 *
 * @api
 */
void *chHeapAllocAligned(memory_heap_t *heapp, size_t size, unsigned align) {
 8003010:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}

  chDbgCheck((size > 0U) && MEM_IS_VALID_ALIGNMENT(align));

  /* If an heap is not specified then the default system header is used.*/
  if (heapp == NULL) {
    heapp = &default_heap;
 8003014:	4b41      	ldr	r3, [pc, #260]	; (800311c <chHeapAllocAligned+0x10c>)
 8003016:	2800      	cmp	r0, #0
 8003018:	bf14      	ite	ne
 800301a:	4681      	movne	r9, r0
 800301c:	4699      	moveq	r9, r3
void *chHeapAllocAligned(memory_heap_t *heapp, size_t size, unsigned align) {
 800301e:	b083      	sub	sp, #12
 8003020:	2a08      	cmp	r2, #8

  /* Size is converted in number of elementary allocation units.*/
  pages = MEM_ALIGN_NEXT(size, CH_HEAP_ALIGNMENT) / CH_HEAP_ALIGNMENT;

  /* Taking heap mutex/semaphore.*/
  H_LOCK(heapp);
 8003022:	f109 0b0c 	add.w	fp, r9, #12
 8003026:	bf38      	it	cc
 8003028:	2208      	movcc	r2, #8
 800302a:	4658      	mov	r0, fp
  pages = MEM_ALIGN_NEXT(size, CH_HEAP_ALIGNMENT) / CH_HEAP_ALIGNMENT;
 800302c:	f101 0807 	add.w	r8, r1, #7
void *chHeapAllocAligned(memory_heap_t *heapp, size_t size, unsigned align) {
 8003030:	9101      	str	r1, [sp, #4]
 8003032:	4692      	mov	sl, r2
  H_LOCK(heapp);
 8003034:	f7ff fa34 	bl	80024a0 <chMtxLock>

  /* Start of the free blocks list.*/
  qp = &heapp->header;
  while (H_NEXT(qp) != NULL) {
 8003038:	f8d9 4004 	ldr.w	r4, [r9, #4]
  pages = MEM_ALIGN_NEXT(size, CH_HEAP_ALIGNMENT) / CH_HEAP_ALIGNMENT;
 800303c:	ea4f 08d8 	mov.w	r8, r8, lsr #3
  while (H_NEXT(qp) != NULL) {
 8003040:	b1ec      	cbz	r4, 800307e <chHeapAllocAligned+0x6e>
 8003042:	f109 0104 	add.w	r1, r9, #4

    /* Next free block.*/
    hp = H_NEXT(qp);

    /* Pointer aligned to the requested alignment.*/
    ahp = (heap_header_t *)MEM_ALIGN_NEXT(H_BLOCK(hp), align) - 1U;
 8003046:	f1ca 0200 	rsb	r2, sl, #0
 800304a:	f10a 0707 	add.w	r7, sl, #7
 800304e:	e000      	b.n	8003052 <chHeapAllocAligned+0x42>
 8003050:	461c      	mov	r4, r3

    if ((ahp < H_LIMIT(hp)) && (pages <= NPAGES(H_LIMIT(hp), ahp + 1U))) {
 8003052:	6866      	ldr	r6, [r4, #4]
    ahp = (heap_header_t *)MEM_ALIGN_NEXT(H_BLOCK(hp), align) - 1U;
 8003054:	19e3      	adds	r3, r4, r7
 8003056:	4013      	ands	r3, r2
    if ((ahp < H_LIMIT(hp)) && (pages <= NPAGES(H_LIMIT(hp), ahp + 1U))) {
 8003058:	f106 0c01 	add.w	ip, r6, #1
 800305c:	461d      	mov	r5, r3
 800305e:	eb04 0ccc 	add.w	ip, r4, ip, lsl #3
    ahp = (heap_header_t *)MEM_ALIGN_NEXT(H_BLOCK(hp), align) - 1U;
 8003062:	3b08      	subs	r3, #8
    if ((ahp < H_LIMIT(hp)) && (pages <= NPAGES(H_LIMIT(hp), ahp + 1U))) {
 8003064:	ebac 0e05 	sub.w	lr, ip, r5
 8003068:	459c      	cmp	ip, r3
 800306a:	ea4f 00ee 	mov.w	r0, lr, asr #3
 800306e:	d902      	bls.n	8003076 <chHeapAllocAligned+0x66>
 8003070:	ebb8 0fee 	cmp.w	r8, lr, asr #3
 8003074:	d919      	bls.n	80030aa <chHeapAllocAligned+0x9a>
  while (H_NEXT(qp) != NULL) {
 8003076:	6823      	ldr	r3, [r4, #0]
 8003078:	4621      	mov	r1, r4
 800307a:	2b00      	cmp	r3, #0
 800307c:	d1e8      	bne.n	8003050 <chHeapAllocAligned+0x40>
    /* Next in the free blocks list.*/
    qp = hp;
  }

  /* Releasing heap mutex/semaphore.*/
  H_UNLOCK(heapp);
 800307e:	4658      	mov	r0, fp
 8003080:	f7ff fa36 	bl	80024f0 <chMtxUnlock>

  /* More memory is required, tries to get it from the associated provider
     else fails.*/
  if (heapp->provider != NULL) {
 8003084:	f8d9 5000 	ldr.w	r5, [r9]
 8003088:	b15d      	cbz	r5, 80030a2 <chHeapAllocAligned+0x92>
    ahp = heapp->provider(pages * CH_HEAP_ALIGNMENT,
 800308a:	4651      	mov	r1, sl
 800308c:	ea4f 00c8 	mov.w	r0, r8, lsl #3
 8003090:	2208      	movs	r2, #8
 8003092:	47a8      	blx	r5
                          align,
                          sizeof (heap_header_t));
    if (ahp != NULL) {
 8003094:	4605      	mov	r5, r0
 8003096:	b120      	cbz	r0, 80030a2 <chHeapAllocAligned+0x92>
      hp = ahp - 1U;
      H_HEAP(hp) = heapp;
      H_SIZE(hp) = size;
 8003098:	9b01      	ldr	r3, [sp, #4]
      H_HEAP(hp) = heapp;
 800309a:	f840 9c08 	str.w	r9, [r0, #-8]
      H_SIZE(hp) = size;
 800309e:	f840 3c04 	str.w	r3, [r0, #-4]
      /*lint -restore*/
    }
  }

  return NULL;
}
 80030a2:	4628      	mov	r0, r5
 80030a4:	b003      	add	sp, #12
 80030a6:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
      if (ahp > hp) {
 80030aa:	429c      	cmp	r4, r3
 80030ac:	d31c      	bcc.n	80030e8 <chHeapAllocAligned+0xd8>
        if (H_PAGES(hp) == pages) {
 80030ae:	4546      	cmp	r6, r8
 80030b0:	d02e      	beq.n	8003110 <chHeapAllocAligned+0x100>
          fp = H_BLOCK(hp) + pages;
 80030b2:	f108 0801 	add.w	r8, r8, #1
 80030b6:	eb04 02c8 	add.w	r2, r4, r8, lsl #3
          H_PAGES(fp) = NPAGES(H_LIMIT(hp), H_BLOCK(fp));
 80030ba:	f102 0308 	add.w	r3, r2, #8
 80030be:	ebac 0303 	sub.w	r3, ip, r3
          H_NEXT(fp) = H_NEXT(hp);
 80030c2:	6820      	ldr	r0, [r4, #0]
 80030c4:	f844 0038 	str.w	r0, [r4, r8, lsl #3]
          H_PAGES(fp) = NPAGES(H_LIMIT(hp), H_BLOCK(fp));
 80030c8:	10db      	asrs	r3, r3, #3
 80030ca:	6053      	str	r3, [r2, #4]
      return (void *)H_BLOCK(hp);
 80030cc:	f104 0508 	add.w	r5, r4, #8
          H_NEXT(qp) = fp;
 80030d0:	600a      	str	r2, [r1, #0]
      return (void *)H_BLOCK(hp);
 80030d2:	4623      	mov	r3, r4
      H_SIZE(hp) = size;
 80030d4:	9a01      	ldr	r2, [sp, #4]
      H_UNLOCK(heapp);
 80030d6:	4658      	mov	r0, fp
      H_HEAP(hp) = heapp;
 80030d8:	e9c3 9200 	strd	r9, r2, [r3]
      H_UNLOCK(heapp);
 80030dc:	f7ff fa08 	bl	80024f0 <chMtxUnlock>
}
 80030e0:	4628      	mov	r0, r5
 80030e2:	b003      	add	sp, #12
 80030e4:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
        H_PAGES(hp) = NPAGES(ahp, H_BLOCK(hp));
 80030e8:	f104 0208 	add.w	r2, r4, #8
 80030ec:	1a9a      	subs	r2, r3, r2
 80030ee:	10d2      	asrs	r2, r2, #3
        if (bpages > pages) {
 80030f0:	4540      	cmp	r0, r8
        H_PAGES(hp) = NPAGES(ahp, H_BLOCK(hp));
 80030f2:	6062      	str	r2, [r4, #4]
        if (bpages > pages) {
 80030f4:	d9ee      	bls.n	80030d4 <chHeapAllocAligned+0xc4>
          fp = H_BLOCK(ahp) + pages;
 80030f6:	f108 0601 	add.w	r6, r8, #1
 80030fa:	eb03 02c6 	add.w	r2, r3, r6, lsl #3
          H_PAGES(fp) = (bpages - pages) - 1U;
 80030fe:	ea6f 0808 	mvn.w	r8, r8
          H_NEXT(fp) = H_NEXT(hp);
 8003102:	6821      	ldr	r1, [r4, #0]
          H_PAGES(fp) = (bpages - pages) - 1U;
 8003104:	4440      	add	r0, r8
 8003106:	6050      	str	r0, [r2, #4]
          H_NEXT(fp) = H_NEXT(hp);
 8003108:	f843 1036 	str.w	r1, [r3, r6, lsl #3]
          H_NEXT(hp) = fp;
 800310c:	6022      	str	r2, [r4, #0]
 800310e:	e7e1      	b.n	80030d4 <chHeapAllocAligned+0xc4>
          H_NEXT(qp) = H_NEXT(hp);
 8003110:	4625      	mov	r5, r4
 8003112:	4623      	mov	r3, r4
 8003114:	f855 2b08 	ldr.w	r2, [r5], #8
 8003118:	600a      	str	r2, [r1, #0]
 800311a:	e7db      	b.n	80030d4 <chHeapAllocAligned+0xc4>
 800311c:	20000c0c 	.word	0x20000c0c

08003120 <chHeapFree>:
 *
 * @param[in] p         pointer to the memory block to be freed
 *
 * @api
 */
void chHeapFree(void *p) {
 8003120:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  chDbgCheck((p != NULL) && MEM_IS_ALIGNED(p, CH_HEAP_ALIGNMENT));

  /*lint -save -e9087 [11.3] Safe cast.*/
  hp = (heap_header_t *)p - 1U;
  /*lint -restore*/
  heapp = H_HEAP(hp);
 8003122:	e950 7302 	ldrd	r7, r3, [r0, #-8]
  qp = &heapp->header;

  /* Size is converted in number of elementary allocation units.*/
  H_PAGES(hp) = MEM_ALIGN_NEXT(H_SIZE(hp),
 8003126:	3307      	adds	r3, #7
                               CH_HEAP_ALIGNMENT) / CH_HEAP_ALIGNMENT;
 8003128:	08db      	lsrs	r3, r3, #3
  qp = &heapp->header;
 800312a:	1d3d      	adds	r5, r7, #4

  /* Taking heap mutex/semaphore.*/
  H_LOCK(heapp);
 800312c:	370c      	adds	r7, #12
  H_PAGES(hp) = MEM_ALIGN_NEXT(H_SIZE(hp),
 800312e:	f840 3c04 	str.w	r3, [r0, #-4]
void chHeapFree(void *p) {
 8003132:	4606      	mov	r6, r0
  hp = (heap_header_t *)p - 1U;
 8003134:	f1a0 0408 	sub.w	r4, r0, #8
  H_LOCK(heapp);
 8003138:	4638      	mov	r0, r7
 800313a:	f7ff f9b1 	bl	80024a0 <chMtxLock>
  qp = &heapp->header;
 800313e:	462b      	mov	r3, r5

  while (true) {
    chDbgAssert((hp < qp) || (hp >= H_LIMIT(qp)), "within free block");

    if (((qp == &heapp->header) || (hp > qp)) &&
 8003140:	429d      	cmp	r5, r3
        ((H_NEXT(qp) == NULL) || (hp < H_NEXT(qp)))) {
 8003142:	681a      	ldr	r2, [r3, #0]
    if (((qp == &heapp->header) || (hp > qp)) &&
 8003144:	d001      	beq.n	800314a <chHeapFree+0x2a>
 8003146:	42a3      	cmp	r3, r4
 8003148:	d202      	bcs.n	8003150 <chHeapFree+0x30>
 800314a:	b11a      	cbz	r2, 8003154 <chHeapFree+0x34>
        ((H_NEXT(qp) == NULL) || (hp < H_NEXT(qp)))) {
 800314c:	4294      	cmp	r4, r2
 800314e:	d301      	bcc.n	8003154 <chHeapFree+0x34>
        H_PAGES(qp) += H_PAGES(hp) + 1U;
        H_NEXT(qp) = H_NEXT(hp);
      }
      break;
    }
    qp = H_NEXT(qp);
 8003150:	4613      	mov	r3, r2
    chDbgAssert((hp < qp) || (hp >= H_LIMIT(qp)), "within free block");
 8003152:	e7f5      	b.n	8003140 <chHeapFree+0x20>
      H_NEXT(hp) = H_NEXT(qp);
 8003154:	f846 2c08 	str.w	r2, [r6, #-8]
      if (H_LIMIT(hp) == H_NEXT(hp)) {
 8003158:	f856 2c04 	ldr.w	r2, [r6, #-4]
      H_NEXT(qp) = hp;
 800315c:	601c      	str	r4, [r3, #0]
      if (H_LIMIT(hp) == H_NEXT(hp)) {
 800315e:	f856 1c08 	ldr.w	r1, [r6, #-8]
 8003162:	3201      	adds	r2, #1
 8003164:	eb04 00c2 	add.w	r0, r4, r2, lsl #3
 8003168:	4281      	cmp	r1, r0
 800316a:	d00a      	beq.n	8003182 <chHeapFree+0x62>
      if ((H_LIMIT(qp) == hp)) {
 800316c:	6859      	ldr	r1, [r3, #4]
 800316e:	1c4a      	adds	r2, r1, #1
 8003170:	eb03 02c2 	add.w	r2, r3, r2, lsl #3
 8003174:	4294      	cmp	r4, r2
 8003176:	d011      	beq.n	800319c <chHeapFree+0x7c>
  }

  /* Releasing heap mutex/semaphore.*/
  H_UNLOCK(heapp);
 8003178:	4638      	mov	r0, r7

  return;
}
 800317a:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
  H_UNLOCK(heapp);
 800317e:	f7ff b9b7 	b.w	80024f0 <chMtxUnlock>
        H_PAGES(hp) += H_PAGES(H_NEXT(hp)) + 1U;
 8003182:	6848      	ldr	r0, [r1, #4]
 8003184:	4402      	add	r2, r0
 8003186:	f846 2c04 	str.w	r2, [r6, #-4]
        H_NEXT(hp) = H_NEXT(H_NEXT(hp));
 800318a:	680a      	ldr	r2, [r1, #0]
      if ((H_LIMIT(qp) == hp)) {
 800318c:	6859      	ldr	r1, [r3, #4]
        H_NEXT(hp) = H_NEXT(H_NEXT(hp));
 800318e:	f846 2c08 	str.w	r2, [r6, #-8]
      if ((H_LIMIT(qp) == hp)) {
 8003192:	1c4a      	adds	r2, r1, #1
 8003194:	eb03 02c2 	add.w	r2, r3, r2, lsl #3
 8003198:	4294      	cmp	r4, r2
 800319a:	d1ed      	bne.n	8003178 <chHeapFree+0x58>
        H_NEXT(qp) = H_NEXT(hp);
 800319c:	e956 0202 	ldrd	r0, r2, [r6, #-8]
        H_PAGES(qp) += H_PAGES(hp) + 1U;
 80031a0:	3201      	adds	r2, #1
 80031a2:	4411      	add	r1, r2
        H_NEXT(qp) = H_NEXT(hp);
 80031a4:	e9c3 0100 	strd	r0, r1, [r3]
  H_UNLOCK(heapp);
 80031a8:	4638      	mov	r0, r7
}
 80031aa:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
  H_UNLOCK(heapp);
 80031ae:	f7ff b99f 	b.w	80024f0 <chMtxUnlock>
 80031b2:	bf00      	nop
	...

080031c0 <chHeapStatus>:
 *                      free free block found space or @p NULL
 * @return              The number of fragments in the heap.
 *
 * @api
 */
size_t chHeapStatus(memory_heap_t *heapp, size_t *totalp, size_t *largestp) {
 80031c0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  heap_header_t *qp;
  size_t n, tpages, lpages;

  if (heapp == NULL) {
    heapp = &default_heap;
 80031c4:	4c17      	ldr	r4, [pc, #92]	; (8003224 <chHeapStatus+0x64>)
 80031c6:	2800      	cmp	r0, #0
 80031c8:	bf18      	it	ne
 80031ca:	4604      	movne	r4, r0
  }

  H_LOCK(heapp);
 80031cc:	f104 070c 	add.w	r7, r4, #12
 80031d0:	4638      	mov	r0, r7
size_t chHeapStatus(memory_heap_t *heapp, size_t *totalp, size_t *largestp) {
 80031d2:	4688      	mov	r8, r1
 80031d4:	4616      	mov	r6, r2
  H_LOCK(heapp);
 80031d6:	f7ff f963 	bl	80024a0 <chMtxLock>
  tpages = 0U;
  lpages = 0U;
  n = 0U;
  qp = &heapp->header;
  while (H_NEXT(qp) != NULL) {
 80031da:	6863      	ldr	r3, [r4, #4]
 80031dc:	b1f3      	cbz	r3, 800321c <chHeapStatus+0x5c>
  lpages = 0U;
 80031de:	f04f 0c00 	mov.w	ip, #0
  tpages = 0U;
 80031e2:	46e6      	mov	lr, ip
  n = 0U;
 80031e4:	4665      	mov	r5, ip
  while (H_NEXT(qp) != NULL) {
 80031e6:	e9d3 3400 	ldrd	r3, r4, [r3]
 80031ea:	45a4      	cmp	ip, r4
    size_t pages = H_PAGES(H_NEXT(qp));

    /* Updating counters.*/
    n++;
 80031ec:	f105 0501 	add.w	r5, r5, #1
    tpages += pages;
 80031f0:	44a6      	add	lr, r4
    if (pages > lpages) {
 80031f2:	bf38      	it	cc
 80031f4:	46a4      	movcc	ip, r4
  while (H_NEXT(qp) != NULL) {
 80031f6:	2b00      	cmp	r3, #0
 80031f8:	d1f5      	bne.n	80031e6 <chHeapStatus+0x26>

    qp = H_NEXT(qp);
  }

  /* Writing out fragmented free memory.*/
  if (totalp != NULL) {
 80031fa:	f1b8 0f00 	cmp.w	r8, #0
 80031fe:	d003      	beq.n	8003208 <chHeapStatus+0x48>
    *totalp = tpages * CH_HEAP_ALIGNMENT;
 8003200:	ea4f 03ce 	mov.w	r3, lr, lsl #3
 8003204:	f8c8 3000 	str.w	r3, [r8]
  }

  /* Writing out unfragmented free memory.*/
  if (largestp != NULL) {
 8003208:	b116      	cbz	r6, 8003210 <chHeapStatus+0x50>
    *largestp = lpages * CH_HEAP_ALIGNMENT;
 800320a:	ea4f 03cc 	mov.w	r3, ip, lsl #3
 800320e:	6033      	str	r3, [r6, #0]
  }
  H_UNLOCK(heapp);
 8003210:	4638      	mov	r0, r7
 8003212:	f7ff f96d 	bl	80024f0 <chMtxUnlock>

  return n;
}
 8003216:	4628      	mov	r0, r5
 8003218:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  lpages = 0U;
 800321c:	469c      	mov	ip, r3
  tpages = 0U;
 800321e:	469e      	mov	lr, r3
  n = 0U;
 8003220:	461d      	mov	r5, r3
 8003222:	e7ea      	b.n	80031fa <chHeapStatus+0x3a>
 8003224:	20000c0c 	.word	0x20000c0c
	...

08003230 <chPoolObjectInitAligned>:
 *                      automatically
 *
 * @init
 */
void chPoolObjectInitAligned(memory_pool_t *mp, size_t size,
                             unsigned align, memgetfunc_t provider) {
 8003230:	b410      	push	{r4}
  chDbgCheck((mp != NULL) &&
             (size >= sizeof(void *)) &&
             (align >= PORT_NATURAL_ALIGN) &&
             MEM_IS_VALID_ALIGNMENT(align));

  mp->next = NULL;
 8003232:	2400      	movs	r4, #0
  mp->object_size = size;
 8003234:	e9c0 4100 	strd	r4, r1, [r0]
  mp->align = align;
  mp->provider = provider;
 8003238:	e9c0 2302 	strd	r2, r3, [r0, #8]
}
 800323c:	bc10      	pop	{r4}
 800323e:	4770      	bx	lr

08003240 <chPoolLoadArray>:
 */
void chPoolLoadArray(memory_pool_t *mp, void *p, size_t n) {

  chDbgCheck((mp != NULL) && (n != 0U));

  while (n != 0U) {
 8003240:	b18a      	cbz	r2, 8003266 <chPoolLoadArray+0x26>
void chPoolLoadArray(memory_pool_t *mp, void *p, size_t n) {
 8003242:	b500      	push	{lr}
 8003244:	f04f 0c00 	mov.w	ip, #0
 8003248:	f04f 0e30 	mov.w	lr, #48	; 0x30
 800324c:	f38e 8811 	msr	BASEPRI, lr
  chDbgCheckClassI();
  chDbgCheck((mp != NULL) &&
             (objp != NULL) &&
             MEM_IS_ALIGNED(objp, mp->align));

  php->next = mp->next;
 8003250:	6803      	ldr	r3, [r0, #0]
 8003252:	600b      	str	r3, [r1, #0]
  mp->next = php;
 8003254:	6001      	str	r1, [r0, #0]
 8003256:	f38c 8811 	msr	BASEPRI, ip
    p = (void *)(((uint8_t *)p) + mp->object_size);
 800325a:	6843      	ldr	r3, [r0, #4]
  while (n != 0U) {
 800325c:	3a01      	subs	r2, #1
    p = (void *)(((uint8_t *)p) + mp->object_size);
 800325e:	4419      	add	r1, r3
  while (n != 0U) {
 8003260:	d1f4      	bne.n	800324c <chPoolLoadArray+0xc>
}
 8003262:	f85d fb04 	ldr.w	pc, [sp], #4
 8003266:	4770      	bx	lr
	...

08003270 <chPoolAlloc>:
void *chPoolAlloc(memory_pool_t *mp) {
 8003270:	b508      	push	{r3, lr}
 8003272:	2230      	movs	r2, #48	; 0x30
 8003274:	4603      	mov	r3, r0
 8003276:	f382 8811 	msr	BASEPRI, r2
  objp = mp->next;
 800327a:	6800      	ldr	r0, [r0, #0]
  if (objp != NULL) {
 800327c:	b128      	cbz	r0, 800328a <chPoolAlloc+0x1a>
    mp->next = mp->next->next;
 800327e:	6802      	ldr	r2, [r0, #0]
 8003280:	601a      	str	r2, [r3, #0]
 8003282:	2300      	movs	r3, #0
 8003284:	f383 8811 	msr	BASEPRI, r3
}
 8003288:	bd08      	pop	{r3, pc}
  else if (mp->provider != NULL) {
 800328a:	68da      	ldr	r2, [r3, #12]
 800328c:	2a00      	cmp	r2, #0
 800328e:	d0f8      	beq.n	8003282 <chPoolAlloc+0x12>
    objp = mp->provider(mp->object_size, mp->align);
 8003290:	e9d3 0101 	ldrd	r0, r1, [r3, #4]
 8003294:	4790      	blx	r2
 8003296:	2300      	movs	r3, #0
 8003298:	f383 8811 	msr	BASEPRI, r3
}
 800329c:	bd08      	pop	{r3, pc}
 800329e:	bf00      	nop

080032a0 <chPoolFree>:
 80032a0:	2330      	movs	r3, #48	; 0x30
 80032a2:	f383 8811 	msr	BASEPRI, r3
  php->next = mp->next;
 80032a6:	6803      	ldr	r3, [r0, #0]
 80032a8:	600b      	str	r3, [r1, #0]
 80032aa:	2300      	movs	r3, #0
  mp->next = php;
 80032ac:	6001      	str	r1, [r0, #0]
 80032ae:	f383 8811 	msr	BASEPRI, r3
void chPoolFree(memory_pool_t *mp, void *objp) {

  chSysLock();
  chPoolFreeI(mp, objp);
  chSysUnlock();
}
 80032b2:	4770      	bx	lr
	...

080032c0 <chGuardedPoolObjectInitAligned>:
 *
 * @init
 */
void chGuardedPoolObjectInitAligned(guarded_memory_pool_t *gmp,
                                    size_t size,
                                    unsigned align) {
 80032c0:	b410      	push	{r4}
  mp->next = NULL;
 80032c2:	2400      	movs	r4, #0
  mp->object_size = size;
 80032c4:	e9c0 4103 	strd	r4, r1, [r0, #12]
  mp->provider = provider;
 80032c8:	e9c0 2405 	strd	r2, r4, [r0, #20]

  chPoolObjectInitAligned(&gmp->pool, size, align, NULL);
  chSemObjectInit(&gmp->sem, (cnt_t)0);
 80032cc:	4621      	mov	r1, r4
}
 80032ce:	bc10      	pop	{r4}
  chSemObjectInit(&gmp->sem, (cnt_t)0);
 80032d0:	f7fe bf46 	b.w	8002160 <chSemObjectInit>
	...

080032e0 <chGuardedPoolLoadArray>:
 */
void chGuardedPoolLoadArray(guarded_memory_pool_t *gmp, void *p, size_t n) {

  chDbgCheck((gmp != NULL) && (n != 0U));

  while (n != 0U) {
 80032e0:	b1ca      	cbz	r2, 8003316 <chGuardedPoolLoadArray+0x36>
void chGuardedPoolLoadArray(guarded_memory_pool_t *gmp, void *p, size_t n) {
 80032e2:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 80032e6:	4604      	mov	r4, r0
 80032e8:	460d      	mov	r5, r1
 80032ea:	4616      	mov	r6, r2
 80032ec:	f04f 0830 	mov.w	r8, #48	; 0x30
 80032f0:	2700      	movs	r7, #0
 80032f2:	f388 8811 	msr	BASEPRI, r8
  php->next = mp->next;
 80032f6:	68e3      	ldr	r3, [r4, #12]
 80032f8:	602b      	str	r3, [r5, #0]
 * @iclass
 */
static inline void chGuardedPoolFreeI(guarded_memory_pool_t *gmp, void *objp) {

  chPoolFreeI(&gmp->pool, objp);
  chSemSignalI(&gmp->sem);
 80032fa:	4620      	mov	r0, r4
  mp->next = php;
 80032fc:	60e5      	str	r5, [r4, #12]
 80032fe:	f7fe ffff 	bl	8002300 <chSemSignalI>
 */
void chGuardedPoolFree(guarded_memory_pool_t *gmp, void *objp) {

  chSysLock();
  chGuardedPoolFreeI(gmp, objp);
  chSchRescheduleS();
 8003302:	f7fe fc4d 	bl	8001ba0 <chSchRescheduleS>
 8003306:	f387 8811 	msr	BASEPRI, r7
    p = (void *)(((uint8_t *)p) + gmp->pool.object_size);
 800330a:	6923      	ldr	r3, [r4, #16]
  while (n != 0U) {
 800330c:	3e01      	subs	r6, #1
    p = (void *)(((uint8_t *)p) + gmp->pool.object_size);
 800330e:	441d      	add	r5, r3
  while (n != 0U) {
 8003310:	d1ef      	bne.n	80032f2 <chGuardedPoolLoadArray+0x12>
}
 8003312:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 8003316:	4770      	bx	lr
	...

08003320 <chGuardedPoolAllocTimeout>:
                                sysinterval_t timeout) {
 8003320:	b510      	push	{r4, lr}
 8003322:	2330      	movs	r3, #48	; 0x30
 8003324:	4604      	mov	r4, r0
 8003326:	f383 8811 	msr	BASEPRI, r3
  msg = chSemWaitTimeoutS(&gmp->sem, timeout);
 800332a:	f7fe ffa9 	bl	8002280 <chSemWaitTimeoutS>
  if (msg != MSG_OK) {
 800332e:	b988      	cbnz	r0, 8003354 <chGuardedPoolAllocTimeout+0x34>
  objp = mp->next;
 8003330:	68e0      	ldr	r0, [r4, #12]
  if (objp != NULL) {
 8003332:	b128      	cbz	r0, 8003340 <chGuardedPoolAllocTimeout+0x20>
    mp->next = mp->next->next;
 8003334:	6803      	ldr	r3, [r0, #0]
 8003336:	60e3      	str	r3, [r4, #12]
 8003338:	2300      	movs	r3, #0
 800333a:	f383 8811 	msr	BASEPRI, r3
}
 800333e:	bd10      	pop	{r4, pc}
  else if (mp->provider != NULL) {
 8003340:	69a3      	ldr	r3, [r4, #24]
 8003342:	2b00      	cmp	r3, #0
 8003344:	d0f8      	beq.n	8003338 <chGuardedPoolAllocTimeout+0x18>
    objp = mp->provider(mp->object_size, mp->align);
 8003346:	e9d4 0104 	ldrd	r0, r1, [r4, #16]
 800334a:	4798      	blx	r3
 800334c:	2300      	movs	r3, #0
 800334e:	f383 8811 	msr	BASEPRI, r3
}
 8003352:	bd10      	pop	{r4, pc}
    return NULL;
 8003354:	2000      	movs	r0, #0
 8003356:	2300      	movs	r3, #0
 8003358:	f383 8811 	msr	BASEPRI, r3
}
 800335c:	bd10      	pop	{r4, pc}
 800335e:	bf00      	nop

08003360 <chGuardedPoolFree>:
void chGuardedPoolFree(guarded_memory_pool_t *gmp, void *objp) {
 8003360:	b508      	push	{r3, lr}
 8003362:	2230      	movs	r2, #48	; 0x30
 8003364:	f382 8811 	msr	BASEPRI, r2
  php->next = mp->next;
 8003368:	68c2      	ldr	r2, [r0, #12]
 800336a:	600a      	str	r2, [r1, #0]
  mp->next = php;
 800336c:	60c1      	str	r1, [r0, #12]
 800336e:	f7fe ffc7 	bl	8002300 <chSemSignalI>
  chSchRescheduleS();
 8003372:	f7fe fc15 	bl	8001ba0 <chSchRescheduleS>
 8003376:	2300      	movs	r3, #0
 8003378:	f383 8811 	msr	BASEPRI, r3
  chSysUnlock();
}
 800337c:	bd08      	pop	{r3, pc}
 800337e:	bf00      	nop

08003380 <chPipeObjectInit>:
 * @param[in] buf       pointer to the pipe buffer as an array of @p uint8_t
 * @param[in] n         number of elements in the buffer array
 *
 * @init
 */
void chPipeObjectInit(pipe_t *pp, uint8_t *buf, size_t n) {
 8003380:	b510      	push	{r4, lr}
 8003382:	4604      	mov	r4, r0

  pp->buffer = buf;
  pp->rdptr  = buf;
  pp->wrptr  = buf;
  pp->top    = &buf[n];
  pp->cnt    = (size_t)0;
 8003384:	2300      	movs	r3, #0
  pp->top    = &buf[n];
 8003386:	440a      	add	r2, r1
  pp->wrptr  = buf;
 8003388:	e9c4 1102 	strd	r1, r1, [r4, #8]
  pp->reset  = false;
  pp->wtr    = NULL;
  pp->rtr    = NULL;
 800338c:	e9c4 3306 	strd	r3, r3, [r4, #24]
  pp->buffer = buf;
 8003390:	6021      	str	r1, [r4, #0]
  pp->top    = &buf[n];
 8003392:	6062      	str	r2, [r4, #4]
  pp->cnt    = (size_t)0;
 8003394:	6123      	str	r3, [r4, #16]
  pp->reset  = false;
 8003396:	7523      	strb	r3, [r4, #20]
  PC_INIT(pp);
 8003398:	3020      	adds	r0, #32
 800339a:	f7ff f811 	bl	80023c0 <chMtxObjectInit>
  PW_INIT(pp);
 800339e:	f104 0030 	add.w	r0, r4, #48	; 0x30
 80033a2:	f7ff f80d 	bl	80023c0 <chMtxObjectInit>
  PR_INIT(pp);
 80033a6:	f104 0040 	add.w	r0, r4, #64	; 0x40
}
 80033aa:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  PR_INIT(pp);
 80033ae:	f7ff b807 	b.w	80023c0 <chMtxObjectInit>
 80033b2:	bf00      	nop
	...

080033c0 <chPipeReset>:
 *
 * @param[in] pp        the pointer to an initialized @p pipe_t object
 *
 * @api
 */
void chPipeReset(pipe_t *pp) {
 80033c0:	b570      	push	{r4, r5, r6, lr}
 80033c2:	4604      	mov	r4, r0

  chDbgCheck(pp != NULL);

  PC_LOCK(pp);
 80033c4:	f100 0520 	add.w	r5, r0, #32
 80033c8:	4628      	mov	r0, r5
 80033ca:	f7ff f869 	bl	80024a0 <chMtxLock>

  pp->wrptr = pp->buffer;
 80033ce:	6823      	ldr	r3, [r4, #0]
  pp->rdptr = pp->buffer;
  pp->cnt   = (size_t)0;
 80033d0:	2600      	movs	r6, #0
  pp->reset = true;
 80033d2:	2201      	movs	r2, #1
  pp->rdptr = pp->buffer;
 80033d4:	e9c4 3302 	strd	r3, r3, [r4, #8]
  pp->reset = true;
 80033d8:	7522      	strb	r2, [r4, #20]
  pp->cnt   = (size_t)0;
 80033da:	6126      	str	r6, [r4, #16]
 80033dc:	2330      	movs	r3, #48	; 0x30
 80033de:	f383 8811 	msr	BASEPRI, r3

  chSysLock();
  chThdResumeI(&pp->wtr, MSG_RESET);
 80033e2:	f06f 0101 	mvn.w	r1, #1
 80033e6:	f104 0018 	add.w	r0, r4, #24
 80033ea:	f7fe fe21 	bl	8002030 <chThdResumeI>
  chThdResumeI(&pp->rtr, MSG_RESET);
 80033ee:	f06f 0101 	mvn.w	r1, #1
 80033f2:	f104 001c 	add.w	r0, r4, #28
 80033f6:	f7fe fe1b 	bl	8002030 <chThdResumeI>
  chSchRescheduleS();
 80033fa:	f7fe fbd1 	bl	8001ba0 <chSchRescheduleS>
 80033fe:	f386 8811 	msr	BASEPRI, r6
  chSysUnlock();

  PC_UNLOCK(pp);
 8003402:	4628      	mov	r0, r5
}
 8003404:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
  PC_UNLOCK(pp);
 8003408:	f7ff b872 	b.w	80024f0 <chMtxUnlock>
 800340c:	0000      	movs	r0, r0
	...

08003410 <chPipeWriteTimeout>:
 *                      pipe went in reset state.
 *
 * @api
 */
size_t chPipeWriteTimeout(pipe_t *pp, const uint8_t *bp,
                          size_t n, sysinterval_t timeout) {
 8003410:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8003414:	4605      	mov	r5, r0
 8003416:	b085      	sub	sp, #20
  size_t max = n;

  chDbgCheck(n > 0U);

  /* If the pipe is in reset state then returns immediately.*/
  if (pp->reset) {
 8003418:	7d00      	ldrb	r0, [r0, #20]
                          size_t n, sysinterval_t timeout) {
 800341a:	9202      	str	r2, [sp, #8]
  if (pp->reset) {
 800341c:	b120      	cbz	r0, 8003428 <chPipeWriteTimeout+0x18>
    return (size_t)0;
 800341e:	2700      	movs	r7, #0
  }

  PW_UNLOCK(pp);

  return max - n;
}
 8003420:	4638      	mov	r0, r7
 8003422:	b005      	add	sp, #20
 8003424:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  PW_LOCK(pp);
 8003428:	469a      	mov	sl, r3
 800342a:	f105 0330 	add.w	r3, r5, #48	; 0x30
 800342e:	4614      	mov	r4, r2
 8003430:	4618      	mov	r0, r3
 8003432:	460e      	mov	r6, r1
 8003434:	9303      	str	r3, [sp, #12]
 8003436:	f7ff f833 	bl	80024a0 <chMtxLock>
  while (n > 0U) {
 800343a:	2c00      	cmp	r4, #0
 800343c:	d042      	beq.n	80034c4 <chPipeWriteTimeout+0xb4>
  PC_LOCK(pp);
 800343e:	9f02      	ldr	r7, [sp, #8]
 8003440:	f105 0820 	add.w	r8, r5, #32
      chThdResume(&pp->rtr, MSG_OK);
 8003444:	f105 091c 	add.w	r9, r5, #28
  PC_LOCK(pp);
 8003448:	4640      	mov	r0, r8
 800344a:	f7ff f829 	bl	80024a0 <chMtxLock>
 */
static inline size_t chPipeGetSize(const pipe_t *pp) {

  /*lint -save -e9033 [10.8] Perfectly safe pointers
    arithmetic.*/
  return (size_t)(pp->top - pp->buffer);
 800344e:	e9d5 4200 	ldrd	r4, r2, [r5]
 *
 * @api
 */
static inline size_t chPipeGetUsedCount(const pipe_t *pp) {

  return pp->cnt;
 8003452:	692b      	ldr	r3, [r5, #16]
  s1 = (size_t)(pp->top - pp->wrptr);
 8003454:	68a8      	ldr	r0, [r5, #8]
  return (size_t)(pp->top - pp->buffer);
 8003456:	1b14      	subs	r4, r2, r4
 *
 * @api
 */
static inline size_t chPipeGetFreeCount(const pipe_t *pp) {

  return chPipeGetSize(pp) - chPipeGetUsedCount(pp);
 8003458:	1ae4      	subs	r4, r4, r3
 800345a:	42bc      	cmp	r4, r7
 800345c:	bf28      	it	cs
 800345e:	463c      	movcs	r4, r7
 8003460:	eba2 0b00 	sub.w	fp, r2, r0
  pp->cnt += n;
 8003464:	4423      	add	r3, r4
  if (n < s1) {
 8003466:	455c      	cmp	r4, fp
  pp->cnt += n;
 8003468:	612b      	str	r3, [r5, #16]
  if (n < s1) {
 800346a:	d339      	bcc.n	80034e0 <chPipeWriteTimeout+0xd0>
    memcpy((void *)pp->wrptr, (const void *)bp, s1);
 800346c:	465a      	mov	r2, fp
 800346e:	4631      	mov	r1, r6
  else if (n > s1) {
 8003470:	d930      	bls.n	80034d4 <chPipeWriteTimeout+0xc4>
    memcpy((void *)pp->wrptr, (const void *)bp, s1);
 8003472:	f7fc ff1b 	bl	80002ac <memcpy>
    s2 = n - s1;
 8003476:	eba4 020b 	sub.w	r2, r4, fp
    memcpy((void *)pp->buffer, (const void *)bp, s2);
 800347a:	6828      	ldr	r0, [r5, #0]
 800347c:	9201      	str	r2, [sp, #4]
 800347e:	eb06 010b 	add.w	r1, r6, fp
 8003482:	f7fc ff13 	bl	80002ac <memcpy>
    pp->wrptr = pp->buffer + s2;
 8003486:	682b      	ldr	r3, [r5, #0]
 8003488:	9a01      	ldr	r2, [sp, #4]
 800348a:	4413      	add	r3, r2
 800348c:	60ab      	str	r3, [r5, #8]
  PC_UNLOCK(pp);
 800348e:	4640      	mov	r0, r8
 8003490:	f7ff f82e 	bl	80024f0 <chMtxUnlock>
      chThdResume(&pp->rtr, MSG_OK);
 8003494:	2100      	movs	r1, #0
 8003496:	4648      	mov	r0, r9
    if (done == (size_t)0) {
 8003498:	b974      	cbnz	r4, 80034b8 <chPipeWriteTimeout+0xa8>
 800349a:	2330      	movs	r3, #48	; 0x30
 800349c:	f383 8811 	msr	BASEPRI, r3
      msg = chThdSuspendTimeoutS(&pp->wtr, timeout);
 80034a0:	4651      	mov	r1, sl
 80034a2:	f105 0018 	add.w	r0, r5, #24
 80034a6:	f7fe fdb3 	bl	8002010 <chThdSuspendTimeoutS>
 80034aa:	f384 8811 	msr	BASEPRI, r4
      if (msg != MSG_OK) {
 80034ae:	2800      	cmp	r0, #0
 80034b0:	d0ca      	beq.n	8003448 <chPipeWriteTimeout+0x38>
  return max - n;
 80034b2:	9b02      	ldr	r3, [sp, #8]
 80034b4:	1bdf      	subs	r7, r3, r7
 80034b6:	e006      	b.n	80034c6 <chPipeWriteTimeout+0xb6>
      n  -= done;
 80034b8:	1b3f      	subs	r7, r7, r4
      bp += done;
 80034ba:	4426      	add	r6, r4
      chThdResume(&pp->rtr, MSG_OK);
 80034bc:	f7fe fdc8 	bl	8002050 <chThdResume>
  while (n > 0U) {
 80034c0:	2f00      	cmp	r7, #0
 80034c2:	d1c1      	bne.n	8003448 <chPipeWriteTimeout+0x38>
  PC_LOCK(pp);
 80034c4:	9f02      	ldr	r7, [sp, #8]
  PW_UNLOCK(pp);
 80034c6:	9803      	ldr	r0, [sp, #12]
 80034c8:	f7ff f812 	bl	80024f0 <chMtxUnlock>
}
 80034cc:	4638      	mov	r0, r7
 80034ce:	b005      	add	sp, #20
 80034d0:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    memcpy((void *)pp->wrptr, (const void *)bp, n);
 80034d4:	4622      	mov	r2, r4
 80034d6:	f7fc fee9 	bl	80002ac <memcpy>
    pp->wrptr = pp->buffer;
 80034da:	682b      	ldr	r3, [r5, #0]
 80034dc:	60ab      	str	r3, [r5, #8]
 80034de:	e7d6      	b.n	800348e <chPipeWriteTimeout+0x7e>
    memcpy((void *)pp->wrptr, (const void *)bp, n);
 80034e0:	4622      	mov	r2, r4
 80034e2:	4631      	mov	r1, r6
 80034e4:	f7fc fee2 	bl	80002ac <memcpy>
    pp->wrptr += n;
 80034e8:	68ab      	ldr	r3, [r5, #8]
 80034ea:	4423      	add	r3, r4
 80034ec:	60ab      	str	r3, [r5, #8]
 80034ee:	e7ce      	b.n	800348e <chPipeWriteTimeout+0x7e>

080034f0 <chPipeReadTimeout>:
 *                      pipe went in reset state.
 *
 * @api
 */
size_t chPipeReadTimeout(pipe_t *pp, uint8_t *bp,
                         size_t n, sysinterval_t timeout) {
 80034f0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 80034f4:	4604      	mov	r4, r0
 80034f6:	b085      	sub	sp, #20
  size_t max = n;

  chDbgCheck(n > 0U);

  /* If the pipe is in reset state then returns immediately.*/
  if (pp->reset) {
 80034f8:	7d00      	ldrb	r0, [r0, #20]
                         size_t n, sysinterval_t timeout) {
 80034fa:	9202      	str	r2, [sp, #8]
  if (pp->reset) {
 80034fc:	b120      	cbz	r0, 8003508 <chPipeReadTimeout+0x18>
    return (size_t)0;
 80034fe:	2700      	movs	r7, #0
  }

  PR_UNLOCK(pp);

  return max - n;
}
 8003500:	4638      	mov	r0, r7
 8003502:	b005      	add	sp, #20
 8003504:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  PR_LOCK(pp);
 8003508:	469a      	mov	sl, r3
 800350a:	f104 0340 	add.w	r3, r4, #64	; 0x40
 800350e:	4615      	mov	r5, r2
 8003510:	4618      	mov	r0, r3
 8003512:	460e      	mov	r6, r1
 8003514:	9303      	str	r3, [sp, #12]
 8003516:	f7fe ffc3 	bl	80024a0 <chMtxLock>
  while (n > 0U) {
 800351a:	2d00      	cmp	r5, #0
 800351c:	d040      	beq.n	80035a0 <chPipeReadTimeout+0xb0>
  PC_LOCK(pp);
 800351e:	9f02      	ldr	r7, [sp, #8]
 8003520:	f104 0820 	add.w	r8, r4, #32
      chThdResume(&pp->wtr, MSG_OK);
 8003524:	f104 0918 	add.w	r9, r4, #24
  PC_LOCK(pp);
 8003528:	4640      	mov	r0, r8
 800352a:	f7fe ffb9 	bl	80024a0 <chMtxLock>
  s1 = (size_t)(pp->top - pp->rdptr);
 800352e:	e9d4 1303 	ldrd	r1, r3, [r4, #12]
 8003532:	6862      	ldr	r2, [r4, #4]
 8003534:	42bb      	cmp	r3, r7
 8003536:	461d      	mov	r5, r3
 8003538:	eba2 0b01 	sub.w	fp, r2, r1
 800353c:	bf28      	it	cs
 800353e:	463d      	movcs	r5, r7
  pp->cnt -= n;
 8003540:	1b5b      	subs	r3, r3, r5
  if (n < s1) {
 8003542:	455d      	cmp	r5, fp
  pp->cnt -= n;
 8003544:	6123      	str	r3, [r4, #16]
  if (n < s1) {
 8003546:	d339      	bcc.n	80035bc <chPipeReadTimeout+0xcc>
    memcpy((void *)bp, (void *)pp->rdptr, s1);
 8003548:	465a      	mov	r2, fp
 800354a:	4630      	mov	r0, r6
  else if (n > s1) {
 800354c:	d930      	bls.n	80035b0 <chPipeReadTimeout+0xc0>
    memcpy((void *)bp, (void *)pp->rdptr, s1);
 800354e:	f7fc fead 	bl	80002ac <memcpy>
    s2 = n - s1;
 8003552:	eba5 020b 	sub.w	r2, r5, fp
    memcpy((void *)bp, (void *)pp->buffer, s2);
 8003556:	6821      	ldr	r1, [r4, #0]
 8003558:	9201      	str	r2, [sp, #4]
 800355a:	eb06 000b 	add.w	r0, r6, fp
 800355e:	f7fc fea5 	bl	80002ac <memcpy>
    pp->rdptr = pp->buffer + s2;
 8003562:	6823      	ldr	r3, [r4, #0]
 8003564:	9a01      	ldr	r2, [sp, #4]
 8003566:	4413      	add	r3, r2
 8003568:	60e3      	str	r3, [r4, #12]
  PC_UNLOCK(pp);
 800356a:	4640      	mov	r0, r8
 800356c:	f7fe ffc0 	bl	80024f0 <chMtxUnlock>
      chThdResume(&pp->wtr, MSG_OK);
 8003570:	2100      	movs	r1, #0
 8003572:	4648      	mov	r0, r9
    if (done == (size_t)0) {
 8003574:	b975      	cbnz	r5, 8003594 <chPipeReadTimeout+0xa4>
 8003576:	2330      	movs	r3, #48	; 0x30
 8003578:	f383 8811 	msr	BASEPRI, r3
      msg = chThdSuspendTimeoutS(&pp->rtr, timeout);
 800357c:	4651      	mov	r1, sl
 800357e:	f104 001c 	add.w	r0, r4, #28
 8003582:	f7fe fd45 	bl	8002010 <chThdSuspendTimeoutS>
 8003586:	f385 8811 	msr	BASEPRI, r5
      if (msg != MSG_OK) {
 800358a:	2800      	cmp	r0, #0
 800358c:	d0cc      	beq.n	8003528 <chPipeReadTimeout+0x38>
  return max - n;
 800358e:	9b02      	ldr	r3, [sp, #8]
 8003590:	1bdf      	subs	r7, r3, r7
 8003592:	e006      	b.n	80035a2 <chPipeReadTimeout+0xb2>
      n  -= done;
 8003594:	1b7f      	subs	r7, r7, r5
      bp += done;
 8003596:	442e      	add	r6, r5
      chThdResume(&pp->wtr, MSG_OK);
 8003598:	f7fe fd5a 	bl	8002050 <chThdResume>
  while (n > 0U) {
 800359c:	2f00      	cmp	r7, #0
 800359e:	d1c3      	bne.n	8003528 <chPipeReadTimeout+0x38>
  PC_LOCK(pp);
 80035a0:	9f02      	ldr	r7, [sp, #8]
  PR_UNLOCK(pp);
 80035a2:	9803      	ldr	r0, [sp, #12]
 80035a4:	f7fe ffa4 	bl	80024f0 <chMtxUnlock>
}
 80035a8:	4638      	mov	r0, r7
 80035aa:	b005      	add	sp, #20
 80035ac:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    memcpy((void *)bp, (void *)pp->rdptr, n);
 80035b0:	462a      	mov	r2, r5
 80035b2:	f7fc fe7b 	bl	80002ac <memcpy>
    pp->rdptr = pp->buffer;
 80035b6:	6823      	ldr	r3, [r4, #0]
 80035b8:	60e3      	str	r3, [r4, #12]
 80035ba:	e7d6      	b.n	800356a <chPipeReadTimeout+0x7a>
    memcpy((void *)bp, (void *)pp->rdptr, n);
 80035bc:	462a      	mov	r2, r5
 80035be:	4630      	mov	r0, r6
 80035c0:	f7fc fe74 	bl	80002ac <memcpy>
    pp->rdptr += n;
 80035c4:	68e3      	ldr	r3, [r4, #12]
 80035c6:	442b      	add	r3, r5
 80035c8:	60e3      	str	r3, [r4, #12]
 80035ca:	e7ce      	b.n	800356a <chPipeReadTimeout+0x7a>
 80035cc:	0000      	movs	r0, r0
	...

080035d0 <chCacheObjectInit>:
                       oc_hash_header_t *hashp,
                       ucnt_t objn,
                       size_t objsz,
                       void *objvp,
                       oc_readf_t readf,
                       oc_writef_t writef) {
 80035d0:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 80035d4:	4606      	mov	r6, r0
 80035d6:	461f      	mov	r7, r3
 80035d8:	4689      	mov	r9, r1
             ((hashn & (hashn - (ucnt_t)1)) == (ucnt_t)0) &&
             (objn > (ucnt_t)0) && (hashn >= objn) &&
             (objsz >= sizeof (oc_object_t)) &&
             ((objsz & (PORT_NATURAL_ALIGN - 1U)) == 0U));

  chSemObjectInit(&ocp->cache_sem, (cnt_t)1);
 80035da:	3024      	adds	r0, #36	; 0x24
 80035dc:	2101      	movs	r1, #1
                       oc_writef_t writef) {
 80035de:	4615      	mov	r5, r2
 80035e0:	9c09      	ldr	r4, [sp, #36]	; 0x24
 80035e2:	f8dd 8020 	ldr.w	r8, [sp, #32]
  chSemObjectInit(&ocp->cache_sem, (cnt_t)1);
 80035e6:	f7fe fdbb 	bl	8002160 <chSemObjectInit>
  chSemObjectInit(&ocp->lru_sem, (cnt_t)objn);
 80035ea:	4639      	mov	r1, r7
 80035ec:	f106 0030 	add.w	r0, r6, #48	; 0x30
 80035f0:	f7fe fdb6 	bl	8002160 <chSemObjectInit>
  ocp->hashn            = hashn;
  ocp->hashp            = hashp;
  ocp->objn             = objn;
  ocp->objvp            = objvp;
  ocp->readf            = readf;
 80035f4:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 80035f6:	63f3      	str	r3, [r6, #60]	; 0x3c
  ocp->writef           = writef;
 80035f8:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 80035fa:	6433      	str	r3, [r6, #64]	; 0x40
  ocp->hashp            = hashp;
 80035fc:	e9c6 9500 	strd	r9, r5, [r6]
  /* Hash headers initialization.*/
  do {
    hashp->hash_next = (oc_object_t *)hashp;
    hashp->hash_prev = (oc_object_t *)hashp;
    hashp++;
  } while (hashp < &ocp->hashp[ocp->hashn]);
 8003600:	eb05 01c9 	add.w	r1, r5, r9, lsl #3
  ocp->lru.hash_next    = NULL;
 8003604:	2300      	movs	r3, #0
  ocp->lru.lru_next     = (oc_object_t *)&ocp->lru;
 8003606:	f106 0914 	add.w	r9, r6, #20
  ocp->lru.hash_prev    = NULL;
 800360a:	e9c6 3305 	strd	r3, r3, [r6, #20]
  ocp->lru.lru_prev     = (oc_object_t *)&ocp->lru;
 800360e:	e9c6 9907 	strd	r9, r9, [r6, #28]
  ocp->objn             = objn;
 8003612:	60b7      	str	r7, [r6, #8]
  ocp->objvp            = objvp;
 8003614:	6134      	str	r4, [r6, #16]
    hashp->hash_prev = (oc_object_t *)hashp;
 8003616:	e9c5 5500 	strd	r5, r5, [r5]
    hashp++;
 800361a:	3508      	adds	r5, #8
  } while (hashp < &ocp->hashp[ocp->hashn]);
 800361c:	42a9      	cmp	r1, r5
 800361e:	d8fa      	bhi.n	8003616 <chCacheObjectInit+0x46>

  /* Object headers initialization.*/
  do {
    oc_object_t *objp = (oc_object_t *)objvp;

    chSemObjectInit(&objp->obj_sem, (cnt_t)1);
 8003620:	f04f 0a01 	mov.w	sl, #1
    LRU_INSERT_HEAD(ocp, objp);
    objp->obj_group = 0U;
 8003624:	2500      	movs	r5, #0
    chSemObjectInit(&objp->obj_sem, (cnt_t)1);
 8003626:	f104 0018 	add.w	r0, r4, #24
 800362a:	2101      	movs	r1, #1
 800362c:	f7fe fd98 	bl	8002160 <chSemObjectInit>
    LRU_INSERT_HEAD(ocp, objp);
 8003630:	69f3      	ldr	r3, [r6, #28]
    objp->obj_key   = 0U;
    objp->obj_flags = OC_FLAG_INLRU;
    objp->dptr      = NULL;
    objvp = (void *)((uint8_t *)objvp + objsz);
    objn--;
  } while (objn > (ucnt_t)0);
 8003632:	3f01      	subs	r7, #1
    LRU_INSERT_HEAD(ocp, objp);
 8003634:	e9c4 3902 	strd	r3, r9, [r4, #8]
 8003638:	60dc      	str	r4, [r3, #12]
 800363a:	61f4      	str	r4, [r6, #28]
    objp->obj_key   = 0U;
 800363c:	e9c4 5504 	strd	r5, r5, [r4, #16]
    objp->dptr      = NULL;
 8003640:	e9c4 a509 	strd	sl, r5, [r4, #36]	; 0x24
    objvp = (void *)((uint8_t *)objvp + objsz);
 8003644:	4444      	add	r4, r8
  } while (objn > (ucnt_t)0);
 8003646:	d1ee      	bne.n	8003626 <chCacheObjectInit+0x56>
}
 8003648:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 800364c:	0000      	movs	r0, r0
	...

08003650 <chCacheGetObject>:
 *
 * @api
 */
oc_object_t *chCacheGetObject(objects_cache_t *ocp,
                              uint32_t group,
                              uint32_t key) {
 8003650:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 8003654:	2330      	movs	r3, #48	; 0x30
 8003656:	b082      	sub	sp, #8
 8003658:	4605      	mov	r5, r0
 800365a:	460f      	mov	r7, r1
 800365c:	4614      	mov	r4, r2
 800365e:	f383 8811 	msr	BASEPRI, r3
  hhp  = &ocp->hashp[OC_HASH_FUNCTION(ocp, group, key)];
 8003662:	6803      	ldr	r3, [r0, #0]
 8003664:	188e      	adds	r6, r1, r2
 8003666:	f103 3cff 	add.w	ip, r3, #4294967295	; 0xffffffff
 800366a:	ea0c 0c06 	and.w	ip, ip, r6
 800366e:	6843      	ldr	r3, [r0, #4]
  objp = hhp->hash_next;
 8003670:	f853 103c 	ldr.w	r1, [r3, ip, lsl #3]
  hhp  = &ocp->hashp[OC_HASH_FUNCTION(ocp, group, key)];
 8003674:	eb03 0ccc 	add.w	ip, r3, ip, lsl #3
  while (objp != (oc_object_t *)hhp) {
 8003678:	458c      	cmp	ip, r1
 800367a:	d103      	bne.n	8003684 <chCacheGetObject+0x34>
 800367c:	e01c      	b.n	80036b8 <chCacheGetObject+0x68>
    objp = objp->hash_next;
 800367e:	6809      	ldr	r1, [r1, #0]
  while (objp != (oc_object_t *)hhp) {
 8003680:	458c      	cmp	ip, r1
 8003682:	d019      	beq.n	80036b8 <chCacheGetObject+0x68>
    if ((objp->obj_key == key) && (objp->obj_group == group)) {
 8003684:	694b      	ldr	r3, [r1, #20]
 8003686:	429c      	cmp	r4, r3
 8003688:	d1f9      	bne.n	800367e <chCacheGetObject+0x2e>
 800368a:	690b      	ldr	r3, [r1, #16]
 800368c:	429f      	cmp	r7, r3
 800368e:	d1f6      	bne.n	800367e <chCacheGetObject+0x2e>
 */
static inline cnt_t chSemGetCounterI(const semaphore_t *sp) {

  chDbgCheckClassI();

  return sp->cnt;
 8003690:	6a0b      	ldr	r3, [r1, #32]
    chDbgAssert((objp->obj_flags & OC_FLAG_INHASH) == OC_FLAG_INHASH,
                "not in hash");

    /* Cache hit, checking if the buffer is owned by some
       other thread.*/
    if (chSemGetCounterI(&objp->obj_sem) > (cnt_t)0) {
 8003692:	2b00      	cmp	r3, #0
 8003694:	dd4e      	ble.n	8003734 <chCacheGetObject+0xe4>
      chDbgAssert((objp->obj_flags & OC_FLAG_INLRU) == OC_FLAG_INLRU,
                  "not in LRU");

      /* Removing the object from LRU, now it is "owned".*/
      LRU_REMOVE(objp);
      objp->obj_flags &= ~OC_FLAG_INLRU;
 8003696:	6a4a      	ldr	r2, [r1, #36]	; 0x24
      LRU_REMOVE(objp);
 8003698:	e9d1 0402 	ldrd	r0, r4, [r1, #8]
      objp->obj_flags &= ~OC_FLAG_INLRU;
 800369c:	f022 0201 	bic.w	r2, r2, #1
  sp->cnt--;
 80036a0:	3b01      	subs	r3, #1
      LRU_REMOVE(objp);
 80036a2:	60a0      	str	r0, [r4, #8]
 80036a4:	60c4      	str	r4, [r0, #12]
 80036a6:	e9c1 3208 	strd	r3, r2, [r1, #32]
 80036aa:	2300      	movs	r3, #0
 80036ac:	f383 8811 	msr	BASEPRI, r3

  /* Out of critical section and returning the object.*/
  chSysUnlock();

  return objp;
}
 80036b0:	4608      	mov	r0, r1
 80036b2:	b002      	add	sp, #8
 80036b4:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    (void) chSemWaitS(&ocp->lru_sem);
 80036b8:	f105 0830 	add.w	r8, r5, #48	; 0x30
 80036bc:	f04f 0a00 	mov.w	sl, #0
    objp->obj_flags = OC_FLAG_INHASH | OC_FLAG_FORGET;
 80036c0:	f04f 0922 	mov.w	r9, #34	; 0x22
 80036c4:	e00a      	b.n	80036dc <chCacheGetObject+0x8c>
 80036c6:	f38a 8811 	msr	BASEPRI, sl
    (void) ocp->writef(ocp, objp, true);
 80036ca:	2201      	movs	r2, #1
 80036cc:	6c2b      	ldr	r3, [r5, #64]	; 0x40
    objp->obj_flags = OC_FLAG_INHASH | OC_FLAG_FORGET;
 80036ce:	f8c1 9024 	str.w	r9, [r1, #36]	; 0x24
    (void) ocp->writef(ocp, objp, true);
 80036d2:	4628      	mov	r0, r5
 80036d4:	4798      	blx	r3
 80036d6:	2330      	movs	r3, #48	; 0x30
 80036d8:	f383 8811 	msr	BASEPRI, r3
    (void) chSemWaitS(&ocp->lru_sem);
 80036dc:	4640      	mov	r0, r8
 80036de:	f7fe fd8f 	bl	8002200 <chSemWaitS>
    objp = ocp->lru.lru_prev;
 80036e2:	6a29      	ldr	r1, [r5, #32]
 80036e4:	e9d1 3208 	ldrd	r3, r2, [r1, #32]
    LRU_REMOVE(objp);
 80036e8:	e9d1 0c02 	ldrd	r0, ip, [r1, #8]
 80036ec:	3b01      	subs	r3, #1
 80036ee:	f8cc 0008 	str.w	r0, [ip, #8]
 80036f2:	f8c0 c00c 	str.w	ip, [r0, #12]
    objp->obj_flags &= ~OC_FLAG_INLRU;
 80036f6:	f022 0001 	bic.w	r0, r2, #1
 80036fa:	e9c1 3008 	strd	r3, r0, [r1, #32]
    if ((objp->obj_flags & OC_FLAG_LAZYWRITE) == 0U) {
 80036fe:	06d0      	lsls	r0, r2, #27
 8003700:	d4e1      	bmi.n	80036c6 <chCacheGetObject+0x76>
      if ((objp->obj_flags & OC_FLAG_INHASH) != 0U) {
 8003702:	0793      	lsls	r3, r2, #30
 8003704:	d504      	bpl.n	8003710 <chCacheGetObject+0xc0>
        HASH_REMOVE(objp);
 8003706:	e9d1 2300 	ldrd	r2, r3, [r1]
 800370a:	601a      	str	r2, [r3, #0]
 800370c:	680a      	ldr	r2, [r1, #0]
 800370e:	6053      	str	r3, [r2, #4]
    HASH_INSERT(ocp, objp, group, key);
 8003710:	e9d5 3200 	ldrd	r3, r2, [r5]
 8003714:	3b01      	subs	r3, #1
 8003716:	401e      	ands	r6, r3
    objp->obj_flags = OC_FLAG_INHASH | OC_FLAG_NOTSYNC;
 8003718:	230a      	movs	r3, #10
 800371a:	624b      	str	r3, [r1, #36]	; 0x24
    HASH_INSERT(ocp, objp, group, key);
 800371c:	f852 3036 	ldr.w	r3, [r2, r6, lsl #3]
    objp->obj_group = group;
 8003720:	610f      	str	r7, [r1, #16]
    HASH_INSERT(ocp, objp, group, key);
 8003722:	eb02 00c6 	add.w	r0, r2, r6, lsl #3
 8003726:	e9c1 3000 	strd	r3, r0, [r1]
    objp->obj_key   = key;
 800372a:	614c      	str	r4, [r1, #20]
    HASH_INSERT(ocp, objp, group, key);
 800372c:	6059      	str	r1, [r3, #4]
 800372e:	f842 1036 	str.w	r1, [r2, r6, lsl #3]
 8003732:	e7ba      	b.n	80036aa <chCacheGetObject+0x5a>
      (void) chSemWaitS(&objp->obj_sem);
 8003734:	f101 0018 	add.w	r0, r1, #24
 8003738:	9101      	str	r1, [sp, #4]
 800373a:	f7fe fd61 	bl	8002200 <chSemWaitS>
 800373e:	9901      	ldr	r1, [sp, #4]
 8003740:	e7b3      	b.n	80036aa <chCacheGetObject+0x5a>
 8003742:	bf00      	nop
	...

08003750 <chCacheReleaseObjectI>:
  chDbgAssert(chSemGetCounterI(&objp->obj_sem) <= (cnt_t)0,
              "semaphore counter greater than 0");

  /* If some thread is waiting for this specific buffer then it is
     handed directly without going through the LRU.*/
  if (chSemGetCounterI(&objp->obj_sem) < (cnt_t)0) {
 8003750:	6a0b      	ldr	r3, [r1, #32]
 8003752:	2b00      	cmp	r3, #0
                           oc_object_t *objp) {
 8003754:	b510      	push	{r4, lr}
    /* Clearing all flags except those that are still meaningful, note,
       OC_FLAG_NOTSYNC and OC_FLAG_LAZYWRITE are passed, the other thread
       will handle them.*/
    objp->obj_flags &= OC_FLAG_INHASH | OC_FLAG_NOTSYNC | OC_FLAG_LAZYWRITE;
 8003756:	6a4b      	ldr	r3, [r1, #36]	; 0x24
                           oc_object_t *objp) {
 8003758:	460c      	mov	r4, r1
  if (chSemGetCounterI(&objp->obj_sem) < (cnt_t)0) {
 800375a:	db2f      	blt.n	80037bc <chCacheReleaseObjectI+0x6c>
    return;
  }

  /* If the object specifies OC_FLAG_NOTSYNC then it must be invalidated
     and removed from the hash table.*/
  if ((objp->obj_flags & OC_FLAG_NOTSYNC) != 0U) {
 800375c:	0719      	lsls	r1, r3, #28
 800375e:	d414      	bmi.n	800378a <chCacheReleaseObjectI+0x3a>
    objp->obj_key   = 0U;
    objp->obj_flags = OC_FLAG_INLRU;
  }
  else {
    /* LRU insertion point depends on the OC_FLAG_FORGET flag.*/
    if ((objp->obj_flags & OC_FLAG_FORGET) == 0U) {
 8003760:	069a      	lsls	r2, r3, #26
 8003762:	d423      	bmi.n	80037ac <chCacheReleaseObjectI+0x5c>
      /* Placing it on head.*/
      LRU_INSERT_HEAD(ocp, objp);
 8003764:	69c2      	ldr	r2, [r0, #28]
 8003766:	f100 0114 	add.w	r1, r0, #20
 800376a:	e9c4 2102 	strd	r2, r1, [r4, #8]
 800376e:	60d4      	str	r4, [r2, #12]
 8003770:	61c4      	str	r4, [r0, #28]
    }
    else {
      /* Low priority data, placing it on tail.*/
      LRU_INSERT_TAIL(ocp, objp);
    }
    objp->obj_flags &= OC_FLAG_INHASH | OC_FLAG_LAZYWRITE;
 8003772:	f003 0312 	and.w	r3, r3, #18
    objp->obj_flags |= OC_FLAG_INLRU;
 8003776:	f043 0301 	orr.w	r3, r3, #1
 800377a:	6263      	str	r3, [r4, #36]	; 0x24
  }

  /* Increasing the LRU counter semaphore.*/
  chSemSignalI(&ocp->lru_sem);
 800377c:	3030      	adds	r0, #48	; 0x30
 800377e:	f7fe fdbf 	bl	8002300 <chSemSignalI>
  sp->cnt++;
 8003782:	6a23      	ldr	r3, [r4, #32]
 8003784:	3301      	adds	r3, #1
 8003786:	6223      	str	r3, [r4, #32]

  /* Releasing the object, we know there are no threads waiting so
     using the "fast" signal variant.*/
  chSemFastSignalI(&objp->obj_sem);
}
 8003788:	bd10      	pop	{r4, pc}
    HASH_REMOVE(objp);
 800378a:	e9d4 3100 	ldrd	r3, r1, [r4]
    LRU_INSERT_TAIL(ocp, objp);
 800378e:	6a02      	ldr	r2, [r0, #32]
    HASH_REMOVE(objp);
 8003790:	600b      	str	r3, [r1, #0]
 8003792:	6059      	str	r1, [r3, #4]
    LRU_INSERT_TAIL(ocp, objp);
 8003794:	f100 0114 	add.w	r1, r0, #20
 8003798:	e9c4 1202 	strd	r1, r2, [r4, #8]
    objp->obj_group = 0U;
 800379c:	2300      	movs	r3, #0
    objp->obj_flags = OC_FLAG_INLRU;
 800379e:	2101      	movs	r1, #1
    LRU_INSERT_TAIL(ocp, objp);
 80037a0:	6094      	str	r4, [r2, #8]
 80037a2:	6204      	str	r4, [r0, #32]
    objp->obj_key   = 0U;
 80037a4:	e9c4 3304 	strd	r3, r3, [r4, #16]
    objp->obj_flags = OC_FLAG_INLRU;
 80037a8:	6261      	str	r1, [r4, #36]	; 0x24
 80037aa:	e7e7      	b.n	800377c <chCacheReleaseObjectI+0x2c>
      LRU_INSERT_TAIL(ocp, objp);
 80037ac:	6a02      	ldr	r2, [r0, #32]
 80037ae:	f100 0114 	add.w	r1, r0, #20
 80037b2:	e9c4 1202 	strd	r1, r2, [r4, #8]
 80037b6:	6094      	str	r4, [r2, #8]
 80037b8:	6204      	str	r4, [r0, #32]
 80037ba:	e7da      	b.n	8003772 <chCacheReleaseObjectI+0x22>
    objp->obj_flags &= OC_FLAG_INHASH | OC_FLAG_NOTSYNC | OC_FLAG_LAZYWRITE;
 80037bc:	f003 031a 	and.w	r3, r3, #26
}
 80037c0:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    chSemSignalI(&objp->obj_sem);
 80037c4:	f101 0018 	add.w	r0, r1, #24
    objp->obj_flags &= OC_FLAG_INHASH | OC_FLAG_NOTSYNC | OC_FLAG_LAZYWRITE;
 80037c8:	624b      	str	r3, [r1, #36]	; 0x24
    chSemSignalI(&objp->obj_sem);
 80037ca:	f7fe bd99 	b.w	8002300 <chSemSignalI>
 80037ce:	bf00      	nop

080037d0 <chCacheReadObject>:
 *
 * @api
 */
bool chCacheReadObject(objects_cache_t *ocp,
                       oc_object_t *objp,
                       bool async) {
 80037d0:	b430      	push	{r4, r5}

  /* Marking it as OC_FLAG_NOTSYNC because the read operation is going
     to corrupt it in case of failure. It is responsibility of the read
     implementation to clear it if the operation succeeds.*/
  objp->obj_flags |= OC_FLAG_NOTSYNC;
 80037d2:	6a4c      	ldr	r4, [r1, #36]	; 0x24

  return ocp->readf(ocp, objp, async);
 80037d4:	6bc5      	ldr	r5, [r0, #60]	; 0x3c
  objp->obj_flags |= OC_FLAG_NOTSYNC;
 80037d6:	f044 0408 	orr.w	r4, r4, #8
 80037da:	624c      	str	r4, [r1, #36]	; 0x24
  return ocp->readf(ocp, objp, async);
 80037dc:	462b      	mov	r3, r5
}
 80037de:	bc30      	pop	{r4, r5}
  return ocp->readf(ocp, objp, async);
 80037e0:	4718      	bx	r3
 80037e2:	bf00      	nop
	...

080037f0 <__ch_delegate_fn0>:
 *
 * @param[in] argsp     the list of arguments
 * @return              The function return value.
 */
msg_t __ch_delegate_fn0(va_list *argsp) {
  delegate_fn0_t fn0 = (delegate_fn0_t)va_arg(*argsp, delegate_fn0_t);
 80037f0:	6803      	ldr	r3, [r0, #0]
 80037f2:	1d1a      	adds	r2, r3, #4
 80037f4:	6002      	str	r2, [r0, #0]
  return fn0();
 80037f6:	681b      	ldr	r3, [r3, #0]
 80037f8:	4718      	bx	r3
 80037fa:	bf00      	nop
 80037fc:	0000      	movs	r0, r0
	...

08003800 <__ch_delegate_fn1>:
 *
 * @param[in] argsp     the list of arguments
 * @return              The function return value.
 */
msg_t __ch_delegate_fn1(va_list *argsp) {
  delegate_fn1_t fn1 = (delegate_fn1_t)va_arg(*argsp, delegate_fn1_t);
 8003800:	6801      	ldr	r1, [r0, #0]
msg_t __ch_delegate_fn1(va_list *argsp) {
 8003802:	4603      	mov	r3, r0
  delegate_fn1_t fn1 = (delegate_fn1_t)va_arg(*argsp, delegate_fn1_t);
 8003804:	460a      	mov	r2, r1
 8003806:	1d08      	adds	r0, r1, #4
msg_t __ch_delegate_fn1(va_list *argsp) {
 8003808:	b410      	push	{r4}
  delegate_fn1_t fn1 = (delegate_fn1_t)va_arg(*argsp, delegate_fn1_t);
 800380a:	6018      	str	r0, [r3, #0]
 800380c:	f852 4b08 	ldr.w	r4, [r2], #8
  msg_t p1 = (msg_t)va_arg(*argsp, msg_t);
  return fn1(p1);
 8003810:	6848      	ldr	r0, [r1, #4]
  msg_t p1 = (msg_t)va_arg(*argsp, msg_t);
 8003812:	601a      	str	r2, [r3, #0]
  return fn1(p1);
 8003814:	4623      	mov	r3, r4
}
 8003816:	bc10      	pop	{r4}
  return fn1(p1);
 8003818:	4718      	bx	r3
 800381a:	bf00      	nop
 800381c:	0000      	movs	r0, r0
	...

08003820 <__ch_delegate_fn2>:
 *
 * @param[in] argsp     the list of arguments
 * @return              The function return value.
 */
msg_t __ch_delegate_fn2(va_list *argsp) {
  delegate_fn2_t fn2 = (delegate_fn2_t)va_arg(*argsp, delegate_fn2_t);
 8003820:	6802      	ldr	r2, [r0, #0]
msg_t __ch_delegate_fn2(va_list *argsp) {
 8003822:	b430      	push	{r4, r5}
 8003824:	4603      	mov	r3, r0
  delegate_fn2_t fn2 = (delegate_fn2_t)va_arg(*argsp, delegate_fn2_t);
 8003826:	1d11      	adds	r1, r2, #4
  msg_t p1 = (msg_t)va_arg(*argsp, msg_t);
 8003828:	6850      	ldr	r0, [r2, #4]
  delegate_fn2_t fn2 = (delegate_fn2_t)va_arg(*argsp, delegate_fn2_t);
 800382a:	6019      	str	r1, [r3, #0]
 800382c:	6814      	ldr	r4, [r2, #0]
  msg_t p2 = (msg_t)va_arg(*argsp, msg_t);
  return fn2(p1, p2);
 800382e:	6891      	ldr	r1, [r2, #8]
  msg_t p2 = (msg_t)va_arg(*argsp, msg_t);
 8003830:	f102 050c 	add.w	r5, r2, #12
 8003834:	601d      	str	r5, [r3, #0]
  return fn2(p1, p2);
 8003836:	4623      	mov	r3, r4
}
 8003838:	bc30      	pop	{r4, r5}
  return fn2(p1, p2);
 800383a:	4718      	bx	r3
 800383c:	0000      	movs	r0, r0
	...

08003840 <__ch_delegate_fn3>:
 *
 * @param[in] argsp     the list of arguments
 * @return              The function return value.
 */
msg_t __ch_delegate_fn3(va_list *argsp) {
  delegate_fn3_t fn3 = (delegate_fn3_t)va_arg(*argsp, delegate_fn3_t);
 8003840:	6803      	ldr	r3, [r0, #0]
msg_t __ch_delegate_fn3(va_list *argsp) {
 8003842:	b430      	push	{r4, r5}
 8003844:	4602      	mov	r2, r0
  delegate_fn3_t fn3 = (delegate_fn3_t)va_arg(*argsp, delegate_fn3_t);
 8003846:	1d1c      	adds	r4, r3, #4
  msg_t p1 = (msg_t)va_arg(*argsp, msg_t);
  msg_t p2 = (msg_t)va_arg(*argsp, msg_t);
 8003848:	e9d3 0101 	ldrd	r0, r1, [r3, #4]
  delegate_fn3_t fn3 = (delegate_fn3_t)va_arg(*argsp, delegate_fn3_t);
 800384c:	6014      	str	r4, [r2, #0]
 800384e:	681c      	ldr	r4, [r3, #0]
  msg_t p3 = (msg_t)va_arg(*argsp, msg_t);
 8003850:	f103 0510 	add.w	r5, r3, #16
 8003854:	6015      	str	r5, [r2, #0]
  return fn3(p1, p2, p3);
 8003856:	68da      	ldr	r2, [r3, #12]
 8003858:	4623      	mov	r3, r4
}
 800385a:	bc30      	pop	{r4, r5}
  return fn3(p1, p2, p3);
 800385c:	4718      	bx	r3
 800385e:	bf00      	nop

08003860 <__ch_delegate_fn4>:
 *
 * @param[in] argsp     the list of arguments
 * @return              The function return value.
 */
msg_t __ch_delegate_fn4(va_list *argsp) {
  delegate_fn4_t fn4 = (delegate_fn4_t)va_arg(*argsp, delegate_fn4_t);
 8003860:	6803      	ldr	r3, [r0, #0]
msg_t __ch_delegate_fn4(va_list *argsp) {
 8003862:	b430      	push	{r4, r5}
 8003864:	4684      	mov	ip, r0
  delegate_fn4_t fn4 = (delegate_fn4_t)va_arg(*argsp, delegate_fn4_t);
 8003866:	1d1c      	adds	r4, r3, #4
  msg_t p1 = (msg_t)va_arg(*argsp, msg_t);
  msg_t p2 = (msg_t)va_arg(*argsp, msg_t);
 8003868:	e9d3 0101 	ldrd	r0, r1, [r3, #4]
  msg_t p3 = (msg_t)va_arg(*argsp, msg_t);
 800386c:	68da      	ldr	r2, [r3, #12]
  delegate_fn4_t fn4 = (delegate_fn4_t)va_arg(*argsp, delegate_fn4_t);
 800386e:	f8cc 4000 	str.w	r4, [ip]
 8003872:	681c      	ldr	r4, [r3, #0]
  msg_t p4 = (msg_t)va_arg(*argsp, msg_t);
 8003874:	f103 0514 	add.w	r5, r3, #20
 8003878:	f8cc 5000 	str.w	r5, [ip]
  return fn4(p1, p2, p3, p4);
 800387c:	691b      	ldr	r3, [r3, #16]
 800387e:	46a4      	mov	ip, r4
}
 8003880:	bc30      	pop	{r4, r5}
  return fn4(p1, p2, p3, p4);
 8003882:	4760      	bx	ip
	...

08003890 <chDelegateCallVeneer>:
 * @param[in] veneer    pointer to the veneer function to be called
 * @param[in] ...       variable number of parameters
 * @return              The function return value casted to msg_t. It is
 *                      garbage for functions returning @p void.
 */
msg_t chDelegateCallVeneer(thread_t *tp, delegate_veneer_t veneer, ...) {
 8003890:	b40e      	push	{r1, r2, r3}
 8003892:	b510      	push	{r4, lr}
 8003894:	b085      	sub	sp, #20
 8003896:	ab07      	add	r3, sp, #28

  va_start(args, veneer);

  /* Preparing the call message.*/
  cm.veneer = veneer;
  cm.argsp  = &args;
 8003898:	aa01      	add	r2, sp, #4
msg_t chDelegateCallVeneer(thread_t *tp, delegate_veneer_t veneer, ...) {
 800389a:	f853 4b04 	ldr.w	r4, [r3], #4
  cm.argsp  = &args;
 800389e:	9203      	str	r2, [sp, #12]
  (void)cm; /* Suppresses a lint warning.*/

  /* Sending the message to the dispatcher thread, the return value is
     contained in the returned message.*/
  msg = chMsgSend(tp, (msg_t)&cm);
 80038a0:	a902      	add	r1, sp, #8
  cm.veneer = veneer;
 80038a2:	e9cd 3401 	strd	r3, r4, [sp, #4]
  msg = chMsgSend(tp, (msg_t)&cm);
 80038a6:	f7ff f933 	bl	8002b10 <chMsgSend>

  va_end(args);

  return msg;
}
 80038aa:	b005      	add	sp, #20
 80038ac:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
 80038b0:	b003      	add	sp, #12
 80038b2:	4770      	bx	lr
	...

080038c0 <chDelegateDispatch>:
 *          are sending messages then the requests are served in priority
 *          order.
 *
 * @api
 */
void chDelegateDispatch(void) {
 80038c0:	b510      	push	{r4, lr}
 80038c2:	2330      	movs	r3, #48	; 0x30
 80038c4:	f383 8811 	msr	BASEPRI, r3
  tp = chMsgWaitS();
 80038c8:	f7ff f942 	bl	8002b50 <chMsgWaitS>
 80038cc:	2300      	movs	r3, #0
 80038ce:	4604      	mov	r4, r0
 80038d0:	f383 8811 	msr	BASEPRI, r3
  thread_t *tp;
  const call_message_t *cmp;
  msg_t ret;

  tp = chMsgWait();
  cmp = (const call_message_t *)chMsgGet(tp);
 80038d4:	6a83      	ldr	r3, [r0, #40]	; 0x28
  ret = cmp->veneer(cmp->argsp);
 80038d6:	e9d3 2000 	ldrd	r2, r0, [r3]
 80038da:	4790      	blx	r2
 80038dc:	4601      	mov	r1, r0

  chMsgRelease(tp, ret);
 80038de:	4620      	mov	r0, r4
}
 80038e0:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  chMsgRelease(tp, ret);
 80038e4:	f7ff b94c 	b.w	8002b80 <chMsgRelease>
	...

080038f0 <chCoreAllocAlignedI>:
 *
 * @iclass
 */
static inline void *chCoreAllocAlignedI(size_t size, unsigned align) {

  return chCoreAllocAlignedWithOffsetI(size, align, 0U);
 80038f0:	2200      	movs	r2, #0
 80038f2:	f7ff bb35 	b.w	8002f60 <chCoreAllocFromTopI>
 80038f6:	bf00      	nop
	...

08003900 <dyn_create_object_heap>:

#if CH_FACTORY_REQUIRES_HEAP || defined(__DOXYGEN__)
static dyn_element_t *dyn_create_object_heap(const char *name,
                                             dyn_list_t *dlp,
                                             size_t size,
                                             unsigned align) {
 8003900:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  dyn_element_t *p = dlp->next;
 8003904:	680c      	ldr	r4, [r1, #0]
  while (p != (dyn_element_t *)dlp) {
 8003906:	42a1      	cmp	r1, r4
                                             unsigned align) {
 8003908:	460e      	mov	r6, r1
 800390a:	4605      	mov	r5, r0
 800390c:	4617      	mov	r7, r2
 800390e:	4698      	mov	r8, r3
  while (p != (dyn_element_t *)dlp) {
 8003910:	d103      	bne.n	800391a <dyn_create_object_heap+0x1a>
 8003912:	e00e      	b.n	8003932 <dyn_create_object_heap+0x32>
    p = p->next;
 8003914:	6824      	ldr	r4, [r4, #0]
  while (p != (dyn_element_t *)dlp) {
 8003916:	42a6      	cmp	r6, r4
 8003918:	d00b      	beq.n	8003932 <dyn_create_object_heap+0x32>
    if (strncmp(p->name, name, CH_CFG_FACTORY_MAX_NAMES_LENGTH) == 0) {
 800391a:	f104 0008 	add.w	r0, r4, #8
 800391e:	2208      	movs	r2, #8
 8003920:	4629      	mov	r1, r5
 8003922:	f006 fe4d 	bl	800a5c0 <strncmp>
 8003926:	2800      	cmp	r0, #0
 8003928:	d1f4      	bne.n	8003914 <dyn_create_object_heap+0x14>

  chDbgCheck(name != NULL);

  /* Checking if an object with this name has already been created.*/
  dep = dyn_list_find(name, dlp);
  if (dep != NULL) {
 800392a:	b114      	cbz	r4, 8003932 <dyn_create_object_heap+0x32>
    return NULL;
 800392c:	2000      	movs	r0, #0

  /* Updating factory list.*/
  dlp->next = dep;

  return dep;
}
 800392e:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  dep = (dyn_element_t *)chHeapAllocAligned(NULL, size, align);
 8003932:	4642      	mov	r2, r8
 8003934:	4639      	mov	r1, r7
 8003936:	2000      	movs	r0, #0
 8003938:	f7ff fb6a 	bl	8003010 <chHeapAllocAligned>
  if (dep == NULL) {
 800393c:	2800      	cmp	r0, #0
 800393e:	d0f5      	beq.n	800392c <dyn_create_object_heap+0x2c>
  copy_name(name, dep->name);
 8003940:	f100 0208 	add.w	r2, r0, #8
  i = CH_CFG_FACTORY_MAX_NAMES_LENGTH;
 8003944:	f105 0108 	add.w	r1, r5, #8
    c = *sp++;
 8003948:	f815 3b01 	ldrb.w	r3, [r5], #1
    *dp++ = c;
 800394c:	f802 3b01 	strb.w	r3, [r2], #1
  } while ((c != (char)0) && (i > 0U));
 8003950:	b10b      	cbz	r3, 8003956 <dyn_create_object_heap+0x56>
 8003952:	42a9      	cmp	r1, r5
 8003954:	d1f8      	bne.n	8003948 <dyn_create_object_heap+0x48>
  dep->next = dlp->next;
 8003956:	6833      	ldr	r3, [r6, #0]
  dep->refs = (ucnt_t)1;
 8003958:	2201      	movs	r2, #1
  dep->next = dlp->next;
 800395a:	e9c0 3200 	strd	r3, r2, [r0]
  dlp->next = dep;
 800395e:	6030      	str	r0, [r6, #0]
}
 8003960:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	...

08003970 <__factory_init>:
/**
 * @brief   Initializes the objects factory.
 *
 * @init
 */
void __factory_init(void) {
 8003970:	b538      	push	{r3, r4, r5, lr}

#if (CH_CFG_USE_MUTEXES == TRUE) || defined(__DOXYGEN__)
  chMtxObjectInit(&ch_factory.mtx);
 8003972:	4c12      	ldr	r4, [pc, #72]	; (80039bc <__factory_init+0x4c>)
  chPoolObjectInitAligned(mp, size, PORT_NATURAL_ALIGN, provider);
 8003974:	4d12      	ldr	r5, [pc, #72]	; (80039c0 <__factory_init+0x50>)
 8003976:	4620      	mov	r0, r4
 8003978:	f7fe fd22 	bl	80023c0 <chMtxObjectInit>
 800397c:	2114      	movs	r1, #20
  dlp->next = (dyn_element_t *)dlp;
 800397e:	f104 0010 	add.w	r0, r4, #16
 8003982:	462b      	mov	r3, r5
 8003984:	2204      	movs	r2, #4
 8003986:	6120      	str	r0, [r4, #16]
 8003988:	1860      	adds	r0, r4, r1
 800398a:	f7ff fc51 	bl	8003230 <chPoolObjectInitAligned>
 800398e:	f104 0024 	add.w	r0, r4, #36	; 0x24
 8003992:	f104 0128 	add.w	r1, r4, #40	; 0x28
 8003996:	e9c4 0109 	strd	r0, r1, [r4, #36]	; 0x24
 800399a:	462b      	mov	r3, r5
 800399c:	2204      	movs	r2, #4
 800399e:	211c      	movs	r1, #28
 80039a0:	f104 002c 	add.w	r0, r4, #44	; 0x2c
 80039a4:	f7ff fc44 	bl	8003230 <chPoolObjectInitAligned>
 80039a8:	f104 013c 	add.w	r1, r4, #60	; 0x3c
 80039ac:	f104 0240 	add.w	r2, r4, #64	; 0x40
 80039b0:	f104 0344 	add.w	r3, r4, #68	; 0x44
 80039b4:	e9c4 120f 	strd	r1, r2, [r4, #60]	; 0x3c
 80039b8:	6463      	str	r3, [r4, #68]	; 0x44
  dyn_list_init(&ch_factory.fifo_list);
#endif
#if CH_CFG_FACTORY_PIPES == TRUE
  dyn_list_init(&ch_factory.pipe_list);
#endif
}
 80039ba:	bd38      	pop	{r3, r4, r5, pc}
 80039bc:	20000c28 	.word	0x20000c28
 80039c0:	080038f1 	.word	0x080038f1
	...

080039d0 <chFactoryRegisterObject>:
 *                      a registered object with the same name exists.
 *
 * @api
 */
registered_object_t *chFactoryRegisterObject(const char *name,
                                             void *objp) {
 80039d0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  registered_object_t *rop;

  F_LOCK();
 80039d4:	4f1e      	ldr	r7, [pc, #120]	; (8003a50 <chFactoryRegisterObject+0x80>)
  dyn_element_t *p = dlp->next;
 80039d6:	463e      	mov	r6, r7
                                             void *objp) {
 80039d8:	4605      	mov	r5, r0
  F_LOCK();
 80039da:	4638      	mov	r0, r7
                                             void *objp) {
 80039dc:	4688      	mov	r8, r1
  F_LOCK();
 80039de:	f7fe fd5f 	bl	80024a0 <chMtxLock>
  dyn_element_t *p = dlp->next;
 80039e2:	f856 4f10 	ldr.w	r4, [r6, #16]!
  while (p != (dyn_element_t *)dlp) {
 80039e6:	42b4      	cmp	r4, r6
 80039e8:	d103      	bne.n	80039f2 <chFactoryRegisterObject+0x22>
 80039ea:	e012      	b.n	8003a12 <chFactoryRegisterObject+0x42>
    p = p->next;
 80039ec:	6824      	ldr	r4, [r4, #0]
  while (p != (dyn_element_t *)dlp) {
 80039ee:	42b4      	cmp	r4, r6
 80039f0:	d00f      	beq.n	8003a12 <chFactoryRegisterObject+0x42>
    if (strncmp(p->name, name, CH_CFG_FACTORY_MAX_NAMES_LENGTH) == 0) {
 80039f2:	f104 0008 	add.w	r0, r4, #8
 80039f6:	2208      	movs	r2, #8
 80039f8:	4629      	mov	r1, r5
 80039fa:	f006 fde1 	bl	800a5c0 <strncmp>
 80039fe:	2800      	cmp	r0, #0
 8003a00:	d1f4      	bne.n	80039ec <chFactoryRegisterObject+0x1c>
  if (dep != NULL) {
 8003a02:	b134      	cbz	r4, 8003a12 <chFactoryRegisterObject+0x42>
  if (rop != NULL) {
    /* Initializing registered object data.*/
    rop->objp = objp;
  }

  F_UNLOCK();
 8003a04:	4812      	ldr	r0, [pc, #72]	; (8003a50 <chFactoryRegisterObject+0x80>)
    return NULL;
 8003a06:	2400      	movs	r4, #0
  F_UNLOCK();
 8003a08:	f7fe fd72 	bl	80024f0 <chMtxUnlock>

  return rop;
}
 8003a0c:	4620      	mov	r0, r4
 8003a0e:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  dep = (dyn_element_t *)chPoolAlloc(mp);
 8003a12:	4810      	ldr	r0, [pc, #64]	; (8003a54 <chFactoryRegisterObject+0x84>)
 8003a14:	f7ff fc2c 	bl	8003270 <chPoolAlloc>
  if (dep == NULL) {
 8003a18:	4604      	mov	r4, r0
 8003a1a:	2800      	cmp	r0, #0
 8003a1c:	d0f2      	beq.n	8003a04 <chFactoryRegisterObject+0x34>
  copy_name(name, dep->name);
 8003a1e:	f100 0208 	add.w	r2, r0, #8
  i = CH_CFG_FACTORY_MAX_NAMES_LENGTH;
 8003a22:	f105 0108 	add.w	r1, r5, #8
    c = *sp++;
 8003a26:	f815 3b01 	ldrb.w	r3, [r5], #1
    *dp++ = c;
 8003a2a:	f802 3b01 	strb.w	r3, [r2], #1
  } while ((c != (char)0) && (i > 0U));
 8003a2e:	b10b      	cbz	r3, 8003a34 <chFactoryRegisterObject+0x64>
 8003a30:	428d      	cmp	r5, r1
 8003a32:	d1f8      	bne.n	8003a26 <chFactoryRegisterObject+0x56>
  dep->next = dlp->next;
 8003a34:	693b      	ldr	r3, [r7, #16]
  F_UNLOCK();
 8003a36:	4806      	ldr	r0, [pc, #24]	; (8003a50 <chFactoryRegisterObject+0x80>)
  dep->refs = (ucnt_t)1;
 8003a38:	2201      	movs	r2, #1
  dep->next = dlp->next;
 8003a3a:	e9c4 3200 	strd	r3, r2, [r4]
  dlp->next = (dyn_element_t *)dep;
 8003a3e:	613c      	str	r4, [r7, #16]
    rop->objp = objp;
 8003a40:	f8c4 8010 	str.w	r8, [r4, #16]
  F_UNLOCK();
 8003a44:	f7fe fd54 	bl	80024f0 <chMtxUnlock>
}
 8003a48:	4620      	mov	r0, r4
 8003a4a:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 8003a4e:	bf00      	nop
 8003a50:	20000c28 	.word	0x20000c28
 8003a54:	20000c3c 	.word	0x20000c3c
	...

08003a60 <chFactoryFindObject>:
 * @api
 */
registered_object_t *chFactoryFindObject(const char *name) {
  registered_object_t *rop;

  F_LOCK();
 8003a60:	4b12      	ldr	r3, [pc, #72]	; (8003aac <chFactoryFindObject+0x4c>)
registered_object_t *chFactoryFindObject(const char *name) {
 8003a62:	b570      	push	{r4, r5, r6, lr}
  dyn_element_t *p = dlp->next;
 8003a64:	461d      	mov	r5, r3
registered_object_t *chFactoryFindObject(const char *name) {
 8003a66:	4606      	mov	r6, r0
  F_LOCK();
 8003a68:	4618      	mov	r0, r3
 8003a6a:	f7fe fd19 	bl	80024a0 <chMtxLock>
  dyn_element_t *p = dlp->next;
 8003a6e:	f855 4f10 	ldr.w	r4, [r5, #16]!
  while (p != (dyn_element_t *)dlp) {
 8003a72:	42ac      	cmp	r4, r5
 8003a74:	d103      	bne.n	8003a7e <chFactoryFindObject+0x1e>
 8003a76:	e013      	b.n	8003aa0 <chFactoryFindObject+0x40>
    p = p->next;
 8003a78:	6824      	ldr	r4, [r4, #0]
  while (p != (dyn_element_t *)dlp) {
 8003a7a:	42ac      	cmp	r4, r5
 8003a7c:	d010      	beq.n	8003aa0 <chFactoryFindObject+0x40>
    if (strncmp(p->name, name, CH_CFG_FACTORY_MAX_NAMES_LENGTH) == 0) {
 8003a7e:	f104 0008 	add.w	r0, r4, #8
 8003a82:	2208      	movs	r2, #8
 8003a84:	4631      	mov	r1, r6
 8003a86:	f006 fd9b 	bl	800a5c0 <strncmp>
 8003a8a:	2800      	cmp	r0, #0
 8003a8c:	d1f4      	bne.n	8003a78 <chFactoryFindObject+0x18>
  if (dep != NULL) {
 8003a8e:	b114      	cbz	r4, 8003a96 <chFactoryFindObject+0x36>
    dep->refs++;
 8003a90:	6863      	ldr	r3, [r4, #4]
 8003a92:	3301      	adds	r3, #1
 8003a94:	6063      	str	r3, [r4, #4]

  rop = (registered_object_t *)dyn_find_object(name, &ch_factory.obj_list);

  F_UNLOCK();
 8003a96:	4805      	ldr	r0, [pc, #20]	; (8003aac <chFactoryFindObject+0x4c>)
 8003a98:	f7fe fd2a 	bl	80024f0 <chMtxUnlock>

  return rop;
}
 8003a9c:	4620      	mov	r0, r4
 8003a9e:	bd70      	pop	{r4, r5, r6, pc}
  F_UNLOCK();
 8003aa0:	4802      	ldr	r0, [pc, #8]	; (8003aac <chFactoryFindObject+0x4c>)
  return NULL;
 8003aa2:	2400      	movs	r4, #0
  F_UNLOCK();
 8003aa4:	f7fe fd24 	bl	80024f0 <chMtxUnlock>
}
 8003aa8:	4620      	mov	r0, r4
 8003aaa:	bd70      	pop	{r4, r5, r6, pc}
 8003aac:	20000c28 	.word	0x20000c28

08003ab0 <chFactoryReleaseObject>:
 *
 * @param[in] rop       registered object reference
 *
 * @api
 */
void chFactoryReleaseObject(registered_object_t *rop) {
 8003ab0:	b510      	push	{r4, lr}
 8003ab2:	4604      	mov	r4, r0

  F_LOCK();
 8003ab4:	480d      	ldr	r0, [pc, #52]	; (8003aec <chFactoryReleaseObject+0x3c>)
 8003ab6:	f7fe fcf3 	bl	80024a0 <chMtxLock>
  dep->refs--;
 8003aba:	6863      	ldr	r3, [r4, #4]
 8003abc:	3b01      	subs	r3, #1
 8003abe:	6063      	str	r3, [r4, #4]
  if (dep->refs == (ucnt_t)0) {
 8003ac0:	b963      	cbnz	r3, 8003adc <chFactoryReleaseObject+0x2c>
  dyn_element_t *prev = (dyn_element_t *)dlp;
 8003ac2:	4b0b      	ldr	r3, [pc, #44]	; (8003af0 <chFactoryReleaseObject+0x40>)
 8003ac4:	4619      	mov	r1, r3
 8003ac6:	e001      	b.n	8003acc <chFactoryReleaseObject+0x1c>
    if (prev->next == element) {
 8003ac8:	428c      	cmp	r4, r1
 8003aca:	d00c      	beq.n	8003ae6 <chFactoryReleaseObject+0x36>
  while (prev->next != (dyn_element_t *)dlp) {
 8003acc:	460a      	mov	r2, r1
 8003ace:	6809      	ldr	r1, [r1, #0]
 8003ad0:	4299      	cmp	r1, r3
 8003ad2:	d1f9      	bne.n	8003ac8 <chFactoryReleaseObject+0x18>
  return NULL;
 8003ad4:	2100      	movs	r1, #0
    chPoolFree(mp, (void *)dep);
 8003ad6:	4807      	ldr	r0, [pc, #28]	; (8003af4 <chFactoryReleaseObject+0x44>)
 8003ad8:	f7ff fbe2 	bl	80032a0 <chPoolFree>
  dyn_release_object_pool(&rop->element,
                          &ch_factory.obj_list,
                          &ch_factory.obj_pool);

  F_UNLOCK();
}
 8003adc:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  F_UNLOCK();
 8003ae0:	4802      	ldr	r0, [pc, #8]	; (8003aec <chFactoryReleaseObject+0x3c>)
 8003ae2:	f7fe bd05 	b.w	80024f0 <chMtxUnlock>
      prev->next = element->next;
 8003ae6:	680b      	ldr	r3, [r1, #0]
 8003ae8:	6013      	str	r3, [r2, #0]
      return element;
 8003aea:	e7f4      	b.n	8003ad6 <chFactoryReleaseObject+0x26>
 8003aec:	20000c28 	.word	0x20000c28
 8003af0:	20000c38 	.word	0x20000c38
 8003af4:	20000c3c 	.word	0x20000c3c
	...

08003b00 <chFactoryCreateBuffer>:
 * @retval NULL         if the dynamic buffer object cannot be allocated or
 *                      a dynamic buffer object with the same name exists.
 *
 * @api
 */
dyn_buffer_t *chFactoryCreateBuffer(const char *name, size_t size) {
 8003b00:	b538      	push	{r3, r4, r5, lr}
 8003b02:	4604      	mov	r4, r0
 8003b04:	460d      	mov	r5, r1
  dyn_buffer_t *dbp;

  F_LOCK();
 8003b06:	480b      	ldr	r0, [pc, #44]	; (8003b34 <chFactoryCreateBuffer+0x34>)
 8003b08:	f7fe fcca 	bl	80024a0 <chMtxLock>

  dbp = (dyn_buffer_t *)dyn_create_object_heap(name,
 8003b0c:	4620      	mov	r0, r4
 8003b0e:	490a      	ldr	r1, [pc, #40]	; (8003b38 <chFactoryCreateBuffer+0x38>)
 8003b10:	2308      	movs	r3, #8
 8003b12:	f105 0210 	add.w	r2, r5, #16
 8003b16:	f7ff fef3 	bl	8003900 <dyn_create_object_heap>
                                               &ch_factory.buf_list,
                                               sizeof (dyn_buffer_t) + size,
                                               CH_HEAP_ALIGNMENT);
  if (dbp != NULL) {
 8003b1a:	4604      	mov	r4, r0
 8003b1c:	b120      	cbz	r0, 8003b28 <chFactoryCreateBuffer+0x28>
    /* Initializing buffer object data.*/
    memset((void *)(dbp + 1), 0, size);
 8003b1e:	462a      	mov	r2, r5
 8003b20:	2100      	movs	r1, #0
 8003b22:	3010      	adds	r0, #16
 8003b24:	f006 fcfa 	bl	800a51c <memset>
  }

  F_UNLOCK();
 8003b28:	4802      	ldr	r0, [pc, #8]	; (8003b34 <chFactoryCreateBuffer+0x34>)
 8003b2a:	f7fe fce1 	bl	80024f0 <chMtxUnlock>

  return dbp;
}
 8003b2e:	4620      	mov	r0, r4
 8003b30:	bd38      	pop	{r3, r4, r5, pc}
 8003b32:	bf00      	nop
 8003b34:	20000c28 	.word	0x20000c28
 8003b38:	20000c4c 	.word	0x20000c4c
 8003b3c:	00000000 	.word	0x00000000

08003b40 <chFactoryFindBuffer>:
 * @api
 */
dyn_buffer_t *chFactoryFindBuffer(const char *name) {
  dyn_buffer_t *dbp;

  F_LOCK();
 8003b40:	4b12      	ldr	r3, [pc, #72]	; (8003b8c <chFactoryFindBuffer+0x4c>)
dyn_buffer_t *chFactoryFindBuffer(const char *name) {
 8003b42:	b570      	push	{r4, r5, r6, lr}
  dyn_element_t *p = dlp->next;
 8003b44:	461d      	mov	r5, r3
dyn_buffer_t *chFactoryFindBuffer(const char *name) {
 8003b46:	4606      	mov	r6, r0
  F_LOCK();
 8003b48:	4618      	mov	r0, r3
 8003b4a:	f7fe fca9 	bl	80024a0 <chMtxLock>
  dyn_element_t *p = dlp->next;
 8003b4e:	f855 4f24 	ldr.w	r4, [r5, #36]!
  while (p != (dyn_element_t *)dlp) {
 8003b52:	42ac      	cmp	r4, r5
 8003b54:	d103      	bne.n	8003b5e <chFactoryFindBuffer+0x1e>
 8003b56:	e013      	b.n	8003b80 <chFactoryFindBuffer+0x40>
    p = p->next;
 8003b58:	6824      	ldr	r4, [r4, #0]
  while (p != (dyn_element_t *)dlp) {
 8003b5a:	42ac      	cmp	r4, r5
 8003b5c:	d010      	beq.n	8003b80 <chFactoryFindBuffer+0x40>
    if (strncmp(p->name, name, CH_CFG_FACTORY_MAX_NAMES_LENGTH) == 0) {
 8003b5e:	f104 0008 	add.w	r0, r4, #8
 8003b62:	2208      	movs	r2, #8
 8003b64:	4631      	mov	r1, r6
 8003b66:	f006 fd2b 	bl	800a5c0 <strncmp>
 8003b6a:	2800      	cmp	r0, #0
 8003b6c:	d1f4      	bne.n	8003b58 <chFactoryFindBuffer+0x18>
  if (dep != NULL) {
 8003b6e:	b114      	cbz	r4, 8003b76 <chFactoryFindBuffer+0x36>
    dep->refs++;
 8003b70:	6863      	ldr	r3, [r4, #4]
 8003b72:	3301      	adds	r3, #1
 8003b74:	6063      	str	r3, [r4, #4]

  dbp = (dyn_buffer_t *)dyn_find_object(name, &ch_factory.buf_list);

  F_UNLOCK();
 8003b76:	4805      	ldr	r0, [pc, #20]	; (8003b8c <chFactoryFindBuffer+0x4c>)
 8003b78:	f7fe fcba 	bl	80024f0 <chMtxUnlock>

  return dbp;
}
 8003b7c:	4620      	mov	r0, r4
 8003b7e:	bd70      	pop	{r4, r5, r6, pc}
  F_UNLOCK();
 8003b80:	4802      	ldr	r0, [pc, #8]	; (8003b8c <chFactoryFindBuffer+0x4c>)
  return NULL;
 8003b82:	2400      	movs	r4, #0
  F_UNLOCK();
 8003b84:	f7fe fcb4 	bl	80024f0 <chMtxUnlock>
}
 8003b88:	4620      	mov	r0, r4
 8003b8a:	bd70      	pop	{r4, r5, r6, pc}
 8003b8c:	20000c28 	.word	0x20000c28

08003b90 <chFactoryReleaseBuffer>:
 *
 * @param[in] dbp       dynamic buffer object reference
 *
 * @api
 */
void chFactoryReleaseBuffer(dyn_buffer_t *dbp) {
 8003b90:	b510      	push	{r4, lr}
 8003b92:	4604      	mov	r4, r0

  F_LOCK();
 8003b94:	480d      	ldr	r0, [pc, #52]	; (8003bcc <chFactoryReleaseBuffer+0x3c>)
 8003b96:	f7fe fc83 	bl	80024a0 <chMtxLock>
  dep->refs--;
 8003b9a:	6863      	ldr	r3, [r4, #4]
 8003b9c:	3b01      	subs	r3, #1
 8003b9e:	6063      	str	r3, [r4, #4]
  if (dep->refs == (ucnt_t)0) {
 8003ba0:	b95b      	cbnz	r3, 8003bba <chFactoryReleaseBuffer+0x2a>
  dyn_element_t *prev = (dyn_element_t *)dlp;
 8003ba2:	4b0b      	ldr	r3, [pc, #44]	; (8003bd0 <chFactoryReleaseBuffer+0x40>)
 8003ba4:	4618      	mov	r0, r3
 8003ba6:	e001      	b.n	8003bac <chFactoryReleaseBuffer+0x1c>
    if (prev->next == element) {
 8003ba8:	4284      	cmp	r4, r0
 8003baa:	d00b      	beq.n	8003bc4 <chFactoryReleaseBuffer+0x34>
  while (prev->next != (dyn_element_t *)dlp) {
 8003bac:	4602      	mov	r2, r0
 8003bae:	6800      	ldr	r0, [r0, #0]
 8003bb0:	4298      	cmp	r0, r3
 8003bb2:	d1f9      	bne.n	8003ba8 <chFactoryReleaseBuffer+0x18>
  return NULL;
 8003bb4:	2000      	movs	r0, #0
    chHeapFree((void *)dep);
 8003bb6:	f7ff fab3 	bl	8003120 <chHeapFree>

  dyn_release_object_heap(&dbp->element, &ch_factory.buf_list);

  F_UNLOCK();
}
 8003bba:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  F_UNLOCK();
 8003bbe:	4803      	ldr	r0, [pc, #12]	; (8003bcc <chFactoryReleaseBuffer+0x3c>)
 8003bc0:	f7fe bc96 	b.w	80024f0 <chMtxUnlock>
      prev->next = element->next;
 8003bc4:	6803      	ldr	r3, [r0, #0]
 8003bc6:	6013      	str	r3, [r2, #0]
      return element;
 8003bc8:	e7f5      	b.n	8003bb6 <chFactoryReleaseBuffer+0x26>
 8003bca:	bf00      	nop
 8003bcc:	20000c28 	.word	0x20000c28
 8003bd0:	20000c4c 	.word	0x20000c4c
	...

08003be0 <chFactoryCreateSemaphore>:
 * @retval NULL         if the dynamic semaphore object cannot be allocated or
 *                      a dynamic semaphore with the same name exists.
 *
 * @api
 */
dyn_semaphore_t *chFactoryCreateSemaphore(const char *name, cnt_t n) {
 8003be0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  dyn_semaphore_t *dsp;

  F_LOCK();
 8003be4:	4f1f      	ldr	r7, [pc, #124]	; (8003c64 <chFactoryCreateSemaphore+0x84>)
  dyn_element_t *p = dlp->next;
 8003be6:	463e      	mov	r6, r7
dyn_semaphore_t *chFactoryCreateSemaphore(const char *name, cnt_t n) {
 8003be8:	4605      	mov	r5, r0
  F_LOCK();
 8003bea:	4638      	mov	r0, r7
dyn_semaphore_t *chFactoryCreateSemaphore(const char *name, cnt_t n) {
 8003bec:	4688      	mov	r8, r1
  F_LOCK();
 8003bee:	f7fe fc57 	bl	80024a0 <chMtxLock>
  dyn_element_t *p = dlp->next;
 8003bf2:	f856 4f28 	ldr.w	r4, [r6, #40]!
  while (p != (dyn_element_t *)dlp) {
 8003bf6:	42b4      	cmp	r4, r6
 8003bf8:	d103      	bne.n	8003c02 <chFactoryCreateSemaphore+0x22>
 8003bfa:	e012      	b.n	8003c22 <chFactoryCreateSemaphore+0x42>
    p = p->next;
 8003bfc:	6824      	ldr	r4, [r4, #0]
  while (p != (dyn_element_t *)dlp) {
 8003bfe:	42b4      	cmp	r4, r6
 8003c00:	d00f      	beq.n	8003c22 <chFactoryCreateSemaphore+0x42>
    if (strncmp(p->name, name, CH_CFG_FACTORY_MAX_NAMES_LENGTH) == 0) {
 8003c02:	f104 0008 	add.w	r0, r4, #8
 8003c06:	2208      	movs	r2, #8
 8003c08:	4629      	mov	r1, r5
 8003c0a:	f006 fcd9 	bl	800a5c0 <strncmp>
 8003c0e:	2800      	cmp	r0, #0
 8003c10:	d1f4      	bne.n	8003bfc <chFactoryCreateSemaphore+0x1c>
  if (dep != NULL) {
 8003c12:	b134      	cbz	r4, 8003c22 <chFactoryCreateSemaphore+0x42>
  if (dsp != NULL) {
    /* Initializing semaphore object dataa.*/
    chSemObjectInit(&dsp->sem, n);
  }

  F_UNLOCK();
 8003c14:	4813      	ldr	r0, [pc, #76]	; (8003c64 <chFactoryCreateSemaphore+0x84>)
    return NULL;
 8003c16:	2400      	movs	r4, #0
  F_UNLOCK();
 8003c18:	f7fe fc6a 	bl	80024f0 <chMtxUnlock>

  return dsp;
}
 8003c1c:	4620      	mov	r0, r4
 8003c1e:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  dep = (dyn_element_t *)chPoolAlloc(mp);
 8003c22:	4811      	ldr	r0, [pc, #68]	; (8003c68 <chFactoryCreateSemaphore+0x88>)
 8003c24:	f7ff fb24 	bl	8003270 <chPoolAlloc>
  if (dep == NULL) {
 8003c28:	4604      	mov	r4, r0
 8003c2a:	2800      	cmp	r0, #0
 8003c2c:	d0f2      	beq.n	8003c14 <chFactoryCreateSemaphore+0x34>
  copy_name(name, dep->name);
 8003c2e:	f100 0208 	add.w	r2, r0, #8
  i = CH_CFG_FACTORY_MAX_NAMES_LENGTH;
 8003c32:	f105 0108 	add.w	r1, r5, #8
    c = *sp++;
 8003c36:	f815 3b01 	ldrb.w	r3, [r5], #1
    *dp++ = c;
 8003c3a:	f802 3b01 	strb.w	r3, [r2], #1
  } while ((c != (char)0) && (i > 0U));
 8003c3e:	b10b      	cbz	r3, 8003c44 <chFactoryCreateSemaphore+0x64>
 8003c40:	428d      	cmp	r5, r1
 8003c42:	d1f8      	bne.n	8003c36 <chFactoryCreateSemaphore+0x56>
  dep->next = dlp->next;
 8003c44:	6abb      	ldr	r3, [r7, #40]	; 0x28
  dep->refs = (ucnt_t)1;
 8003c46:	2201      	movs	r2, #1
  dep->next = dlp->next;
 8003c48:	e9c4 3200 	strd	r3, r2, [r4]
    chSemObjectInit(&dsp->sem, n);
 8003c4c:	4641      	mov	r1, r8
 8003c4e:	f104 0010 	add.w	r0, r4, #16
  dlp->next = (dyn_element_t *)dep;
 8003c52:	62bc      	str	r4, [r7, #40]	; 0x28
    chSemObjectInit(&dsp->sem, n);
 8003c54:	f7fe fa84 	bl	8002160 <chSemObjectInit>
  F_UNLOCK();
 8003c58:	4802      	ldr	r0, [pc, #8]	; (8003c64 <chFactoryCreateSemaphore+0x84>)
 8003c5a:	f7fe fc49 	bl	80024f0 <chMtxUnlock>
}
 8003c5e:	4620      	mov	r0, r4
 8003c60:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 8003c64:	20000c28 	.word	0x20000c28
 8003c68:	20000c54 	.word	0x20000c54
 8003c6c:	00000000 	.word	0x00000000

08003c70 <chFactoryFindSemaphore>:
 * @api
 */
dyn_semaphore_t *chFactoryFindSemaphore(const char *name) {
  dyn_semaphore_t *dsp;

  F_LOCK();
 8003c70:	4b12      	ldr	r3, [pc, #72]	; (8003cbc <chFactoryFindSemaphore+0x4c>)
dyn_semaphore_t *chFactoryFindSemaphore(const char *name) {
 8003c72:	b570      	push	{r4, r5, r6, lr}
  dyn_element_t *p = dlp->next;
 8003c74:	461d      	mov	r5, r3
dyn_semaphore_t *chFactoryFindSemaphore(const char *name) {
 8003c76:	4606      	mov	r6, r0
  F_LOCK();
 8003c78:	4618      	mov	r0, r3
 8003c7a:	f7fe fc11 	bl	80024a0 <chMtxLock>
  dyn_element_t *p = dlp->next;
 8003c7e:	f855 4f28 	ldr.w	r4, [r5, #40]!
  while (p != (dyn_element_t *)dlp) {
 8003c82:	42ac      	cmp	r4, r5
 8003c84:	d103      	bne.n	8003c8e <chFactoryFindSemaphore+0x1e>
 8003c86:	e013      	b.n	8003cb0 <chFactoryFindSemaphore+0x40>
    p = p->next;
 8003c88:	6824      	ldr	r4, [r4, #0]
  while (p != (dyn_element_t *)dlp) {
 8003c8a:	42ac      	cmp	r4, r5
 8003c8c:	d010      	beq.n	8003cb0 <chFactoryFindSemaphore+0x40>
    if (strncmp(p->name, name, CH_CFG_FACTORY_MAX_NAMES_LENGTH) == 0) {
 8003c8e:	f104 0008 	add.w	r0, r4, #8
 8003c92:	2208      	movs	r2, #8
 8003c94:	4631      	mov	r1, r6
 8003c96:	f006 fc93 	bl	800a5c0 <strncmp>
 8003c9a:	2800      	cmp	r0, #0
 8003c9c:	d1f4      	bne.n	8003c88 <chFactoryFindSemaphore+0x18>
  if (dep != NULL) {
 8003c9e:	b114      	cbz	r4, 8003ca6 <chFactoryFindSemaphore+0x36>
    dep->refs++;
 8003ca0:	6863      	ldr	r3, [r4, #4]
 8003ca2:	3301      	adds	r3, #1
 8003ca4:	6063      	str	r3, [r4, #4]

  dsp = (dyn_semaphore_t *)dyn_find_object(name, &ch_factory.sem_list);

  F_UNLOCK();
 8003ca6:	4805      	ldr	r0, [pc, #20]	; (8003cbc <chFactoryFindSemaphore+0x4c>)
 8003ca8:	f7fe fc22 	bl	80024f0 <chMtxUnlock>

  return dsp;
}
 8003cac:	4620      	mov	r0, r4
 8003cae:	bd70      	pop	{r4, r5, r6, pc}
  F_UNLOCK();
 8003cb0:	4802      	ldr	r0, [pc, #8]	; (8003cbc <chFactoryFindSemaphore+0x4c>)
  return NULL;
 8003cb2:	2400      	movs	r4, #0
  F_UNLOCK();
 8003cb4:	f7fe fc1c 	bl	80024f0 <chMtxUnlock>
}
 8003cb8:	4620      	mov	r0, r4
 8003cba:	bd70      	pop	{r4, r5, r6, pc}
 8003cbc:	20000c28 	.word	0x20000c28

08003cc0 <chFactoryReleaseSemaphore>:
 *
 * @param[in] dsp       dynamic semaphore object reference
 *
 * @api
 */
void chFactoryReleaseSemaphore(dyn_semaphore_t *dsp) {
 8003cc0:	b510      	push	{r4, lr}
 8003cc2:	4604      	mov	r4, r0

  F_LOCK();
 8003cc4:	480d      	ldr	r0, [pc, #52]	; (8003cfc <chFactoryReleaseSemaphore+0x3c>)
 8003cc6:	f7fe fbeb 	bl	80024a0 <chMtxLock>
  dep->refs--;
 8003cca:	6863      	ldr	r3, [r4, #4]
 8003ccc:	3b01      	subs	r3, #1
 8003cce:	6063      	str	r3, [r4, #4]
  if (dep->refs == (ucnt_t)0) {
 8003cd0:	b963      	cbnz	r3, 8003cec <chFactoryReleaseSemaphore+0x2c>
  dyn_element_t *prev = (dyn_element_t *)dlp;
 8003cd2:	4b0b      	ldr	r3, [pc, #44]	; (8003d00 <chFactoryReleaseSemaphore+0x40>)
 8003cd4:	4619      	mov	r1, r3
 8003cd6:	e001      	b.n	8003cdc <chFactoryReleaseSemaphore+0x1c>
    if (prev->next == element) {
 8003cd8:	428c      	cmp	r4, r1
 8003cda:	d00c      	beq.n	8003cf6 <chFactoryReleaseSemaphore+0x36>
  while (prev->next != (dyn_element_t *)dlp) {
 8003cdc:	460a      	mov	r2, r1
 8003cde:	6809      	ldr	r1, [r1, #0]
 8003ce0:	4299      	cmp	r1, r3
 8003ce2:	d1f9      	bne.n	8003cd8 <chFactoryReleaseSemaphore+0x18>
  return NULL;
 8003ce4:	2100      	movs	r1, #0
    chPoolFree(mp, (void *)dep);
 8003ce6:	4807      	ldr	r0, [pc, #28]	; (8003d04 <chFactoryReleaseSemaphore+0x44>)
 8003ce8:	f7ff fada 	bl	80032a0 <chPoolFree>
  dyn_release_object_pool(&dsp->element,
                          &ch_factory.sem_list,
                          &ch_factory.sem_pool);

  F_UNLOCK();
}
 8003cec:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  F_UNLOCK();
 8003cf0:	4802      	ldr	r0, [pc, #8]	; (8003cfc <chFactoryReleaseSemaphore+0x3c>)
 8003cf2:	f7fe bbfd 	b.w	80024f0 <chMtxUnlock>
      prev->next = element->next;
 8003cf6:	680b      	ldr	r3, [r1, #0]
 8003cf8:	6013      	str	r3, [r2, #0]
      return element;
 8003cfa:	e7f4      	b.n	8003ce6 <chFactoryReleaseSemaphore+0x26>
 8003cfc:	20000c28 	.word	0x20000c28
 8003d00:	20000c50 	.word	0x20000c50
 8003d04:	20000c54 	.word	0x20000c54
	...

08003d10 <chFactoryCreateMailbox>:
 * @retval NULL         if the dynamic mailbox object cannot be allocated or
 *                      a dynamic mailbox object with the same name exists.
 *
 * @api
 */
dyn_mailbox_t *chFactoryCreateMailbox(const char *name, size_t n) {
 8003d10:	b538      	push	{r3, r4, r5, lr}
 8003d12:	4604      	mov	r4, r0
 8003d14:	460d      	mov	r5, r1
  dyn_mailbox_t *dmp;

  F_LOCK();
 8003d16:	480c      	ldr	r0, [pc, #48]	; (8003d48 <chFactoryCreateMailbox+0x38>)
 8003d18:	f7fe fbc2 	bl	80024a0 <chMtxLock>

  dmp = (dyn_mailbox_t *)dyn_create_object_heap(name,
                                                &ch_factory.mbx_list,
                                                sizeof (dyn_mailbox_t) +
 8003d1c:	f105 020e 	add.w	r2, r5, #14
  dmp = (dyn_mailbox_t *)dyn_create_object_heap(name,
 8003d20:	4620      	mov	r0, r4
 8003d22:	490a      	ldr	r1, [pc, #40]	; (8003d4c <chFactoryCreateMailbox+0x3c>)
 8003d24:	2308      	movs	r3, #8
 8003d26:	0092      	lsls	r2, r2, #2
 8003d28:	f7ff fdea 	bl	8003900 <dyn_create_object_heap>
                                                (n * sizeof (msg_t)),
                                                CH_HEAP_ALIGNMENT);
  if (dmp != NULL) {
 8003d2c:	4604      	mov	r4, r0
 8003d2e:	b128      	cbz	r0, 8003d3c <chFactoryCreateMailbox+0x2c>
    /* Initializing mailbox object data.*/
    chMBObjectInit(&dmp->mbx, (msg_t *)(dmp + 1), n);
 8003d30:	f100 0138 	add.w	r1, r0, #56	; 0x38
 8003d34:	462a      	mov	r2, r5
 8003d36:	3010      	adds	r0, #16
 8003d38:	f7fe ff8a 	bl	8002c50 <chMBObjectInit>
  }

  F_UNLOCK();
 8003d3c:	4802      	ldr	r0, [pc, #8]	; (8003d48 <chFactoryCreateMailbox+0x38>)
 8003d3e:	f7fe fbd7 	bl	80024f0 <chMtxUnlock>

  return dmp;
}
 8003d42:	4620      	mov	r0, r4
 8003d44:	bd38      	pop	{r3, r4, r5, pc}
 8003d46:	bf00      	nop
 8003d48:	20000c28 	.word	0x20000c28
 8003d4c:	20000c64 	.word	0x20000c64

08003d50 <chFactoryFindMailbox>:
 * @api
 */
dyn_mailbox_t *chFactoryFindMailbox(const char *name) {
  dyn_mailbox_t *dmp;

  F_LOCK();
 8003d50:	4b12      	ldr	r3, [pc, #72]	; (8003d9c <chFactoryFindMailbox+0x4c>)
dyn_mailbox_t *chFactoryFindMailbox(const char *name) {
 8003d52:	b570      	push	{r4, r5, r6, lr}
  dyn_element_t *p = dlp->next;
 8003d54:	461d      	mov	r5, r3
dyn_mailbox_t *chFactoryFindMailbox(const char *name) {
 8003d56:	4606      	mov	r6, r0
  F_LOCK();
 8003d58:	4618      	mov	r0, r3
 8003d5a:	f7fe fba1 	bl	80024a0 <chMtxLock>
  dyn_element_t *p = dlp->next;
 8003d5e:	f855 4f3c 	ldr.w	r4, [r5, #60]!
  while (p != (dyn_element_t *)dlp) {
 8003d62:	42ac      	cmp	r4, r5
 8003d64:	d103      	bne.n	8003d6e <chFactoryFindMailbox+0x1e>
 8003d66:	e013      	b.n	8003d90 <chFactoryFindMailbox+0x40>
    p = p->next;
 8003d68:	6824      	ldr	r4, [r4, #0]
  while (p != (dyn_element_t *)dlp) {
 8003d6a:	42ac      	cmp	r4, r5
 8003d6c:	d010      	beq.n	8003d90 <chFactoryFindMailbox+0x40>
    if (strncmp(p->name, name, CH_CFG_FACTORY_MAX_NAMES_LENGTH) == 0) {
 8003d6e:	f104 0008 	add.w	r0, r4, #8
 8003d72:	2208      	movs	r2, #8
 8003d74:	4631      	mov	r1, r6
 8003d76:	f006 fc23 	bl	800a5c0 <strncmp>
 8003d7a:	2800      	cmp	r0, #0
 8003d7c:	d1f4      	bne.n	8003d68 <chFactoryFindMailbox+0x18>
  if (dep != NULL) {
 8003d7e:	b114      	cbz	r4, 8003d86 <chFactoryFindMailbox+0x36>
    dep->refs++;
 8003d80:	6863      	ldr	r3, [r4, #4]
 8003d82:	3301      	adds	r3, #1
 8003d84:	6063      	str	r3, [r4, #4]

  dmp = (dyn_mailbox_t *)dyn_find_object(name, &ch_factory.mbx_list);

  F_UNLOCK();
 8003d86:	4805      	ldr	r0, [pc, #20]	; (8003d9c <chFactoryFindMailbox+0x4c>)
 8003d88:	f7fe fbb2 	bl	80024f0 <chMtxUnlock>

  return dmp;
}
 8003d8c:	4620      	mov	r0, r4
 8003d8e:	bd70      	pop	{r4, r5, r6, pc}
  F_UNLOCK();
 8003d90:	4802      	ldr	r0, [pc, #8]	; (8003d9c <chFactoryFindMailbox+0x4c>)
  return NULL;
 8003d92:	2400      	movs	r4, #0
  F_UNLOCK();
 8003d94:	f7fe fbac 	bl	80024f0 <chMtxUnlock>
}
 8003d98:	4620      	mov	r0, r4
 8003d9a:	bd70      	pop	{r4, r5, r6, pc}
 8003d9c:	20000c28 	.word	0x20000c28

08003da0 <chFactoryReleaseMailbox>:
 *
 * @param[in] dmp       dynamic mailbox object reference
 *
 * @api
 */
void chFactoryReleaseMailbox(dyn_mailbox_t *dmp) {
 8003da0:	b510      	push	{r4, lr}
 8003da2:	4604      	mov	r4, r0

  F_LOCK();
 8003da4:	480d      	ldr	r0, [pc, #52]	; (8003ddc <chFactoryReleaseMailbox+0x3c>)
 8003da6:	f7fe fb7b 	bl	80024a0 <chMtxLock>
  dep->refs--;
 8003daa:	6863      	ldr	r3, [r4, #4]
 8003dac:	3b01      	subs	r3, #1
 8003dae:	6063      	str	r3, [r4, #4]
  if (dep->refs == (ucnt_t)0) {
 8003db0:	b95b      	cbnz	r3, 8003dca <chFactoryReleaseMailbox+0x2a>
  dyn_element_t *prev = (dyn_element_t *)dlp;
 8003db2:	4b0b      	ldr	r3, [pc, #44]	; (8003de0 <chFactoryReleaseMailbox+0x40>)
 8003db4:	4618      	mov	r0, r3
 8003db6:	e001      	b.n	8003dbc <chFactoryReleaseMailbox+0x1c>
    if (prev->next == element) {
 8003db8:	4284      	cmp	r4, r0
 8003dba:	d00b      	beq.n	8003dd4 <chFactoryReleaseMailbox+0x34>
  while (prev->next != (dyn_element_t *)dlp) {
 8003dbc:	4602      	mov	r2, r0
 8003dbe:	6800      	ldr	r0, [r0, #0]
 8003dc0:	4298      	cmp	r0, r3
 8003dc2:	d1f9      	bne.n	8003db8 <chFactoryReleaseMailbox+0x18>
  return NULL;
 8003dc4:	2000      	movs	r0, #0
    chHeapFree((void *)dep);
 8003dc6:	f7ff f9ab 	bl	8003120 <chHeapFree>

  dyn_release_object_heap(&dmp->element, &ch_factory.mbx_list);

  F_UNLOCK();
}
 8003dca:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  F_UNLOCK();
 8003dce:	4803      	ldr	r0, [pc, #12]	; (8003ddc <chFactoryReleaseMailbox+0x3c>)
 8003dd0:	f7fe bb8e 	b.w	80024f0 <chMtxUnlock>
      prev->next = element->next;
 8003dd4:	6803      	ldr	r3, [r0, #0]
 8003dd6:	6013      	str	r3, [r2, #0]
      return element;
 8003dd8:	e7f5      	b.n	8003dc6 <chFactoryReleaseMailbox+0x26>
 8003dda:	bf00      	nop
 8003ddc:	20000c28 	.word	0x20000c28
 8003de0:	20000c64 	.word	0x20000c64
	...

08003df0 <chFactoryCreateObjectsFIFO>:
 * @api
 */
dyn_objects_fifo_t *chFactoryCreateObjectsFIFO(const char *name,
                                               size_t objsize,
                                               size_t objn,
                                               unsigned objalign) {
 8003df0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8003df4:	461f      	mov	r7, r3
 8003df6:	4616      	mov	r6, r2
 8003df8:	460c      	mov	r4, r1
 8003dfa:	4680      	mov	r8, r0
  dyn_objects_fifo_t *dofp;

  F_LOCK();

  /* Enforcing alignment for the objects array.*/
  objsize = MEM_ALIGN_NEXT(objsize, objalign);
 8003dfc:	3c01      	subs	r4, #1
  F_LOCK();
 8003dfe:	4816      	ldr	r0, [pc, #88]	; (8003e58 <chFactoryCreateObjectsFIFO+0x68>)
  size1   = MEM_ALIGN_NEXT(sizeof (dyn_objects_fifo_t) + (objn * sizeof (msg_t)),
 8003e00:	eb07 0586 	add.w	r5, r7, r6, lsl #2
  F_LOCK();
 8003e04:	f7fe fb4c 	bl	80024a0 <chMtxLock>
  objsize = MEM_ALIGN_NEXT(objsize, objalign);
 8003e08:	443c      	add	r4, r7
 8003e0a:	427b      	negs	r3, r7
  size1   = MEM_ALIGN_NEXT(sizeof (dyn_objects_fifo_t) + (objn * sizeof (msg_t)),
 8003e0c:	3553      	adds	r5, #83	; 0x53
  objsize = MEM_ALIGN_NEXT(objsize, objalign);
 8003e0e:	401c      	ands	r4, r3
  size1   = MEM_ALIGN_NEXT(sizeof (dyn_objects_fifo_t) + (objn * sizeof (msg_t)),
 8003e10:	401d      	ands	r5, r3
                           objalign);
  size2   = objn * objsize;

  /* Allocating the FIFO object with messages buffer and objects buffer.*/
  dofp = (dyn_objects_fifo_t *)dyn_create_object_heap(name,
 8003e12:	4640      	mov	r0, r8
 8003e14:	4911      	ldr	r1, [pc, #68]	; (8003e5c <chFactoryCreateObjectsFIFO+0x6c>)
 8003e16:	463b      	mov	r3, r7
 8003e18:	fb06 5204 	mla	r2, r6, r4, r5
 8003e1c:	f7ff fd70 	bl	8003900 <dyn_create_object_heap>
                                                      &ch_factory.fifo_list,
                                                      size1 + size2,
                                                      objalign);
  if (dofp != NULL) {
 8003e20:	4680      	mov	r8, r0
 8003e22:	b198      	cbz	r0, 8003e4c <chFactoryCreateObjectsFIFO+0x5c>
                                           size_t objn, unsigned objalign,
                                           void *objbuf, msg_t *msgbuf) {

  chDbgCheck((objsize >= objalign) && ((objsize % objalign) == 0U));

  chGuardedPoolObjectInitAligned(&ofp->free, objsize, objalign);
 8003e24:	4621      	mov	r1, r4
 8003e26:	f100 0410 	add.w	r4, r0, #16
    msg_t *msgbuf = (msg_t *)(dofp + 1);
    uint8_t *objbuf = (uint8_t *)dofp + size1;
 8003e2a:	4405      	add	r5, r0
 8003e2c:	463a      	mov	r2, r7
 8003e2e:	4620      	mov	r0, r4
 8003e30:	f7ff fa46 	bl	80032c0 <chGuardedPoolObjectInitAligned>
  chGuardedPoolLoadArray(&ofp->free, objbuf, objn);
 8003e34:	4632      	mov	r2, r6
 8003e36:	4629      	mov	r1, r5
 8003e38:	4620      	mov	r0, r4
 8003e3a:	f7ff fa51 	bl	80032e0 <chGuardedPoolLoadArray>
  chMBObjectInit(&ofp->mbx, msgbuf, objn);
 8003e3e:	4632      	mov	r2, r6
 8003e40:	f108 0154 	add.w	r1, r8, #84	; 0x54
 8003e44:	f108 002c 	add.w	r0, r8, #44	; 0x2c
 8003e48:	f7fe ff02 	bl	8002c50 <chMBObjectInit>
    /* Initializing mailbox object data.*/
    chFifoObjectInitAligned(&dofp->fifo, objsize, objn, objalign,
                            (void *)objbuf, msgbuf);
  }

  F_UNLOCK();
 8003e4c:	4802      	ldr	r0, [pc, #8]	; (8003e58 <chFactoryCreateObjectsFIFO+0x68>)
 8003e4e:	f7fe fb4f 	bl	80024f0 <chMtxUnlock>

  return dofp;
}
 8003e52:	4640      	mov	r0, r8
 8003e54:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 8003e58:	20000c28 	.word	0x20000c28
 8003e5c:	20000c68 	.word	0x20000c68

08003e60 <chFactoryFindObjectsFIFO>:
 * @api
 */
dyn_objects_fifo_t *chFactoryFindObjectsFIFO(const char *name) {
  dyn_objects_fifo_t *dofp;

  F_LOCK();
 8003e60:	4b12      	ldr	r3, [pc, #72]	; (8003eac <chFactoryFindObjectsFIFO+0x4c>)
dyn_objects_fifo_t *chFactoryFindObjectsFIFO(const char *name) {
 8003e62:	b570      	push	{r4, r5, r6, lr}
  dyn_element_t *p = dlp->next;
 8003e64:	461d      	mov	r5, r3
dyn_objects_fifo_t *chFactoryFindObjectsFIFO(const char *name) {
 8003e66:	4606      	mov	r6, r0
  F_LOCK();
 8003e68:	4618      	mov	r0, r3
 8003e6a:	f7fe fb19 	bl	80024a0 <chMtxLock>
  dyn_element_t *p = dlp->next;
 8003e6e:	f855 4f40 	ldr.w	r4, [r5, #64]!
  while (p != (dyn_element_t *)dlp) {
 8003e72:	42ac      	cmp	r4, r5
 8003e74:	d103      	bne.n	8003e7e <chFactoryFindObjectsFIFO+0x1e>
 8003e76:	e013      	b.n	8003ea0 <chFactoryFindObjectsFIFO+0x40>
    p = p->next;
 8003e78:	6824      	ldr	r4, [r4, #0]
  while (p != (dyn_element_t *)dlp) {
 8003e7a:	42ac      	cmp	r4, r5
 8003e7c:	d010      	beq.n	8003ea0 <chFactoryFindObjectsFIFO+0x40>
    if (strncmp(p->name, name, CH_CFG_FACTORY_MAX_NAMES_LENGTH) == 0) {
 8003e7e:	f104 0008 	add.w	r0, r4, #8
 8003e82:	2208      	movs	r2, #8
 8003e84:	4631      	mov	r1, r6
 8003e86:	f006 fb9b 	bl	800a5c0 <strncmp>
 8003e8a:	2800      	cmp	r0, #0
 8003e8c:	d1f4      	bne.n	8003e78 <chFactoryFindObjectsFIFO+0x18>
  if (dep != NULL) {
 8003e8e:	b114      	cbz	r4, 8003e96 <chFactoryFindObjectsFIFO+0x36>
    dep->refs++;
 8003e90:	6863      	ldr	r3, [r4, #4]
 8003e92:	3301      	adds	r3, #1
 8003e94:	6063      	str	r3, [r4, #4]

  dofp = (dyn_objects_fifo_t *)dyn_find_object(name, &ch_factory.fifo_list);

  F_UNLOCK();
 8003e96:	4805      	ldr	r0, [pc, #20]	; (8003eac <chFactoryFindObjectsFIFO+0x4c>)
 8003e98:	f7fe fb2a 	bl	80024f0 <chMtxUnlock>

  return dofp;
}
 8003e9c:	4620      	mov	r0, r4
 8003e9e:	bd70      	pop	{r4, r5, r6, pc}
  F_UNLOCK();
 8003ea0:	4802      	ldr	r0, [pc, #8]	; (8003eac <chFactoryFindObjectsFIFO+0x4c>)
  return NULL;
 8003ea2:	2400      	movs	r4, #0
  F_UNLOCK();
 8003ea4:	f7fe fb24 	bl	80024f0 <chMtxUnlock>
}
 8003ea8:	4620      	mov	r0, r4
 8003eaa:	bd70      	pop	{r4, r5, r6, pc}
 8003eac:	20000c28 	.word	0x20000c28

08003eb0 <chFactoryReleaseObjectsFIFO>:
 *
 * @param[in] dofp      dynamic "objects FIFO" object reference
 *
 * @api
 */
void chFactoryReleaseObjectsFIFO(dyn_objects_fifo_t *dofp) {
 8003eb0:	b510      	push	{r4, lr}
 8003eb2:	4604      	mov	r4, r0

  F_LOCK();
 8003eb4:	480d      	ldr	r0, [pc, #52]	; (8003eec <chFactoryReleaseObjectsFIFO+0x3c>)
 8003eb6:	f7fe faf3 	bl	80024a0 <chMtxLock>
  dep->refs--;
 8003eba:	6863      	ldr	r3, [r4, #4]
 8003ebc:	3b01      	subs	r3, #1
 8003ebe:	6063      	str	r3, [r4, #4]
  if (dep->refs == (ucnt_t)0) {
 8003ec0:	b95b      	cbnz	r3, 8003eda <chFactoryReleaseObjectsFIFO+0x2a>
  dyn_element_t *prev = (dyn_element_t *)dlp;
 8003ec2:	4b0b      	ldr	r3, [pc, #44]	; (8003ef0 <chFactoryReleaseObjectsFIFO+0x40>)
 8003ec4:	4618      	mov	r0, r3
 8003ec6:	e001      	b.n	8003ecc <chFactoryReleaseObjectsFIFO+0x1c>
    if (prev->next == element) {
 8003ec8:	4284      	cmp	r4, r0
 8003eca:	d00b      	beq.n	8003ee4 <chFactoryReleaseObjectsFIFO+0x34>
  while (prev->next != (dyn_element_t *)dlp) {
 8003ecc:	4602      	mov	r2, r0
 8003ece:	6800      	ldr	r0, [r0, #0]
 8003ed0:	4298      	cmp	r0, r3
 8003ed2:	d1f9      	bne.n	8003ec8 <chFactoryReleaseObjectsFIFO+0x18>
  return NULL;
 8003ed4:	2000      	movs	r0, #0
    chHeapFree((void *)dep);
 8003ed6:	f7ff f923 	bl	8003120 <chHeapFree>

  dyn_release_object_heap(&dofp->element, &ch_factory.fifo_list);

  F_UNLOCK();
}
 8003eda:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  F_UNLOCK();
 8003ede:	4803      	ldr	r0, [pc, #12]	; (8003eec <chFactoryReleaseObjectsFIFO+0x3c>)
 8003ee0:	f7fe bb06 	b.w	80024f0 <chMtxUnlock>
      prev->next = element->next;
 8003ee4:	6803      	ldr	r3, [r0, #0]
 8003ee6:	6013      	str	r3, [r2, #0]
      return element;
 8003ee8:	e7f5      	b.n	8003ed6 <chFactoryReleaseObjectsFIFO+0x26>
 8003eea:	bf00      	nop
 8003eec:	20000c28 	.word	0x20000c28
 8003ef0:	20000c68 	.word	0x20000c68
	...

08003f00 <chFactoryCreatePipe>:
 *                      allocated or a dynamic pipe object with
 *                      the same name exists.
 *
 * @api
 */
dyn_pipe_t *chFactoryCreatePipe(const char *name, size_t size) {
 8003f00:	b538      	push	{r3, r4, r5, lr}
 8003f02:	4604      	mov	r4, r0
 8003f04:	460d      	mov	r5, r1
  dyn_pipe_t *dpp;

  F_LOCK();
 8003f06:	480b      	ldr	r0, [pc, #44]	; (8003f34 <chFactoryCreatePipe+0x34>)
 8003f08:	f7fe faca 	bl	80024a0 <chMtxLock>

  dpp = (dyn_pipe_t *)dyn_create_object_heap(name,
 8003f0c:	4620      	mov	r0, r4
 8003f0e:	490a      	ldr	r1, [pc, #40]	; (8003f38 <chFactoryCreatePipe+0x38>)
 8003f10:	2308      	movs	r3, #8
 8003f12:	f105 0260 	add.w	r2, r5, #96	; 0x60
 8003f16:	f7ff fcf3 	bl	8003900 <dyn_create_object_heap>
                                             &ch_factory.pipe_list,
                                             sizeof (dyn_pipe_t) + size,
                                             CH_HEAP_ALIGNMENT);
  if (dpp != NULL) {
 8003f1a:	4604      	mov	r4, r0
 8003f1c:	b128      	cbz	r0, 8003f2a <chFactoryCreatePipe+0x2a>
    /* Initializing mailbox object data.*/
    chPipeObjectInit(&dpp->pipe, (uint8_t *)(dpp + 1), size);
 8003f1e:	f100 0160 	add.w	r1, r0, #96	; 0x60
 8003f22:	462a      	mov	r2, r5
 8003f24:	3010      	adds	r0, #16
 8003f26:	f7ff fa2b 	bl	8003380 <chPipeObjectInit>
  }

  F_UNLOCK();
 8003f2a:	4802      	ldr	r0, [pc, #8]	; (8003f34 <chFactoryCreatePipe+0x34>)
 8003f2c:	f7fe fae0 	bl	80024f0 <chMtxUnlock>

  return dpp;
}
 8003f30:	4620      	mov	r0, r4
 8003f32:	bd38      	pop	{r3, r4, r5, pc}
 8003f34:	20000c28 	.word	0x20000c28
 8003f38:	20000c6c 	.word	0x20000c6c
 8003f3c:	00000000 	.word	0x00000000

08003f40 <chFactoryFindPipe>:
 * @api
 */
dyn_pipe_t *chFactoryFindPipe(const char *name) {
  dyn_pipe_t *dpp;

  F_LOCK();
 8003f40:	4b12      	ldr	r3, [pc, #72]	; (8003f8c <chFactoryFindPipe+0x4c>)
dyn_pipe_t *chFactoryFindPipe(const char *name) {
 8003f42:	b570      	push	{r4, r5, r6, lr}
  dyn_element_t *p = dlp->next;
 8003f44:	461d      	mov	r5, r3
dyn_pipe_t *chFactoryFindPipe(const char *name) {
 8003f46:	4606      	mov	r6, r0
  F_LOCK();
 8003f48:	4618      	mov	r0, r3
 8003f4a:	f7fe faa9 	bl	80024a0 <chMtxLock>
  dyn_element_t *p = dlp->next;
 8003f4e:	f855 4f44 	ldr.w	r4, [r5, #68]!
  while (p != (dyn_element_t *)dlp) {
 8003f52:	42ac      	cmp	r4, r5
 8003f54:	d103      	bne.n	8003f5e <chFactoryFindPipe+0x1e>
 8003f56:	e013      	b.n	8003f80 <chFactoryFindPipe+0x40>
    p = p->next;
 8003f58:	6824      	ldr	r4, [r4, #0]
  while (p != (dyn_element_t *)dlp) {
 8003f5a:	42ac      	cmp	r4, r5
 8003f5c:	d010      	beq.n	8003f80 <chFactoryFindPipe+0x40>
    if (strncmp(p->name, name, CH_CFG_FACTORY_MAX_NAMES_LENGTH) == 0) {
 8003f5e:	f104 0008 	add.w	r0, r4, #8
 8003f62:	2208      	movs	r2, #8
 8003f64:	4631      	mov	r1, r6
 8003f66:	f006 fb2b 	bl	800a5c0 <strncmp>
 8003f6a:	2800      	cmp	r0, #0
 8003f6c:	d1f4      	bne.n	8003f58 <chFactoryFindPipe+0x18>
  if (dep != NULL) {
 8003f6e:	b114      	cbz	r4, 8003f76 <chFactoryFindPipe+0x36>
    dep->refs++;
 8003f70:	6863      	ldr	r3, [r4, #4]
 8003f72:	3301      	adds	r3, #1
 8003f74:	6063      	str	r3, [r4, #4]

  dpp = (dyn_pipe_t *)dyn_find_object(name, &ch_factory.pipe_list);

  F_UNLOCK();
 8003f76:	4805      	ldr	r0, [pc, #20]	; (8003f8c <chFactoryFindPipe+0x4c>)
 8003f78:	f7fe faba 	bl	80024f0 <chMtxUnlock>

  return dpp;
}
 8003f7c:	4620      	mov	r0, r4
 8003f7e:	bd70      	pop	{r4, r5, r6, pc}
  F_UNLOCK();
 8003f80:	4802      	ldr	r0, [pc, #8]	; (8003f8c <chFactoryFindPipe+0x4c>)
  return NULL;
 8003f82:	2400      	movs	r4, #0
  F_UNLOCK();
 8003f84:	f7fe fab4 	bl	80024f0 <chMtxUnlock>
}
 8003f88:	4620      	mov	r0, r4
 8003f8a:	bd70      	pop	{r4, r5, r6, pc}
 8003f8c:	20000c28 	.word	0x20000c28

08003f90 <chFactoryReleasePipe>:
 *
 * @param[in] dpp       dynamic pipe object reference
 *
 * @api
 */
void chFactoryReleasePipe(dyn_pipe_t *dpp) {
 8003f90:	b510      	push	{r4, lr}
 8003f92:	4604      	mov	r4, r0

  F_LOCK();
 8003f94:	480d      	ldr	r0, [pc, #52]	; (8003fcc <chFactoryReleasePipe+0x3c>)
 8003f96:	f7fe fa83 	bl	80024a0 <chMtxLock>
  dep->refs--;
 8003f9a:	6863      	ldr	r3, [r4, #4]
 8003f9c:	3b01      	subs	r3, #1
 8003f9e:	6063      	str	r3, [r4, #4]
  if (dep->refs == (ucnt_t)0) {
 8003fa0:	b95b      	cbnz	r3, 8003fba <chFactoryReleasePipe+0x2a>
  dyn_element_t *prev = (dyn_element_t *)dlp;
 8003fa2:	4b0b      	ldr	r3, [pc, #44]	; (8003fd0 <chFactoryReleasePipe+0x40>)
 8003fa4:	4618      	mov	r0, r3
 8003fa6:	e001      	b.n	8003fac <chFactoryReleasePipe+0x1c>
    if (prev->next == element) {
 8003fa8:	4284      	cmp	r4, r0
 8003faa:	d00b      	beq.n	8003fc4 <chFactoryReleasePipe+0x34>
  while (prev->next != (dyn_element_t *)dlp) {
 8003fac:	4602      	mov	r2, r0
 8003fae:	6800      	ldr	r0, [r0, #0]
 8003fb0:	4298      	cmp	r0, r3
 8003fb2:	d1f9      	bne.n	8003fa8 <chFactoryReleasePipe+0x18>
  return NULL;
 8003fb4:	2000      	movs	r0, #0
    chHeapFree((void *)dep);
 8003fb6:	f7ff f8b3 	bl	8003120 <chHeapFree>

  dyn_release_object_heap(&dpp->element, &ch_factory.pipe_list);

  F_UNLOCK();
}
 8003fba:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  F_UNLOCK();
 8003fbe:	4803      	ldr	r0, [pc, #12]	; (8003fcc <chFactoryReleasePipe+0x3c>)
 8003fc0:	f7fe ba96 	b.w	80024f0 <chMtxUnlock>
      prev->next = element->next;
 8003fc4:	6803      	ldr	r3, [r0, #0]
 8003fc6:	6013      	str	r3, [r2, #0]
      return element;
 8003fc8:	e7f5      	b.n	8003fb6 <chFactoryReleasePipe+0x26>
 8003fca:	bf00      	nop
 8003fcc:	20000c28 	.word	0x20000c28
 8003fd0:	20000c6c 	.word	0x20000c6c
	...

08003fe0 <SVC_Handler>:
  __ASM volatile ("MRS %0, psp"  : "=r" (result) );
 8003fe0:	f3ef 8309 	mrs	r3, PSP
    /* From privileged mode, it is used for context discarding in the
       preemption code.*/

    /* Unstacking procedure, discarding the current exception context and
       positioning the stack to point to the real one.*/
    psp += sizeof (struct port_extctx);
 8003fe4:	3320      	adds	r3, #32
  __ASM volatile ("MSR psp, %0" : : "r" (topOfProcStack) : );
 8003fe6:	f383 8809 	msr	PSP, r3
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 8003fea:	2300      	movs	r3, #0
 8003fec:	f383 8811 	msr	BASEPRI, r3
#endif

    /* Restoring the normal interrupts status.*/
    port_unlock_from_isr();
  }
}
 8003ff0:	4770      	bx	lr
 8003ff2:	bf00      	nop
	...

08004000 <port_init>:
 8004000:	2030      	movs	r0, #48	; 0x30
 8004002:	f380 8811 	msr	BASEPRI, r0
  __ASM volatile ("cpsie i" : : : "memory");
 8004006:	b662      	cpsie	i
__STATIC_INLINE void __NVIC_SetPriorityGrouping(uint32_t PriorityGroup)
{
  uint32_t reg_value;
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);             /* only values 0..7 are used          */

  reg_value  =  SCB->AIRCR;                                                   /* read old register configuration    */
 8004008:	4b0d      	ldr	r3, [pc, #52]	; (8004040 <port_init+0x40>)
  reg_value &= ~((uint32_t)(SCB_AIRCR_VECTKEY_Msk | SCB_AIRCR_PRIGROUP_Msk)); /* clear bits to change               */
  reg_value  =  (reg_value                                   |
 800400a:	4a0e      	ldr	r2, [pc, #56]	; (8004044 <port_init+0x44>)
  reg_value  =  SCB->AIRCR;                                                   /* read old register configuration    */
 800400c:	68d9      	ldr	r1, [r3, #12]
  reg_value &= ~((uint32_t)(SCB_AIRCR_VECTKEY_Msk | SCB_AIRCR_PRIGROUP_Msk)); /* clear bits to change               */
 800400e:	f64f 0cff 	movw	ip, #63743	; 0xf8ff
 8004012:	ea01 010c 	and.w	r1, r1, ip
  reg_value  =  (reg_value                                   |
 8004016:	430a      	orrs	r2, r1
                ((uint32_t)0x5FAUL << SCB_AIRCR_VECTKEY_Pos) |
                (PriorityGroupTmp << SCB_AIRCR_PRIGROUP_Pos)  );              /* Insert write key and priority group */
  SCB->AIRCR =  reg_value;
 8004018:	60da      	str	r2, [r3, #12]

  /* Initializing priority grouping.*/
  NVIC_SetPriorityGrouping(CORTEX_PRIGROUP_INIT);

  /* DWT cycle counter enable, note, the M7 requires DWT unlocking.*/
  CoreDebug->DEMCR |= CoreDebug_DEMCR_TRCENA_Msk;
 800401a:	f8d3 20fc 	ldr.w	r2, [r3, #252]	; 0xfc
#if CORTEX_MODEL == 7
  DWT->LAR = 0xC5ACCE55U;
#endif
  DWT->CTRL |= DWT_CTRL_CYCCNTENA_Msk;
 800401e:	490a      	ldr	r1, [pc, #40]	; (8004048 <port_init+0x48>)
  CoreDebug->DEMCR |= CoreDebug_DEMCR_TRCENA_Msk;
 8004020:	f042 7280 	orr.w	r2, r2, #16777216	; 0x1000000
 8004024:	f8c3 20fc 	str.w	r2, [r3, #252]	; 0xfc
  DWT->CTRL |= DWT_CTRL_CYCCNTENA_Msk;
 8004028:	680a      	ldr	r2, [r1, #0]
  {
    NVIC->IP[((uint32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
  }
  else
  {
    SCB->SHP[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 800402a:	f04f 0c20 	mov.w	ip, #32
 800402e:	f042 0201 	orr.w	r2, r2, #1
 8004032:	600a      	str	r2, [r1, #0]
 8004034:	f883 c01f 	strb.w	ip, [r3, #31]
 8004038:	f883 0022 	strb.w	r0, [r3, #34]	; 0x22

#if (PORT_ENABLE_GUARD_PAGES == TRUE) || (PORT_USE_SYSCALL == TRUE)
  /* MPU is enabled.*/
  mpuEnable(MPU_CTRL_PRIVDEFENA);
#endif
}
 800403c:	4770      	bx	lr
 800403e:	bf00      	nop
 8004040:	e000ed00 	.word	0xe000ed00
 8004044:	05fa0300 	.word	0x05fa0300
 8004048:	e0001000 	.word	0xe0001000
 800404c:	00000000 	.word	0x00000000

08004050 <__port_irq_epilogue>:
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 8004050:	2330      	movs	r3, #48	; 0x30
 8004052:	f383 8811 	msr	BASEPRI, r3
 * @brief   Exception exit redirection to @p __port_switch_from_isr().
 */
void __port_irq_epilogue(void) {

  port_lock_from_isr();
  if ((SCB->ICSR & SCB_ICSR_RETTOBASE_Msk) != 0U) {
 8004056:	4b0d      	ldr	r3, [pc, #52]	; (800408c <__port_irq_epilogue+0x3c>)
 8004058:	685b      	ldr	r3, [r3, #4]
 800405a:	f413 6300 	ands.w	r3, r3, #2048	; 0x800
 800405e:	d102      	bne.n	8004066 <__port_irq_epilogue+0x16>
 8004060:	f383 8811 	msr	BASEPRI, r3
 8004064:	4770      	bx	lr
void __port_irq_epilogue(void) {
 8004066:	b510      	push	{r4, lr}
  __ASM volatile ("MRS %0, psp"  : "=r" (result) );
 8004068:	f3ef 8409 	mrs	r4, PSP
    s_psp = __get_PSP();
#endif

    /* Adding an artificial exception return context, there is no need to
       populate it fully.*/
    s_psp -= sizeof (struct port_extctx);
 800406c:	3c20      	subs	r4, #32

    /* The port_extctx structure is pointed by the S-PSP register.*/
    ectxp = (struct port_extctx *)s_psp;

    /* Setting up a fake XPSR register value.*/
    ectxp->xpsr = 0x01000000U;
 800406e:	f04f 7380 	mov.w	r3, #16777216	; 0x1000000
 8004072:	61e3      	str	r3, [r4, #28]
  __ASM volatile ("MSR psp, %0" : : "r" (topOfProcStack) : );
 8004074:	f384 8809 	msr	PSP, r4
    /* Writing back the modified S-PSP value.*/
    __set_PSP(s_psp);

    /* The exit sequence is different depending on if a preemption is
       required or not.*/
    if (chSchIsPreemptionRequired()) {
 8004078:	f7fd fd62 	bl	8001b40 <chSchIsPreemptionRequired>
 800407c:	b110      	cbz	r0, 8004084 <__port_irq_epilogue+0x34>
      /* Preemption is required we need to enforce a context switch.*/
      ectxp->pc = (uint32_t)__port_switch_from_isr;
 800407e:	4b04      	ldr	r3, [pc, #16]	; (8004090 <__port_irq_epilogue+0x40>)
 8004080:	61a3      	str	r3, [r4, #24]
    /* Note, returning without unlocking is intentional, this is done in
       order to keep the rest of the context switch atomic.*/
    return;
  }
  port_unlock_from_isr();
}
 8004082:	bd10      	pop	{r4, pc}
      ectxp->pc = (uint32_t)__port_exit_from_isr;
 8004084:	4b03      	ldr	r3, [pc, #12]	; (8004094 <__port_irq_epilogue+0x44>)
 8004086:	61a3      	str	r3, [r4, #24]
}
 8004088:	bd10      	pop	{r4, pc}
 800408a:	bf00      	nop
 800408c:	e000ed00 	.word	0xe000ed00
 8004090:	080002a3 	.word	0x080002a3
 8004094:	080002a6 	.word	0x080002a6
	...

080040a0 <test_stream_putchar>:
/*===========================================================================*/

#if (TEST_CFG_CHIBIOS_SUPPORT == TRUE) || defined(__DOXYGEN__)
static int test_stream_putchar(int c) {

  streamPut(chtest.stream, (uint8_t)c);
 80040a0:	4b04      	ldr	r3, [pc, #16]	; (80040b4 <test_stream_putchar+0x14>)
static int test_stream_putchar(int c) {
 80040a2:	b510      	push	{r4, lr}
 80040a4:	4604      	mov	r4, r0
  streamPut(chtest.stream, (uint8_t)c);
 80040a6:	6a58      	ldr	r0, [r3, #36]	; 0x24
 80040a8:	6803      	ldr	r3, [r0, #0]
 80040aa:	b2e1      	uxtb	r1, r4
 80040ac:	68db      	ldr	r3, [r3, #12]
 80040ae:	4798      	blx	r3

  return c;
}
 80040b0:	4620      	mov	r0, r4
 80040b2:	bd10      	pop	{r4, pc}
 80040b4:	20000c70 	.word	0x20000c70
	...

080040c0 <test_execute_inner>:
 * @param[in] tsp       test suite to execute
 * @return              A failure boolean.
 * @retval false        if no errors occurred.
 * @retval true         if one or more tests failed.
 */
static bool test_execute_inner(const testsuite_t *tsp) {
 80040c0:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
 80040c4:	4680      	mov	r8, r0
  unsigned tseq, tcase;

  /* Test execution.*/
  test_printf(TEST_CFG_EOL_STRING);
 80040c6:	4875      	ldr	r0, [pc, #468]	; (800429c <test_execute_inner+0x1dc>)
 80040c8:	f000 fbb2 	bl	8004830 <test_printf>
  if (tsp->name != NULL) {
 80040cc:	f8d8 1000 	ldr.w	r1, [r8]
 80040d0:	2900      	cmp	r1, #0
 80040d2:	f000 80df 	beq.w	8004294 <test_execute_inner+0x1d4>
    test_printf("*** %s"TEST_CFG_EOL_STRING, tsp->name);
 80040d6:	4872      	ldr	r0, [pc, #456]	; (80042a0 <test_execute_inner+0x1e0>)
 80040d8:	f000 fbaa 	bl	8004830 <test_printf>
  }
  else {
    test_printf("*** Test Suite"TEST_CFG_EOL_STRING);
  }
  test_printf("***"TEST_CFG_EOL_STRING);
 80040dc:	4871      	ldr	r0, [pc, #452]	; (80042a4 <test_execute_inner+0x1e4>)
#if defined(TEST_REPORT_HOOK_HEADER)
  TEST_REPORT_HOOK_HEADER();
#endif
  test_printf(TEST_CFG_EOL_STRING);

  chtest.global_fail = false;
 80040de:	4e72      	ldr	r6, [pc, #456]	; (80042a8 <test_execute_inner+0x1e8>)
  test_printf("***"TEST_CFG_EOL_STRING);
 80040e0:	f000 fba6 	bl	8004830 <test_printf>
  test_printf("*** Compiled:     %s"TEST_CFG_EOL_STRING, __DATE__ " - " __TIME__);
 80040e4:	4971      	ldr	r1, [pc, #452]	; (80042ac <test_execute_inner+0x1ec>)
 80040e6:	4872      	ldr	r0, [pc, #456]	; (80042b0 <test_execute_inner+0x1f0>)
 80040e8:	f000 fba2 	bl	8004830 <test_printf>
  test_printf("*** Platform:     %s"TEST_CFG_EOL_STRING, PLATFORM_NAME);
 80040ec:	4971      	ldr	r1, [pc, #452]	; (80042b4 <test_execute_inner+0x1f4>)
 80040ee:	4872      	ldr	r0, [pc, #456]	; (80042b8 <test_execute_inner+0x1f8>)
 80040f0:	f000 fb9e 	bl	8004830 <test_printf>
  test_printf("*** Test Board:   %s"TEST_CFG_EOL_STRING, BOARD_NAME);
 80040f4:	4971      	ldr	r1, [pc, #452]	; (80042bc <test_execute_inner+0x1fc>)
 80040f6:	4872      	ldr	r0, [pc, #456]	; (80042c0 <test_execute_inner+0x200>)
 80040f8:	f000 fb9a 	bl	8004830 <test_printf>
    test_printf("***"TEST_CFG_EOL_STRING);
 80040fc:	4869      	ldr	r0, [pc, #420]	; (80042a4 <test_execute_inner+0x1e4>)
 80040fe:	f000 fb97 	bl	8004830 <test_printf>
    test_printf("*** Text size:    %u bytes"TEST_CFG_EOL_STRING, &__text_end__   - &__text_base__);
 8004102:	4b70      	ldr	r3, [pc, #448]	; (80042c4 <test_execute_inner+0x204>)
 8004104:	4970      	ldr	r1, [pc, #448]	; (80042c8 <test_execute_inner+0x208>)
 8004106:	4871      	ldr	r0, [pc, #452]	; (80042cc <test_execute_inner+0x20c>)
 8004108:	1ac9      	subs	r1, r1, r3
 800410a:	f000 fb91 	bl	8004830 <test_printf>
    test_printf("*** RO data size: %u bytes"TEST_CFG_EOL_STRING, &__rodata_end__ - &__rodata_base__);
 800410e:	4b70      	ldr	r3, [pc, #448]	; (80042d0 <test_execute_inner+0x210>)
 8004110:	4970      	ldr	r1, [pc, #448]	; (80042d4 <test_execute_inner+0x214>)
 8004112:	4871      	ldr	r0, [pc, #452]	; (80042d8 <test_execute_inner+0x218>)
 8004114:	1ac9      	subs	r1, r1, r3
 8004116:	f000 fb8b 	bl	8004830 <test_printf>
    test_printf("*** Data size:    %u bytes"TEST_CFG_EOL_STRING, &__data_end__   - &__data_base__);
 800411a:	4b70      	ldr	r3, [pc, #448]	; (80042dc <test_execute_inner+0x21c>)
 800411c:	4970      	ldr	r1, [pc, #448]	; (80042e0 <test_execute_inner+0x220>)
 800411e:	4871      	ldr	r0, [pc, #452]	; (80042e4 <test_execute_inner+0x224>)
 8004120:	1ac9      	subs	r1, r1, r3
 8004122:	f000 fb85 	bl	8004830 <test_printf>
    test_printf("*** BSS size:     %u bytes"TEST_CFG_EOL_STRING, &__bss_end__    - &__bss_base__);
 8004126:	4b70      	ldr	r3, [pc, #448]	; (80042e8 <test_execute_inner+0x228>)
 8004128:	4970      	ldr	r1, [pc, #448]	; (80042ec <test_execute_inner+0x22c>)
 800412a:	4871      	ldr	r0, [pc, #452]	; (80042f0 <test_execute_inner+0x230>)
 800412c:	1ac9      	subs	r1, r1, r3
 800412e:	f000 fb7f 	bl	8004830 <test_printf>
  test_printf(TEST_CFG_EOL_STRING);
 8004132:	485a      	ldr	r0, [pc, #360]	; (800429c <test_execute_inner+0x1dc>)
 8004134:	f000 fb7c 	bl	8004830 <test_printf>
  tseq = 0U;
  while (tsp->sequences[tseq] != NULL) {
 8004138:	f8d8 3004 	ldr.w	r3, [r8, #4]
 800413c:	681a      	ldr	r2, [r3, #0]
  chtest.global_fail = false;
 800413e:	2300      	movs	r3, #0
 8004140:	7133      	strb	r3, [r6, #4]
  while (tsp->sequences[tseq] != NULL) {
 8004142:	2a00      	cmp	r2, #0
 8004144:	f000 8084 	beq.w	8004250 <test_execute_inner+0x190>
  tseq = 0U;
 8004148:	469a      	mov	sl, r3
  while (tsp->sequences[tseq] != NULL) {
 800414a:	4699      	mov	r9, r3
 800414c:	244c      	movs	r4, #76	; 0x4c
    test_putchar('=');
 800414e:	203d      	movs	r0, #61	; 0x3d
 8004150:	f000 f94e 	bl	80043f0 <test_putchar>
  for (i = 0; i < 76; i++) {
 8004154:	3c01      	subs	r4, #1
 8004156:	d1fa      	bne.n	800414e <test_execute_inner+0x8e>
 8004158:	4d50      	ldr	r5, [pc, #320]	; (800429c <test_execute_inner+0x1dc>)
  while ((c = *s) != '\0') {
 800415a:	200d      	movs	r0, #13
    test_putchar(c);
 800415c:	f000 f948 	bl	80043f0 <test_putchar>
  while ((c = *s) != '\0') {
 8004160:	f815 0f01 	ldrb.w	r0, [r5, #1]!
 8004164:	2800      	cmp	r0, #0
 8004166:	d1f9      	bne.n	800415c <test_execute_inner+0x9c>
#if defined(TEST_REPORT_HOOK_TESTSEQUENCE)
    TEST_REPORT_HOOK_TESTSEQUENCE(tsp->sequences[tseq]);
#endif
#if TEST_CFG_SHOW_SEQUENCES == TRUE
    test_print_fat_line();
    test_printf("=== Test Sequence %u (%s)"TEST_CFG_EOL_STRING, tseq + 1U, tsp->sequences[tseq]->name);
 8004168:	f8d8 3004 	ldr.w	r3, [r8, #4]
 800416c:	4861      	ldr	r0, [pc, #388]	; (80042f4 <test_execute_inner+0x234>)
 800416e:	f853 3009 	ldr.w	r3, [r3, r9]
 8004172:	f10a 0a01 	add.w	sl, sl, #1
 8004176:	681a      	ldr	r2, [r3, #0]
 8004178:	4651      	mov	r1, sl
 800417a:	f000 fb59 	bl	8004830 <test_printf>
#endif
    tcase = 0U;
    while (tsp->sequences[tseq]->cases[tcase] != NULL) {
 800417e:	f8d8 2004 	ldr.w	r2, [r8, #4]
 8004182:	f852 3009 	ldr.w	r3, [r2, r9]
 8004186:	685b      	ldr	r3, [r3, #4]
 8004188:	681b      	ldr	r3, [r3, #0]
 800418a:	2b00      	cmp	r3, #0
 800418c:	d059      	beq.n	8004242 <test_execute_inner+0x182>
 800418e:	00a7      	lsls	r7, r4, #2
  while ((c = *s) != '\0') {
 8004190:	254c      	movs	r5, #76	; 0x4c
    test_putchar('-');
 8004192:	202d      	movs	r0, #45	; 0x2d
 8004194:	f000 f92c 	bl	80043f0 <test_putchar>
  for (i = 0; i < 76; i++) {
 8004198:	3d01      	subs	r5, #1
 800419a:	d1fa      	bne.n	8004192 <test_execute_inner+0xd2>
  while ((c = *s) != '\0') {
 800419c:	250d      	movs	r5, #13
 800419e:	f8df b0fc 	ldr.w	fp, [pc, #252]	; 800429c <test_execute_inner+0x1dc>
 80041a2:	4628      	mov	r0, r5
    test_putchar(c);
 80041a4:	f000 f924 	bl	80043f0 <test_putchar>
  while ((c = *s) != '\0') {
 80041a8:	f81b 0f01 	ldrb.w	r0, [fp, #1]!
 80041ac:	2800      	cmp	r0, #0
 80041ae:	d1f9      	bne.n	80041a4 <test_execute_inner+0xe4>
      test_print_line();
      test_printf("--- Test Case %u.%u (%s)"TEST_CFG_EOL_STRING, tseq + 1U, tcase + 1U, tsp->sequences[tseq]->cases[tcase]->name);
 80041b0:	f8d8 3004 	ldr.w	r3, [r8, #4]
 80041b4:	f853 3009 	ldr.w	r3, [r3, r9]
 80041b8:	685b      	ldr	r3, [r3, #4]
 80041ba:	59db      	ldr	r3, [r3, r7]
 80041bc:	3401      	adds	r4, #1
 80041be:	681b      	ldr	r3, [r3, #0]
 80041c0:	4605      	mov	r5, r0
 80041c2:	4622      	mov	r2, r4
 80041c4:	4651      	mov	r1, sl
 80041c6:	484c      	ldr	r0, [pc, #304]	; (80042f8 <test_execute_inner+0x238>)
 80041c8:	f000 fb32 	bl	8004830 <test_printf>
  chThdSleep(delay);
 80041cc:	f44f 60fa 	mov.w	r0, #2000	; 0x7d0
 80041d0:	f7fd feee 	bl	8001fb0 <chThdSleep>
      osalThreadSleepMilliseconds(TEST_CFG_DELAY_BETWEEN_TESTS);
#endif
#if defined(TEST_REPORT_HOOK_TESTCASE)
      TEST_REPORT_HOOK_TESTCASE(tsp->sequences[tseq]->cases[tcase]);
#endif
      test_execute_case(tsp->sequences[tseq]->cases[tcase]);
 80041d4:	f8d8 3004 	ldr.w	r3, [r8, #4]
 80041d8:	f853 3009 	ldr.w	r3, [r3, r9]
 80041dc:	685b      	ldr	r3, [r3, #4]
 80041de:	f853 b007 	ldr.w	fp, [r3, r7]
  chtest.tokp = chtest.tokens_buffer;
 80041e2:	4b46      	ldr	r3, [pc, #280]	; (80042fc <test_execute_inner+0x23c>)
 80041e4:	60f3      	str	r3, [r6, #12]
  if (tcp->setup != NULL) {
 80041e6:	f8db 3004 	ldr.w	r3, [fp, #4]
  chtest.local_fail = false;
 80041ea:	7175      	strb	r5, [r6, #5]
  if (tcp->setup != NULL) {
 80041ec:	b103      	cbz	r3, 80041f0 <test_execute_inner+0x130>
    tcp->setup();
 80041ee:	4798      	blx	r3
  tcp->execute();
 80041f0:	f8db 300c 	ldr.w	r3, [fp, #12]
 80041f4:	4798      	blx	r3
  if (tcp->teardown != NULL) {
 80041f6:	f8db 3008 	ldr.w	r3, [fp, #8]
 80041fa:	b103      	cbz	r3, 80041fe <test_execute_inner+0x13e>
    tcp->teardown();
 80041fc:	4798      	blx	r3
      if (chtest.local_fail) {
 80041fe:	7973      	ldrb	r3, [r6, #5]
 8004200:	2b00      	cmp	r3, #0
 8004202:	d043      	beq.n	800428c <test_execute_inner+0x1cc>
        test_printf("--- Result: FAILURE (#%u [", chtest.current_step, "", chtest.failure_message);
 8004204:	68b3      	ldr	r3, [r6, #8]
 8004206:	4a3e      	ldr	r2, [pc, #248]	; (8004300 <test_execute_inner+0x240>)
 8004208:	6831      	ldr	r1, [r6, #0]
 800420a:	483e      	ldr	r0, [pc, #248]	; (8004304 <test_execute_inner+0x244>)
 800420c:	f000 fb10 	bl	8004830 <test_printf>
  while (cp < chtest.tokp) {
 8004210:	68f3      	ldr	r3, [r6, #12]
 8004212:	4a3a      	ldr	r2, [pc, #232]	; (80042fc <test_execute_inner+0x23c>)
 8004214:	4293      	cmp	r3, r2
 8004216:	d907      	bls.n	8004228 <test_execute_inner+0x168>
  char *cp = chtest.tokens_buffer;
 8004218:	4d38      	ldr	r5, [pc, #224]	; (80042fc <test_execute_inner+0x23c>)
    test_putchar(*cp++);
 800421a:	f815 0b01 	ldrb.w	r0, [r5], #1
 800421e:	f000 f8e7 	bl	80043f0 <test_putchar>
  while (cp < chtest.tokp) {
 8004222:	68f3      	ldr	r3, [r6, #12]
 8004224:	429d      	cmp	r5, r3
 8004226:	d3f8      	bcc.n	800421a <test_execute_inner+0x15a>
        test_print_tokens();
        test_printf("] \"%s\")"TEST_CFG_EOL_STRING, chtest.failure_message);
 8004228:	68b1      	ldr	r1, [r6, #8]
 800422a:	4837      	ldr	r0, [pc, #220]	; (8004308 <test_execute_inner+0x248>)
 800422c:	f000 fb00 	bl	8004830 <test_printf>
    while (tsp->sequences[tseq]->cases[tcase] != NULL) {
 8004230:	f8d8 2004 	ldr.w	r2, [r8, #4]
 8004234:	f852 3009 	ldr.w	r3, [r2, r9]
 8004238:	685b      	ldr	r3, [r3, #4]
 800423a:	441f      	add	r7, r3
 800423c:	687b      	ldr	r3, [r7, #4]
 800423e:	2b00      	cmp	r3, #0
 8004240:	d1a5      	bne.n	800418e <test_execute_inner+0xce>
  while (tsp->sequences[tseq] != NULL) {
 8004242:	f109 0904 	add.w	r9, r9, #4
 8004246:	f852 3009 	ldr.w	r3, [r2, r9]
 800424a:	2b00      	cmp	r3, #0
 800424c:	f47f af7e 	bne.w	800414c <test_execute_inner+0x8c>
  char *cp = chtest.tokens_buffer;
 8004250:	244c      	movs	r4, #76	; 0x4c
    test_putchar('-');
 8004252:	202d      	movs	r0, #45	; 0x2d
 8004254:	f000 f8cc 	bl	80043f0 <test_putchar>
  for (i = 0; i < 76; i++) {
 8004258:	3c01      	subs	r4, #1
 800425a:	d1fa      	bne.n	8004252 <test_execute_inner+0x192>
 800425c:	4c0f      	ldr	r4, [pc, #60]	; (800429c <test_execute_inner+0x1dc>)
  while ((c = *s) != '\0') {
 800425e:	200d      	movs	r0, #13
    test_putchar(c);
 8004260:	f000 f8c6 	bl	80043f0 <test_putchar>
  while ((c = *s) != '\0') {
 8004264:	f814 0f01 	ldrb.w	r0, [r4, #1]!
 8004268:	2800      	cmp	r0, #0
 800426a:	d1f9      	bne.n	8004260 <test_execute_inner+0x1a0>
      tcase++;
    }
    tseq++;
  }
  test_print_line();
  test_printf(TEST_CFG_EOL_STRING);
 800426c:	480b      	ldr	r0, [pc, #44]	; (800429c <test_execute_inner+0x1dc>)
 800426e:	f000 fadf 	bl	8004830 <test_printf>
  test_printf("Final result: %s"TEST_CFG_EOL_STRING,
 8004272:	7931      	ldrb	r1, [r6, #4]
 8004274:	4a25      	ldr	r2, [pc, #148]	; (800430c <test_execute_inner+0x24c>)
 8004276:	4b26      	ldr	r3, [pc, #152]	; (8004310 <test_execute_inner+0x250>)
 8004278:	4826      	ldr	r0, [pc, #152]	; (8004314 <test_execute_inner+0x254>)
 800427a:	2900      	cmp	r1, #0
 800427c:	bf14      	ite	ne
 800427e:	4611      	movne	r1, r2
 8004280:	4619      	moveq	r1, r3
 8004282:	f000 fad5 	bl	8004830 <test_printf>
#if defined(TEST_REPORT_HOOK_END)
  TEST_REPORT_HOOK_END();
#endif

  return chtest.global_fail;
}
 8004286:	7930      	ldrb	r0, [r6, #4]
 8004288:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
        test_printf("--- Result: SUCCESS"TEST_CFG_EOL_STRING);
 800428c:	4822      	ldr	r0, [pc, #136]	; (8004318 <test_execute_inner+0x258>)
 800428e:	f000 facf 	bl	8004830 <test_printf>
 8004292:	e7cd      	b.n	8004230 <test_execute_inner+0x170>
    test_printf("*** Test Suite"TEST_CFG_EOL_STRING);
 8004294:	4821      	ldr	r0, [pc, #132]	; (800431c <test_execute_inner+0x25c>)
 8004296:	f000 facb 	bl	8004830 <test_printf>
 800429a:	e71f      	b.n	80040dc <test_execute_inner+0x1c>
 800429c:	0800aa04 	.word	0x0800aa04
 80042a0:	0800a880 	.word	0x0800a880
 80042a4:	0800a8a0 	.word	0x0800a8a0
 80042a8:	20000c70 	.word	0x20000c70
 80042ac:	0800a8a8 	.word	0x0800a8a8
 80042b0:	0800a8c0 	.word	0x0800a8c0
 80042b4:	0800a8d8 	.word	0x0800a8d8
 80042b8:	0800a8f4 	.word	0x0800a8f4
 80042bc:	0800a90c 	.word	0x0800a90c
 80042c0:	0800a938 	.word	0x0800a938
 80042c4:	080001a0 	.word	0x080001a0
 80042c8:	0800a640 	.word	0x0800a640
 80042cc:	0800a950 	.word	0x0800a950
 80042d0:	0800a640 	.word	0x0800a640
 80042d4:	0800cec4 	.word	0x0800cec4
 80042d8:	0800a970 	.word	0x0800a970
 80042dc:	20000800 	.word	0x20000800
 80042e0:	200008dc 	.word	0x200008dc
 80042e4:	0800a990 	.word	0x0800a990
 80042e8:	200008e0 	.word	0x200008e0
 80042ec:	20001e60 	.word	0x20001e60
 80042f0:	0800a9b0 	.word	0x0800a9b0
 80042f4:	0800a9d0 	.word	0x0800a9d0
 80042f8:	0800a9ec 	.word	0x0800a9ec
 80042fc:	20000c80 	.word	0x20000c80
 8004300:	0800a89c 	.word	0x0800a89c
 8004304:	0800aa08 	.word	0x0800aa08
 8004308:	0800aa24 	.word	0x0800aa24
 800430c:	0800a870 	.word	0x0800a870
 8004310:	0800a878 	.word	0x0800a878
 8004314:	0800aa48 	.word	0x0800aa48
 8004318:	0800aa30 	.word	0x0800aa30
 800431c:	0800a88c 	.word	0x0800a88c

08004320 <__test_assert>:
  return true;
}

bool __test_assert(bool condition, const char *msg) {

  if (!condition) {
 8004320:	b108      	cbz	r0, 8004326 <__test_assert+0x6>
    return __test_fail(msg);
  }
  return false;
 8004322:	2000      	movs	r0, #0
}
 8004324:	4770      	bx	lr
  chtest.global_fail     = true;
 8004326:	4b03      	ldr	r3, [pc, #12]	; (8004334 <__test_assert+0x14>)
 8004328:	f240 1201 	movw	r2, #257	; 0x101
 800432c:	809a      	strh	r2, [r3, #4]
  chtest.failure_message = msg;
 800432e:	6099      	str	r1, [r3, #8]
    return __test_fail(msg);
 8004330:	2001      	movs	r0, #1
 8004332:	4770      	bx	lr
 8004334:	20000c70 	.word	0x20000c70
	...

08004340 <__test_assert_sequence>:

bool __test_assert_sequence(char *expected, const char *msg) {
 8004340:	b470      	push	{r4, r5, r6}
  char *cp = chtest.tokens_buffer;

  while (cp < chtest.tokp) {
 8004342:	4d0d      	ldr	r5, [pc, #52]	; (8004378 <__test_assert_sequence+0x38>)
  char *cp = chtest.tokens_buffer;
 8004344:	f105 0610 	add.w	r6, r5, #16
  while (cp < chtest.tokp) {
 8004348:	68ec      	ldr	r4, [r5, #12]
  char *cp = chtest.tokens_buffer;
 800434a:	4633      	mov	r3, r6
  while (cp < chtest.tokp) {
 800434c:	e005      	b.n	800435a <__test_assert_sequence+0x1a>
    if (*cp++ != *expected++)
 800434e:	f813 cb01 	ldrb.w	ip, [r3], #1
 8004352:	f810 2b01 	ldrb.w	r2, [r0], #1
 8004356:	4594      	cmp	ip, r2
 8004358:	d106      	bne.n	8004368 <__test_assert_sequence+0x28>
  while (cp < chtest.tokp) {
 800435a:	429c      	cmp	r4, r3
 800435c:	d8f7      	bhi.n	800434e <__test_assert_sequence+0xe>
     return __test_fail(msg);
  }

  if (*expected) {
 800435e:	7800      	ldrb	r0, [r0, #0]
 8004360:	b910      	cbnz	r0, 8004368 <__test_assert_sequence+0x28>
  chtest.tokp = chtest.tokens_buffer;
 8004362:	60ee      	str	r6, [r5, #12]
  }

  test_clear_tokens();

  return false;
}
 8004364:	bc70      	pop	{r4, r5, r6}
 8004366:	4770      	bx	lr
  chtest.global_fail     = true;
 8004368:	f240 1301 	movw	r3, #257	; 0x101
 800436c:	80ab      	strh	r3, [r5, #4]
  chtest.failure_message = msg;
 800436e:	60a9      	str	r1, [r5, #8]
     return __test_fail(msg);
 8004370:	2001      	movs	r0, #1
}
 8004372:	bc70      	pop	{r4, r5, r6}
 8004374:	4770      	bx	lr
 8004376:	bf00      	nop
 8004378:	20000c70 	.word	0x20000c70
 800437c:	00000000 	.word	0x00000000

08004380 <__test_assert_time_window>:

#if (TEST_CFG_CHIBIOS_SUPPORT == TRUE) || defined(__DOXYGEN__)
bool __test_assert_time_window(systime_t start,
                               systime_t end,
                               const char *msg) {
 8004380:	b570      	push	{r4, r5, r6, lr}
 8004382:	4605      	mov	r5, r0
 8004384:	460c      	mov	r4, r1
 8004386:	4616      	mov	r6, r2
 8004388:	f7fc f89a 	bl	80004c0 <stGetCounter>
static inline bool chTimeIsInRangeX(systime_t time,
                                    systime_t start,
                                    systime_t end) {

  return (bool)((systime_t)((systime_t)time - (systime_t)start) <
                (systime_t)((systime_t)end - (systime_t)start));
 800438c:	1b64      	subs	r4, r4, r5
  return (bool)((systime_t)((systime_t)time - (systime_t)start) <
 800438e:	1b40      	subs	r0, r0, r5
  if (!condition) {
 8004390:	42a0      	cmp	r0, r4
 8004392:	d201      	bcs.n	8004398 <__test_assert_time_window+0x18>
  return false;
 8004394:	2000      	movs	r0, #0

  return __test_assert(osalTimeIsInRangeX(osalOsGetSystemTimeX(), start, end),
                       msg);
}
 8004396:	bd70      	pop	{r4, r5, r6, pc}
  chtest.global_fail     = true;
 8004398:	4b03      	ldr	r3, [pc, #12]	; (80043a8 <__test_assert_time_window+0x28>)
 800439a:	f240 1201 	movw	r2, #257	; 0x101
 800439e:	809a      	strh	r2, [r3, #4]
  chtest.failure_message = msg;
 80043a0:	609e      	str	r6, [r3, #8]
    return __test_fail(msg);
 80043a2:	2001      	movs	r0, #1
}
 80043a4:	bd70      	pop	{r4, r5, r6, pc}
 80043a6:	bf00      	nop
 80043a8:	20000c70 	.word	0x20000c70
 80043ac:	00000000 	.word	0x00000000

080043b0 <test_emit_token>:
 *
 * @api
 */
void test_emit_token(char token) {

  if (chtest.tokp < &chtest.tokens_buffer[TEST_CFG_MAX_TOKENS]) {
 80043b0:	4b04      	ldr	r3, [pc, #16]	; (80043c4 <test_emit_token+0x14>)
 80043b2:	68da      	ldr	r2, [r3, #12]
 80043b4:	f103 0120 	add.w	r1, r3, #32
 80043b8:	428a      	cmp	r2, r1
 80043ba:	d202      	bcs.n	80043c2 <test_emit_token+0x12>
    *chtest.tokp++ = token;
 80043bc:	1c51      	adds	r1, r2, #1
 80043be:	60d9      	str	r1, [r3, #12]
 80043c0:	7010      	strb	r0, [r2, #0]
  }
}
 80043c2:	4770      	bx	lr
 80043c4:	20000c70 	.word	0x20000c70
	...

080043d0 <test_execute_stream>:
 */
bool test_execute_stream(BaseSequentialStream *stream,
                         const testsuite_t *tsp) {

  /* Output initialization using streams.*/
  chtest.stream  = stream;
 80043d0:	4b04      	ldr	r3, [pc, #16]	; (80043e4 <test_execute_stream+0x14>)
  chtest.putchar = test_stream_putchar;
 80043d2:	4a05      	ldr	r2, [pc, #20]	; (80043e8 <test_execute_stream+0x18>)
                         const testsuite_t *tsp) {
 80043d4:	b410      	push	{r4}
 80043d6:	4604      	mov	r4, r0
  chtest.putchar = test_stream_putchar;
 80043d8:	e9c3 2408 	strd	r2, r4, [r3, #32]

  /* Test execution.*/
  return test_execute_inner(tsp);
 80043dc:	4608      	mov	r0, r1
}
 80043de:	bc10      	pop	{r4}
  return test_execute_inner(tsp);
 80043e0:	f7ff be6e 	b.w	80040c0 <test_execute_inner>
 80043e4:	20000c70 	.word	0x20000c70
 80043e8:	080040a1 	.word	0x080040a1
 80043ec:	00000000 	.word	0x00000000

080043f0 <test_putchar>:
 *
 * @param[in] c         character to be printed
 */
void test_putchar(char c) {

  if (chtest.putchar != NULL) {
 80043f0:	4b02      	ldr	r3, [pc, #8]	; (80043fc <test_putchar+0xc>)
 80043f2:	6a1b      	ldr	r3, [r3, #32]
 80043f4:	b103      	cbz	r3, 80043f8 <test_putchar+0x8>
    chtest.putchar(c);
 80043f6:	4718      	bx	r3
  }
}
 80043f8:	4770      	bx	lr
 80043fa:	bf00      	nop
 80043fc:	20000c70 	.word	0x20000c70

08004400 <test_vprintf>:
 * @param[in] ap        list of parameters
 * @return              The number of bytes written.
 *
 * @api
 */
int test_vprintf(const char *fmt, va_list ap) {
 8004400:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  while (true) {
    char *p, *s, c, filler;
    int i, precision, width;
    bool is_long, left_align, do_sign;

    c = *fmt++;
 8004404:	4607      	mov	r7, r0
int test_vprintf(const char *fmt, va_list ap) {
 8004406:	4604      	mov	r4, r0
    c = *fmt++;
 8004408:	f817 0b01 	ldrb.w	r0, [r7], #1
int test_vprintf(const char *fmt, va_list ap) {
 800440c:	b087      	sub	sp, #28
    if (c == '\0') {
 800440e:	2800      	cmp	r0, #0
 8004410:	f000 81fe 	beq.w	8004810 <test_vprintf+0x410>
 8004414:	4d97      	ldr	r5, [pc, #604]	; (8004674 <test_vprintf+0x274>)
  n = 0;
 8004416:	f04f 0b00 	mov.w	fp, #0
 800441a:	4689      	mov	r9, r1
 800441c:	e00a      	b.n	8004434 <test_vprintf+0x34>
  if (chtest.putchar != NULL) {
 800441e:	6a2b      	ldr	r3, [r5, #32]
 8004420:	b103      	cbz	r3, 8004424 <test_vprintf+0x24>
    chtest.putchar(c);
 8004422:	4798      	blx	r3
      return n;
    }

    if (c != '%') {
      test_putchar(c);
      n++;
 8004424:	f10b 0b01 	add.w	fp, fp, #1
      continue;
 8004428:	463c      	mov	r4, r7
    c = *fmt++;
 800442a:	4627      	mov	r7, r4
 800442c:	f817 0b01 	ldrb.w	r0, [r7], #1
    if (c == '\0') {
 8004430:	2800      	cmp	r0, #0
 8004432:	d072      	beq.n	800451a <test_vprintf+0x11a>
    if (c != '%') {
 8004434:	2825      	cmp	r0, #37	; 0x25
 8004436:	d1f2      	bne.n	800441e <test_vprintf+0x1e>
    p = tmpbuf;
    s = tmpbuf;

    /* Alignment mode.*/
    left_align = false;
    if (*fmt == '-') {
 8004438:	7863      	ldrb	r3, [r4, #1]
 800443a:	2b2d      	cmp	r3, #45	; 0x2d
      fmt++;
 800443c:	bf04      	itt	eq
 800443e:	1ca7      	addeq	r7, r4, #2
      left_align = true;
 8004440:	f04f 0c01 	moveq.w	ip, #1
    }

    /* Sign mode.*/
    do_sign = false;
    if (*fmt == '+') {
 8004444:	783b      	ldrb	r3, [r7, #0]
    left_align = false;
 8004446:	bf18      	it	ne
 8004448:	f04f 0c00 	movne.w	ip, #0
    if (*fmt == '+') {
 800444c:	2b2b      	cmp	r3, #43	; 0x2b
      do_sign = true;
    }

    /* Filler mode.*/
    filler = ' ';
    if (*fmt == '0') {
 800444e:	bf03      	ittte	eq
 8004450:	787b      	ldrbeq	r3, [r7, #1]
      do_sign = true;
 8004452:	2601      	moveq	r6, #1
      fmt++;
 8004454:	3701      	addeq	r7, #1
    do_sign = false;
 8004456:	2600      	movne	r6, #0
    if (*fmt == '0') {
 8004458:	2b30      	cmp	r3, #48	; 0x30
      fmt++;
 800445a:	bf03      	ittte	eq
 800445c:	3701      	addeq	r7, #1
      filler = '0';
 800445e:	4698      	moveq	r8, r3
    }

    /* Width modifier.*/
    if ( *fmt == '*') {
 8004460:	783b      	ldrbeq	r3, [r7, #0]
    filler = ' ';
 8004462:	f04f 0820 	movne.w	r8, #32
    if ( *fmt == '*') {
 8004466:	2b2a      	cmp	r3, #42	; 0x2a
 8004468:	d147      	bne.n	80044fa <test_vprintf+0xfa>
      width = va_arg(ap, int);
 800446a:	f859 2b04 	ldr.w	r2, [r9], #4
      ++fmt;
      c = *fmt++;
 800446e:	787b      	ldrb	r3, [r7, #1]
 8004470:	1cbc      	adds	r4, r7, #2
      }
    }

    /* Precision modifier.*/
    precision = 0;
    if (c == '.') {
 8004472:	2b2e      	cmp	r3, #46	; 0x2e
 8004474:	f000 8094 	beq.w	80045a0 <test_vprintf+0x1a0>
    precision = 0;
 8004478:	2000      	movs	r0, #0
        }
      }
    }

    /* Long modifier.*/
    if ((c == 'l') || (c == 'L')) {
 800447a:	f003 01df 	and.w	r1, r3, #223	; 0xdf
 800447e:	294c      	cmp	r1, #76	; 0x4c
 8004480:	d04f      	beq.n	8004522 <test_vprintf+0x122>
    else {
      is_long = (c >= 'A') && (c <= 'Z');
    }

    /* Command decoding.*/
    switch (c) {
 8004482:	f1a3 0744 	sub.w	r7, r3, #68	; 0x44
 8004486:	2f34      	cmp	r7, #52	; 0x34
 8004488:	f200 8094 	bhi.w	80045b4 <test_vprintf+0x1b4>
 800448c:	e8df f017 	tbh	[pc, r7, lsl #1]
 8004490:	009200b9 	.word	0x009200b9
 8004494:	00920092 	.word	0x00920092
 8004498:	00b90092 	.word	0x00b90092
 800449c:	00920092 	.word	0x00920092
 80044a0:	00920092 	.word	0x00920092
 80044a4:	01440092 	.word	0x01440092
 80044a8:	009200eb 	.word	0x009200eb
 80044ac:	00920092 	.word	0x00920092
 80044b0:	01b50092 	.word	0x01b50092
 80044b4:	00920092 	.word	0x00920092
 80044b8:	009200eb 	.word	0x009200eb
 80044bc:	00920092 	.word	0x00920092
 80044c0:	00920092 	.word	0x00920092
 80044c4:	00920092 	.word	0x00920092
 80044c8:	00920092 	.word	0x00920092
 80044cc:	01660092 	.word	0x01660092
 80044d0:	009200b9 	.word	0x009200b9
 80044d4:	00920092 	.word	0x00920092
 80044d8:	00b90092 	.word	0x00b90092
 80044dc:	00920092 	.word	0x00920092
 80044e0:	00920092 	.word	0x00920092
 80044e4:	01440092 	.word	0x01440092
 80044e8:	009200eb 	.word	0x009200eb
 80044ec:	01470092 	.word	0x01470092
 80044f0:	01b50092 	.word	0x01b50092
 80044f4:	00920092 	.word	0x00920092
 80044f8:	00eb      	.short	0x00eb
        c = *fmt++;
 80044fa:	1c7c      	adds	r4, r7, #1
        if (c == '\0') {
 80044fc:	b16b      	cbz	r3, 800451a <test_vprintf+0x11a>
      width = 0;
 80044fe:	2200      	movs	r2, #0
        if ((c >= '0') && (c <= '9')) {
 8004500:	f1a3 0130 	sub.w	r1, r3, #48	; 0x30
 8004504:	b2c9      	uxtb	r1, r1
 8004506:	2909      	cmp	r1, #9
          width = width * 10 + c;
 8004508:	eb02 0082 	add.w	r0, r2, r2, lsl #2
        if ((c >= '0') && (c <= '9')) {
 800450c:	d8b1      	bhi.n	8004472 <test_vprintf+0x72>
        c = *fmt++;
 800450e:	f814 3b01 	ldrb.w	r3, [r4], #1
          width = width * 10 + c;
 8004512:	eb01 0240 	add.w	r2, r1, r0, lsl #1
        if (c == '\0') {
 8004516:	2b00      	cmp	r3, #0
 8004518:	d1f2      	bne.n	8004500 <test_vprintf+0x100>
      test_putchar(filler);
      n++;
      width--;
    }
  }
}
 800451a:	4658      	mov	r0, fp
 800451c:	b007      	add	sp, #28
 800451e:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
      c = *fmt++;
 8004522:	f814 3b01 	ldrb.w	r3, [r4], #1
      if (c == '\0') {
 8004526:	2b00      	cmp	r3, #0
 8004528:	d0f7      	beq.n	800451a <test_vprintf+0x11a>
    switch (c) {
 800452a:	f1a3 0144 	sub.w	r1, r3, #68	; 0x44
 800452e:	2934      	cmp	r1, #52	; 0x34
 8004530:	d840      	bhi.n	80045b4 <test_vprintf+0x1b4>
 8004532:	e8df f011 	tbh	[pc, r1, lsl #1]
 8004536:	0066      	.short	0x0066
 8004538:	003f003f 	.word	0x003f003f
 800453c:	003f003f 	.word	0x003f003f
 8004540:	003f0066 	.word	0x003f0066
 8004544:	003f003f 	.word	0x003f003f
 8004548:	003f003f 	.word	0x003f003f
 800454c:	009800f1 	.word	0x009800f1
 8004550:	003f003f 	.word	0x003f003f
 8004554:	003f003f 	.word	0x003f003f
 8004558:	003f0162 	.word	0x003f0162
 800455c:	0098003f 	.word	0x0098003f
 8004560:	003f003f 	.word	0x003f003f
 8004564:	003f003f 	.word	0x003f003f
 8004568:	003f003f 	.word	0x003f003f
 800456c:	003f003f 	.word	0x003f003f
 8004570:	003f003f 	.word	0x003f003f
 8004574:	00660113 	.word	0x00660113
 8004578:	003f003f 	.word	0x003f003f
 800457c:	003f003f 	.word	0x003f003f
 8004580:	003f0066 	.word	0x003f0066
 8004584:	003f003f 	.word	0x003f003f
 8004588:	003f003f 	.word	0x003f003f
 800458c:	009800f1 	.word	0x009800f1
 8004590:	003f003f 	.word	0x003f003f
 8004594:	003f00f4 	.word	0x003f00f4
 8004598:	003f0162 	.word	0x003f0162
 800459c:	0098003f 	.word	0x0098003f
      c = *fmt++;
 80045a0:	7823      	ldrb	r3, [r4, #0]
      if (c == '\0') {
 80045a2:	2b00      	cmp	r3, #0
 80045a4:	d0b9      	beq.n	800451a <test_vprintf+0x11a>
      if (c == '*') {
 80045a6:	2b2a      	cmp	r3, #42	; 0x2a
 80045a8:	d117      	bne.n	80045da <test_vprintf+0x1da>
        c = *fmt++;
 80045aa:	7863      	ldrb	r3, [r4, #1]
        precision = va_arg(ap, int);
 80045ac:	f859 0b04 	ldr.w	r0, [r9], #4
        c = *fmt++;
 80045b0:	3402      	adds	r4, #2
 80045b2:	e762      	b.n	800447a <test_vprintf+0x7a>
      *p++ = c;
 80045b4:	3a01      	subs	r2, #1
 80045b6:	f88d 300c 	strb.w	r3, [sp, #12]
    if (width < 0) {
 80045ba:	ea22 77e2 	bic.w	r7, r2, r2, asr #31
    if (left_align == false) {
 80045be:	f1bc 0f00 	cmp.w	ip, #0
 80045c2:	f040 80d8 	bne.w	8004776 <test_vprintf+0x376>
    if (width < 0) {
 80045c6:	2a00      	cmp	r2, #0
      width = -width;
 80045c8:	f1c7 0700 	rsb	r7, r7, #0
    if (width < 0) {
 80045cc:	f8cd c004 	str.w	ip, [sp, #4]
 80045d0:	f300 80f8 	bgt.w	80047c4 <test_vprintf+0x3c4>
 80045d4:	f10d 0a0c 	add.w	sl, sp, #12
 80045d8:	e080      	b.n	80046dc <test_vprintf+0x2dc>
      c = *fmt++;
 80045da:	3401      	adds	r4, #1
    precision = 0;
 80045dc:	2000      	movs	r0, #0
        while ((c >= '0') && (c <= '9')) {
 80045de:	f1a3 0130 	sub.w	r1, r3, #48	; 0x30
 80045e2:	b2c9      	uxtb	r1, r1
 80045e4:	2909      	cmp	r1, #9
          precision = precision * 10 + c;
 80045e6:	eb00 0780 	add.w	r7, r0, r0, lsl #2
        while ((c >= '0') && (c <= '9')) {
 80045ea:	f63f af46 	bhi.w	800447a <test_vprintf+0x7a>
          c = *fmt++;
 80045ee:	f814 3b01 	ldrb.w	r3, [r4], #1
          precision = precision * 10 + c;
 80045f2:	eb01 0047 	add.w	r0, r1, r7, lsl #1
          if (c == '\0') {
 80045f6:	2b00      	cmp	r3, #0
 80045f8:	d1f1      	bne.n	80045de <test_vprintf+0x1de>
}
 80045fa:	4658      	mov	r0, fp
 80045fc:	b007      	add	sp, #28
 80045fe:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
        arg = va_arg(ap, int);
 8004602:	f859 0b04 	ldr.w	r0, [r9], #4
      if (arg < 0) {
 8004606:	2800      	cmp	r0, #0
 8004608:	f2c0 80e0 	blt.w	80047cc <test_vprintf+0x3cc>
        if (do_sign) {
 800460c:	2e00      	cmp	r6, #0
 800460e:	f000 80fc 	beq.w	800480a <test_vprintf+0x40a>
          *p++ = '+';
 8004612:	232b      	movs	r3, #43	; 0x2b
 8004614:	f88d 300c 	strb.w	r3, [sp, #12]
 8004618:	f10d 070d 	add.w	r7, sp, #13
 800461c:	ab03      	add	r3, sp, #12
  q = p + MAX_FILLER;
 800461e:	f107 010b 	add.w	r1, r7, #11
 8004622:	9101      	str	r1, [sp, #4]
 8004624:	460e      	mov	r6, r1
    c = (int)(l % (long)radix);
 8004626:	4914      	ldr	r1, [pc, #80]	; (8004678 <test_vprintf+0x278>)
 8004628:	fba1 e100 	umull	lr, r1, r1, r0
 800462c:	08c9      	lsrs	r1, r1, #3
 800462e:	eb01 0a81 	add.w	sl, r1, r1, lsl #2
 8004632:	468e      	mov	lr, r1
 8004634:	eba0 014a 	sub.w	r1, r0, sl, lsl #1
    c += '0';
 8004638:	3130      	adds	r1, #48	; 0x30
    *--q = (char)c;
 800463a:	b2c9      	uxtb	r1, r1
  } while (ll != 0);
 800463c:	4670      	mov	r0, lr
    *--q = (char)c;
 800463e:	f806 1d01 	strb.w	r1, [r6, #-1]!
  } while (ll != 0);
 8004642:	2800      	cmp	r0, #0
 8004644:	d1ef      	bne.n	8004626 <test_vprintf+0x226>
  i = (int)(p + MAX_FILLER - q);
 8004646:	9801      	ldr	r0, [sp, #4]
 8004648:	1b80      	subs	r0, r0, r6
 800464a:	4438      	add	r0, r7
 800464c:	e001      	b.n	8004652 <test_vprintf+0x252>
    *p++ = *q++;
 800464e:	f816 1f01 	ldrb.w	r1, [r6, #1]!
 8004652:	f807 1b01 	strb.w	r1, [r7], #1
  } while (--i);
 8004656:	42b8      	cmp	r0, r7
 8004658:	d1f9      	bne.n	800464e <test_vprintf+0x24e>
    i = (int)(p - s);
 800465a:	1ac0      	subs	r0, r0, r3
        i--;
 800465c:	1e41      	subs	r1, r0, #1
    width -= i;
 800465e:	1a12      	subs	r2, r2, r0
        i--;
 8004660:	9101      	str	r1, [sp, #4]
    s = tmpbuf;
 8004662:	469a      	mov	sl, r3
 8004664:	e02e      	b.n	80046c4 <test_vprintf+0x2c4>
      radix = 16;
 8004666:	f04f 0e10 	mov.w	lr, #16
        arg = va_arg(ap, unsigned int);
 800466a:	f859 3b04 	ldr.w	r3, [r9], #4
    switch (c) {
 800466e:	f10d 0017 	add.w	r0, sp, #23
 8004672:	e004      	b.n	800467e <test_vprintf+0x27e>
 8004674:	20000c70 	.word	0x20000c70
 8004678:	cccccccd 	.word	0xcccccccd
 800467c:	4630      	mov	r0, r6
    c = (int)(l % (long)radix);
 800467e:	fb93 f7fe 	sdiv	r7, r3, lr
 8004682:	fb0e 3317 	mls	r3, lr, r7, r3
    c += '0';
 8004686:	f103 0130 	add.w	r1, r3, #48	; 0x30
    if (c > '9') {
 800468a:	2939      	cmp	r1, #57	; 0x39
      c += ('A' - '0') - 10;
 800468c:	bfc8      	it	gt
 800468e:	f103 0137 	addgt.w	r1, r3, #55	; 0x37
    *--q = (char)c;
 8004692:	b2c9      	uxtb	r1, r1
 8004694:	1e46      	subs	r6, r0, #1
 8004696:	f800 1c01 	strb.w	r1, [r0, #-1]
    l /= radix;
 800469a:	463b      	mov	r3, r7
  } while (ll != 0);
 800469c:	2f00      	cmp	r7, #0
 800469e:	d1ed      	bne.n	800467c <test_vprintf+0x27c>
  i = (int)(p + MAX_FILLER - q);
 80046a0:	f10d 0317 	add.w	r3, sp, #23
 80046a4:	1b9e      	subs	r6, r3, r6
 80046a6:	ab03      	add	r3, sp, #12
 80046a8:	f10d 0e17 	add.w	lr, sp, #23
 80046ac:	461f      	mov	r7, r3
 80046ae:	e001      	b.n	80046b4 <test_vprintf+0x2b4>
    *p++ = *q++;
 80046b0:	f810 1b01 	ldrb.w	r1, [r0], #1
 80046b4:	f807 1b01 	strb.w	r1, [r7], #1
  } while (--i);
 80046b8:	4586      	cmp	lr, r0
 80046ba:	d1f9      	bne.n	80046b0 <test_vprintf+0x2b0>
        i--;
 80046bc:	1e71      	subs	r1, r6, #1
    width -= i;
 80046be:	1b92      	subs	r2, r2, r6
        i--;
 80046c0:	9101      	str	r1, [sp, #4]
    s = tmpbuf;
 80046c2:	469a      	mov	sl, r3
    if (width < 0) {
 80046c4:	ea22 77e2 	bic.w	r7, r2, r2, asr #31
    if (left_align == false) {
 80046c8:	f1bc 0f00 	cmp.w	ip, #0
 80046cc:	d103      	bne.n	80046d6 <test_vprintf+0x2d6>
    if (width < 0) {
 80046ce:	2a00      	cmp	r2, #0
      width = -width;
 80046d0:	f1c7 0700 	rsb	r7, r7, #0
    if (width < 0) {
 80046d4:	dc54      	bgt.n	8004780 <test_vprintf+0x380>
    while (--i >= 0) {
 80046d6:	9b01      	ldr	r3, [sp, #4]
 80046d8:	2b00      	cmp	r3, #0
 80046da:	db11      	blt.n	8004700 <test_vprintf+0x300>
 80046dc:	9b01      	ldr	r3, [sp, #4]
    if (left_align == false) {
 80046de:	4656      	mov	r6, sl
 80046e0:	449a      	add	sl, r3
  if (chtest.putchar != NULL) {
 80046e2:	6a2b      	ldr	r3, [r5, #32]
      test_putchar(*s++);
 80046e4:	3601      	adds	r6, #1
  if (chtest.putchar != NULL) {
 80046e6:	b113      	cbz	r3, 80046ee <test_vprintf+0x2ee>
    chtest.putchar(c);
 80046e8:	f816 0c01 	ldrb.w	r0, [r6, #-1]
 80046ec:	4798      	blx	r3
    while (--i >= 0) {
 80046ee:	ebaa 0306 	sub.w	r3, sl, r6
 80046f2:	2b00      	cmp	r3, #0
 80046f4:	daf5      	bge.n	80046e2 <test_vprintf+0x2e2>
      n++;
 80046f6:	9b01      	ldr	r3, [sp, #4]
 80046f8:	f10b 0b01 	add.w	fp, fp, #1
 80046fc:	445b      	add	r3, fp
 80046fe:	469b      	mov	fp, r3
    while (width) {
 8004700:	2f00      	cmp	r7, #0
 8004702:	f43f ae92 	beq.w	800442a <test_vprintf+0x2a>
 8004706:	463e      	mov	r6, r7
  if (chtest.putchar != NULL) {
 8004708:	6a2b      	ldr	r3, [r5, #32]
    chtest.putchar(c);
 800470a:	4640      	mov	r0, r8
  if (chtest.putchar != NULL) {
 800470c:	b103      	cbz	r3, 8004710 <test_vprintf+0x310>
    chtest.putchar(c);
 800470e:	4798      	blx	r3
    while (width) {
 8004710:	3e01      	subs	r6, #1
 8004712:	d1f9      	bne.n	8004708 <test_vprintf+0x308>
      n++;
 8004714:	44bb      	add	fp, r7
 8004716:	e688      	b.n	800442a <test_vprintf+0x2a>
      radix = 8;
 8004718:	f04f 0e08 	mov.w	lr, #8
 800471c:	e7a5      	b.n	800466a <test_vprintf+0x26a>
      if ((s = va_arg(ap, char *)) == NULL) {
 800471e:	f859 ab04 	ldr.w	sl, [r9], #4
 8004722:	f1ba 0f00 	cmp.w	sl, #0
 8004726:	d06b      	beq.n	8004800 <test_vprintf+0x400>
      for (p = s; (*p != '\0') && (--precision >= 0); p++) {
 8004728:	f89a 1000 	ldrb.w	r1, [sl]
      if (precision == 0) {
 800472c:	2800      	cmp	r0, #0
 800472e:	d155      	bne.n	80047dc <test_vprintf+0x3dc>
      for (p = s; (*p != '\0') && (--precision >= 0); p++) {
 8004730:	2900      	cmp	r1, #0
 8004732:	d056      	beq.n	80047e2 <test_vprintf+0x3e2>
 8004734:	f647 70fe 	movw	r0, #32766	; 0x7ffe
 8004738:	4651      	mov	r1, sl
 800473a:	e001      	b.n	8004740 <test_vprintf+0x340>
 800473c:	42c6      	cmn	r6, r0
 800473e:	d405      	bmi.n	800474c <test_vprintf+0x34c>
 8004740:	f811 3f01 	ldrb.w	r3, [r1, #1]!
 8004744:	ebaa 0601 	sub.w	r6, sl, r1
 8004748:	2b00      	cmp	r3, #0
 800474a:	d1f7      	bne.n	800473c <test_vprintf+0x33c>
    i = (int)(p - s);
 800474c:	eba1 010a 	sub.w	r1, r1, sl
        i--;
 8004750:	1e4b      	subs	r3, r1, #1
    width -= i;
 8004752:	1a52      	subs	r2, r2, r1
        i--;
 8004754:	9301      	str	r3, [sp, #4]
      filler = ' ';
 8004756:	f04f 0820 	mov.w	r8, #32
 800475a:	e7b3      	b.n	80046c4 <test_vprintf+0x2c4>
      *p++ = va_arg(ap, int);
 800475c:	f859 3b04 	ldr.w	r3, [r9], #4
 8004760:	f88d 300c 	strb.w	r3, [sp, #12]
      break;
 8004764:	3a01      	subs	r2, #1
      filler = ' ';
 8004766:	f04f 0820 	mov.w	r8, #32
    if (width < 0) {
 800476a:	ea22 77e2 	bic.w	r7, r2, r2, asr #31
    if (left_align == false) {
 800476e:	f1bc 0f00 	cmp.w	ip, #0
 8004772:	f43f af28 	beq.w	80045c6 <test_vprintf+0x1c6>
 8004776:	2300      	movs	r3, #0
 8004778:	f10d 0a0c 	add.w	sl, sp, #12
 800477c:	9301      	str	r3, [sp, #4]
 800477e:	e7ad      	b.n	80046dc <test_vprintf+0x2dc>
      width = -width;
 8004780:	463e      	mov	r6, r7
      if (((*s == '-') || (*s == '+')) && (filler == '0')) {
 8004782:	f89a 0000 	ldrb.w	r0, [sl]
 8004786:	282d      	cmp	r0, #45	; 0x2d
 8004788:	d00d      	beq.n	80047a6 <test_vprintf+0x3a6>
 800478a:	282b      	cmp	r0, #43	; 0x2b
 800478c:	d00b      	beq.n	80047a6 <test_vprintf+0x3a6>
  if (chtest.putchar != NULL) {
 800478e:	6a2a      	ldr	r2, [r5, #32]
    chtest.putchar(c);
 8004790:	4640      	mov	r0, r8
  if (chtest.putchar != NULL) {
 8004792:	b102      	cbz	r2, 8004796 <test_vprintf+0x396>
    chtest.putchar(c);
 8004794:	4790      	blx	r2
      } while (++width != 0);
 8004796:	3701      	adds	r7, #1
 8004798:	d1f9      	bne.n	800478e <test_vprintf+0x38e>
    while (--i >= 0) {
 800479a:	9b01      	ldr	r3, [sp, #4]
 800479c:	2b00      	cmp	r3, #0
 800479e:	ebab 0b06 	sub.w	fp, fp, r6
 80047a2:	da9b      	bge.n	80046dc <test_vprintf+0x2dc>
 80047a4:	e641      	b.n	800442a <test_vprintf+0x2a>
      if (((*s == '-') || (*s == '+')) && (filler == '0')) {
 80047a6:	f1b8 0f30 	cmp.w	r8, #48	; 0x30
 80047aa:	d1f0      	bne.n	800478e <test_vprintf+0x38e>
  if (chtest.putchar != NULL) {
 80047ac:	6a2a      	ldr	r2, [r5, #32]
        test_putchar(*s++);
 80047ae:	f10a 0a01 	add.w	sl, sl, #1
  if (chtest.putchar != NULL) {
 80047b2:	b10a      	cbz	r2, 80047b8 <test_vprintf+0x3b8>
    chtest.putchar(c);
 80047b4:	4790      	blx	r2
  if (chtest.putchar != NULL) {
 80047b6:	6a2a      	ldr	r2, [r5, #32]
    while (--i >= 0) {
 80047b8:	9b01      	ldr	r3, [sp, #4]
 80047ba:	3b01      	subs	r3, #1
        n++;
 80047bc:	f10b 0b01 	add.w	fp, fp, #1
    while (--i >= 0) {
 80047c0:	9301      	str	r3, [sp, #4]
 80047c2:	e7e5      	b.n	8004790 <test_vprintf+0x390>
      width = -width;
 80047c4:	463e      	mov	r6, r7
    if (width < 0) {
 80047c6:	f10d 0a0c 	add.w	sl, sp, #12
 80047ca:	e7da      	b.n	8004782 <test_vprintf+0x382>
        *p++ = '-';
 80047cc:	232d      	movs	r3, #45	; 0x2d
 80047ce:	f88d 300c 	strb.w	r3, [sp, #12]
        arg = -arg;
 80047d2:	4240      	negs	r0, r0
        *p++ = '-';
 80047d4:	f10d 070d 	add.w	r7, sp, #13
 80047d8:	ab03      	add	r3, sp, #12
 80047da:	e720      	b.n	800461e <test_vprintf+0x21e>
      for (p = s; (*p != '\0') && (--precision >= 0); p++) {
 80047dc:	b109      	cbz	r1, 80047e2 <test_vprintf+0x3e2>
 80047de:	3801      	subs	r0, #1
 80047e0:	d5aa      	bpl.n	8004738 <test_vprintf+0x338>
    if (width < 0) {
 80047e2:	ea22 77e2 	bic.w	r7, r2, r2, asr #31
    if (left_align == false) {
 80047e6:	f1bc 0f00 	cmp.w	ip, #0
 80047ea:	d103      	bne.n	80047f4 <test_vprintf+0x3f4>
    if (width < 0) {
 80047ec:	2a00      	cmp	r2, #0
      width = -width;
 80047ee:	f1c7 0700 	rsb	r7, r7, #0
    if (width < 0) {
 80047f2:	dc0f      	bgt.n	8004814 <test_vprintf+0x414>
    if (left_align == false) {
 80047f4:	f04f 0820 	mov.w	r8, #32
 80047f8:	e782      	b.n	8004700 <test_vprintf+0x300>
    switch (c) {
 80047fa:	f04f 0e0a 	mov.w	lr, #10
 80047fe:	e734      	b.n	800466a <test_vprintf+0x26a>
        s = "(null)";
 8004800:	f8df a020 	ldr.w	sl, [pc, #32]	; 8004824 <test_vprintf+0x424>
      if (precision == 0) {
 8004804:	2800      	cmp	r0, #0
 8004806:	d095      	beq.n	8004734 <test_vprintf+0x334>
 8004808:	e7e9      	b.n	80047de <test_vprintf+0x3de>
    p = tmpbuf;
 800480a:	ab03      	add	r3, sp, #12
 800480c:	461f      	mov	r7, r3
 800480e:	e706      	b.n	800461e <test_vprintf+0x21e>
  n = 0;
 8004810:	4683      	mov	fp, r0
 8004812:	e682      	b.n	800451a <test_vprintf+0x11a>
    if (width < 0) {
 8004814:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
      width = -width;
 8004818:	463e      	mov	r6, r7
    if (width < 0) {
 800481a:	f04f 0820 	mov.w	r8, #32
 800481e:	9301      	str	r3, [sp, #4]
 8004820:	e7af      	b.n	8004782 <test_vprintf+0x382>
 8004822:	bf00      	nop
 8004824:	0800aa5c 	.word	0x0800aa5c
	...

08004830 <test_printf>:
 * @param[in] fmt       formatting string
 * @return              The number of bytes written.
 *
 * @api
 */
int test_printf(const char *fmt, ...) {
 8004830:	b40f      	push	{r0, r1, r2, r3}
 8004832:	b500      	push	{lr}
 8004834:	b083      	sub	sp, #12
 8004836:	a904      	add	r1, sp, #16
 8004838:	f851 0b04 	ldr.w	r0, [r1], #4
  va_list ap;
  int formatted_bytes;

  va_start(ap, fmt);
 800483c:	9101      	str	r1, [sp, #4]
  formatted_bytes = test_vprintf(fmt, ap);
 800483e:	f7ff fddf 	bl	8004400 <test_vprintf>
  va_end(ap);

  return formatted_bytes;
}
 8004842:	b003      	add	sp, #12
 8004844:	f85d eb04 	ldr.w	lr, [sp], #4
 8004848:	b004      	add	sp, #16
 800484a:	4770      	bx	lr
 800484c:	0000      	movs	r0, r0
	...

08004850 <test_terminate_threads>:
                         test_buffer + (WA_SIZE * 4)};

/*
 * Sets a termination request in all the test-spawned threads.
 */
void test_terminate_threads(void) {
 8004850:	b538      	push	{r3, r4, r5, lr}
 8004852:	4c05      	ldr	r4, [pc, #20]	; (8004868 <test_terminate_threads+0x18>)
 8004854:	f104 0514 	add.w	r5, r4, #20
  unsigned i;

  for (i = 0; i < MAX_THREADS; i++)
    if (threads[i])
 8004858:	f854 0b04 	ldr.w	r0, [r4], #4
 800485c:	b108      	cbz	r0, 8004862 <test_terminate_threads+0x12>
      chThdTerminate(threads[i]);
 800485e:	f7fd fb97 	bl	8001f90 <chThdTerminate>
  for (i = 0; i < MAX_THREADS; i++)
 8004862:	42ac      	cmp	r4, r5
 8004864:	d1f8      	bne.n	8004858 <test_terminate_threads+0x8>
}
 8004866:	bd38      	pop	{r3, r4, r5, pc}
 8004868:	200013c8 	.word	0x200013c8
 800486c:	00000000 	.word	0x00000000

08004870 <test_wait_threads>:

/*
 * Waits for the completion of all the test-spawned threads.
 */
void test_wait_threads(void) {
 8004870:	b570      	push	{r4, r5, r6, lr}
 8004872:	4c07      	ldr	r4, [pc, #28]	; (8004890 <test_wait_threads+0x20>)
  unsigned i;

  for (i = 0; i < MAX_THREADS; i++)
    if (threads[i] != NULL) {
      chThdWait(threads[i]);
      threads[i] = NULL;
 8004874:	2600      	movs	r6, #0
 8004876:	f104 0514 	add.w	r5, r4, #20
    if (threads[i] != NULL) {
 800487a:	f854 0b04 	ldr.w	r0, [r4], #4
 800487e:	b118      	cbz	r0, 8004888 <test_wait_threads+0x18>
      chThdWait(threads[i]);
 8004880:	f7fd fb2e 	bl	8001ee0 <chThdWait>
      threads[i] = NULL;
 8004884:	f844 6c04 	str.w	r6, [r4, #-4]
  for (i = 0; i < MAX_THREADS; i++)
 8004888:	42ac      	cmp	r4, r5
 800488a:	d1f6      	bne.n	800487a <test_wait_threads+0xa>
    }
}
 800488c:	bd70      	pop	{r4, r5, r6, pc}
 800488e:	bf00      	nop
 8004890:	200013c8 	.word	0x200013c8
	...

080048a0 <test_wait_tick>:

/*
 * Delays execution until next system time tick.
 */
systime_t test_wait_tick(void) {
 80048a0:	b508      	push	{r3, lr}

  chThdSleep(1);
 80048a2:	2001      	movs	r0, #1
 80048a4:	f7fd fb84 	bl	8001fb0 <chThdSleep>
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 80048a8:	2330      	movs	r3, #48	; 0x30
 80048aa:	f383 8811 	msr	BASEPRI, r3
 80048ae:	f7fb fe07 	bl	80004c0 <stGetCounter>
 80048b2:	2300      	movs	r3, #0
 80048b4:	f383 8811 	msr	BASEPRI, r3
  return chVTGetSystemTime();
}
 80048b8:	bd08      	pop	{r3, pc}
 80048ba:	bf00      	nop
 80048bc:	0000      	movs	r0, r0
	...

080048c0 <rt_test_001_003_execute>:
 * <h2>Test Steps</h2>
 * - [1.3.1] Prints the configuration options settings.
 * .
 */

static void rt_test_001_003_execute(void) {
 80048c0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 *
 * @api
 */
static inline void test_print(const char *msgp) {

  test_printf("%s", msgp);
 80048c4:	4fc5      	ldr	r7, [pc, #788]	; (8004bdc <rt_test_001_003_execute+0x31c>)

  /* [1.3.1] Prints the configuration options settings.*/
  test_set_step(1);
 80048c6:	4bc6      	ldr	r3, [pc, #792]	; (8004be0 <rt_test_001_003_execute+0x320>)
  test_printf("%u", n);
 80048c8:	4ec6      	ldr	r6, [pc, #792]	; (8004be4 <rt_test_001_003_execute+0x324>)
 *
 * @api
 */
static inline void test_println(const char *msgp) {

  test_printf("%s" TEST_CFG_EOL_STRING, msgp);
 80048ca:	4dc7      	ldr	r5, [pc, #796]	; (8004be8 <rt_test_001_003_execute+0x328>)
 80048cc:	4cc7      	ldr	r4, [pc, #796]	; (8004bec <rt_test_001_003_execute+0x32c>)
  test_printf("%s", msgp);
 80048ce:	49c8      	ldr	r1, [pc, #800]	; (8004bf0 <rt_test_001_003_execute+0x330>)
 80048d0:	f04f 0801 	mov.w	r8, #1
 80048d4:	4638      	mov	r0, r7
 80048d6:	f8c3 8000 	str.w	r8, [r3]
 80048da:	f7ff ffa9 	bl	8004830 <test_printf>
  test_printf("%u", n);
 80048de:	2120      	movs	r1, #32
 80048e0:	4630      	mov	r0, r6
 80048e2:	f7ff ffa5 	bl	8004830 <test_printf>
  test_printf("%s" TEST_CFG_EOL_STRING, msgp);
 80048e6:	4629      	mov	r1, r5
 80048e8:	4620      	mov	r0, r4
 80048ea:	f7ff ffa1 	bl	8004830 <test_printf>
  test_printf("%s", msgp);
 80048ee:	49c1      	ldr	r1, [pc, #772]	; (8004bf4 <rt_test_001_003_execute+0x334>)
 80048f0:	4638      	mov	r0, r7
 80048f2:	f7ff ff9d 	bl	8004830 <test_printf>
  test_printf("%u", n);
 80048f6:	f242 7110 	movw	r1, #10000	; 0x2710
 80048fa:	4630      	mov	r0, r6
 80048fc:	f7ff ff98 	bl	8004830 <test_printf>
  test_printf("%s" TEST_CFG_EOL_STRING, msgp);
 8004900:	4629      	mov	r1, r5
 8004902:	4620      	mov	r0, r4
 8004904:	f7ff ff94 	bl	8004830 <test_printf>
  test_printf("%s", msgp);
 8004908:	49bb      	ldr	r1, [pc, #748]	; (8004bf8 <rt_test_001_003_execute+0x338>)
 800490a:	4638      	mov	r0, r7
 800490c:	f7ff ff90 	bl	8004830 <test_printf>
  test_printf("%u", n);
 8004910:	2120      	movs	r1, #32
 8004912:	4630      	mov	r0, r6
 8004914:	f7ff ff8c 	bl	8004830 <test_printf>
  test_printf("%s" TEST_CFG_EOL_STRING, msgp);
 8004918:	4629      	mov	r1, r5
 800491a:	4620      	mov	r0, r4
 800491c:	f7ff ff88 	bl	8004830 <test_printf>
  test_printf("%s", msgp);
 8004920:	49b6      	ldr	r1, [pc, #728]	; (8004bfc <rt_test_001_003_execute+0x33c>)
 8004922:	4638      	mov	r0, r7
 8004924:	f7ff ff84 	bl	8004830 <test_printf>
  test_printf("%u", n);
 8004928:	2120      	movs	r1, #32
 800492a:	4630      	mov	r0, r6
 800492c:	f7ff ff80 	bl	8004830 <test_printf>
  test_printf("%s" TEST_CFG_EOL_STRING, msgp);
 8004930:	4629      	mov	r1, r5
 8004932:	4620      	mov	r0, r4
 8004934:	f7ff ff7c 	bl	8004830 <test_printf>
  test_printf("%s", msgp);
 8004938:	49b1      	ldr	r1, [pc, #708]	; (8004c00 <rt_test_001_003_execute+0x340>)
 800493a:	4638      	mov	r0, r7
 800493c:	f7ff ff78 	bl	8004830 <test_printf>
  test_printf("%u", n);
 8004940:	2102      	movs	r1, #2
 8004942:	4630      	mov	r0, r6
 8004944:	f7ff ff74 	bl	8004830 <test_printf>
  test_printf("%s" TEST_CFG_EOL_STRING, msgp);
 8004948:	4629      	mov	r1, r5
 800494a:	4620      	mov	r0, r4
 800494c:	f7ff ff70 	bl	8004830 <test_printf>
  test_printf("%s", msgp);
 8004950:	49ac      	ldr	r1, [pc, #688]	; (8004c04 <rt_test_001_003_execute+0x344>)
 8004952:	4638      	mov	r0, r7
 8004954:	f7ff ff6c 	bl	8004830 <test_printf>
  test_printf("%u", n);
 8004958:	2100      	movs	r1, #0
 800495a:	4630      	mov	r0, r6
 800495c:	f7ff ff68 	bl	8004830 <test_printf>
  test_printf("%s" TEST_CFG_EOL_STRING, msgp);
 8004960:	4629      	mov	r1, r5
 8004962:	4620      	mov	r0, r4
 8004964:	f7ff ff64 	bl	8004830 <test_printf>
  test_printf("%s", msgp);
 8004968:	49a7      	ldr	r1, [pc, #668]	; (8004c08 <rt_test_001_003_execute+0x348>)
 800496a:	4638      	mov	r0, r7
 800496c:	f7ff ff60 	bl	8004830 <test_printf>
  test_printf("%u", n);
 8004970:	2100      	movs	r1, #0
 8004972:	4630      	mov	r0, r6
 8004974:	f7ff ff5c 	bl	8004830 <test_printf>
  test_printf("%s" TEST_CFG_EOL_STRING, msgp);
 8004978:	4629      	mov	r1, r5
 800497a:	4620      	mov	r0, r4
 800497c:	f7ff ff58 	bl	8004830 <test_printf>
  test_printf("%s", msgp);
 8004980:	49a2      	ldr	r1, [pc, #648]	; (8004c0c <rt_test_001_003_execute+0x34c>)
 8004982:	4638      	mov	r0, r7
 8004984:	f7ff ff54 	bl	8004830 <test_printf>
  test_printf("%u", n);
 8004988:	2100      	movs	r1, #0
 800498a:	4630      	mov	r0, r6
 800498c:	f7ff ff50 	bl	8004830 <test_printf>
  test_printf("%s" TEST_CFG_EOL_STRING, msgp);
 8004990:	4629      	mov	r1, r5
 8004992:	4620      	mov	r0, r4
 8004994:	f7ff ff4c 	bl	8004830 <test_printf>
  test_printf("%s", msgp);
 8004998:	499d      	ldr	r1, [pc, #628]	; (8004c10 <rt_test_001_003_execute+0x350>)
 800499a:	4638      	mov	r0, r7
 800499c:	f7ff ff48 	bl	8004830 <test_printf>
  test_printf("%u", n);
 80049a0:	4641      	mov	r1, r8
 80049a2:	4630      	mov	r0, r6
 80049a4:	f7ff ff44 	bl	8004830 <test_printf>
  test_printf("%s" TEST_CFG_EOL_STRING, msgp);
 80049a8:	4629      	mov	r1, r5
 80049aa:	4620      	mov	r0, r4
 80049ac:	f7ff ff40 	bl	8004830 <test_printf>
  test_printf("%s", msgp);
 80049b0:	4998      	ldr	r1, [pc, #608]	; (8004c14 <rt_test_001_003_execute+0x354>)
 80049b2:	4638      	mov	r0, r7
 80049b4:	f7ff ff3c 	bl	8004830 <test_printf>
  test_printf("%u", n);
 80049b8:	4641      	mov	r1, r8
 80049ba:	4630      	mov	r0, r6
 80049bc:	f7ff ff38 	bl	8004830 <test_printf>
  test_printf("%s" TEST_CFG_EOL_STRING, msgp);
 80049c0:	4629      	mov	r1, r5
 80049c2:	4620      	mov	r0, r4
 80049c4:	f7ff ff34 	bl	8004830 <test_printf>
  test_printf("%s", msgp);
 80049c8:	4993      	ldr	r1, [pc, #588]	; (8004c18 <rt_test_001_003_execute+0x358>)
 80049ca:	4638      	mov	r0, r7
 80049cc:	f7ff ff30 	bl	8004830 <test_printf>
  test_printf("%u", n);
 80049d0:	4641      	mov	r1, r8
 80049d2:	4630      	mov	r0, r6
 80049d4:	f7ff ff2c 	bl	8004830 <test_printf>
  test_printf("%s" TEST_CFG_EOL_STRING, msgp);
 80049d8:	4629      	mov	r1, r5
 80049da:	4620      	mov	r0, r4
 80049dc:	f7ff ff28 	bl	8004830 <test_printf>
  test_printf("%s", msgp);
 80049e0:	498e      	ldr	r1, [pc, #568]	; (8004c1c <rt_test_001_003_execute+0x35c>)
 80049e2:	4638      	mov	r0, r7
 80049e4:	f7ff ff24 	bl	8004830 <test_printf>
  test_printf("%u", n);
 80049e8:	4641      	mov	r1, r8
 80049ea:	4630      	mov	r0, r6
 80049ec:	f7ff ff20 	bl	8004830 <test_printf>
  test_printf("%s" TEST_CFG_EOL_STRING, msgp);
 80049f0:	4629      	mov	r1, r5
 80049f2:	4620      	mov	r0, r4
 80049f4:	f7ff ff1c 	bl	8004830 <test_printf>
  test_printf("%s", msgp);
 80049f8:	4989      	ldr	r1, [pc, #548]	; (8004c20 <rt_test_001_003_execute+0x360>)
 80049fa:	4638      	mov	r0, r7
 80049fc:	f7ff ff18 	bl	8004830 <test_printf>
  test_printf("%u", n);
 8004a00:	4641      	mov	r1, r8
 8004a02:	4630      	mov	r0, r6
 8004a04:	f7ff ff14 	bl	8004830 <test_printf>
  test_printf("%s" TEST_CFG_EOL_STRING, msgp);
 8004a08:	4629      	mov	r1, r5
 8004a0a:	4620      	mov	r0, r4
 8004a0c:	f7ff ff10 	bl	8004830 <test_printf>
  test_printf("%s", msgp);
 8004a10:	4984      	ldr	r1, [pc, #528]	; (8004c24 <rt_test_001_003_execute+0x364>)
 8004a12:	4638      	mov	r0, r7
 8004a14:	f7ff ff0c 	bl	8004830 <test_printf>
  test_printf("%u", n);
 8004a18:	2100      	movs	r1, #0
 8004a1a:	4630      	mov	r0, r6
 8004a1c:	f7ff ff08 	bl	8004830 <test_printf>
  test_printf("%s" TEST_CFG_EOL_STRING, msgp);
 8004a20:	4629      	mov	r1, r5
 8004a22:	4620      	mov	r0, r4
 8004a24:	f7ff ff04 	bl	8004830 <test_printf>
  test_printf("%s", msgp);
 8004a28:	497f      	ldr	r1, [pc, #508]	; (8004c28 <rt_test_001_003_execute+0x368>)
 8004a2a:	4638      	mov	r0, r7
 8004a2c:	f7ff ff00 	bl	8004830 <test_printf>
  test_printf("%u", n);
 8004a30:	4641      	mov	r1, r8
 8004a32:	4630      	mov	r0, r6
 8004a34:	f7ff fefc 	bl	8004830 <test_printf>
  test_printf("%s" TEST_CFG_EOL_STRING, msgp);
 8004a38:	4629      	mov	r1, r5
 8004a3a:	4620      	mov	r0, r4
 8004a3c:	f7ff fef8 	bl	8004830 <test_printf>
  test_printf("%s", msgp);
 8004a40:	497a      	ldr	r1, [pc, #488]	; (8004c2c <rt_test_001_003_execute+0x36c>)
 8004a42:	4638      	mov	r0, r7
 8004a44:	f7ff fef4 	bl	8004830 <test_printf>
  test_printf("%u", n);
 8004a48:	2100      	movs	r1, #0
 8004a4a:	4630      	mov	r0, r6
 8004a4c:	f7ff fef0 	bl	8004830 <test_printf>
  test_printf("%s" TEST_CFG_EOL_STRING, msgp);
 8004a50:	4629      	mov	r1, r5
 8004a52:	4620      	mov	r0, r4
 8004a54:	f7ff feec 	bl	8004830 <test_printf>
  test_printf("%s", msgp);
 8004a58:	4975      	ldr	r1, [pc, #468]	; (8004c30 <rt_test_001_003_execute+0x370>)
 8004a5a:	4638      	mov	r0, r7
 8004a5c:	f7ff fee8 	bl	8004830 <test_printf>
  test_printf("%u", n);
 8004a60:	4641      	mov	r1, r8
 8004a62:	4630      	mov	r0, r6
 8004a64:	f7ff fee4 	bl	8004830 <test_printf>
  test_printf("%s" TEST_CFG_EOL_STRING, msgp);
 8004a68:	4629      	mov	r1, r5
 8004a6a:	4620      	mov	r0, r4
 8004a6c:	f7ff fee0 	bl	8004830 <test_printf>
  test_printf("%s", msgp);
 8004a70:	4970      	ldr	r1, [pc, #448]	; (8004c34 <rt_test_001_003_execute+0x374>)
 8004a72:	4638      	mov	r0, r7
 8004a74:	f7ff fedc 	bl	8004830 <test_printf>
  test_printf("%u", n);
 8004a78:	4641      	mov	r1, r8
 8004a7a:	4630      	mov	r0, r6
 8004a7c:	f7ff fed8 	bl	8004830 <test_printf>
  test_printf("%s" TEST_CFG_EOL_STRING, msgp);
 8004a80:	4629      	mov	r1, r5
 8004a82:	4620      	mov	r0, r4
 8004a84:	f7ff fed4 	bl	8004830 <test_printf>
  test_printf("%s", msgp);
 8004a88:	496b      	ldr	r1, [pc, #428]	; (8004c38 <rt_test_001_003_execute+0x378>)
 8004a8a:	4638      	mov	r0, r7
 8004a8c:	f7ff fed0 	bl	8004830 <test_printf>
  test_printf("%u", n);
 8004a90:	4641      	mov	r1, r8
 8004a92:	4630      	mov	r0, r6
 8004a94:	f7ff fecc 	bl	8004830 <test_printf>
  test_printf("%s" TEST_CFG_EOL_STRING, msgp);
 8004a98:	4629      	mov	r1, r5
 8004a9a:	4620      	mov	r0, r4
 8004a9c:	f7ff fec8 	bl	8004830 <test_printf>
  test_printf("%s", msgp);
 8004aa0:	4966      	ldr	r1, [pc, #408]	; (8004c3c <rt_test_001_003_execute+0x37c>)
 8004aa2:	4638      	mov	r0, r7
 8004aa4:	f7ff fec4 	bl	8004830 <test_printf>
  test_printf("%u", n);
 8004aa8:	4641      	mov	r1, r8
 8004aaa:	4630      	mov	r0, r6
 8004aac:	f7ff fec0 	bl	8004830 <test_printf>
  test_printf("%s" TEST_CFG_EOL_STRING, msgp);
 8004ab0:	4629      	mov	r1, r5
 8004ab2:	4620      	mov	r0, r4
 8004ab4:	f7ff febc 	bl	8004830 <test_printf>
  test_printf("%s", msgp);
 8004ab8:	4961      	ldr	r1, [pc, #388]	; (8004c40 <rt_test_001_003_execute+0x380>)
 8004aba:	4638      	mov	r0, r7
 8004abc:	f7ff feb8 	bl	8004830 <test_printf>
  test_printf("%u", n);
 8004ac0:	4641      	mov	r1, r8
 8004ac2:	4630      	mov	r0, r6
 8004ac4:	f7ff feb4 	bl	8004830 <test_printf>
  test_printf("%s" TEST_CFG_EOL_STRING, msgp);
 8004ac8:	4629      	mov	r1, r5
 8004aca:	4620      	mov	r0, r4
 8004acc:	f7ff feb0 	bl	8004830 <test_printf>
  test_printf("%s", msgp);
 8004ad0:	495c      	ldr	r1, [pc, #368]	; (8004c44 <rt_test_001_003_execute+0x384>)
 8004ad2:	4638      	mov	r0, r7
 8004ad4:	f7ff feac 	bl	8004830 <test_printf>
  test_printf("%u", n);
 8004ad8:	2100      	movs	r1, #0
 8004ada:	4630      	mov	r0, r6
 8004adc:	f7ff fea8 	bl	8004830 <test_printf>
  test_printf("%s" TEST_CFG_EOL_STRING, msgp);
 8004ae0:	4629      	mov	r1, r5
 8004ae2:	4620      	mov	r0, r4
 8004ae4:	f7ff fea4 	bl	8004830 <test_printf>
  test_printf("%s", msgp);
 8004ae8:	4957      	ldr	r1, [pc, #348]	; (8004c48 <rt_test_001_003_execute+0x388>)
 8004aea:	4638      	mov	r0, r7
 8004aec:	f7ff fea0 	bl	8004830 <test_printf>
  test_printf("%u", n);
 8004af0:	4641      	mov	r1, r8
 8004af2:	4630      	mov	r0, r6
 8004af4:	f7ff fe9c 	bl	8004830 <test_printf>
  test_printf("%s" TEST_CFG_EOL_STRING, msgp);
 8004af8:	4629      	mov	r1, r5
 8004afa:	4620      	mov	r0, r4
 8004afc:	f7ff fe98 	bl	8004830 <test_printf>
  test_printf("%s", msgp);
 8004b00:	4952      	ldr	r1, [pc, #328]	; (8004c4c <rt_test_001_003_execute+0x38c>)
 8004b02:	4638      	mov	r0, r7
 8004b04:	f7ff fe94 	bl	8004830 <test_printf>
  test_printf("%u", n);
 8004b08:	2100      	movs	r1, #0
 8004b0a:	4630      	mov	r0, r6
 8004b0c:	f7ff fe90 	bl	8004830 <test_printf>
  test_printf("%s" TEST_CFG_EOL_STRING, msgp);
 8004b10:	4629      	mov	r1, r5
 8004b12:	4620      	mov	r0, r4
 8004b14:	f7ff fe8c 	bl	8004830 <test_printf>
  test_printf("%s", msgp);
 8004b18:	494d      	ldr	r1, [pc, #308]	; (8004c50 <rt_test_001_003_execute+0x390>)
 8004b1a:	4638      	mov	r0, r7
 8004b1c:	f7ff fe88 	bl	8004830 <test_printf>
  test_printf("%u", n);
 8004b20:	2100      	movs	r1, #0
 8004b22:	4630      	mov	r0, r6
 8004b24:	f7ff fe84 	bl	8004830 <test_printf>
  test_printf("%s" TEST_CFG_EOL_STRING, msgp);
 8004b28:	4629      	mov	r1, r5
 8004b2a:	4620      	mov	r0, r4
 8004b2c:	f7ff fe80 	bl	8004830 <test_printf>
  test_printf("%s", msgp);
 8004b30:	4948      	ldr	r1, [pc, #288]	; (8004c54 <rt_test_001_003_execute+0x394>)
 8004b32:	4638      	mov	r0, r7
 8004b34:	f7ff fe7c 	bl	8004830 <test_printf>
  test_printf("%u", n);
 8004b38:	2100      	movs	r1, #0
 8004b3a:	4630      	mov	r0, r6
 8004b3c:	f7ff fe78 	bl	8004830 <test_printf>
  test_printf("%s" TEST_CFG_EOL_STRING, msgp);
 8004b40:	4629      	mov	r1, r5
 8004b42:	4620      	mov	r0, r4
 8004b44:	f7ff fe74 	bl	8004830 <test_printf>
  test_printf("%s", msgp);
 8004b48:	4943      	ldr	r1, [pc, #268]	; (8004c58 <rt_test_001_003_execute+0x398>)
 8004b4a:	4638      	mov	r0, r7
 8004b4c:	f7ff fe70 	bl	8004830 <test_printf>
  test_printf("%u", n);
 8004b50:	2100      	movs	r1, #0
 8004b52:	4630      	mov	r0, r6
 8004b54:	f7ff fe6c 	bl	8004830 <test_printf>
  test_printf("%s" TEST_CFG_EOL_STRING, msgp);
 8004b58:	4629      	mov	r1, r5
 8004b5a:	4620      	mov	r0, r4
 8004b5c:	f7ff fe68 	bl	8004830 <test_printf>
  test_printf("%s", msgp);
 8004b60:	493e      	ldr	r1, [pc, #248]	; (8004c5c <rt_test_001_003_execute+0x39c>)
 8004b62:	4638      	mov	r0, r7
 8004b64:	f7ff fe64 	bl	8004830 <test_printf>
  test_printf("%u", n);
 8004b68:	21ff      	movs	r1, #255	; 0xff
 8004b6a:	4630      	mov	r0, r6
 8004b6c:	f7ff fe60 	bl	8004830 <test_printf>
  test_printf("%s" TEST_CFG_EOL_STRING, msgp);
 8004b70:	4629      	mov	r1, r5
 8004b72:	4620      	mov	r0, r4
 8004b74:	f7ff fe5c 	bl	8004830 <test_printf>
  test_printf("%s", msgp);
 8004b78:	4939      	ldr	r1, [pc, #228]	; (8004c60 <rt_test_001_003_execute+0x3a0>)
 8004b7a:	4638      	mov	r0, r7
 8004b7c:	f7ff fe58 	bl	8004830 <test_printf>
  test_printf("%u", n);
 8004b80:	2180      	movs	r1, #128	; 0x80
 8004b82:	4630      	mov	r0, r6
 8004b84:	f7ff fe54 	bl	8004830 <test_printf>
  test_printf("%s" TEST_CFG_EOL_STRING, msgp);
 8004b88:	4629      	mov	r1, r5
 8004b8a:	4620      	mov	r0, r4
 8004b8c:	f7ff fe50 	bl	8004830 <test_printf>
  test_printf("%s", msgp);
 8004b90:	4934      	ldr	r1, [pc, #208]	; (8004c64 <rt_test_001_003_execute+0x3a4>)
 8004b92:	4638      	mov	r0, r7
 8004b94:	f7ff fe4c 	bl	8004830 <test_printf>
  test_printf("%u", n);
 8004b98:	2100      	movs	r1, #0
 8004b9a:	4630      	mov	r0, r6
 8004b9c:	f7ff fe48 	bl	8004830 <test_printf>
  test_printf("%s" TEST_CFG_EOL_STRING, msgp);
 8004ba0:	4629      	mov	r1, r5
 8004ba2:	4620      	mov	r0, r4
 8004ba4:	f7ff fe44 	bl	8004830 <test_printf>
  test_printf("%s", msgp);
 8004ba8:	492f      	ldr	r1, [pc, #188]	; (8004c68 <rt_test_001_003_execute+0x3a8>)
 8004baa:	4638      	mov	r0, r7
 8004bac:	f7ff fe40 	bl	8004830 <test_printf>
  test_printf("%u", n);
 8004bb0:	2100      	movs	r1, #0
 8004bb2:	4630      	mov	r0, r6
 8004bb4:	f7ff fe3c 	bl	8004830 <test_printf>
  test_printf("%s" TEST_CFG_EOL_STRING, msgp);
 8004bb8:	4629      	mov	r1, r5
 8004bba:	4620      	mov	r0, r4
 8004bbc:	f7ff fe38 	bl	8004830 <test_printf>
  test_printf("%s", msgp);
 8004bc0:	492a      	ldr	r1, [pc, #168]	; (8004c6c <rt_test_001_003_execute+0x3ac>)
 8004bc2:	4638      	mov	r0, r7
 8004bc4:	f7ff fe34 	bl	8004830 <test_printf>
  test_printf("%u", n);
 8004bc8:	2100      	movs	r1, #0
 8004bca:	4630      	mov	r0, r6
 8004bcc:	f7ff fe30 	bl	8004830 <test_printf>
  test_printf("%s" TEST_CFG_EOL_STRING, msgp);
 8004bd0:	4629      	mov	r1, r5
 8004bd2:	4620      	mov	r0, r4
    test_print("--- CH_DBG_THREADS_PROFILING:           ");
    test_printn(CH_DBG_THREADS_PROFILING);
    test_println("");
  }
  test_end_step(1);
}
 8004bd4:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
 8004bd8:	f7ff be2a 	b.w	8004830 <test_printf>
 8004bdc:	0800aaf8 	.word	0x0800aaf8
 8004be0:	20000c70 	.word	0x20000c70
 8004be4:	0800aafc 	.word	0x0800aafc
 8004be8:	0800a89c 	.word	0x0800a89c
 8004bec:	0800a884 	.word	0x0800a884
 8004bf0:	0800aacc 	.word	0x0800aacc
 8004bf4:	0800ab00 	.word	0x0800ab00
 8004bf8:	0800ab2c 	.word	0x0800ab2c
 8004bfc:	0800ab58 	.word	0x0800ab58
 8004c00:	0800ab84 	.word	0x0800ab84
 8004c04:	0800abb0 	.word	0x0800abb0
 8004c08:	0800abdc 	.word	0x0800abdc
 8004c0c:	0800ac08 	.word	0x0800ac08
 8004c10:	0800ac34 	.word	0x0800ac34
 8004c14:	0800ac60 	.word	0x0800ac60
 8004c18:	0800ac8c 	.word	0x0800ac8c
 8004c1c:	0800acb8 	.word	0x0800acb8
 8004c20:	0800ace4 	.word	0x0800ace4
 8004c24:	0800ad10 	.word	0x0800ad10
 8004c28:	0800ad3c 	.word	0x0800ad3c
 8004c2c:	0800ad68 	.word	0x0800ad68
 8004c30:	0800ad94 	.word	0x0800ad94
 8004c34:	0800adc0 	.word	0x0800adc0
 8004c38:	0800adec 	.word	0x0800adec
 8004c3c:	0800ae18 	.word	0x0800ae18
 8004c40:	0800ae44 	.word	0x0800ae44
 8004c44:	0800ae70 	.word	0x0800ae70
 8004c48:	0800ae9c 	.word	0x0800ae9c
 8004c4c:	0800aec8 	.word	0x0800aec8
 8004c50:	0800aef4 	.word	0x0800aef4
 8004c54:	0800af20 	.word	0x0800af20
 8004c58:	0800af4c 	.word	0x0800af4c
 8004c5c:	0800af78 	.word	0x0800af78
 8004c60:	0800afa4 	.word	0x0800afa4
 8004c64:	0800afd0 	.word	0x0800afd0
 8004c68:	0800affc 	.word	0x0800affc
 8004c6c:	0800b028 	.word	0x0800b028

08004c70 <rt_test_001_002_execute>:
static void rt_test_001_002_execute(void) {
 8004c70:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8004c74:	4c23      	ldr	r4, [pc, #140]	; (8004d04 <rt_test_001_002_execute+0x94>)
  test_set_step(1);
 8004c76:	4b24      	ldr	r3, [pc, #144]	; (8004d08 <rt_test_001_002_execute+0x98>)
  test_printf("%s", msgp);
 8004c78:	4d24      	ldr	r5, [pc, #144]	; (8004d0c <rt_test_001_002_execute+0x9c>)
  test_printf("%u", n);
 8004c7a:	4f25      	ldr	r7, [pc, #148]	; (8004d10 <rt_test_001_002_execute+0xa0>)
  test_printf("%s" TEST_CFG_EOL_STRING, msgp);
 8004c7c:	4925      	ldr	r1, [pc, #148]	; (8004d14 <rt_test_001_002_execute+0xa4>)
 8004c7e:	4e26      	ldr	r6, [pc, #152]	; (8004d18 <rt_test_001_002_execute+0xa8>)
 8004c80:	f04f 0801 	mov.w	r8, #1
 8004c84:	4620      	mov	r0, r4
 8004c86:	f8c3 8000 	str.w	r8, [r3]
 8004c8a:	f7ff fdd1 	bl	8004830 <test_printf>
  test_printf("%s", msgp);
 8004c8e:	4923      	ldr	r1, [pc, #140]	; (8004d1c <rt_test_001_002_execute+0xac>)
 8004c90:	4628      	mov	r0, r5
 8004c92:	f7ff fdcd 	bl	8004830 <test_printf>
  test_printf("%u", n);
 8004c96:	2100      	movs	r1, #0
 8004c98:	4638      	mov	r0, r7
 8004c9a:	f7ff fdc9 	bl	8004830 <test_printf>
  test_printf("%s" TEST_CFG_EOL_STRING, msgp);
 8004c9e:	4631      	mov	r1, r6
 8004ca0:	4620      	mov	r0, r4
 8004ca2:	f7ff fdc5 	bl	8004830 <test_printf>
  test_printf("%s", msgp);
 8004ca6:	491e      	ldr	r1, [pc, #120]	; (8004d20 <rt_test_001_002_execute+0xb0>)
 8004ca8:	4628      	mov	r0, r5
 8004caa:	f7ff fdc1 	bl	8004830 <test_printf>
  test_printf("%s" TEST_CFG_EOL_STRING, msgp);
 8004cae:	491d      	ldr	r1, [pc, #116]	; (8004d24 <rt_test_001_002_execute+0xb4>)
 8004cb0:	4620      	mov	r0, r4
 8004cb2:	f7ff fdbd 	bl	8004830 <test_printf>
  test_printf("%s", msgp);
 8004cb6:	491c      	ldr	r1, [pc, #112]	; (8004d28 <rt_test_001_002_execute+0xb8>)
 8004cb8:	4628      	mov	r0, r5
 8004cba:	f7ff fdb9 	bl	8004830 <test_printf>
  test_printf("%u", n);
 8004cbe:	2107      	movs	r1, #7
 8004cc0:	4638      	mov	r0, r7
 8004cc2:	f7ff fdb5 	bl	8004830 <test_printf>
  test_printf("%s" TEST_CFG_EOL_STRING, msgp);
 8004cc6:	4631      	mov	r1, r6
 8004cc8:	4620      	mov	r0, r4
 8004cca:	f7ff fdb1 	bl	8004830 <test_printf>
  test_printf("%s", msgp);
 8004cce:	4917      	ldr	r1, [pc, #92]	; (8004d2c <rt_test_001_002_execute+0xbc>)
 8004cd0:	4628      	mov	r0, r5
 8004cd2:	f7ff fdad 	bl	8004830 <test_printf>
  test_printf("%u", n);
 8004cd6:	2100      	movs	r1, #0
 8004cd8:	4638      	mov	r0, r7
 8004cda:	f7ff fda9 	bl	8004830 <test_printf>
  test_printf("%s" TEST_CFG_EOL_STRING, msgp);
 8004cde:	4631      	mov	r1, r6
 8004ce0:	4620      	mov	r0, r4
 8004ce2:	f7ff fda5 	bl	8004830 <test_printf>
  test_printf("%s", msgp);
 8004ce6:	4912      	ldr	r1, [pc, #72]	; (8004d30 <rt_test_001_002_execute+0xc0>)
 8004ce8:	4628      	mov	r0, r5
 8004cea:	f7ff fda1 	bl	8004830 <test_printf>
  test_printf("%u", n);
 8004cee:	4641      	mov	r1, r8
 8004cf0:	4638      	mov	r0, r7
 8004cf2:	f7ff fd9d 	bl	8004830 <test_printf>
  test_printf("%s" TEST_CFG_EOL_STRING, msgp);
 8004cf6:	4631      	mov	r1, r6
 8004cf8:	4620      	mov	r0, r4
}
 8004cfa:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
 8004cfe:	f7ff bd97 	b.w	8004830 <test_printf>
 8004d02:	bf00      	nop
 8004d04:	0800a884 	.word	0x0800a884
 8004d08:	20000c70 	.word	0x20000c70
 8004d0c:	0800aaf8 	.word	0x0800aaf8
 8004d10:	0800aafc 	.word	0x0800aafc
 8004d14:	0800b054 	.word	0x0800b054
 8004d18:	0800a89c 	.word	0x0800a89c
 8004d1c:	0800b088 	.word	0x0800b088
 8004d20:	0800b0b4 	.word	0x0800b0b4
 8004d24:	0800b0e0 	.word	0x0800b0e0
 8004d28:	0800b0e8 	.word	0x0800b0e8
 8004d2c:	0800b114 	.word	0x0800b114
 8004d30:	0800b140 	.word	0x0800b140
	...

08004d40 <rt_test_001_001_execute>:
static void rt_test_001_001_execute(void) {
 8004d40:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  test_printf("%s", msgp);
 8004d42:	4d26      	ldr	r5, [pc, #152]	; (8004ddc <rt_test_001_001_execute+0x9c>)
  test_set_step(1);
 8004d44:	4b26      	ldr	r3, [pc, #152]	; (8004de0 <rt_test_001_001_execute+0xa0>)
  test_printf("%s" TEST_CFG_EOL_STRING, msgp);
 8004d46:	4c27      	ldr	r4, [pc, #156]	; (8004de4 <rt_test_001_001_execute+0xa4>)
  test_printf("%s", msgp);
 8004d48:	4927      	ldr	r1, [pc, #156]	; (8004de8 <rt_test_001_001_execute+0xa8>)
  test_printf("%u", n);
 8004d4a:	4f28      	ldr	r7, [pc, #160]	; (8004dec <rt_test_001_001_execute+0xac>)
  test_printf("%s" TEST_CFG_EOL_STRING, msgp);
 8004d4c:	4e28      	ldr	r6, [pc, #160]	; (8004df0 <rt_test_001_001_execute+0xb0>)
 8004d4e:	2201      	movs	r2, #1
  test_printf("%s", msgp);
 8004d50:	4628      	mov	r0, r5
 8004d52:	601a      	str	r2, [r3, #0]
 8004d54:	f7ff fd6c 	bl	8004830 <test_printf>
  test_printf("%s" TEST_CFG_EOL_STRING, msgp);
 8004d58:	4926      	ldr	r1, [pc, #152]	; (8004df4 <rt_test_001_001_execute+0xb4>)
 8004d5a:	4620      	mov	r0, r4
 8004d5c:	f7ff fd68 	bl	8004830 <test_printf>
  test_printf("%s", msgp);
 8004d60:	4925      	ldr	r1, [pc, #148]	; (8004df8 <rt_test_001_001_execute+0xb8>)
 8004d62:	4628      	mov	r0, r5
 8004d64:	f7ff fd64 	bl	8004830 <test_printf>
  test_printf("%s" TEST_CFG_EOL_STRING, msgp);
 8004d68:	4924      	ldr	r1, [pc, #144]	; (8004dfc <rt_test_001_001_execute+0xbc>)
 8004d6a:	4620      	mov	r0, r4
 8004d6c:	f7ff fd60 	bl	8004830 <test_printf>
  test_printf("%s", msgp);
 8004d70:	4923      	ldr	r1, [pc, #140]	; (8004e00 <rt_test_001_001_execute+0xc0>)
 8004d72:	4628      	mov	r0, r5
 8004d74:	f7ff fd5c 	bl	8004830 <test_printf>
  test_printf("%s" TEST_CFG_EOL_STRING, msgp);
 8004d78:	4922      	ldr	r1, [pc, #136]	; (8004e04 <rt_test_001_001_execute+0xc4>)
 8004d7a:	4620      	mov	r0, r4
 8004d7c:	f7ff fd58 	bl	8004830 <test_printf>
  test_printf("%s", msgp);
 8004d80:	4921      	ldr	r1, [pc, #132]	; (8004e08 <rt_test_001_001_execute+0xc8>)
 8004d82:	4628      	mov	r0, r5
 8004d84:	f7ff fd54 	bl	8004830 <test_printf>
  test_printf("%s" TEST_CFG_EOL_STRING, msgp);
 8004d88:	4920      	ldr	r1, [pc, #128]	; (8004e0c <rt_test_001_001_execute+0xcc>)
 8004d8a:	4620      	mov	r0, r4
 8004d8c:	f7ff fd50 	bl	8004830 <test_printf>
  test_printf("%s", msgp);
 8004d90:	491f      	ldr	r1, [pc, #124]	; (8004e10 <rt_test_001_001_execute+0xd0>)
 8004d92:	4628      	mov	r0, r5
 8004d94:	f7ff fd4c 	bl	8004830 <test_printf>
  test_printf("%u", n);
 8004d98:	2104      	movs	r1, #4
 8004d9a:	4638      	mov	r0, r7
 8004d9c:	f7ff fd48 	bl	8004830 <test_printf>
  test_printf("%s" TEST_CFG_EOL_STRING, msgp);
 8004da0:	4631      	mov	r1, r6
 8004da2:	4620      	mov	r0, r4
 8004da4:	f7ff fd44 	bl	8004830 <test_printf>
  test_printf("%s", msgp);
 8004da8:	491a      	ldr	r1, [pc, #104]	; (8004e14 <rt_test_001_001_execute+0xd4>)
 8004daa:	4628      	mov	r0, r5
 8004dac:	f7ff fd40 	bl	8004830 <test_printf>
  test_printf("%u", n);
 8004db0:	2108      	movs	r1, #8
 8004db2:	4638      	mov	r0, r7
 8004db4:	f7ff fd3c 	bl	8004830 <test_printf>
  test_printf("%s" TEST_CFG_EOL_STRING, msgp);
 8004db8:	4631      	mov	r1, r6
 8004dba:	4620      	mov	r0, r4
 8004dbc:	f7ff fd38 	bl	8004830 <test_printf>
  test_printf("%s", msgp);
 8004dc0:	4915      	ldr	r1, [pc, #84]	; (8004e18 <rt_test_001_001_execute+0xd8>)
 8004dc2:	4628      	mov	r0, r5
 8004dc4:	f7ff fd34 	bl	8004830 <test_printf>
  test_printf("%u", n);
 8004dc8:	2108      	movs	r1, #8
 8004dca:	4638      	mov	r0, r7
 8004dcc:	f7ff fd30 	bl	8004830 <test_printf>
  test_printf("%s" TEST_CFG_EOL_STRING, msgp);
 8004dd0:	4631      	mov	r1, r6
 8004dd2:	4620      	mov	r0, r4
}
 8004dd4:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
 8004dd8:	f7ff bd2a 	b.w	8004830 <test_printf>
 8004ddc:	0800aaf8 	.word	0x0800aaf8
 8004de0:	20000c70 	.word	0x20000c70
 8004de4:	0800a884 	.word	0x0800a884
 8004de8:	0800b16c 	.word	0x0800b16c
 8004dec:	0800aafc 	.word	0x0800aafc
 8004df0:	0800a89c 	.word	0x0800a89c
 8004df4:	0800b198 	.word	0x0800b198
 8004df8:	0800b1a4 	.word	0x0800b1a4
 8004dfc:	0800b1d0 	.word	0x0800b1d0
 8004e00:	0800b1dc 	.word	0x0800b1dc
 8004e04:	0800b208 	.word	0x0800b208
 8004e08:	0800b228 	.word	0x0800b228
 8004e0c:	0800b254 	.word	0x0800b254
 8004e10:	0800b26c 	.word	0x0800b26c
 8004e14:	0800b298 	.word	0x0800b298
 8004e18:	0800b2c4 	.word	0x0800b2c4
 8004e1c:	00000000 	.word	0x00000000

08004e20 <rt_test_002_003_execute>:

static void rt_test_002_003_execute(void) {

  /* [2.3.1] Testing chSysSuspend(), chSysDisable() and
     chSysEnable().*/
  test_set_step(1);
 8004e20:	4b07      	ldr	r3, [pc, #28]	; (8004e40 <rt_test_002_003_execute+0x20>)
 8004e22:	2201      	movs	r2, #1
 8004e24:	601a      	str	r2, [r3, #0]
 8004e26:	2330      	movs	r3, #48	; 0x30
 8004e28:	f383 8811 	msr	BASEPRI, r3
  __ASM volatile ("cpsie i" : : : "memory");
 8004e2c:	b662      	cpsie	i
  __ASM volatile ("cpsid i" : : : "memory");
 8004e2e:	b672      	cpsid	i
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 8004e30:	f383 8811 	msr	BASEPRI, r3
  __ASM volatile ("cpsie i" : : : "memory");
 8004e34:	b662      	cpsie	i
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 8004e36:	2300      	movs	r3, #0
 8004e38:	f383 8811 	msr	BASEPRI, r3
  __ASM volatile ("cpsie i" : : : "memory");
 8004e3c:	b662      	cpsie	i
    chSysDisable();
    chSysSuspend();
    chSysEnable();
  }
  test_end_step(1);
}
 8004e3e:	4770      	bx	lr
 8004e40:	20000c70 	.word	0x20000c70
	...

08004e50 <vtcb>:
static void vtcb(virtual_timer_t *vtp, void *p) {
 8004e50:	b510      	push	{r4, lr}
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 8004e52:	2330      	movs	r3, #48	; 0x30
 8004e54:	f383 8811 	msr	BASEPRI, r3
 8004e58:	2400      	movs	r4, #0
 8004e5a:	f384 8811 	msr	BASEPRI, r4
 8004e5e:	f383 8811 	msr	BASEPRI, r3
  sts = chSysGetStatusAndLockX();
 8004e62:	f7fc fc0d 	bl	8001680 <chSysGetStatusAndLockX>
  chSysRestoreStatusX(sts);
 8004e66:	f7fc fc1b 	bl	80016a0 <chSysRestoreStatusX>
 8004e6a:	f384 8811 	msr	BASEPRI, r4
}
 8004e6e:	bd10      	pop	{r4, pc}

08004e70 <rt_test_002_001_execute>:
static void rt_test_002_001_execute(void) {
 8004e70:	b570      	push	{r4, r5, r6, lr}
  test_set_step(1);
 8004e72:	4e24      	ldr	r6, [pc, #144]	; (8004f04 <rt_test_002_001_execute+0x94>)
 8004e74:	2001      	movs	r0, #1
 8004e76:	6030      	str	r0, [r6, #0]
 8004e78:	2530      	movs	r5, #48	; 0x30
 8004e7a:	f385 8811 	msr	BASEPRI, r5
    result = chSysIntegrityCheckI(CH_INTEGRITY_RLIST);
 8004e7e:	f7fc fb97 	bl	80015b0 <chSysIntegrityCheckI>
 8004e82:	2300      	movs	r3, #0
 8004e84:	f383 8811 	msr	BASEPRI, r3
    test_assert(result == false, "ready list check failed");
 8004e88:	f080 0001 	eor.w	r0, r0, #1
 8004e8c:	491e      	ldr	r1, [pc, #120]	; (8004f08 <rt_test_002_001_execute+0x98>)
 8004e8e:	b2c0      	uxtb	r0, r0
 8004e90:	f7ff fa46 	bl	8004320 <__test_assert>
 8004e94:	b100      	cbz	r0, 8004e98 <rt_test_002_001_execute+0x28>
}
 8004e96:	bd70      	pop	{r4, r5, r6, pc}
  test_set_step(2);
 8004e98:	4604      	mov	r4, r0
 8004e9a:	2002      	movs	r0, #2
 8004e9c:	6030      	str	r0, [r6, #0]
 8004e9e:	f385 8811 	msr	BASEPRI, r5
    result = chSysIntegrityCheckI(CH_INTEGRITY_VTLIST);
 8004ea2:	f7fc fb85 	bl	80015b0 <chSysIntegrityCheckI>
 8004ea6:	f384 8811 	msr	BASEPRI, r4
    test_assert(result == false, "virtual timers list check failed");
 8004eaa:	f080 0001 	eor.w	r0, r0, #1
 8004eae:	4917      	ldr	r1, [pc, #92]	; (8004f0c <rt_test_002_001_execute+0x9c>)
 8004eb0:	b2c0      	uxtb	r0, r0
 8004eb2:	f7ff fa35 	bl	8004320 <__test_assert>
 8004eb6:	4604      	mov	r4, r0
 8004eb8:	2800      	cmp	r0, #0
 8004eba:	d1ec      	bne.n	8004e96 <rt_test_002_001_execute+0x26>
  test_set_step(3);
 8004ebc:	2303      	movs	r3, #3
 8004ebe:	6033      	str	r3, [r6, #0]
 8004ec0:	f385 8811 	msr	BASEPRI, r5
    result = chSysIntegrityCheckI(CH_INTEGRITY_REGISTRY);
 8004ec4:	2004      	movs	r0, #4
 8004ec6:	f7fc fb73 	bl	80015b0 <chSysIntegrityCheckI>
 8004eca:	f384 8811 	msr	BASEPRI, r4
    test_assert(result == false, "registry list check failed");
 8004ece:	f080 0001 	eor.w	r0, r0, #1
 8004ed2:	490f      	ldr	r1, [pc, #60]	; (8004f10 <rt_test_002_001_execute+0xa0>)
 8004ed4:	b2c0      	uxtb	r0, r0
 8004ed6:	f7ff fa23 	bl	8004320 <__test_assert>
 8004eda:	4604      	mov	r4, r0
 8004edc:	2800      	cmp	r0, #0
 8004ede:	d1da      	bne.n	8004e96 <rt_test_002_001_execute+0x26>
  test_set_step(4);
 8004ee0:	2304      	movs	r3, #4
 8004ee2:	6033      	str	r3, [r6, #0]
 8004ee4:	f385 8811 	msr	BASEPRI, r5
    result = chSysIntegrityCheckI(CH_INTEGRITY_PORT);
 8004ee8:	2008      	movs	r0, #8
 8004eea:	f7fc fb61 	bl	80015b0 <chSysIntegrityCheckI>
 8004eee:	f384 8811 	msr	BASEPRI, r4
    test_assert(result == false, "port layer check failed");
 8004ef2:	f080 0001 	eor.w	r0, r0, #1
}
 8004ef6:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
    test_assert(result == false, "port layer check failed");
 8004efa:	4906      	ldr	r1, [pc, #24]	; (8004f14 <rt_test_002_001_execute+0xa4>)
 8004efc:	b2c0      	uxtb	r0, r0
 8004efe:	f7ff ba0f 	b.w	8004320 <__test_assert>
 8004f02:	bf00      	nop
 8004f04:	20000c70 	.word	0x20000c70
 8004f08:	0800b36c 	.word	0x0800b36c
 8004f0c:	0800b384 	.word	0x0800b384
 8004f10:	0800b3a8 	.word	0x0800b3a8
 8004f14:	0800b3c4 	.word	0x0800b3c4
	...

08004f20 <rt_test_002_002_execute>:
static void rt_test_002_002_execute(void) {
 8004f20:	b530      	push	{r4, r5, lr}
  test_set_step(1);
 8004f22:	4c2d      	ldr	r4, [pc, #180]	; (8004fd8 <rt_test_002_002_execute+0xb8>)
 8004f24:	2301      	movs	r3, #1
static void rt_test_002_002_execute(void) {
 8004f26:	b087      	sub	sp, #28
  test_set_step(1);
 8004f28:	6023      	str	r3, [r4, #0]
    sts = chSysGetStatusAndLockX();
 8004f2a:	f7fc fba9 	bl	8001680 <chSysGetStatusAndLockX>
    chSysRestoreStatusX(sts);
 8004f2e:	f7fc fbb7 	bl	80016a0 <chSysRestoreStatusX>
  test_set_step(2);
 8004f32:	2302      	movs	r3, #2
 8004f34:	6023      	str	r3, [r4, #0]
 8004f36:	2530      	movs	r5, #48	; 0x30
 8004f38:	f385 8811 	msr	BASEPRI, r5
    sts = chSysGetStatusAndLockX();
 8004f3c:	f7fc fba0 	bl	8001680 <chSysGetStatusAndLockX>
    chSysRestoreStatusX(sts);
 8004f40:	f7fc fbae 	bl	80016a0 <chSysRestoreStatusX>
 8004f44:	2300      	movs	r3, #0
 8004f46:	f383 8811 	msr	BASEPRI, r3
  test_set_step(3);
 8004f4a:	2303      	movs	r3, #3
 8004f4c:	6023      	str	r3, [r4, #0]
  __ASM volatile ("MRS %0, basepri" : "=r" (result) );
 8004f4e:	f3ef 8311 	mrs	r3, BASEPRI
 *
 * @special
 */
static inline void chSysUnconditionalLock(void) {

  if (port_irq_enabled(port_get_irq_status())) {
 8004f52:	b90b      	cbnz	r3, 8004f58 <rt_test_002_002_execute+0x38>
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 8004f54:	f385 8811 	msr	BASEPRI, r5
  __ASM volatile ("MRS %0, basepri" : "=r" (result) );
 8004f58:	f3ef 8311 	mrs	r3, BASEPRI
 8004f5c:	b913      	cbnz	r3, 8004f64 <rt_test_002_002_execute+0x44>
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 8004f5e:	2330      	movs	r3, #48	; 0x30
 8004f60:	f383 8811 	msr	BASEPRI, r3
 8004f64:	2300      	movs	r3, #0
 8004f66:	f383 8811 	msr	BASEPRI, r3
  test_set_step(4);
 8004f6a:	2204      	movs	r2, #4
 8004f6c:	6022      	str	r2, [r4, #0]
 8004f6e:	2230      	movs	r2, #48	; 0x30
 8004f70:	f382 8811 	msr	BASEPRI, r2
  __ASM volatile ("MRS %0, basepri" : "=r" (result) );
 8004f74:	f3ef 8211 	mrs	r2, BASEPRI
 *
 * @special
 */
static inline void chSysUnconditionalUnlock(void) {

  if (!port_irq_enabled(port_get_irq_status())) {
 8004f78:	b10a      	cbz	r2, 8004f7e <rt_test_002_002_execute+0x5e>
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 8004f7a:	f383 8811 	msr	BASEPRI, r3
  __ASM volatile ("MRS %0, basepri" : "=r" (result) );
 8004f7e:	f3ef 8311 	mrs	r3, BASEPRI
 8004f82:	b113      	cbz	r3, 8004f8a <rt_test_002_002_execute+0x6a>
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 8004f84:	2300      	movs	r3, #0
 8004f86:	f383 8811 	msr	BASEPRI, r3
  test_set_step(5);
 8004f8a:	2205      	movs	r2, #5
  vtp->dlist.next = NULL;
 8004f8c:	2300      	movs	r3, #0
 8004f8e:	9300      	str	r3, [sp, #0]
 8004f90:	6022      	str	r2, [r4, #0]
 8004f92:	2330      	movs	r3, #48	; 0x30
 8004f94:	f383 8811 	msr	BASEPRI, r3
  if (chVTIsArmedI(vtp)) {
 8004f98:	9b00      	ldr	r3, [sp, #0]
    chVTDoResetI(vtp);
 8004f9a:	466c      	mov	r4, sp
  if (chVTIsArmedI(vtp)) {
 8004f9c:	b113      	cbz	r3, 8004fa4 <rt_test_002_002_execute+0x84>
    chVTDoResetI(vtp);
 8004f9e:	4620      	mov	r0, r4
 8004fa0:	f7fc fc26 	bl	80017f0 <chVTDoResetI>
  chVTDoSetI(vtp, delay, vtfunc, par);
 8004fa4:	4620      	mov	r0, r4
 8004fa6:	4a0d      	ldr	r2, [pc, #52]	; (8004fdc <rt_test_002_002_execute+0xbc>)
 8004fa8:	2300      	movs	r3, #0
 8004faa:	2101      	movs	r1, #1
 8004fac:	f7fc fc18 	bl	80017e0 <chVTDoSetI>
 8004fb0:	2400      	movs	r4, #0
 8004fb2:	f384 8811 	msr	BASEPRI, r4
    chThdSleep(10);
 8004fb6:	200a      	movs	r0, #10
 8004fb8:	f7fc fffa 	bl	8001fb0 <chThdSleep>
 8004fbc:	2330      	movs	r3, #48	; 0x30
 8004fbe:	f383 8811 	msr	BASEPRI, r3
  return (bool)(vtp->dlist.next != NULL);
 8004fc2:	9800      	ldr	r0, [sp, #0]
 8004fc4:	f384 8811 	msr	BASEPRI, r4
    test_assert(chVTIsArmed(&vt) == false, "timer still armed");
 8004fc8:	fab0 f080 	clz	r0, r0
 8004fcc:	4904      	ldr	r1, [pc, #16]	; (8004fe0 <rt_test_002_002_execute+0xc0>)
 8004fce:	0940      	lsrs	r0, r0, #5
 8004fd0:	f7ff f9a6 	bl	8004320 <__test_assert>
}
 8004fd4:	b007      	add	sp, #28
 8004fd6:	bd30      	pop	{r4, r5, pc}
 8004fd8:	20000c70 	.word	0x20000c70
 8004fdc:	08004e51 	.word	0x08004e51
 8004fe0:	0800b3dc 	.word	0x0800b3dc
	...

08004ff0 <rt_test_003_001_execute>:

static void rt_test_003_001_execute(void) {

  /* [3.1.1] A System Tick Counter increment is expected, the test
     simply hangs if it does not happen.*/
  test_set_step(1);
 8004ff0:	4b05      	ldr	r3, [pc, #20]	; (8005008 <rt_test_003_001_execute+0x18>)
static void rt_test_003_001_execute(void) {
 8004ff2:	b510      	push	{r4, lr}
  test_set_step(1);
 8004ff4:	2201      	movs	r2, #1
 8004ff6:	601a      	str	r2, [r3, #0]
 8004ff8:	f7fb fa62 	bl	80004c0 <stGetCounter>
 8004ffc:	4604      	mov	r4, r0
 8004ffe:	f7fb fa5f 	bl	80004c0 <stGetCounter>
  {
    systime_t time = chVTGetSystemTimeX();
    while (time == chVTGetSystemTimeX()) {
 8005002:	4284      	cmp	r4, r0
 8005004:	d0fb      	beq.n	8004ffe <rt_test_003_001_execute+0xe>
        _sim_check_for_interrupts();
#endif
    }
  }
  test_end_step(1);
}
 8005006:	bd10      	pop	{r4, pc}
 8005008:	20000c70 	.word	0x20000c70
 800500c:	00000000 	.word	0x00000000

08005010 <rt_test_003_002_execute>:
 * - [3.2.2] Checking boundaries for start < end.
 * - [3.2.3] Checking boundaries for start > end.
 * .
 */

static void rt_test_003_002_execute(void) {
 8005010:	b538      	push	{r3, r4, r5, lr}

  /* [3.2.1] Checking case where start == end, it must always evaluate
     as not in range.*/
  test_set_step(1);
 8005012:	2401      	movs	r4, #1
 8005014:	4d26      	ldr	r5, [pc, #152]	; (80050b0 <rt_test_003_002_execute+0xa0>)
  {
    bool b;

    b = chTimeIsInRangeX((systime_t)0, (systime_t)0, (systime_t)0);
    test_assert(b == false, "in range");
 8005016:	4927      	ldr	r1, [pc, #156]	; (80050b4 <rt_test_003_002_execute+0xa4>)
  test_set_step(1);
 8005018:	602c      	str	r4, [r5, #0]
    test_assert(b == false, "in range");
 800501a:	4620      	mov	r0, r4
 800501c:	f7ff f980 	bl	8004320 <__test_assert>
 8005020:	b100      	cbz	r0, 8005024 <rt_test_003_002_execute+0x14>
    test_assert(b == true, "not in range");
    b = chTimeIsInRangeX((systime_t)10, (systime_t)100, (systime_t)10);
    test_assert(b == false, "in range");
  }
  test_end_step(3);
}
 8005022:	bd38      	pop	{r3, r4, r5, pc}
    test_assert(b == false, "in range");
 8005024:	4923      	ldr	r1, [pc, #140]	; (80050b4 <rt_test_003_002_execute+0xa4>)
 8005026:	4620      	mov	r0, r4
 8005028:	f7ff f97a 	bl	8004320 <__test_assert>
 800502c:	2800      	cmp	r0, #0
 800502e:	d1f8      	bne.n	8005022 <rt_test_003_002_execute+0x12>
    test_assert(b == false, "in range");
 8005030:	4920      	ldr	r1, [pc, #128]	; (80050b4 <rt_test_003_002_execute+0xa4>)
 8005032:	4620      	mov	r0, r4
 8005034:	f7ff f974 	bl	8004320 <__test_assert>
 8005038:	2800      	cmp	r0, #0
 800503a:	d1f2      	bne.n	8005022 <rt_test_003_002_execute+0x12>
    test_assert(b == false, "in range");
 800503c:	491d      	ldr	r1, [pc, #116]	; (80050b4 <rt_test_003_002_execute+0xa4>)
 800503e:	4620      	mov	r0, r4
 8005040:	f7ff f96e 	bl	8004320 <__test_assert>
 8005044:	2800      	cmp	r0, #0
 8005046:	d1ec      	bne.n	8005022 <rt_test_003_002_execute+0x12>
  test_set_step(2);
 8005048:	2302      	movs	r3, #2
    test_assert(b == true, "not in range");
 800504a:	491b      	ldr	r1, [pc, #108]	; (80050b8 <rt_test_003_002_execute+0xa8>)
  test_set_step(2);
 800504c:	602b      	str	r3, [r5, #0]
    test_assert(b == true, "not in range");
 800504e:	4620      	mov	r0, r4
 8005050:	f7ff f966 	bl	8004320 <__test_assert>
 8005054:	2800      	cmp	r0, #0
 8005056:	d1e4      	bne.n	8005022 <rt_test_003_002_execute+0x12>
    test_assert(b == false, "in range");
 8005058:	4916      	ldr	r1, [pc, #88]	; (80050b4 <rt_test_003_002_execute+0xa4>)
 800505a:	4620      	mov	r0, r4
 800505c:	f7ff f960 	bl	8004320 <__test_assert>
 8005060:	2800      	cmp	r0, #0
 8005062:	d1de      	bne.n	8005022 <rt_test_003_002_execute+0x12>
    test_assert(b == true, "not in range");
 8005064:	4914      	ldr	r1, [pc, #80]	; (80050b8 <rt_test_003_002_execute+0xa8>)
 8005066:	4620      	mov	r0, r4
 8005068:	f7ff f95a 	bl	8004320 <__test_assert>
 800506c:	2800      	cmp	r0, #0
 800506e:	d1d8      	bne.n	8005022 <rt_test_003_002_execute+0x12>
    test_assert(b == false, "in range");
 8005070:	4910      	ldr	r1, [pc, #64]	; (80050b4 <rt_test_003_002_execute+0xa4>)
 8005072:	4620      	mov	r0, r4
 8005074:	f7ff f954 	bl	8004320 <__test_assert>
 8005078:	2800      	cmp	r0, #0
 800507a:	d1d2      	bne.n	8005022 <rt_test_003_002_execute+0x12>
  test_set_step(3);
 800507c:	2303      	movs	r3, #3
    test_assert(b == true, "not in range");
 800507e:	490e      	ldr	r1, [pc, #56]	; (80050b8 <rt_test_003_002_execute+0xa8>)
  test_set_step(3);
 8005080:	602b      	str	r3, [r5, #0]
    test_assert(b == true, "not in range");
 8005082:	4620      	mov	r0, r4
 8005084:	f7ff f94c 	bl	8004320 <__test_assert>
 8005088:	2800      	cmp	r0, #0
 800508a:	d1ca      	bne.n	8005022 <rt_test_003_002_execute+0x12>
    test_assert(b == false, "in range");
 800508c:	4909      	ldr	r1, [pc, #36]	; (80050b4 <rt_test_003_002_execute+0xa4>)
 800508e:	4620      	mov	r0, r4
 8005090:	f7ff f946 	bl	8004320 <__test_assert>
 8005094:	2800      	cmp	r0, #0
 8005096:	d1c4      	bne.n	8005022 <rt_test_003_002_execute+0x12>
    test_assert(b == true, "not in range");
 8005098:	4907      	ldr	r1, [pc, #28]	; (80050b8 <rt_test_003_002_execute+0xa8>)
 800509a:	4620      	mov	r0, r4
 800509c:	f7ff f940 	bl	8004320 <__test_assert>
 80050a0:	2800      	cmp	r0, #0
 80050a2:	d1be      	bne.n	8005022 <rt_test_003_002_execute+0x12>
    test_assert(b == false, "in range");
 80050a4:	4620      	mov	r0, r4
 80050a6:	4903      	ldr	r1, [pc, #12]	; (80050b4 <rt_test_003_002_execute+0xa4>)
}
 80050a8:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
    test_assert(b == false, "in range");
 80050ac:	f7ff b938 	b.w	8004320 <__test_assert>
 80050b0:	20000c70 	.word	0x20000c70
 80050b4:	0800b4c0 	.word	0x0800b4c0
 80050b8:	0800b4bc 	.word	0x0800b4bc
 80050bc:	00000000 	.word	0x00000000

080050c0 <rt_test_004_001_execute>:
 * <h2>Test Steps</h2>
 * - [4.1.1] Time stamps are generated and checked for monotonicity.
 * .
 */

static void rt_test_004_001_execute(void) {
 80050c0:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}

  /* [4.1.1] Time stamps are generated and checked for monotonicity.*/
  test_set_step(1);
 80050c4:	4b18      	ldr	r3, [pc, #96]	; (8005128 <rt_test_004_001_execute+0x68>)
 80050c6:	2201      	movs	r2, #1
 80050c8:	601a      	str	r2, [r3, #0]
 80050ca:	f04f 0830 	mov.w	r8, #48	; 0x30
 80050ce:	f388 8811 	msr	BASEPRI, r8
  stamp = chVTGetTimeStampI();
 80050d2:	f7fc fc5d 	bl	8001990 <chVTGetTimeStampI>
 80050d6:	2700      	movs	r7, #0
 80050d8:	4605      	mov	r5, r0
 80050da:	460c      	mov	r4, r1
 80050dc:	f387 8811 	msr	BASEPRI, r7
  {
    systime_t start, end;
    systimestamp_t last, now;

    last = chVTGetTimeStamp();
    start = test_wait_tick();
 80050e0:	f7ff fbde 	bl	80048a0 <test_wait_tick>
    end = chTimeAddX(start, TIME_MS2I(1000));
    do {
      now = chVTGetTimeStamp();
      test_assert(last <= now, "not monotonic");
 80050e4:	f8df 9044 	ldr.w	r9, [pc, #68]	; 800512c <rt_test_004_001_execute+0x6c>
    start = test_wait_tick();
 80050e8:	4606      	mov	r6, r0
  return systime + (systime_t)interval;
 80050ea:	e006      	b.n	80050fa <rt_test_004_001_execute+0x3a>
 80050ec:	f7fb f9e8 	bl	80004c0 <stGetCounter>
      last = now;
#if defined(SIMULATOR)
      _sim_check_for_interrupts();
#endif
    } while (chVTIsSystemTimeWithinX(start, end));
 80050f0:	f242 730f 	movw	r3, #9999	; 0x270f
  return (bool)((systime_t)((systime_t)time - (systime_t)start) <
 80050f4:	1b80      	subs	r0, r0, r6
 80050f6:	4298      	cmp	r0, r3
 80050f8:	d814      	bhi.n	8005124 <rt_test_004_001_execute+0x64>
 80050fa:	f388 8811 	msr	BASEPRI, r8
 80050fe:	f7fc fc47 	bl	8001990 <chVTGetTimeStampI>
 8005102:	462a      	mov	r2, r5
 8005104:	4623      	mov	r3, r4
 8005106:	4605      	mov	r5, r0
 8005108:	460c      	mov	r4, r1
 800510a:	f387 8811 	msr	BASEPRI, r7
      test_assert(last <= now, "not monotonic");
 800510e:	4290      	cmp	r0, r2
 8005110:	eb71 0303 	sbcs.w	r3, r1, r3
 8005114:	bf2c      	ite	cs
 8005116:	2001      	movcs	r0, #1
 8005118:	2000      	movcc	r0, #0
 800511a:	4649      	mov	r1, r9
 800511c:	f7ff f900 	bl	8004320 <__test_assert>
 8005120:	2800      	cmp	r0, #0
 8005122:	d0e3      	beq.n	80050ec <rt_test_004_001_execute+0x2c>
  }
  test_end_step(1);
}
 8005124:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
 8005128:	20000c70 	.word	0x20000c70
 800512c:	0800b564 	.word	0x0800b564

08005130 <rt_test_005_004_execute>:
 * - [5.4.3] Raising thread priority above the boosted level.
 * - [5.4.4] Restoring original conditions.
 * .
 */

static void rt_test_005_004_execute(void) {
 8005130:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  return __sch_get_currthread();
 8005134:	4e32      	ldr	r6, [pc, #200]	; (8005200 <rt_test_005_004_execute+0xd0>)
  tprio_t prio, p1;

  /* [5.4.1] Simulating a priority boost situation (prio > realprio).*/
  test_set_step(1);
 8005136:	4d33      	ldr	r5, [pc, #204]	; (8005204 <rt_test_005_004_execute+0xd4>)
 8005138:	68f3      	ldr	r3, [r6, #12]
  {
    prio = chThdGetPriorityX();
    chThdGetSelfX()->hdr.pqueue.prio += 2;
    test_assert(chThdGetPriorityX() == prio + 2, "unexpected priority level");
 800513a:	4933      	ldr	r1, [pc, #204]	; (8005208 <rt_test_005_004_execute+0xd8>)
  return chThdGetSelfX()->hdr.pqueue.prio;
 800513c:	689c      	ldr	r4, [r3, #8]
    chThdGetSelfX()->hdr.pqueue.prio += 2;
 800513e:	1ca7      	adds	r7, r4, #2
  test_set_step(1);
 8005140:	2001      	movs	r0, #1
    chThdGetSelfX()->hdr.pqueue.prio += 2;
 8005142:	609f      	str	r7, [r3, #8]
  test_set_step(1);
 8005144:	6028      	str	r0, [r5, #0]
    test_assert(chThdGetPriorityX() == prio + 2, "unexpected priority level");
 8005146:	f7ff f8eb 	bl	8004320 <__test_assert>
 800514a:	b108      	cbz	r0, 8005150 <rt_test_005_004_execute+0x20>
    chThdGetSelfX()->hdr.pqueue.prio = prio;
    chThdGetSelfX()->realprio = prio;
    chSysUnlock();
  }
  test_end_step(4);
}
 800514c:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    p1 = chThdSetPriority(prio + 1);
 8005150:	f104 0801 	add.w	r8, r4, #1
  test_set_step(2);
 8005154:	2302      	movs	r3, #2
    p1 = chThdSetPriority(prio + 1);
 8005156:	4640      	mov	r0, r8
  test_set_step(2);
 8005158:	602b      	str	r3, [r5, #0]
    p1 = chThdSetPriority(prio + 1);
 800515a:	f7fc ff01 	bl	8001f60 <chThdSetPriority>
    test_assert(p1 == prio, "unexpected returned priority level");
 800515e:	1b00      	subs	r0, r0, r4
 8005160:	fab0 f080 	clz	r0, r0
 8005164:	4929      	ldr	r1, [pc, #164]	; (800520c <rt_test_005_004_execute+0xdc>)
 8005166:	0940      	lsrs	r0, r0, #5
 8005168:	f7ff f8da 	bl	8004320 <__test_assert>
 800516c:	2800      	cmp	r0, #0
 800516e:	d1ed      	bne.n	800514c <rt_test_005_004_execute+0x1c>
    test_assert(chThdGetSelfX()->hdr.pqueue.prio == prio + 2, "unexpected priority level");
 8005170:	68f3      	ldr	r3, [r6, #12]
 8005172:	4925      	ldr	r1, [pc, #148]	; (8005208 <rt_test_005_004_execute+0xd8>)
 8005174:	6898      	ldr	r0, [r3, #8]
 8005176:	1bc0      	subs	r0, r0, r7
 8005178:	fab0 f080 	clz	r0, r0
 800517c:	0940      	lsrs	r0, r0, #5
 800517e:	f7ff f8cf 	bl	8004320 <__test_assert>
 8005182:	2800      	cmp	r0, #0
 8005184:	d1e2      	bne.n	800514c <rt_test_005_004_execute+0x1c>
    test_assert(chThdGetSelfX()->realprio == prio + 1, "unexpected returned real priority level");
 8005186:	68f3      	ldr	r3, [r6, #12]
 8005188:	4921      	ldr	r1, [pc, #132]	; (8005210 <rt_test_005_004_execute+0xe0>)
 800518a:	6c18      	ldr	r0, [r3, #64]	; 0x40
 800518c:	eba0 0008 	sub.w	r0, r0, r8
 8005190:	fab0 f080 	clz	r0, r0
 8005194:	0940      	lsrs	r0, r0, #5
 8005196:	f7ff f8c3 	bl	8004320 <__test_assert>
 800519a:	2800      	cmp	r0, #0
 800519c:	d1d6      	bne.n	800514c <rt_test_005_004_execute+0x1c>
  test_set_step(3);
 800519e:	2303      	movs	r3, #3
    p1 = chThdSetPriority(prio + 3);
 80051a0:	18e7      	adds	r7, r4, r3
 80051a2:	4638      	mov	r0, r7
  test_set_step(3);
 80051a4:	602b      	str	r3, [r5, #0]
    p1 = chThdSetPriority(prio + 3);
 80051a6:	f7fc fedb 	bl	8001f60 <chThdSetPriority>
    test_assert(p1 == prio + 1, "unexpected returned priority level");
 80051aa:	eba8 0000 	sub.w	r0, r8, r0
 80051ae:	fab0 f080 	clz	r0, r0
 80051b2:	4916      	ldr	r1, [pc, #88]	; (800520c <rt_test_005_004_execute+0xdc>)
 80051b4:	0940      	lsrs	r0, r0, #5
 80051b6:	f7ff f8b3 	bl	8004320 <__test_assert>
 80051ba:	2800      	cmp	r0, #0
 80051bc:	d1c6      	bne.n	800514c <rt_test_005_004_execute+0x1c>
    test_assert(chThdGetSelfX()->hdr.pqueue.prio == prio + 3, "unexpected priority level");
 80051be:	68f3      	ldr	r3, [r6, #12]
 80051c0:	4911      	ldr	r1, [pc, #68]	; (8005208 <rt_test_005_004_execute+0xd8>)
 80051c2:	6898      	ldr	r0, [r3, #8]
 80051c4:	1bc0      	subs	r0, r0, r7
 80051c6:	fab0 f080 	clz	r0, r0
 80051ca:	0940      	lsrs	r0, r0, #5
 80051cc:	f7ff f8a8 	bl	8004320 <__test_assert>
 80051d0:	2800      	cmp	r0, #0
 80051d2:	d1bb      	bne.n	800514c <rt_test_005_004_execute+0x1c>
    test_assert(chThdGetSelfX()->realprio == prio + 3, "unexpected real priority level");
 80051d4:	68f3      	ldr	r3, [r6, #12]
 80051d6:	490f      	ldr	r1, [pc, #60]	; (8005214 <rt_test_005_004_execute+0xe4>)
 80051d8:	6c18      	ldr	r0, [r3, #64]	; 0x40
 80051da:	1bc0      	subs	r0, r0, r7
 80051dc:	fab0 f080 	clz	r0, r0
 80051e0:	0940      	lsrs	r0, r0, #5
 80051e2:	f7ff f89d 	bl	8004320 <__test_assert>
 80051e6:	2800      	cmp	r0, #0
 80051e8:	d1b0      	bne.n	800514c <rt_test_005_004_execute+0x1c>
  test_set_step(4);
 80051ea:	2304      	movs	r3, #4
 80051ec:	602b      	str	r3, [r5, #0]
 80051ee:	2330      	movs	r3, #48	; 0x30
 80051f0:	f383 8811 	msr	BASEPRI, r3
  return __sch_get_currthread();
 80051f4:	68f3      	ldr	r3, [r6, #12]
    chThdGetSelfX()->hdr.pqueue.prio = prio;
 80051f6:	609c      	str	r4, [r3, #8]
    chThdGetSelfX()->realprio = prio;
 80051f8:	641c      	str	r4, [r3, #64]	; 0x40
 80051fa:	f380 8811 	msr	BASEPRI, r0
}
 80051fe:	e7a5      	b.n	800514c <rt_test_005_004_execute+0x1c>
 8005200:	20000a40 	.word	0x20000a40
 8005204:	20000c70 	.word	0x20000c70
 8005208:	0800b5cc 	.word	0x0800b5cc
 800520c:	0800b5e8 	.word	0x0800b5e8
 8005210:	0800b60c 	.word	0x0800b60c
 8005214:	0800b634 	.word	0x0800b634
	...

08005220 <rt_test_005_003_execute>:
static void rt_test_005_003_execute(void) {
 8005220:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8005224:	4f1d      	ldr	r7, [pc, #116]	; (800529c <rt_test_005_003_execute+0x7c>)
  test_set_step(1);
 8005226:	f8df 8078 	ldr.w	r8, [pc, #120]	; 80052a0 <rt_test_005_003_execute+0x80>
  return chThdGetSelfX()->hdr.pqueue.prio;
 800522a:	68fa      	ldr	r2, [r7, #12]
 800522c:	6896      	ldr	r6, [r2, #8]
 800522e:	2301      	movs	r3, #1
    p1 = chThdSetPriority(prio + 1);
 8005230:	18f5      	adds	r5, r6, r3
 8005232:	4628      	mov	r0, r5
  test_set_step(1);
 8005234:	f8c8 3000 	str.w	r3, [r8]
    p1 = chThdSetPriority(prio + 1);
 8005238:	f7fc fe92 	bl	8001f60 <chThdSetPriority>
 800523c:	4604      	mov	r4, r0
    test_assert(p1 == prio, "unexpected returned priority level");
 800523e:	1b80      	subs	r0, r0, r6
 8005240:	fab0 f080 	clz	r0, r0
 8005244:	4917      	ldr	r1, [pc, #92]	; (80052a4 <rt_test_005_003_execute+0x84>)
 8005246:	0940      	lsrs	r0, r0, #5
 8005248:	f7ff f86a 	bl	8004320 <__test_assert>
 800524c:	b108      	cbz	r0, 8005252 <rt_test_005_003_execute+0x32>
}
 800524e:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 8005252:	68fb      	ldr	r3, [r7, #12]
    test_assert(chThdGetPriorityX() == prio + 1, "unexpected priority level");
 8005254:	4914      	ldr	r1, [pc, #80]	; (80052a8 <rt_test_005_003_execute+0x88>)
 8005256:	6898      	ldr	r0, [r3, #8]
 8005258:	1b40      	subs	r0, r0, r5
 800525a:	fab0 f080 	clz	r0, r0
 800525e:	0940      	lsrs	r0, r0, #5
 8005260:	f7ff f85e 	bl	8004320 <__test_assert>
 8005264:	2800      	cmp	r0, #0
 8005266:	d1f2      	bne.n	800524e <rt_test_005_003_execute+0x2e>
  test_set_step(2);
 8005268:	2302      	movs	r3, #2
    p1 = chThdSetPriority(p1);
 800526a:	4620      	mov	r0, r4
  test_set_step(2);
 800526c:	f8c8 3000 	str.w	r3, [r8]
    p1 = chThdSetPriority(p1);
 8005270:	f7fc fe76 	bl	8001f60 <chThdSetPriority>
    test_assert(p1 == prio + 1, "unexpected returned priority level");
 8005274:	1a28      	subs	r0, r5, r0
 8005276:	fab0 f080 	clz	r0, r0
 800527a:	490a      	ldr	r1, [pc, #40]	; (80052a4 <rt_test_005_003_execute+0x84>)
 800527c:	0940      	lsrs	r0, r0, #5
 800527e:	f7ff f84f 	bl	8004320 <__test_assert>
 8005282:	2800      	cmp	r0, #0
 8005284:	d1e3      	bne.n	800524e <rt_test_005_003_execute+0x2e>
 8005286:	68fb      	ldr	r3, [r7, #12]
    test_assert(chThdGetPriorityX() == prio, "unexpected priority level");
 8005288:	4907      	ldr	r1, [pc, #28]	; (80052a8 <rt_test_005_003_execute+0x88>)
 800528a:	6898      	ldr	r0, [r3, #8]
 800528c:	1b80      	subs	r0, r0, r6
 800528e:	fab0 f080 	clz	r0, r0
}
 8005292:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
    test_assert(chThdGetPriorityX() == prio, "unexpected priority level");
 8005296:	0940      	lsrs	r0, r0, #5
 8005298:	f7ff b842 	b.w	8004320 <__test_assert>
 800529c:	20000a40 	.word	0x20000a40
 80052a0:	20000c70 	.word	0x20000c70
 80052a4:	0800b5e8 	.word	0x0800b5e8
 80052a8:	0800b5cc 	.word	0x0800b5cc
 80052ac:	00000000 	.word	0x00000000

080052b0 <rt_test_005_002_execute>:
static void rt_test_005_002_execute(void) {
 80052b0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  return __sch_get_currthread();
 80052b4:	4d78      	ldr	r5, [pc, #480]	; (8005498 <rt_test_005_002_execute+0x1e8>)
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()-5, thread, "E");
 80052b6:	4f79      	ldr	r7, [pc, #484]	; (800549c <rt_test_005_002_execute+0x1ec>)
  return chThdGetSelfX()->hdr.pqueue.prio;
 80052b8:	68eb      	ldr	r3, [r5, #12]
 80052ba:	683c      	ldr	r4, [r7, #0]
 80052bc:	689a      	ldr	r2, [r3, #8]
  test_set_step(1);
 80052be:	f8df a1e0 	ldr.w	sl, [pc, #480]	; 80054a0 <rt_test_005_002_execute+0x1f0>
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()-5, thread, "E");
 80052c2:	f8df 91e0 	ldr.w	r9, [pc, #480]	; 80054a4 <rt_test_005_002_execute+0x1f4>
 80052c6:	4b78      	ldr	r3, [pc, #480]	; (80054a8 <rt_test_005_002_execute+0x1f8>)
    threads[1] = chThdCreateStatic(wa[1], WA_SIZE, chThdGetPriorityX()-4, thread, "D");
 80052c8:	f8df b1e0 	ldr.w	fp, [pc, #480]	; 80054ac <rt_test_005_002_execute+0x1fc>
    threads[2] = chThdCreateStatic(wa[2], WA_SIZE, chThdGetPriorityX()-3, thread, "C");
 80052cc:	f8df 81e0 	ldr.w	r8, [pc, #480]	; 80054b0 <rt_test_005_002_execute+0x200>
static void rt_test_005_002_execute(void) {
 80052d0:	b089      	sub	sp, #36	; 0x24
  test_set_step(1);
 80052d2:	2001      	movs	r0, #1
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()-5, thread, "E");
 80052d4:	3a05      	subs	r2, #5
 80052d6:	f44f 71b8 	mov.w	r1, #368	; 0x170
  test_set_step(1);
 80052da:	f8ca 0000 	str.w	r0, [sl]
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()-5, thread, "E");
 80052de:	f8cd 9000 	str.w	r9, [sp]
 80052e2:	4620      	mov	r0, r4
 80052e4:	9403      	str	r4, [sp, #12]
 80052e6:	f7fc fd63 	bl	8001db0 <chThdCreateStatic>
 80052ea:	68eb      	ldr	r3, [r5, #12]
    threads[1] = chThdCreateStatic(wa[1], WA_SIZE, chThdGetPriorityX()-4, thread, "D");
 80052ec:	687e      	ldr	r6, [r7, #4]
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()-5, thread, "E");
 80052ee:	4c71      	ldr	r4, [pc, #452]	; (80054b4 <rt_test_005_002_execute+0x204>)
    threads[1] = chThdCreateStatic(wa[1], WA_SIZE, chThdGetPriorityX()-4, thread, "D");
 80052f0:	689a      	ldr	r2, [r3, #8]
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()-5, thread, "E");
 80052f2:	6020      	str	r0, [r4, #0]
    threads[1] = chThdCreateStatic(wa[1], WA_SIZE, chThdGetPriorityX()-4, thread, "D");
 80052f4:	4b6c      	ldr	r3, [pc, #432]	; (80054a8 <rt_test_005_002_execute+0x1f8>)
 80052f6:	f8cd b000 	str.w	fp, [sp]
 80052fa:	3a04      	subs	r2, #4
 80052fc:	f44f 71b8 	mov.w	r1, #368	; 0x170
 8005300:	4630      	mov	r0, r6
 8005302:	9604      	str	r6, [sp, #16]
 8005304:	f7fc fd54 	bl	8001db0 <chThdCreateStatic>
 8005308:	68eb      	ldr	r3, [r5, #12]
 800530a:	6060      	str	r0, [r4, #4]
    threads[2] = chThdCreateStatic(wa[2], WA_SIZE, chThdGetPriorityX()-3, thread, "C");
 800530c:	689a      	ldr	r2, [r3, #8]
 800530e:	68bb      	ldr	r3, [r7, #8]
 8005310:	f8cd 8000 	str.w	r8, [sp]
 8005314:	469c      	mov	ip, r3
 8005316:	4660      	mov	r0, ip
 8005318:	4b63      	ldr	r3, [pc, #396]	; (80054a8 <rt_test_005_002_execute+0x1f8>)
 800531a:	f8cd c014 	str.w	ip, [sp, #20]
 800531e:	3a03      	subs	r2, #3
 8005320:	f44f 71b8 	mov.w	r1, #368	; 0x170
 8005324:	f7fc fd44 	bl	8001db0 <chThdCreateStatic>
 8005328:	68eb      	ldr	r3, [r5, #12]
    threads[3] = chThdCreateStatic(wa[3], WA_SIZE, chThdGetPriorityX()-2, thread, "B");
 800532a:	4e63      	ldr	r6, [pc, #396]	; (80054b8 <rt_test_005_002_execute+0x208>)
 800532c:	689a      	ldr	r2, [r3, #8]
 800532e:	68fb      	ldr	r3, [r7, #12]
    threads[2] = chThdCreateStatic(wa[2], WA_SIZE, chThdGetPriorityX()-3, thread, "C");
 8005330:	60a0      	str	r0, [r4, #8]
    threads[3] = chThdCreateStatic(wa[3], WA_SIZE, chThdGetPriorityX()-2, thread, "B");
 8005332:	469e      	mov	lr, r3
 8005334:	4670      	mov	r0, lr
 8005336:	4b5c      	ldr	r3, [pc, #368]	; (80054a8 <rt_test_005_002_execute+0x1f8>)
 8005338:	9600      	str	r6, [sp, #0]
 800533a:	3a02      	subs	r2, #2
 800533c:	f44f 71b8 	mov.w	r1, #368	; 0x170
 8005340:	f8cd e018 	str.w	lr, [sp, #24]
 8005344:	f7fc fd34 	bl	8001db0 <chThdCreateStatic>
    threads[4] = chThdCreateStatic(wa[4], WA_SIZE, chThdGetPriorityX()-1, thread, "A");
 8005348:	693b      	ldr	r3, [r7, #16]
 800534a:	4f5c      	ldr	r7, [pc, #368]	; (80054bc <rt_test_005_002_execute+0x20c>)
    threads[3] = chThdCreateStatic(wa[3], WA_SIZE, chThdGetPriorityX()-2, thread, "B");
 800534c:	60e0      	str	r0, [r4, #12]
    threads[4] = chThdCreateStatic(wa[4], WA_SIZE, chThdGetPriorityX()-1, thread, "A");
 800534e:	469c      	mov	ip, r3
 8005350:	68eb      	ldr	r3, [r5, #12]
 8005352:	f8cd c01c 	str.w	ip, [sp, #28]
 8005356:	689a      	ldr	r2, [r3, #8]
 8005358:	4b53      	ldr	r3, [pc, #332]	; (80054a8 <rt_test_005_002_execute+0x1f8>)
 800535a:	9700      	str	r7, [sp, #0]
 800535c:	f44f 71b8 	mov.w	r1, #368	; 0x170
 8005360:	3a01      	subs	r2, #1
 8005362:	4660      	mov	r0, ip
 8005364:	f7fc fd24 	bl	8001db0 <chThdCreateStatic>
 8005368:	6120      	str	r0, [r4, #16]
    test_wait_threads();
 800536a:	f7ff fa81 	bl	8004870 <test_wait_threads>
    test_assert_sequence("ABCDE", "invalid sequence");
 800536e:	4954      	ldr	r1, [pc, #336]	; (80054c0 <rt_test_005_002_execute+0x210>)
 8005370:	4854      	ldr	r0, [pc, #336]	; (80054c4 <rt_test_005_002_execute+0x214>)
 8005372:	f7fe ffe5 	bl	8004340 <__test_assert_sequence>
 8005376:	b110      	cbz	r0, 800537e <rt_test_005_002_execute+0xce>
}
 8005378:	b009      	add	sp, #36	; 0x24
 800537a:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 800537e:	68eb      	ldr	r3, [r5, #12]
    threads[4] = chThdCreateStatic(wa[4], WA_SIZE, chThdGetPriorityX()-1, thread, "A");
 8005380:	689a      	ldr	r2, [r3, #8]
 8005382:	4b49      	ldr	r3, [pc, #292]	; (80054a8 <rt_test_005_002_execute+0x1f8>)
 8005384:	9700      	str	r7, [sp, #0]
  test_set_step(2);
 8005386:	2002      	movs	r0, #2
    threads[4] = chThdCreateStatic(wa[4], WA_SIZE, chThdGetPriorityX()-1, thread, "A");
 8005388:	3a01      	subs	r2, #1
 800538a:	f44f 71b8 	mov.w	r1, #368	; 0x170
  test_set_step(2);
 800538e:	f8ca 0000 	str.w	r0, [sl]
    threads[4] = chThdCreateStatic(wa[4], WA_SIZE, chThdGetPriorityX()-1, thread, "A");
 8005392:	9807      	ldr	r0, [sp, #28]
 8005394:	f7fc fd0c 	bl	8001db0 <chThdCreateStatic>
 8005398:	68eb      	ldr	r3, [r5, #12]
 800539a:	6120      	str	r0, [r4, #16]
    threads[3] = chThdCreateStatic(wa[3], WA_SIZE, chThdGetPriorityX()-2, thread, "B");
 800539c:	689a      	ldr	r2, [r3, #8]
 800539e:	9806      	ldr	r0, [sp, #24]
 80053a0:	4b41      	ldr	r3, [pc, #260]	; (80054a8 <rt_test_005_002_execute+0x1f8>)
 80053a2:	9600      	str	r6, [sp, #0]
 80053a4:	3a02      	subs	r2, #2
 80053a6:	f44f 71b8 	mov.w	r1, #368	; 0x170
 80053aa:	f7fc fd01 	bl	8001db0 <chThdCreateStatic>
 80053ae:	68eb      	ldr	r3, [r5, #12]
 80053b0:	60e0      	str	r0, [r4, #12]
    threads[2] = chThdCreateStatic(wa[2], WA_SIZE, chThdGetPriorityX()-3, thread, "C");
 80053b2:	689a      	ldr	r2, [r3, #8]
 80053b4:	9805      	ldr	r0, [sp, #20]
 80053b6:	4b3c      	ldr	r3, [pc, #240]	; (80054a8 <rt_test_005_002_execute+0x1f8>)
 80053b8:	f8cd 8000 	str.w	r8, [sp]
 80053bc:	3a03      	subs	r2, #3
 80053be:	f44f 71b8 	mov.w	r1, #368	; 0x170
 80053c2:	f7fc fcf5 	bl	8001db0 <chThdCreateStatic>
 80053c6:	68eb      	ldr	r3, [r5, #12]
 80053c8:	60a0      	str	r0, [r4, #8]
    threads[1] = chThdCreateStatic(wa[1], WA_SIZE, chThdGetPriorityX()-4, thread, "D");
 80053ca:	689a      	ldr	r2, [r3, #8]
 80053cc:	9804      	ldr	r0, [sp, #16]
 80053ce:	4b36      	ldr	r3, [pc, #216]	; (80054a8 <rt_test_005_002_execute+0x1f8>)
 80053d0:	f8cd b000 	str.w	fp, [sp]
 80053d4:	3a04      	subs	r2, #4
 80053d6:	f44f 71b8 	mov.w	r1, #368	; 0x170
 80053da:	f7fc fce9 	bl	8001db0 <chThdCreateStatic>
 80053de:	68eb      	ldr	r3, [r5, #12]
 80053e0:	6060      	str	r0, [r4, #4]
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()-5, thread, "E");
 80053e2:	689a      	ldr	r2, [r3, #8]
 80053e4:	9803      	ldr	r0, [sp, #12]
 80053e6:	4b30      	ldr	r3, [pc, #192]	; (80054a8 <rt_test_005_002_execute+0x1f8>)
 80053e8:	f8cd 9000 	str.w	r9, [sp]
 80053ec:	f44f 71b8 	mov.w	r1, #368	; 0x170
 80053f0:	3a05      	subs	r2, #5
 80053f2:	f7fc fcdd 	bl	8001db0 <chThdCreateStatic>
 80053f6:	6020      	str	r0, [r4, #0]
    test_wait_threads();
 80053f8:	f7ff fa3a 	bl	8004870 <test_wait_threads>
    test_assert_sequence("ABCDE", "invalid sequence");
 80053fc:	4930      	ldr	r1, [pc, #192]	; (80054c0 <rt_test_005_002_execute+0x210>)
 80053fe:	4831      	ldr	r0, [pc, #196]	; (80054c4 <rt_test_005_002_execute+0x214>)
 8005400:	f7fe ff9e 	bl	8004340 <__test_assert_sequence>
 8005404:	2800      	cmp	r0, #0
 8005406:	d1b7      	bne.n	8005378 <rt_test_005_002_execute+0xc8>
 8005408:	68eb      	ldr	r3, [r5, #12]
    threads[1] = chThdCreateStatic(wa[1], WA_SIZE, chThdGetPriorityX()-4, thread, "D");
 800540a:	9804      	ldr	r0, [sp, #16]
 800540c:	689a      	ldr	r2, [r3, #8]
 800540e:	4b26      	ldr	r3, [pc, #152]	; (80054a8 <rt_test_005_002_execute+0x1f8>)
 8005410:	f8cd b000 	str.w	fp, [sp]
  test_set_step(3);
 8005414:	f04f 0c03 	mov.w	ip, #3
    threads[1] = chThdCreateStatic(wa[1], WA_SIZE, chThdGetPriorityX()-4, thread, "D");
 8005418:	3a04      	subs	r2, #4
 800541a:	f44f 71b8 	mov.w	r1, #368	; 0x170
  test_set_step(3);
 800541e:	f8ca c000 	str.w	ip, [sl]
    threads[1] = chThdCreateStatic(wa[1], WA_SIZE, chThdGetPriorityX()-4, thread, "D");
 8005422:	f7fc fcc5 	bl	8001db0 <chThdCreateStatic>
 8005426:	68eb      	ldr	r3, [r5, #12]
 8005428:	6060      	str	r0, [r4, #4]
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()-5, thread, "E");
 800542a:	689a      	ldr	r2, [r3, #8]
 800542c:	9803      	ldr	r0, [sp, #12]
 800542e:	4b1e      	ldr	r3, [pc, #120]	; (80054a8 <rt_test_005_002_execute+0x1f8>)
 8005430:	f8cd 9000 	str.w	r9, [sp]
 8005434:	3a05      	subs	r2, #5
 8005436:	f44f 71b8 	mov.w	r1, #368	; 0x170
 800543a:	f7fc fcb9 	bl	8001db0 <chThdCreateStatic>
 800543e:	68eb      	ldr	r3, [r5, #12]
 8005440:	6020      	str	r0, [r4, #0]
    threads[4] = chThdCreateStatic(wa[4], WA_SIZE, chThdGetPriorityX()-1, thread, "A");
 8005442:	689a      	ldr	r2, [r3, #8]
 8005444:	9807      	ldr	r0, [sp, #28]
 8005446:	4b18      	ldr	r3, [pc, #96]	; (80054a8 <rt_test_005_002_execute+0x1f8>)
 8005448:	9700      	str	r7, [sp, #0]
 800544a:	3a01      	subs	r2, #1
 800544c:	f44f 71b8 	mov.w	r1, #368	; 0x170
 8005450:	f7fc fcae 	bl	8001db0 <chThdCreateStatic>
 8005454:	68eb      	ldr	r3, [r5, #12]
 8005456:	6120      	str	r0, [r4, #16]
    threads[3] = chThdCreateStatic(wa[3], WA_SIZE, chThdGetPriorityX()-2, thread, "B");
 8005458:	689a      	ldr	r2, [r3, #8]
 800545a:	9806      	ldr	r0, [sp, #24]
 800545c:	4b12      	ldr	r3, [pc, #72]	; (80054a8 <rt_test_005_002_execute+0x1f8>)
 800545e:	9600      	str	r6, [sp, #0]
 8005460:	3a02      	subs	r2, #2
 8005462:	f44f 71b8 	mov.w	r1, #368	; 0x170
 8005466:	f7fc fca3 	bl	8001db0 <chThdCreateStatic>
 800546a:	68eb      	ldr	r3, [r5, #12]
    threads[2] = chThdCreateStatic(wa[2], WA_SIZE, chThdGetPriorityX()-3, thread, "C");
 800546c:	689a      	ldr	r2, [r3, #8]
 800546e:	4b0e      	ldr	r3, [pc, #56]	; (80054a8 <rt_test_005_002_execute+0x1f8>)
 8005470:	f8cd 8000 	str.w	r8, [sp]
    threads[3] = chThdCreateStatic(wa[3], WA_SIZE, chThdGetPriorityX()-2, thread, "B");
 8005474:	4601      	mov	r1, r0
    threads[2] = chThdCreateStatic(wa[2], WA_SIZE, chThdGetPriorityX()-3, thread, "C");
 8005476:	3a03      	subs	r2, #3
    threads[3] = chThdCreateStatic(wa[3], WA_SIZE, chThdGetPriorityX()-2, thread, "B");
 8005478:	60e1      	str	r1, [r4, #12]
    threads[2] = chThdCreateStatic(wa[2], WA_SIZE, chThdGetPriorityX()-3, thread, "C");
 800547a:	9805      	ldr	r0, [sp, #20]
 800547c:	f44f 71b8 	mov.w	r1, #368	; 0x170
 8005480:	f7fc fc96 	bl	8001db0 <chThdCreateStatic>
 8005484:	60a0      	str	r0, [r4, #8]
    test_wait_threads();
 8005486:	f7ff f9f3 	bl	8004870 <test_wait_threads>
    test_assert_sequence("ABCDE", "invalid sequence");
 800548a:	490d      	ldr	r1, [pc, #52]	; (80054c0 <rt_test_005_002_execute+0x210>)
 800548c:	480d      	ldr	r0, [pc, #52]	; (80054c4 <rt_test_005_002_execute+0x214>)
}
 800548e:	b009      	add	sp, #36	; 0x24
 8005490:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    test_assert_sequence("ABCDE", "invalid sequence");
 8005494:	f7fe bf54 	b.w	8004340 <__test_assert_sequence>
 8005498:	20000a40 	.word	0x20000a40
 800549c:	0800aab8 	.word	0x0800aab8
 80054a0:	20000c70 	.word	0x20000c70
 80054a4:	0800b67c 	.word	0x0800b67c
 80054a8:	080054d1 	.word	0x080054d1
 80054ac:	0800b654 	.word	0x0800b654
 80054b0:	0800b658 	.word	0x0800b658
 80054b4:	200013c8 	.word	0x200013c8
 80054b8:	0800b65c 	.word	0x0800b65c
 80054bc:	0800b660 	.word	0x0800b660
 80054c0:	0800b664 	.word	0x0800b664
 80054c4:	0800b678 	.word	0x0800b678
	...

080054d0 <thread>:
  test_emit_token(*(char *)p);
 80054d0:	7800      	ldrb	r0, [r0, #0]
 80054d2:	f7fe bf6d 	b.w	80043b0 <test_emit_token>
 80054d6:	bf00      	nop
	...

080054e0 <rt_test_005_001_execute>:
static void rt_test_005_001_execute(void) {
 80054e0:	b538      	push	{r3, r4, r5, lr}
  test_set_step(1);
 80054e2:	4d2d      	ldr	r5, [pc, #180]	; (8005598 <rt_test_005_001_execute+0xb8>)
 80054e4:	2301      	movs	r3, #1
 80054e6:	602b      	str	r3, [r5, #0]
 80054e8:	f7fa ffea 	bl	80004c0 <stGetCounter>
 80054ec:	4604      	mov	r4, r0
    chThdSleep(100);
 80054ee:	2064      	movs	r0, #100	; 0x64
 80054f0:	f7fc fd5e 	bl	8001fb0 <chThdSleep>
    test_assert_time_window(chTimeAddX(time, 100),
 80054f4:	4a29      	ldr	r2, [pc, #164]	; (800559c <rt_test_005_001_execute+0xbc>)
 80054f6:	f104 0167 	add.w	r1, r4, #103	; 0x67
 80054fa:	f104 0064 	add.w	r0, r4, #100	; 0x64
 80054fe:	f7fe ff3f 	bl	8004380 <__test_assert_time_window>
 8005502:	b100      	cbz	r0, 8005506 <rt_test_005_001_execute+0x26>
}
 8005504:	bd38      	pop	{r3, r4, r5, pc}
  test_set_step(2);
 8005506:	2302      	movs	r3, #2
 8005508:	602b      	str	r3, [r5, #0]
 800550a:	f7fa ffd9 	bl	80004c0 <stGetCounter>
 800550e:	4604      	mov	r4, r0
    chThdSleepMicroseconds(100000);
 8005510:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
 8005514:	f7fc fd4c 	bl	8001fb0 <chThdSleep>
    test_assert_time_window(chTimeAddX(time, TIME_US2I(100000)),
 8005518:	4a20      	ldr	r2, [pc, #128]	; (800559c <rt_test_005_001_execute+0xbc>)
 800551a:	f204 31eb 	addw	r1, r4, #1003	; 0x3eb
 800551e:	f504 707a 	add.w	r0, r4, #1000	; 0x3e8
 8005522:	f7fe ff2d 	bl	8004380 <__test_assert_time_window>
 8005526:	2800      	cmp	r0, #0
 8005528:	d1ec      	bne.n	8005504 <rt_test_005_001_execute+0x24>
  test_set_step(3);
 800552a:	2303      	movs	r3, #3
 800552c:	602b      	str	r3, [r5, #0]
 800552e:	f7fa ffc7 	bl	80004c0 <stGetCounter>
 8005532:	4604      	mov	r4, r0
    chThdSleepMilliseconds(100);
 8005534:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
 8005538:	f7fc fd3a 	bl	8001fb0 <chThdSleep>
    test_assert_time_window(chTimeAddX(time, TIME_MS2I(100)),
 800553c:	4a17      	ldr	r2, [pc, #92]	; (800559c <rt_test_005_001_execute+0xbc>)
 800553e:	f204 31eb 	addw	r1, r4, #1003	; 0x3eb
 8005542:	f504 707a 	add.w	r0, r4, #1000	; 0x3e8
 8005546:	f7fe ff1b 	bl	8004380 <__test_assert_time_window>
 800554a:	2800      	cmp	r0, #0
 800554c:	d1da      	bne.n	8005504 <rt_test_005_001_execute+0x24>
  test_set_step(4);
 800554e:	2304      	movs	r3, #4
 8005550:	602b      	str	r3, [r5, #0]
 8005552:	f7fa ffb5 	bl	80004c0 <stGetCounter>
 8005556:	4604      	mov	r4, r0
    chThdSleepSeconds(1);
 8005558:	f242 7010 	movw	r0, #10000	; 0x2710
 800555c:	f7fc fd28 	bl	8001fb0 <chThdSleep>
    test_assert_time_window(chTimeAddX(time, TIME_S2I(1)),
 8005560:	f504 511c 	add.w	r1, r4, #9984	; 0x2700
 8005564:	4608      	mov	r0, r1
 8005566:	4a0d      	ldr	r2, [pc, #52]	; (800559c <rt_test_005_001_execute+0xbc>)
 8005568:	3113      	adds	r1, #19
 800556a:	3010      	adds	r0, #16
 800556c:	f7fe ff08 	bl	8004380 <__test_assert_time_window>
 8005570:	2800      	cmp	r0, #0
 8005572:	d1c7      	bne.n	8005504 <rt_test_005_001_execute+0x24>
  test_set_step(5);
 8005574:	2305      	movs	r3, #5
 8005576:	602b      	str	r3, [r5, #0]
 8005578:	f7fa ffa2 	bl	80004c0 <stGetCounter>
  return systime + (systime_t)interval;
 800557c:	f100 0564 	add.w	r5, r0, #100	; 0x64
 8005580:	4604      	mov	r4, r0
    chThdSleepUntil(chTimeAddX(time, 100));
 8005582:	4628      	mov	r0, r5
 8005584:	f7fc fd24 	bl	8001fd0 <chThdSleepUntil>
    test_assert_time_window(chTimeAddX(time, 100),
 8005588:	f104 0167 	add.w	r1, r4, #103	; 0x67
 800558c:	4628      	mov	r0, r5
 800558e:	4a03      	ldr	r2, [pc, #12]	; (800559c <rt_test_005_001_execute+0xbc>)
}
 8005590:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
    test_assert_time_window(chTimeAddX(time, 100),
 8005594:	f7fe bef4 	b.w	8004380 <__test_assert_time_window>
 8005598:	20000c70 	.word	0x20000c70
 800559c:	0800b680 	.word	0x0800b680

080055a0 <rt_test_006_001_setup>:
 *   the state of the reference are tested.
 * .
 */

static void rt_test_006_001_setup(void) {
  tr1 = NULL;
 80055a0:	4b01      	ldr	r3, [pc, #4]	; (80055a8 <rt_test_006_001_setup+0x8>)
 80055a2:	2200      	movs	r2, #0
 80055a4:	601a      	str	r2, [r3, #0]
}
 80055a6:	4770      	bx	lr
 80055a8:	200013dc 	.word	0x200013dc
 80055ac:	00000000 	.word	0x00000000

080055b0 <thread1>:
static THD_FUNCTION(thread1, p) {
 80055b0:	b510      	push	{r4, lr}
 80055b2:	2330      	movs	r3, #48	; 0x30
 80055b4:	4604      	mov	r4, r0
 80055b6:	f383 8811 	msr	BASEPRI, r3
  chThdResumeI(&tr1, MSG_OK);
 80055ba:	4807      	ldr	r0, [pc, #28]	; (80055d8 <thread1+0x28>)
 80055bc:	2100      	movs	r1, #0
 80055be:	f7fc fd37 	bl	8002030 <chThdResumeI>
  chSchRescheduleS();
 80055c2:	f7fc faed 	bl	8001ba0 <chSchRescheduleS>
 80055c6:	2300      	movs	r3, #0
 80055c8:	f383 8811 	msr	BASEPRI, r3
  test_emit_token(*(char *)p);
 80055cc:	7820      	ldrb	r0, [r4, #0]
}
 80055ce:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  test_emit_token(*(char *)p);
 80055d2:	f7fe beed 	b.w	80043b0 <test_emit_token>
 80055d6:	bf00      	nop
 80055d8:	200013dc 	.word	0x200013dc
 80055dc:	00000000 	.word	0x00000000

080055e0 <rt_test_006_001_execute>:

static void rt_test_006_001_execute(void) {
 80055e0:	b5f0      	push	{r4, r5, r6, r7, lr}
  return __sch_get_currthread();
 80055e2:	4b31      	ldr	r3, [pc, #196]	; (80056a8 <rt_test_006_001_execute+0xc8>)
  /* [6.1.1] The function chThdSuspendTimeoutS() is invoked, the thread
     is remotely resumed with message @p MSG_OK. On return the message
     and the state of the reference are tested.*/
  test_set_step(1);
  {
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()-1, thread1, "A");
 80055e4:	4931      	ldr	r1, [pc, #196]	; (80056ac <rt_test_006_001_execute+0xcc>)
  return chThdGetSelfX()->hdr.pqueue.prio;
 80055e6:	68db      	ldr	r3, [r3, #12]
  test_set_step(1);
 80055e8:	4f31      	ldr	r7, [pc, #196]	; (80056b0 <rt_test_006_001_execute+0xd0>)
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()-1, thread1, "A");
 80055ea:	689a      	ldr	r2, [r3, #8]
 80055ec:	4c31      	ldr	r4, [pc, #196]	; (80056b4 <rt_test_006_001_execute+0xd4>)
 80055ee:	6808      	ldr	r0, [r1, #0]
 80055f0:	4b31      	ldr	r3, [pc, #196]	; (80056b8 <rt_test_006_001_execute+0xd8>)
static void rt_test_006_001_execute(void) {
 80055f2:	b083      	sub	sp, #12
  test_set_step(1);
 80055f4:	2101      	movs	r1, #1
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()-1, thread1, "A");
 80055f6:	9400      	str	r4, [sp, #0]
 80055f8:	3a01      	subs	r2, #1
  test_set_step(1);
 80055fa:	6039      	str	r1, [r7, #0]
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()-1, thread1, "A");
 80055fc:	f44f 71b8 	mov.w	r1, #368	; 0x170
 8005600:	f7fc fbd6 	bl	8001db0 <chThdCreateStatic>
 8005604:	4b2d      	ldr	r3, [pc, #180]	; (80056bc <rt_test_006_001_execute+0xdc>)
 8005606:	2630      	movs	r6, #48	; 0x30
 8005608:	6018      	str	r0, [r3, #0]
 800560a:	f386 8811 	msr	BASEPRI, r6
    chSysLock();
    msg = chThdSuspendTimeoutS(&tr1, TIME_INFINITE);
 800560e:	4d2c      	ldr	r5, [pc, #176]	; (80056c0 <rt_test_006_001_execute+0xe0>)
 8005610:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
 8005614:	4628      	mov	r0, r5
 8005616:	f7fc fcfb 	bl	8002010 <chThdSuspendTimeoutS>
 800561a:	2300      	movs	r3, #0
 800561c:	4604      	mov	r4, r0
 800561e:	f383 8811 	msr	BASEPRI, r3
    chSysUnlock();
    test_assert(NULL == tr1, "not NULL");
 8005622:	6828      	ldr	r0, [r5, #0]
 8005624:	4927      	ldr	r1, [pc, #156]	; (80056c4 <rt_test_006_001_execute+0xe4>)
 8005626:	fab0 f080 	clz	r0, r0
 800562a:	0940      	lsrs	r0, r0, #5
 800562c:	f7fe fe78 	bl	8004320 <__test_assert>
 8005630:	b108      	cbz	r0, 8005636 <rt_test_006_001_execute+0x56>
                            "out of time window");
    test_assert(NULL == tr1, "not NULL");
    test_assert(MSG_TIMEOUT == msg, "wrong returned message");
  }
  test_end_step(2);
}
 8005632:	b003      	add	sp, #12
 8005634:	bdf0      	pop	{r4, r5, r6, r7, pc}
    test_assert(MSG_OK == msg,"wrong returned message");
 8005636:	fab4 f084 	clz	r0, r4
 800563a:	4923      	ldr	r1, [pc, #140]	; (80056c8 <rt_test_006_001_execute+0xe8>)
 800563c:	0940      	lsrs	r0, r0, #5
 800563e:	f7fe fe6f 	bl	8004320 <__test_assert>
 8005642:	4604      	mov	r4, r0
 8005644:	2800      	cmp	r0, #0
 8005646:	d1f4      	bne.n	8005632 <rt_test_006_001_execute+0x52>
    test_wait_threads();
 8005648:	f7ff f912 	bl	8004870 <test_wait_threads>
  test_set_step(2);
 800564c:	2302      	movs	r3, #2
 800564e:	603b      	str	r3, [r7, #0]
 8005650:	f386 8811 	msr	BASEPRI, r6
 8005654:	f7fa ff34 	bl	80004c0 <stGetCounter>
    msg = chThdSuspendTimeoutS(&tr1, TIME_MS2I(1000));
 8005658:	f242 7110 	movw	r1, #10000	; 0x2710
 800565c:	4606      	mov	r6, r0
 800565e:	4628      	mov	r0, r5
 8005660:	f7fc fcd6 	bl	8002010 <chThdSuspendTimeoutS>
 8005664:	4607      	mov	r7, r0
 8005666:	f384 8811 	msr	BASEPRI, r4
    test_assert_time_window(chTimeAddX(time, TIME_MS2I(1000)),
 800566a:	f506 511c 	add.w	r1, r6, #9984	; 0x2700
 800566e:	4608      	mov	r0, r1
 8005670:	4a16      	ldr	r2, [pc, #88]	; (80056cc <rt_test_006_001_execute+0xec>)
 8005672:	3113      	adds	r1, #19
 8005674:	3010      	adds	r0, #16
 8005676:	f7fe fe83 	bl	8004380 <__test_assert_time_window>
 800567a:	2800      	cmp	r0, #0
 800567c:	d1d9      	bne.n	8005632 <rt_test_006_001_execute+0x52>
    test_assert(NULL == tr1, "not NULL");
 800567e:	6828      	ldr	r0, [r5, #0]
 8005680:	4910      	ldr	r1, [pc, #64]	; (80056c4 <rt_test_006_001_execute+0xe4>)
 8005682:	fab0 f080 	clz	r0, r0
 8005686:	0940      	lsrs	r0, r0, #5
 8005688:	f7fe fe4a 	bl	8004320 <__test_assert>
 800568c:	2800      	cmp	r0, #0
 800568e:	d1d0      	bne.n	8005632 <rt_test_006_001_execute+0x52>
    test_assert(MSG_TIMEOUT == msg, "wrong returned message");
 8005690:	f1a7 30ff 	sub.w	r0, r7, #4294967295	; 0xffffffff
 8005694:	490c      	ldr	r1, [pc, #48]	; (80056c8 <rt_test_006_001_execute+0xe8>)
 8005696:	fab0 f080 	clz	r0, r0
 800569a:	0940      	lsrs	r0, r0, #5
}
 800569c:	b003      	add	sp, #12
 800569e:	e8bd 40f0 	ldmia.w	sp!, {r4, r5, r6, r7, lr}
    test_assert(MSG_TIMEOUT == msg, "wrong returned message");
 80056a2:	f7fe be3d 	b.w	8004320 <__test_assert>
 80056a6:	bf00      	nop
 80056a8:	20000a40 	.word	0x20000a40
 80056ac:	0800aab8 	.word	0x0800aab8
 80056b0:	20000c70 	.word	0x20000c70
 80056b4:	0800b660 	.word	0x0800b660
 80056b8:	080055b1 	.word	0x080055b1
 80056bc:	200013c8 	.word	0x200013c8
 80056c0:	200013dc 	.word	0x200013dc
 80056c4:	0800b7a0 	.word	0x0800b7a0
 80056c8:	0800b7ac 	.word	0x0800b7ac
 80056cc:	0800b680 	.word	0x0800b680

080056d0 <rt_test_007_002_setup>:
 *   sequence is tested.
 * .
 */

static void rt_test_007_002_setup(void) {
  chSemObjectInit(&sem1, 0);
 80056d0:	4801      	ldr	r0, [pc, #4]	; (80056d8 <rt_test_007_002_setup+0x8>)
 80056d2:	2100      	movs	r1, #0
 80056d4:	f7fc bd44 	b.w	8002160 <chSemObjectInit>
 80056d8:	200013e0 	.word	0x200013e0
 80056dc:	00000000 	.word	0x00000000

080056e0 <rt_test_007_001_setup>:
  chSemObjectInit(&sem1, 1);
 80056e0:	4801      	ldr	r0, [pc, #4]	; (80056e8 <rt_test_007_001_setup+0x8>)
 80056e2:	2101      	movs	r1, #1
 80056e4:	f7fc bd3c 	b.w	8002160 <chSemObjectInit>
 80056e8:	200013e0 	.word	0x200013e0
 80056ec:	00000000 	.word	0x00000000

080056f0 <rt_test_007_001_teardown>:
  chSemResetWithMessage(sp, n, MSG_RESET);
 80056f0:	4802      	ldr	r0, [pc, #8]	; (80056fc <rt_test_007_001_teardown+0xc>)
 80056f2:	f06f 0201 	mvn.w	r2, #1
 80056f6:	2100      	movs	r1, #0
 80056f8:	f7fc bd3a 	b.w	8002170 <chSemResetWithMessage>
 80056fc:	200013e0 	.word	0x200013e0

08005700 <rt_test_007_005_teardown>:
static void rt_test_007_005_setup(void) {
  chSemObjectInit(&sem1, 0);
}

static void rt_test_007_005_teardown(void) {
  test_wait_threads();
 8005700:	f7ff b8b6 	b.w	8004870 <test_wait_threads>
	...

08005710 <rt_test_007_005_execute>:
}

static void rt_test_007_005_execute(void) {
 8005710:	b530      	push	{r4, r5, lr}
  return __sch_get_currthread();
 8005712:	4b24      	ldr	r3, [pc, #144]	; (80057a4 <rt_test_007_005_execute+0x94>)

  /* [7.5.1] An higher priority thread is created that performs
     non-atomical wait and signal operations on a semaphore.*/
  test_set_step(1);
  {
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()+1, thread3, 0);
 8005714:	4924      	ldr	r1, [pc, #144]	; (80057a8 <rt_test_007_005_execute+0x98>)
  return chThdGetSelfX()->hdr.pqueue.prio;
 8005716:	68db      	ldr	r3, [r3, #12]
  test_set_step(1);
 8005718:	4d24      	ldr	r5, [pc, #144]	; (80057ac <rt_test_007_005_execute+0x9c>)
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()+1, thread3, 0);
 800571a:	689a      	ldr	r2, [r3, #8]
 800571c:	6808      	ldr	r0, [r1, #0]
 800571e:	4b24      	ldr	r3, [pc, #144]	; (80057b0 <rt_test_007_005_execute+0xa0>)
static void rt_test_007_005_execute(void) {
 8005720:	b083      	sub	sp, #12
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()+1, thread3, 0);
 8005722:	2400      	movs	r4, #0
  test_set_step(1);
 8005724:	2101      	movs	r1, #1
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()+1, thread3, 0);
 8005726:	3201      	adds	r2, #1
 8005728:	9400      	str	r4, [sp, #0]
  test_set_step(1);
 800572a:	6029      	str	r1, [r5, #0]
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()+1, thread3, 0);
 800572c:	f44f 71b8 	mov.w	r1, #368	; 0x170
 8005730:	f7fc fb3e 	bl	8001db0 <chThdCreateStatic>
  /* [7.5.2] The function chSemSignalWait() is invoked by specifying
     the same semaphore for the wait and signal phases. The counter
     value must be one on exit.*/
  test_set_step(2);
  {
    chSemSignalWait(&sem1, &sem1);
 8005734:	4c1f      	ldr	r4, [pc, #124]	; (80057b4 <rt_test_007_005_execute+0xa4>)
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()+1, thread3, 0);
 8005736:	4b20      	ldr	r3, [pc, #128]	; (80057b8 <rt_test_007_005_execute+0xa8>)
    chSemSignalWait(&sem1, &sem1);
 8005738:	4621      	mov	r1, r4
  test_set_step(2);
 800573a:	2202      	movs	r2, #2
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()+1, thread3, 0);
 800573c:	6018      	str	r0, [r3, #0]
    chSemSignalWait(&sem1, &sem1);
 800573e:	4620      	mov	r0, r4
  test_set_step(2);
 8005740:	602a      	str	r2, [r5, #0]
    chSemSignalWait(&sem1, &sem1);
 8005742:	f7fc fe05 	bl	8002350 <chSemSignalWait>
  return (bool)(qp->next == qp);
 8005746:	6820      	ldr	r0, [r4, #0]
    test_assert(ch_queue_isempty(&sem1.queue), "queue not empty");
 8005748:	491c      	ldr	r1, [pc, #112]	; (80057bc <rt_test_007_005_execute+0xac>)
 800574a:	1b00      	subs	r0, r0, r4
 800574c:	fab0 f080 	clz	r0, r0
 8005750:	0940      	lsrs	r0, r0, #5
 8005752:	f7fe fde5 	bl	8004320 <__test_assert>
 8005756:	b108      	cbz	r0, 800575c <rt_test_007_005_execute+0x4c>
    chSemSignalWait(&sem1, &sem1);
    test_assert(ch_queue_isempty(&sem1.queue), "queue not empty");
    test_assert(sem1.cnt == 0, "counter not zero");
  }
  test_end_step(3);
}
 8005758:	b003      	add	sp, #12
 800575a:	bd30      	pop	{r4, r5, pc}
    test_assert(sem1.cnt == 0, "counter not zero");
 800575c:	68a0      	ldr	r0, [r4, #8]
 800575e:	4918      	ldr	r1, [pc, #96]	; (80057c0 <rt_test_007_005_execute+0xb0>)
 8005760:	fab0 f080 	clz	r0, r0
 8005764:	0940      	lsrs	r0, r0, #5
 8005766:	f7fe fddb 	bl	8004320 <__test_assert>
 800576a:	2800      	cmp	r0, #0
 800576c:	d1f4      	bne.n	8005758 <rt_test_007_005_execute+0x48>
    chSemSignalWait(&sem1, &sem1);
 800576e:	4621      	mov	r1, r4
  test_set_step(3);
 8005770:	2303      	movs	r3, #3
    chSemSignalWait(&sem1, &sem1);
 8005772:	4620      	mov	r0, r4
  test_set_step(3);
 8005774:	602b      	str	r3, [r5, #0]
    chSemSignalWait(&sem1, &sem1);
 8005776:	f7fc fdeb 	bl	8002350 <chSemSignalWait>
 800577a:	6820      	ldr	r0, [r4, #0]
    test_assert(ch_queue_isempty(&sem1.queue), "queue not empty");
 800577c:	490f      	ldr	r1, [pc, #60]	; (80057bc <rt_test_007_005_execute+0xac>)
 800577e:	1b00      	subs	r0, r0, r4
 8005780:	fab0 f080 	clz	r0, r0
 8005784:	0940      	lsrs	r0, r0, #5
 8005786:	f7fe fdcb 	bl	8004320 <__test_assert>
 800578a:	2800      	cmp	r0, #0
 800578c:	d1e4      	bne.n	8005758 <rt_test_007_005_execute+0x48>
    test_assert(sem1.cnt == 0, "counter not zero");
 800578e:	68a0      	ldr	r0, [r4, #8]
 8005790:	490b      	ldr	r1, [pc, #44]	; (80057c0 <rt_test_007_005_execute+0xb0>)
 8005792:	fab0 f080 	clz	r0, r0
 8005796:	0940      	lsrs	r0, r0, #5
}
 8005798:	b003      	add	sp, #12
 800579a:	e8bd 4030 	ldmia.w	sp!, {r4, r5, lr}
    test_assert(sem1.cnt == 0, "counter not zero");
 800579e:	f7fe bdbf 	b.w	8004320 <__test_assert>
 80057a2:	bf00      	nop
 80057a4:	20000a40 	.word	0x20000a40
 80057a8:	0800aab8 	.word	0x0800aab8
 80057ac:	20000c70 	.word	0x20000c70
 80057b0:	080057d1 	.word	0x080057d1
 80057b4:	200013e0 	.word	0x200013e0
 80057b8:	200013c8 	.word	0x200013c8
 80057bc:	0800b818 	.word	0x0800b818
 80057c0:	0800b828 	.word	0x0800b828
	...

080057d0 <thread3>:
static THD_FUNCTION(thread3, p) {
 80057d0:	b510      	push	{r4, lr}
  chSemWait(&sem1);
 80057d2:	4c04      	ldr	r4, [pc, #16]	; (80057e4 <thread3+0x14>)
 80057d4:	4620      	mov	r0, r4
 80057d6:	f7fc fceb 	bl	80021b0 <chSemWait>
  chSemSignal(&sem1);
 80057da:	4620      	mov	r0, r4
}
 80057dc:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  chSemSignal(&sem1);
 80057e0:	f7fc bd6e 	b.w	80022c0 <chSemSignal>
 80057e4:	200013e0 	.word	0x200013e0
	...

080057f0 <rt_test_007_001_execute>:
static void rt_test_007_001_execute(void) {
 80057f0:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
    msg = chSemWait(&sem1);
 80057f4:	4c2b      	ldr	r4, [pc, #172]	; (80058a4 <rt_test_007_001_execute+0xb4>)
  test_set_step(1);
 80057f6:	4f2c      	ldr	r7, [pc, #176]	; (80058a8 <rt_test_007_001_execute+0xb8>)
 80057f8:	2301      	movs	r3, #1
    msg = chSemWait(&sem1);
 80057fa:	4620      	mov	r0, r4
  test_set_step(1);
 80057fc:	603b      	str	r3, [r7, #0]
    msg = chSemWait(&sem1);
 80057fe:	f7fc fcd7 	bl	80021b0 <chSemWait>
 8005802:	2630      	movs	r6, #48	; 0x30
 8005804:	4605      	mov	r5, r0
 8005806:	f386 8811 	msr	BASEPRI, r6
    test_assert_lock(chSemGetCounterI(&sem1) == 0, "wrong counter value");
 800580a:	68a0      	ldr	r0, [r4, #8]
 800580c:	4927      	ldr	r1, [pc, #156]	; (80058ac <rt_test_007_001_execute+0xbc>)
 800580e:	fab0 f080 	clz	r0, r0
 8005812:	0940      	lsrs	r0, r0, #5
 8005814:	f7fe fd84 	bl	8004320 <__test_assert>
 8005818:	b120      	cbz	r0, 8005824 <rt_test_007_001_execute+0x34>
 800581a:	2300      	movs	r3, #0
 800581c:	f383 8811 	msr	BASEPRI, r3
}
 8005820:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
 8005824:	f380 8811 	msr	BASEPRI, r0
    test_assert(MSG_OK == msg, "wrong returned message");
 8005828:	fab5 f085 	clz	r0, r5
 800582c:	4920      	ldr	r1, [pc, #128]	; (80058b0 <rt_test_007_001_execute+0xc0>)
 800582e:	0940      	lsrs	r0, r0, #5
 8005830:	f7fe fd76 	bl	8004320 <__test_assert>
 8005834:	4605      	mov	r5, r0
 8005836:	2800      	cmp	r0, #0
 8005838:	d1f2      	bne.n	8005820 <rt_test_007_001_execute+0x30>
  test_set_step(2);
 800583a:	f04f 0902 	mov.w	r9, #2
    chSemSignal(&sem1);
 800583e:	4620      	mov	r0, r4
  test_set_step(2);
 8005840:	f8c7 9000 	str.w	r9, [r7]
    chSemSignal(&sem1);
 8005844:	f7fc fd3c 	bl	80022c0 <chSemSignal>
 8005848:	f386 8811 	msr	BASEPRI, r6
    test_assert_lock(chSemGetCounterI(&sem1) == 1, "wrong counter value");
 800584c:	68a0      	ldr	r0, [r4, #8]
 800584e:	4917      	ldr	r1, [pc, #92]	; (80058ac <rt_test_007_001_execute+0xbc>)
 8005850:	f1a0 0001 	sub.w	r0, r0, #1
 8005854:	fab0 f080 	clz	r0, r0
 8005858:	0940      	lsrs	r0, r0, #5
 800585a:	f7fe fd61 	bl	8004320 <__test_assert>
 800585e:	4680      	mov	r8, r0
 8005860:	b118      	cbz	r0, 800586a <rt_test_007_001_execute+0x7a>
 8005862:	f385 8811 	msr	BASEPRI, r5
}
 8005866:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
 800586a:	f380 8811 	msr	BASEPRI, r0
  test_set_step(3);
 800586e:	2303      	movs	r3, #3
 8005870:	4649      	mov	r1, r9
 8005872:	f06f 0201 	mvn.w	r2, #1
 8005876:	4620      	mov	r0, r4
 8005878:	603b      	str	r3, [r7, #0]
 800587a:	f7fc fc79 	bl	8002170 <chSemResetWithMessage>
 800587e:	f386 8811 	msr	BASEPRI, r6
    test_assert_lock(chSemGetCounterI(&sem1) == 2, "wrong counter value");
 8005882:	68a0      	ldr	r0, [r4, #8]
 8005884:	4909      	ldr	r1, [pc, #36]	; (80058ac <rt_test_007_001_execute+0xbc>)
 8005886:	f1a0 0002 	sub.w	r0, r0, #2
 800588a:	fab0 f080 	clz	r0, r0
 800588e:	0940      	lsrs	r0, r0, #5
 8005890:	f7fe fd46 	bl	8004320 <__test_assert>
 8005894:	b910      	cbnz	r0, 800589c <rt_test_007_001_execute+0xac>
 8005896:	f380 8811 	msr	BASEPRI, r0
}
 800589a:	e7c1      	b.n	8005820 <rt_test_007_001_execute+0x30>
 800589c:	f388 8811 	msr	BASEPRI, r8
 80058a0:	e7be      	b.n	8005820 <rt_test_007_001_execute+0x30>
 80058a2:	bf00      	nop
 80058a4:	200013e0 	.word	0x200013e0
 80058a8:	20000c70 	.word	0x20000c70
 80058ac:	0800b83c 	.word	0x0800b83c
 80058b0:	0800b7ac 	.word	0x0800b7ac
	...

080058c0 <rt_test_007_004_execute>:
static void rt_test_007_004_execute(void) {
 80058c0:	b5f0      	push	{r4, r5, r6, r7, lr}
  return __sch_get_currthread();
 80058c2:	4b1e      	ldr	r3, [pc, #120]	; (800593c <rt_test_007_004_execute+0x7c>)
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()+1, thread1, "A");
 80058c4:	491e      	ldr	r1, [pc, #120]	; (8005940 <rt_test_007_004_execute+0x80>)
  return chThdGetSelfX()->hdr.pqueue.prio;
 80058c6:	68db      	ldr	r3, [r3, #12]
  test_set_step(1);
 80058c8:	4c1e      	ldr	r4, [pc, #120]	; (8005944 <rt_test_007_004_execute+0x84>)
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()+1, thread1, "A");
 80058ca:	689a      	ldr	r2, [r3, #8]
 80058cc:	4f1e      	ldr	r7, [pc, #120]	; (8005948 <rt_test_007_004_execute+0x88>)
 80058ce:	6808      	ldr	r0, [r1, #0]
 80058d0:	4b1e      	ldr	r3, [pc, #120]	; (800594c <rt_test_007_004_execute+0x8c>)
static void rt_test_007_004_execute(void) {
 80058d2:	b083      	sub	sp, #12
  test_set_step(1);
 80058d4:	2101      	movs	r1, #1
 80058d6:	6021      	str	r1, [r4, #0]
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()+1, thread1, "A");
 80058d8:	440a      	add	r2, r1
 80058da:	9700      	str	r7, [sp, #0]
 80058dc:	f44f 71b8 	mov.w	r1, #368	; 0x170
 80058e0:	f7fc fa66 	bl	8001db0 <chThdCreateStatic>
 80058e4:	4b1a      	ldr	r3, [pc, #104]	; (8005950 <rt_test_007_004_execute+0x90>)
  test_set_step(2);
 80058e6:	2102      	movs	r1, #2
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()+1, thread1, "A");
 80058e8:	6018      	str	r0, [r3, #0]
  test_set_step(2);
 80058ea:	6021      	str	r1, [r4, #0]
 80058ec:	2530      	movs	r5, #48	; 0x30
 80058ee:	f385 8811 	msr	BASEPRI, r5
    chSemAddCounterI(&sem1, 2);
 80058f2:	4c18      	ldr	r4, [pc, #96]	; (8005954 <rt_test_007_004_execute+0x94>)
 80058f4:	4620      	mov	r0, r4
 80058f6:	f7fc fd13 	bl	8002320 <chSemAddCounterI>
 80058fa:	2600      	movs	r6, #0
    chSchRescheduleS();
 80058fc:	f7fc f950 	bl	8001ba0 <chSchRescheduleS>
 8005900:	f386 8811 	msr	BASEPRI, r6
    test_wait_threads();
 8005904:	f7fe ffb4 	bl	8004870 <test_wait_threads>
 8005908:	f385 8811 	msr	BASEPRI, r5
    test_assert_lock(chSemGetCounterI(&sem1) == 1, "invalid counter");
 800590c:	68a0      	ldr	r0, [r4, #8]
 800590e:	4912      	ldr	r1, [pc, #72]	; (8005958 <rt_test_007_004_execute+0x98>)
 8005910:	f1a0 0001 	sub.w	r0, r0, #1
 8005914:	fab0 f080 	clz	r0, r0
 8005918:	0940      	lsrs	r0, r0, #5
 800591a:	f7fe fd01 	bl	8004320 <__test_assert>
 800591e:	b118      	cbz	r0, 8005928 <rt_test_007_004_execute+0x68>
 8005920:	f386 8811 	msr	BASEPRI, r6
}
 8005924:	b003      	add	sp, #12
 8005926:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8005928:	f380 8811 	msr	BASEPRI, r0
    test_assert_sequence("A", "invalid sequence");
 800592c:	490b      	ldr	r1, [pc, #44]	; (800595c <rt_test_007_004_execute+0x9c>)
 800592e:	4638      	mov	r0, r7
}
 8005930:	b003      	add	sp, #12
 8005932:	e8bd 40f0 	ldmia.w	sp!, {r4, r5, r6, r7, lr}
    test_assert_sequence("A", "invalid sequence");
 8005936:	f7fe bd03 	b.w	8004340 <__test_assert_sequence>
 800593a:	bf00      	nop
 800593c:	20000a40 	.word	0x20000a40
 8005940:	0800aab8 	.word	0x0800aab8
 8005944:	20000c70 	.word	0x20000c70
 8005948:	0800b660 	.word	0x0800b660
 800594c:	08005a61 	.word	0x08005a61
 8005950:	200013c8 	.word	0x200013c8
 8005954:	200013e0 	.word	0x200013e0
 8005958:	0800b850 	.word	0x0800b850
 800595c:	0800b664 	.word	0x0800b664

08005960 <rt_test_007_002_execute>:
static void rt_test_007_002_execute(void) {
 8005960:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  return __sch_get_currthread();
 8005964:	4f30      	ldr	r7, [pc, #192]	; (8005a28 <rt_test_007_002_execute+0xc8>)
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()+5, thread1, "A");
 8005966:	4e31      	ldr	r6, [pc, #196]	; (8005a2c <rt_test_007_002_execute+0xcc>)
  return chThdGetSelfX()->hdr.pqueue.prio;
 8005968:	68fb      	ldr	r3, [r7, #12]
 800596a:	4c31      	ldr	r4, [pc, #196]	; (8005a30 <rt_test_007_002_execute+0xd0>)
 800596c:	689a      	ldr	r2, [r3, #8]
  test_set_step(1);
 800596e:	f8df 80c4 	ldr.w	r8, [pc, #196]	; 8005a34 <rt_test_007_002_execute+0xd4>
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()+5, thread1, "A");
 8005972:	4b31      	ldr	r3, [pc, #196]	; (8005a38 <rt_test_007_002_execute+0xd8>)
 8005974:	6820      	ldr	r0, [r4, #0]
static void rt_test_007_002_execute(void) {
 8005976:	b082      	sub	sp, #8
  test_set_step(1);
 8005978:	2501      	movs	r5, #1
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()+5, thread1, "A");
 800597a:	9300      	str	r3, [sp, #0]
 800597c:	3205      	adds	r2, #5
 800597e:	4633      	mov	r3, r6
 8005980:	f44f 71b8 	mov.w	r1, #368	; 0x170
  test_set_step(1);
 8005984:	f8c8 5000 	str.w	r5, [r8]
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()+5, thread1, "A");
 8005988:	f7fc fa12 	bl	8001db0 <chThdCreateStatic>
 800598c:	68fb      	ldr	r3, [r7, #12]
    threads[1] = chThdCreateStatic(wa[1], WA_SIZE, chThdGetPriorityX()+1, thread1, "B");
 800598e:	689a      	ldr	r2, [r3, #8]
 8005990:	4b2a      	ldr	r3, [pc, #168]	; (8005a3c <rt_test_007_002_execute+0xdc>)
 8005992:	442a      	add	r2, r5
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()+5, thread1, "A");
 8005994:	4d2a      	ldr	r5, [pc, #168]	; (8005a40 <rt_test_007_002_execute+0xe0>)
    threads[1] = chThdCreateStatic(wa[1], WA_SIZE, chThdGetPriorityX()+1, thread1, "B");
 8005996:	f44f 71b8 	mov.w	r1, #368	; 0x170
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()+5, thread1, "A");
 800599a:	6028      	str	r0, [r5, #0]
    threads[1] = chThdCreateStatic(wa[1], WA_SIZE, chThdGetPriorityX()+1, thread1, "B");
 800599c:	9300      	str	r3, [sp, #0]
 800599e:	6860      	ldr	r0, [r4, #4]
 80059a0:	4633      	mov	r3, r6
 80059a2:	f7fc fa05 	bl	8001db0 <chThdCreateStatic>
 80059a6:	68fb      	ldr	r3, [r7, #12]
 80059a8:	6068      	str	r0, [r5, #4]
    threads[2] = chThdCreateStatic(wa[2], WA_SIZE, chThdGetPriorityX()+3, thread1, "C");
 80059aa:	689a      	ldr	r2, [r3, #8]
 80059ac:	4b25      	ldr	r3, [pc, #148]	; (8005a44 <rt_test_007_002_execute+0xe4>)
 80059ae:	9300      	str	r3, [sp, #0]
 80059b0:	68a0      	ldr	r0, [r4, #8]
 80059b2:	4633      	mov	r3, r6
 80059b4:	3203      	adds	r2, #3
 80059b6:	f44f 71b8 	mov.w	r1, #368	; 0x170
 80059ba:	f7fc f9f9 	bl	8001db0 <chThdCreateStatic>
 80059be:	68fb      	ldr	r3, [r7, #12]
 80059c0:	60a8      	str	r0, [r5, #8]
    threads[3] = chThdCreateStatic(wa[3], WA_SIZE, chThdGetPriorityX()+4, thread1, "D");
 80059c2:	689a      	ldr	r2, [r3, #8]
 80059c4:	4b20      	ldr	r3, [pc, #128]	; (8005a48 <rt_test_007_002_execute+0xe8>)
 80059c6:	9300      	str	r3, [sp, #0]
 80059c8:	68e0      	ldr	r0, [r4, #12]
 80059ca:	4633      	mov	r3, r6
 80059cc:	3204      	adds	r2, #4
 80059ce:	f44f 71b8 	mov.w	r1, #368	; 0x170
 80059d2:	f7fc f9ed 	bl	8001db0 <chThdCreateStatic>
 80059d6:	68fa      	ldr	r2, [r7, #12]
    threads[4] = chThdCreateStatic(wa[4], WA_SIZE, chThdGetPriorityX()+2, thread1, "E");
 80059d8:	491c      	ldr	r1, [pc, #112]	; (8005a4c <rt_test_007_002_execute+0xec>)
 80059da:	6892      	ldr	r2, [r2, #8]
    threads[3] = chThdCreateStatic(wa[3], WA_SIZE, chThdGetPriorityX()+4, thread1, "D");
 80059dc:	60e8      	str	r0, [r5, #12]
    threads[4] = chThdCreateStatic(wa[4], WA_SIZE, chThdGetPriorityX()+2, thread1, "E");
 80059de:	3202      	adds	r2, #2
 80059e0:	4633      	mov	r3, r6
 80059e2:	9100      	str	r1, [sp, #0]
 80059e4:	6920      	ldr	r0, [r4, #16]
    chSemSignal(&sem1);
 80059e6:	4c1a      	ldr	r4, [pc, #104]	; (8005a50 <rt_test_007_002_execute+0xf0>)
    threads[4] = chThdCreateStatic(wa[4], WA_SIZE, chThdGetPriorityX()+2, thread1, "E");
 80059e8:	f44f 71b8 	mov.w	r1, #368	; 0x170
 80059ec:	f7fc f9e0 	bl	8001db0 <chThdCreateStatic>
  test_set_step(2);
 80059f0:	2302      	movs	r3, #2
    threads[4] = chThdCreateStatic(wa[4], WA_SIZE, chThdGetPriorityX()+2, thread1, "E");
 80059f2:	6128      	str	r0, [r5, #16]
    chSemSignal(&sem1);
 80059f4:	4620      	mov	r0, r4
  test_set_step(2);
 80059f6:	f8c8 3000 	str.w	r3, [r8]
    chSemSignal(&sem1);
 80059fa:	f7fc fc61 	bl	80022c0 <chSemSignal>
    chSemSignal(&sem1);
 80059fe:	4620      	mov	r0, r4
 8005a00:	f7fc fc5e 	bl	80022c0 <chSemSignal>
    chSemSignal(&sem1);
 8005a04:	4620      	mov	r0, r4
 8005a06:	f7fc fc5b 	bl	80022c0 <chSemSignal>
    chSemSignal(&sem1);
 8005a0a:	4620      	mov	r0, r4
 8005a0c:	f7fc fc58 	bl	80022c0 <chSemSignal>
    chSemSignal(&sem1);
 8005a10:	4620      	mov	r0, r4
 8005a12:	f7fc fc55 	bl	80022c0 <chSemSignal>
    test_wait_threads();
 8005a16:	f7fe ff2b 	bl	8004870 <test_wait_threads>
    test_assert_sequence("ABCDE", "invalid sequence");
 8005a1a:	490e      	ldr	r1, [pc, #56]	; (8005a54 <rt_test_007_002_execute+0xf4>)
 8005a1c:	480e      	ldr	r0, [pc, #56]	; (8005a58 <rt_test_007_002_execute+0xf8>)
}
 8005a1e:	b002      	add	sp, #8
 8005a20:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
    test_assert_sequence("ABCDE", "invalid sequence");
 8005a24:	f7fe bc8c 	b.w	8004340 <__test_assert_sequence>
 8005a28:	20000a40 	.word	0x20000a40
 8005a2c:	08005a61 	.word	0x08005a61
 8005a30:	0800aab8 	.word	0x0800aab8
 8005a34:	20000c70 	.word	0x20000c70
 8005a38:	0800b660 	.word	0x0800b660
 8005a3c:	0800b65c 	.word	0x0800b65c
 8005a40:	200013c8 	.word	0x200013c8
 8005a44:	0800b658 	.word	0x0800b658
 8005a48:	0800b654 	.word	0x0800b654
 8005a4c:	0800b67c 	.word	0x0800b67c
 8005a50:	200013e0 	.word	0x200013e0
 8005a54:	0800b664 	.word	0x0800b664
 8005a58:	0800b678 	.word	0x0800b678
 8005a5c:	00000000 	.word	0x00000000

08005a60 <thread1>:
static THD_FUNCTION(thread1, p) {
 8005a60:	b510      	push	{r4, lr}
 8005a62:	4604      	mov	r4, r0
  chSemWait(&sem1);
 8005a64:	4803      	ldr	r0, [pc, #12]	; (8005a74 <thread1+0x14>)
 8005a66:	f7fc fba3 	bl	80021b0 <chSemWait>
  test_emit_token(*(char *)p);
 8005a6a:	7820      	ldrb	r0, [r4, #0]
}
 8005a6c:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  test_emit_token(*(char *)p);
 8005a70:	f7fe bc9e 	b.w	80043b0 <test_emit_token>
 8005a74:	200013e0 	.word	0x200013e0
	...

08005a80 <thread2>:
static THD_FUNCTION(thread2, p) {
 8005a80:	b508      	push	{r3, lr}
  chThdSleepMilliseconds(50);
 8005a82:	f44f 70fa 	mov.w	r0, #500	; 0x1f4
 8005a86:	f7fc fa93 	bl	8001fb0 <chThdSleep>
 8005a8a:	2330      	movs	r3, #48	; 0x30
 8005a8c:	f383 8811 	msr	BASEPRI, r3
  chSemSignalI(&sem1); /* For coverage reasons */
 8005a90:	4804      	ldr	r0, [pc, #16]	; (8005aa4 <thread2+0x24>)
 8005a92:	f7fc fc35 	bl	8002300 <chSemSignalI>
  chSchRescheduleS();
 8005a96:	f7fc f883 	bl	8001ba0 <chSchRescheduleS>
 8005a9a:	2300      	movs	r3, #0
 8005a9c:	f383 8811 	msr	BASEPRI, r3
}
 8005aa0:	bd08      	pop	{r3, pc}
 8005aa2:	bf00      	nop
 8005aa4:	200013e0 	.word	0x200013e0
	...

08005ab0 <rt_test_007_003_execute>:
static void rt_test_007_003_execute(void) {
 8005ab0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    msg = chSemWaitTimeout(&sem1, TIME_IMMEDIATE);
 8005ab4:	4c4e      	ldr	r4, [pc, #312]	; (8005bf0 <rt_test_007_003_execute+0x140>)
  test_set_step(1);
 8005ab6:	4d4f      	ldr	r5, [pc, #316]	; (8005bf4 <rt_test_007_003_execute+0x144>)
static void rt_test_007_003_execute(void) {
 8005ab8:	b082      	sub	sp, #8
    msg = chSemWaitTimeout(&sem1, TIME_IMMEDIATE);
 8005aba:	2100      	movs	r1, #0
  test_set_step(1);
 8005abc:	2301      	movs	r3, #1
    msg = chSemWaitTimeout(&sem1, TIME_IMMEDIATE);
 8005abe:	4620      	mov	r0, r4
  test_set_step(1);
 8005ac0:	602b      	str	r3, [r5, #0]
    msg = chSemWaitTimeout(&sem1, TIME_IMMEDIATE);
 8005ac2:	f7fc fbb5 	bl	8002230 <chSemWaitTimeout>
    test_assert(msg == MSG_TIMEOUT, "wrong wake-up message");
 8005ac6:	f1a0 30ff 	sub.w	r0, r0, #4294967295	; 0xffffffff
 8005aca:	fab0 f080 	clz	r0, r0
 8005ace:	494a      	ldr	r1, [pc, #296]	; (8005bf8 <rt_test_007_003_execute+0x148>)
 8005ad0:	0940      	lsrs	r0, r0, #5
 8005ad2:	f7fe fc25 	bl	8004320 <__test_assert>
 8005ad6:	b110      	cbz	r0, 8005ade <rt_test_007_003_execute+0x2e>
}
 8005ad8:	b002      	add	sp, #8
 8005ada:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 8005ade:	6820      	ldr	r0, [r4, #0]
    test_assert(ch_queue_isempty(&sem1.queue), "queue not empty");
 8005ae0:	4946      	ldr	r1, [pc, #280]	; (8005bfc <rt_test_007_003_execute+0x14c>)
 8005ae2:	1b00      	subs	r0, r0, r4
 8005ae4:	fab0 f080 	clz	r0, r0
 8005ae8:	0940      	lsrs	r0, r0, #5
 8005aea:	f7fe fc19 	bl	8004320 <__test_assert>
 8005aee:	2800      	cmp	r0, #0
 8005af0:	d1f2      	bne.n	8005ad8 <rt_test_007_003_execute+0x28>
    test_assert(sem1.cnt == 0, "counter not zero");
 8005af2:	68a0      	ldr	r0, [r4, #8]
 8005af4:	4942      	ldr	r1, [pc, #264]	; (8005c00 <rt_test_007_003_execute+0x150>)
 8005af6:	fab0 f080 	clz	r0, r0
 8005afa:	0940      	lsrs	r0, r0, #5
 8005afc:	f7fe fc10 	bl	8004320 <__test_assert>
 8005b00:	4603      	mov	r3, r0
 8005b02:	2800      	cmp	r0, #0
 8005b04:	d1e8      	bne.n	8005ad8 <rt_test_007_003_execute+0x28>
  return __sch_get_currthread();
 8005b06:	4a3f      	ldr	r2, [pc, #252]	; (8005c04 <rt_test_007_003_execute+0x154>)
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX() - 1,
 8005b08:	493f      	ldr	r1, [pc, #252]	; (8005c08 <rt_test_007_003_execute+0x158>)
  return chThdGetSelfX()->hdr.pqueue.prio;
 8005b0a:	68d2      	ldr	r2, [r2, #12]
 8005b0c:	6808      	ldr	r0, [r1, #0]
 8005b0e:	6892      	ldr	r2, [r2, #8]
 8005b10:	9300      	str	r3, [sp, #0]
  test_set_step(2);
 8005b12:	2102      	movs	r1, #2
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX() - 1,
 8005b14:	3a01      	subs	r2, #1
 8005b16:	4b3d      	ldr	r3, [pc, #244]	; (8005c0c <rt_test_007_003_execute+0x15c>)
  test_set_step(2);
 8005b18:	6029      	str	r1, [r5, #0]
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX() - 1,
 8005b1a:	f44f 71b8 	mov.w	r1, #368	; 0x170
 8005b1e:	f7fc f947 	bl	8001db0 <chThdCreateStatic>
 8005b22:	4b3b      	ldr	r3, [pc, #236]	; (8005c10 <rt_test_007_003_execute+0x160>)
    msg = chSemWaitTimeout(&sem1, TIME_MS2I(500));
 8005b24:	f241 3188 	movw	r1, #5000	; 0x1388
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX() - 1,
 8005b28:	6018      	str	r0, [r3, #0]
    msg = chSemWaitTimeout(&sem1, TIME_MS2I(500));
 8005b2a:	4620      	mov	r0, r4
 8005b2c:	f7fc fb80 	bl	8002230 <chSemWaitTimeout>
 8005b30:	4606      	mov	r6, r0
    test_wait_threads();
 8005b32:	f7fe fe9d 	bl	8004870 <test_wait_threads>
    test_assert(msg == MSG_OK, "wrong wake-up message");
 8005b36:	fab6 f086 	clz	r0, r6
 8005b3a:	492f      	ldr	r1, [pc, #188]	; (8005bf8 <rt_test_007_003_execute+0x148>)
 8005b3c:	0940      	lsrs	r0, r0, #5
 8005b3e:	f7fe fbef 	bl	8004320 <__test_assert>
 8005b42:	2800      	cmp	r0, #0
 8005b44:	d1c8      	bne.n	8005ad8 <rt_test_007_003_execute+0x28>
 8005b46:	6820      	ldr	r0, [r4, #0]
    test_assert(ch_queue_isempty(&sem1.queue), "queue not empty");
 8005b48:	492c      	ldr	r1, [pc, #176]	; (8005bfc <rt_test_007_003_execute+0x14c>)
 8005b4a:	1b00      	subs	r0, r0, r4
 8005b4c:	fab0 f080 	clz	r0, r0
 8005b50:	0940      	lsrs	r0, r0, #5
 8005b52:	f7fe fbe5 	bl	8004320 <__test_assert>
 8005b56:	2800      	cmp	r0, #0
 8005b58:	d1be      	bne.n	8005ad8 <rt_test_007_003_execute+0x28>
    test_assert(sem1.cnt == 0, "counter not zero");
 8005b5a:	68a0      	ldr	r0, [r4, #8]
 8005b5c:	4928      	ldr	r1, [pc, #160]	; (8005c00 <rt_test_007_003_execute+0x150>)
 8005b5e:	fab0 f080 	clz	r0, r0
 8005b62:	0940      	lsrs	r0, r0, #5
 8005b64:	f7fe fbdc 	bl	8004320 <__test_assert>
 8005b68:	2800      	cmp	r0, #0
 8005b6a:	d1b5      	bne.n	8005ad8 <rt_test_007_003_execute+0x28>
  test_set_step(3);
 8005b6c:	2303      	movs	r3, #3
 8005b6e:	602b      	str	r3, [r5, #0]
    target_time = chTimeAddX(test_wait_tick(), TIME_MS2I(5 * 50));
 8005b70:	f7fe fe96 	bl	80048a0 <test_wait_tick>
      test_assert(msg == MSG_TIMEOUT, "wrong wake-up message");
 8005b74:	4f20      	ldr	r7, [pc, #128]	; (8005bf8 <rt_test_007_003_execute+0x148>)
      test_assert(ch_queue_isempty(&sem1.queue), "queue not empty");
 8005b76:	4e21      	ldr	r6, [pc, #132]	; (8005bfc <rt_test_007_003_execute+0x14c>)
    target_time = chTimeAddX(test_wait_tick(), TIME_MS2I(5 * 50));
 8005b78:	4680      	mov	r8, r0
 8005b7a:	2541      	movs	r5, #65	; 0x41
      test_emit_token('A' + i);
 8005b7c:	4628      	mov	r0, r5
 8005b7e:	f7fe fc17 	bl	80043b0 <test_emit_token>
      msg = chSemWaitTimeout(&sem1, TIME_MS2I(50));
 8005b82:	f44f 71fa 	mov.w	r1, #500	; 0x1f4
 8005b86:	4620      	mov	r0, r4
 8005b88:	f7fc fb52 	bl	8002230 <chSemWaitTimeout>
      test_assert(msg == MSG_TIMEOUT, "wrong wake-up message");
 8005b8c:	f1a0 30ff 	sub.w	r0, r0, #4294967295	; 0xffffffff
 8005b90:	fab0 f080 	clz	r0, r0
 8005b94:	4639      	mov	r1, r7
 8005b96:	0940      	lsrs	r0, r0, #5
 8005b98:	f7fe fbc2 	bl	8004320 <__test_assert>
      test_assert(ch_queue_isempty(&sem1.queue), "queue not empty");
 8005b9c:	4631      	mov	r1, r6
      test_assert(msg == MSG_TIMEOUT, "wrong wake-up message");
 8005b9e:	2800      	cmp	r0, #0
 8005ba0:	d19a      	bne.n	8005ad8 <rt_test_007_003_execute+0x28>
 8005ba2:	6820      	ldr	r0, [r4, #0]
      test_assert(ch_queue_isempty(&sem1.queue), "queue not empty");
 8005ba4:	1b00      	subs	r0, r0, r4
 8005ba6:	fab0 f080 	clz	r0, r0
 8005baa:	0940      	lsrs	r0, r0, #5
 8005bac:	f7fe fbb8 	bl	8004320 <__test_assert>
      test_assert(sem1.cnt == 0, "counter not zero");
 8005bb0:	4913      	ldr	r1, [pc, #76]	; (8005c00 <rt_test_007_003_execute+0x150>)
      test_assert(ch_queue_isempty(&sem1.queue), "queue not empty");
 8005bb2:	2800      	cmp	r0, #0
 8005bb4:	d190      	bne.n	8005ad8 <rt_test_007_003_execute+0x28>
      test_assert(sem1.cnt == 0, "counter not zero");
 8005bb6:	68a0      	ldr	r0, [r4, #8]
 8005bb8:	fab0 f080 	clz	r0, r0
 8005bbc:	0940      	lsrs	r0, r0, #5
 8005bbe:	f7fe fbaf 	bl	8004320 <__test_assert>
    for (i = 0; i < 5; i++) {
 8005bc2:	3501      	adds	r5, #1
 8005bc4:	b2ed      	uxtb	r5, r5
      test_assert(sem1.cnt == 0, "counter not zero");
 8005bc6:	2800      	cmp	r0, #0
 8005bc8:	d186      	bne.n	8005ad8 <rt_test_007_003_execute+0x28>
    for (i = 0; i < 5; i++) {
 8005bca:	2d46      	cmp	r5, #70	; 0x46
 8005bcc:	d1d6      	bne.n	8005b7c <rt_test_007_003_execute+0xcc>
    test_assert_sequence("ABCDE", "invalid sequence");
 8005bce:	4911      	ldr	r1, [pc, #68]	; (8005c14 <rt_test_007_003_execute+0x164>)
 8005bd0:	4811      	ldr	r0, [pc, #68]	; (8005c18 <rt_test_007_003_execute+0x168>)
 8005bd2:	f7fe fbb5 	bl	8004340 <__test_assert_sequence>
 8005bd6:	2800      	cmp	r0, #0
 8005bd8:	f47f af7e 	bne.w	8005ad8 <rt_test_007_003_execute+0x28>
    test_assert_time_window(target_time,
 8005bdc:	4a0f      	ldr	r2, [pc, #60]	; (8005c1c <rt_test_007_003_execute+0x16c>)
 8005bde:	f608 11d8 	addw	r1, r8, #2520	; 0x9d8
 8005be2:	f608 10c4 	addw	r0, r8, #2500	; 0x9c4
}
 8005be6:	b002      	add	sp, #8
 8005be8:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
    test_assert_time_window(target_time,
 8005bec:	f7fe bbc8 	b.w	8004380 <__test_assert_time_window>
 8005bf0:	200013e0 	.word	0x200013e0
 8005bf4:	20000c70 	.word	0x20000c70
 8005bf8:	0800b860 	.word	0x0800b860
 8005bfc:	0800b818 	.word	0x0800b818
 8005c00:	0800b828 	.word	0x0800b828
 8005c04:	20000a40 	.word	0x20000a40
 8005c08:	0800aab8 	.word	0x0800aab8
 8005c0c:	08005a81 	.word	0x08005a81
 8005c10:	200013c8 	.word	0x200013c8
 8005c14:	0800b664 	.word	0x0800b664
 8005c18:	0800b678 	.word	0x0800b678
 8005c1c:	0800b680 	.word	0x0800b680

08005c20 <rt_test_007_006_teardown>:
 8005c20:	f7fe be26 	b.w	8004870 <test_wait_threads>
	...

08005c30 <thread4>:
static THD_FUNCTION(thread4, p) {
 8005c30:	b508      	push	{r3, lr}
 8005c32:	2230      	movs	r2, #48	; 0x30
 8005c34:	f382 8811 	msr	BASEPRI, r2
 */
static inline void chBSemSignalI(binary_semaphore_t *bsp) {

  chDbgCheckClassI();

  if (bsp->sem.cnt < (cnt_t)1) {
 8005c38:	6883      	ldr	r3, [r0, #8]
 8005c3a:	2b00      	cmp	r3, #0
 8005c3c:	dd05      	ble.n	8005c4a <thread4+0x1a>
 */
static inline void chBSemSignal(binary_semaphore_t *bsp) {

  chSysLock();
  chBSemSignalI(bsp);
  chSchRescheduleS();
 8005c3e:	f7fb ffaf 	bl	8001ba0 <chSchRescheduleS>
 8005c42:	2300      	movs	r3, #0
 8005c44:	f383 8811 	msr	BASEPRI, r3
}
 8005c48:	bd08      	pop	{r3, pc}
    chSemSignalI(&bsp->sem);
 8005c4a:	f7fc fb59 	bl	8002300 <chSemSignalI>
  chSchRescheduleS();
 8005c4e:	f7fb ffa7 	bl	8001ba0 <chSchRescheduleS>
 8005c52:	2300      	movs	r3, #0
 8005c54:	f383 8811 	msr	BASEPRI, r3
 8005c58:	bd08      	pop	{r3, pc}
 8005c5a:	bf00      	nop
 8005c5c:	0000      	movs	r0, r0
	...

08005c60 <rt_test_007_003_setup>:
 8005c60:	4801      	ldr	r0, [pc, #4]	; (8005c68 <rt_test_007_003_setup+0x8>)
 8005c62:	2100      	movs	r1, #0
 8005c64:	f7fc ba7c 	b.w	8002160 <chSemObjectInit>
 8005c68:	200013e0 	.word	0x200013e0
 8005c6c:	00000000 	.word	0x00000000

08005c70 <rt_test_007_004_setup>:
 8005c70:	4801      	ldr	r0, [pc, #4]	; (8005c78 <rt_test_007_004_setup+0x8>)
 8005c72:	2100      	movs	r1, #0
 8005c74:	f7fc ba74 	b.w	8002160 <chSemObjectInit>
 8005c78:	200013e0 	.word	0x200013e0
 8005c7c:	00000000 	.word	0x00000000

08005c80 <rt_test_007_005_setup>:
 8005c80:	4801      	ldr	r0, [pc, #4]	; (8005c88 <rt_test_007_005_setup+0x8>)
 8005c82:	2100      	movs	r1, #0
 8005c84:	f7fc ba6c 	b.w	8002160 <chSemObjectInit>
 8005c88:	200013e0 	.word	0x200013e0
 8005c8c:	00000000 	.word	0x00000000

08005c90 <rt_test_007_006_execute>:

static void rt_test_007_006_teardown(void) {
  test_wait_threads();
}

static void rt_test_007_006_execute(void) {
 8005c90:	b5f0      	push	{r4, r5, r6, r7, lr}
  binary_semaphore_t bsem;
  msg_t msg;

  /* [7.6.1] Creating a binary semaphore in "taken" state, the state is
     checked.*/
  test_set_step(1);
 8005c92:	4d63      	ldr	r5, [pc, #396]	; (8005e20 <rt_test_007_006_execute+0x190>)
static void rt_test_007_006_execute(void) {
 8005c94:	b087      	sub	sp, #28
  test_set_step(1);
 8005c96:	2301      	movs	r3, #1
  chSemObjectInit(&bsp->sem, taken ? (cnt_t)0 : (cnt_t)1);
 8005c98:	2100      	movs	r1, #0
 8005c9a:	a803      	add	r0, sp, #12
 8005c9c:	602b      	str	r3, [r5, #0]
 8005c9e:	2630      	movs	r6, #48	; 0x30
 8005ca0:	f7fc fa5e 	bl	8002160 <chSemObjectInit>
 8005ca4:	f386 8811 	msr	BASEPRI, r6
 */
static inline bool chBSemGetStateI(const binary_semaphore_t *bsp) {

  chDbgCheckClassI();

  return (bsp->sem.cnt > (cnt_t)0) ? false : true;
 8005ca8:	9805      	ldr	r0, [sp, #20]
  {
    chBSemObjectInit(&bsem, true);
    test_assert_lock(chBSemGetStateI(&bsem) == true, "not taken");
 8005caa:	495e      	ldr	r1, [pc, #376]	; (8005e24 <rt_test_007_006_execute+0x194>)
 8005cac:	2800      	cmp	r0, #0
 8005cae:	bfcc      	ite	gt
 8005cb0:	2000      	movgt	r0, #0
 8005cb2:	2001      	movle	r0, #1
 8005cb4:	f7fe fb34 	bl	8004320 <__test_assert>
 8005cb8:	b120      	cbz	r0, 8005cc4 <rt_test_007_006_execute+0x34>
 8005cba:	2300      	movs	r3, #0
 8005cbc:	f383 8811 	msr	BASEPRI, r3
    chBSemSignal(&bsem);
    test_assert_lock(chBSemGetStateI(&bsem) == false, "taken");
    test_assert_lock(chSemGetCounterI(&bsem.sem) == 1, "unexpected counter");
  }
  test_end_step(6);
}
 8005cc0:	b007      	add	sp, #28
 8005cc2:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8005cc4:	4604      	mov	r4, r0
 8005cc6:	f380 8811 	msr	BASEPRI, r0
  test_set_step(2);
 8005cca:	2302      	movs	r3, #2
 8005ccc:	4601      	mov	r1, r0
 8005cce:	f06f 0201 	mvn.w	r2, #1
 8005cd2:	a803      	add	r0, sp, #12
 8005cd4:	602b      	str	r3, [r5, #0]
 8005cd6:	f7fc fa4b 	bl	8002170 <chSemResetWithMessage>
 8005cda:	f386 8811 	msr	BASEPRI, r6
 8005cde:	9805      	ldr	r0, [sp, #20]
    test_assert_lock(chBSemGetStateI(&bsem) == true, "not taken");
 8005ce0:	4950      	ldr	r1, [pc, #320]	; (8005e24 <rt_test_007_006_execute+0x194>)
 8005ce2:	2800      	cmp	r0, #0
 8005ce4:	bfcc      	ite	gt
 8005ce6:	2000      	movgt	r0, #0
 8005ce8:	2001      	movle	r0, #1
 8005cea:	f7fe fb19 	bl	8004320 <__test_assert>
 8005cee:	4607      	mov	r7, r0
 8005cf0:	bb38      	cbnz	r0, 8005d42 <rt_test_007_006_execute+0xb2>
 8005cf2:	f380 8811 	msr	BASEPRI, r0
  test_set_step(3);
 8005cf6:	2303      	movs	r3, #3
 8005cf8:	602b      	str	r3, [r5, #0]
  return __sch_get_currthread();
 8005cfa:	4b4b      	ldr	r3, [pc, #300]	; (8005e28 <rt_test_007_006_execute+0x198>)
  return chThdGetSelfX()->hdr.pqueue.prio;
 8005cfc:	68db      	ldr	r3, [r3, #12]
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE,
 8005cfe:	689a      	ldr	r2, [r3, #8]
 8005d00:	ab03      	add	r3, sp, #12
 8005d02:	9300      	str	r3, [sp, #0]
 8005d04:	4b49      	ldr	r3, [pc, #292]	; (8005e2c <rt_test_007_006_execute+0x19c>)
 8005d06:	3a01      	subs	r2, #1
 8005d08:	f44f 71b8 	mov.w	r1, #368	; 0x170
 8005d0c:	6818      	ldr	r0, [r3, #0]
 8005d0e:	4b48      	ldr	r3, [pc, #288]	; (8005e30 <rt_test_007_006_execute+0x1a0>)
 8005d10:	f7fc f84e 	bl	8001db0 <chThdCreateStatic>
 8005d14:	4b47      	ldr	r3, [pc, #284]	; (8005e34 <rt_test_007_006_execute+0x1a4>)
 8005d16:	6018      	str	r0, [r3, #0]
  test_set_step(4);
 8005d18:	2304      	movs	r3, #4
  return chSemWait(&bsp->sem);
 8005d1a:	a803      	add	r0, sp, #12
 8005d1c:	602b      	str	r3, [r5, #0]
 8005d1e:	f7fc fa47 	bl	80021b0 <chSemWait>
 8005d22:	4604      	mov	r4, r0
 8005d24:	f386 8811 	msr	BASEPRI, r6
  return (bsp->sem.cnt > (cnt_t)0) ? false : true;
 8005d28:	9805      	ldr	r0, [sp, #20]
    test_assert_lock(chBSemGetStateI(&bsem) == true, "not taken");
 8005d2a:	493e      	ldr	r1, [pc, #248]	; (8005e24 <rt_test_007_006_execute+0x194>)
 8005d2c:	2800      	cmp	r0, #0
 8005d2e:	bfcc      	ite	gt
 8005d30:	2000      	movgt	r0, #0
 8005d32:	2001      	movle	r0, #1
 8005d34:	f7fe faf4 	bl	8004320 <__test_assert>
 8005d38:	b138      	cbz	r0, 8005d4a <rt_test_007_006_execute+0xba>
 8005d3a:	f387 8811 	msr	BASEPRI, r7
}
 8005d3e:	b007      	add	sp, #28
 8005d40:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8005d42:	f384 8811 	msr	BASEPRI, r4
 8005d46:	b007      	add	sp, #28
 8005d48:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8005d4a:	f380 8811 	msr	BASEPRI, r0
    test_assert(msg == MSG_OK, "unexpected message");
 8005d4e:	fab4 f084 	clz	r0, r4
 8005d52:	4939      	ldr	r1, [pc, #228]	; (8005e38 <rt_test_007_006_execute+0x1a8>)
 8005d54:	0940      	lsrs	r0, r0, #5
 8005d56:	f7fe fae3 	bl	8004320 <__test_assert>
 8005d5a:	2800      	cmp	r0, #0
 8005d5c:	d1b0      	bne.n	8005cc0 <rt_test_007_006_execute+0x30>
  test_set_step(5);
 8005d5e:	2305      	movs	r3, #5
 8005d60:	602b      	str	r3, [r5, #0]
 8005d62:	f386 8811 	msr	BASEPRI, r6
  if (bsp->sem.cnt < (cnt_t)1) {
 8005d66:	9b05      	ldr	r3, [sp, #20]
 8005d68:	2b00      	cmp	r3, #0
 8005d6a:	dd3f      	ble.n	8005dec <rt_test_007_006_execute+0x15c>
  chSchRescheduleS();
 8005d6c:	f7fb ff18 	bl	8001ba0 <chSchRescheduleS>
 8005d70:	2700      	movs	r7, #0
 8005d72:	f387 8811 	msr	BASEPRI, r7
 8005d76:	2630      	movs	r6, #48	; 0x30
 8005d78:	f386 8811 	msr	BASEPRI, r6
    test_assert_lock(chBSemGetStateI(&bsem) ==false, "still taken");
 8005d7c:	9805      	ldr	r0, [sp, #20]
 8005d7e:	492f      	ldr	r1, [pc, #188]	; (8005e3c <rt_test_007_006_execute+0x1ac>)
 8005d80:	42b8      	cmp	r0, r7
 8005d82:	bfd4      	ite	le
 8005d84:	2000      	movle	r0, #0
 8005d86:	2001      	movgt	r0, #1
 8005d88:	f7fe faca 	bl	8004320 <__test_assert>
 8005d8c:	4604      	mov	r4, r0
 8005d8e:	2800      	cmp	r0, #0
 8005d90:	d1d3      	bne.n	8005d3a <rt_test_007_006_execute+0xaa>
 8005d92:	f380 8811 	msr	BASEPRI, r0
 8005d96:	f386 8811 	msr	BASEPRI, r6
    test_assert_lock(chSemGetCounterI(&bsem.sem) == 1, "unexpected counter");
 8005d9a:	9805      	ldr	r0, [sp, #20]
 8005d9c:	4928      	ldr	r1, [pc, #160]	; (8005e40 <rt_test_007_006_execute+0x1b0>)
 8005d9e:	f1a0 0001 	sub.w	r0, r0, #1
 8005da2:	fab0 f080 	clz	r0, r0
 8005da6:	0940      	lsrs	r0, r0, #5
 8005da8:	f7fe faba 	bl	8004320 <__test_assert>
 8005dac:	2800      	cmp	r0, #0
 8005dae:	d1c8      	bne.n	8005d42 <rt_test_007_006_execute+0xb2>
 8005db0:	f380 8811 	msr	BASEPRI, r0
  test_set_step(6);
 8005db4:	2306      	movs	r3, #6
 8005db6:	602b      	str	r3, [r5, #0]
 8005db8:	f386 8811 	msr	BASEPRI, r6
  if (bsp->sem.cnt < (cnt_t)1) {
 8005dbc:	9b05      	ldr	r3, [sp, #20]
 8005dbe:	2b00      	cmp	r3, #0
 8005dc0:	dd2a      	ble.n	8005e18 <rt_test_007_006_execute+0x188>
  chSchRescheduleS();
 8005dc2:	f7fb feed 	bl	8001ba0 <chSchRescheduleS>
 8005dc6:	2500      	movs	r5, #0
 8005dc8:	f385 8811 	msr	BASEPRI, r5
 8005dcc:	2630      	movs	r6, #48	; 0x30
 8005dce:	f386 8811 	msr	BASEPRI, r6
    test_assert_lock(chBSemGetStateI(&bsem) == false, "taken");
 8005dd2:	9805      	ldr	r0, [sp, #20]
 8005dd4:	491b      	ldr	r1, [pc, #108]	; (8005e44 <rt_test_007_006_execute+0x1b4>)
 8005dd6:	42a8      	cmp	r0, r5
 8005dd8:	bfd4      	ite	le
 8005dda:	2000      	movle	r0, #0
 8005ddc:	2001      	movgt	r0, #1
 8005dde:	f7fe fa9f 	bl	8004320 <__test_assert>
 8005de2:	4604      	mov	r4, r0
 8005de4:	b130      	cbz	r0, 8005df4 <rt_test_007_006_execute+0x164>
 8005de6:	f385 8811 	msr	BASEPRI, r5
 8005dea:	e769      	b.n	8005cc0 <rt_test_007_006_execute+0x30>
    chSemSignalI(&bsp->sem);
 8005dec:	a803      	add	r0, sp, #12
 8005dee:	f7fc fa87 	bl	8002300 <chSemSignalI>
 8005df2:	e7bb      	b.n	8005d6c <rt_test_007_006_execute+0xdc>
 8005df4:	f380 8811 	msr	BASEPRI, r0
 8005df8:	f386 8811 	msr	BASEPRI, r6
    test_assert_lock(chSemGetCounterI(&bsem.sem) == 1, "unexpected counter");
 8005dfc:	9805      	ldr	r0, [sp, #20]
 8005dfe:	4910      	ldr	r1, [pc, #64]	; (8005e40 <rt_test_007_006_execute+0x1b0>)
 8005e00:	f1a0 0001 	sub.w	r0, r0, #1
 8005e04:	fab0 f080 	clz	r0, r0
 8005e08:	0940      	lsrs	r0, r0, #5
 8005e0a:	f7fe fa89 	bl	8004320 <__test_assert>
 8005e0e:	2800      	cmp	r0, #0
 8005e10:	d197      	bne.n	8005d42 <rt_test_007_006_execute+0xb2>
 8005e12:	f380 8811 	msr	BASEPRI, r0
  test_end_step(6);
 8005e16:	e753      	b.n	8005cc0 <rt_test_007_006_execute+0x30>
 8005e18:	a803      	add	r0, sp, #12
 8005e1a:	f7fc fa71 	bl	8002300 <chSemSignalI>
 8005e1e:	e7d0      	b.n	8005dc2 <rt_test_007_006_execute+0x132>
 8005e20:	20000c70 	.word	0x20000c70
 8005e24:	0800b878 	.word	0x0800b878
 8005e28:	20000a40 	.word	0x20000a40
 8005e2c:	0800aab8 	.word	0x0800aab8
 8005e30:	08005c31 	.word	0x08005c31
 8005e34:	200013c8 	.word	0x200013c8
 8005e38:	0800b884 	.word	0x0800b884
 8005e3c:	0800b898 	.word	0x0800b898
 8005e40:	0800b8a4 	.word	0x0800b8a4
 8005e44:	0800b87c 	.word	0x0800b87c
	...

08005e50 <rt_test_008_004_teardown>:
  chMtxObjectInit(&m1);
  chMtxObjectInit(&m2);
}

static void rt_test_008_004_teardown(void) {
  test_wait_threads();
 8005e50:	f7fe bd0e 	b.w	8004870 <test_wait_threads>
	...

08005e60 <rt_test_008_009_execute>:
  chCondObjectInit(&c1);
  chMtxObjectInit(&m1);
  chMtxObjectInit(&m2);
}

static void rt_test_008_009_execute(void) {
 8005e60:	b5f0      	push	{r4, r5, r6, r7, lr}
  return __sch_get_currthread();
 8005e62:	4b21      	ldr	r3, [pc, #132]	; (8005ee8 <rt_test_008_009_execute+0x88>)
  }
  test_end_step(1);

  /* [8.9.2] Thread A is created at priority P(+1), it locks M2, locks
     M1 and goes to wait on C1.*/
  test_set_step(2);
 8005e64:	4c21      	ldr	r4, [pc, #132]	; (8005eec <rt_test_008_009_execute+0x8c>)
  return chThdGetSelfX()->hdr.pqueue.prio;
 8005e66:	68db      	ldr	r3, [r3, #12]
  {
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, prio+1, thread8, "A");
 8005e68:	4e21      	ldr	r6, [pc, #132]	; (8005ef0 <rt_test_008_009_execute+0x90>)
 8005e6a:	689f      	ldr	r7, [r3, #8]
 8005e6c:	4921      	ldr	r1, [pc, #132]	; (8005ef4 <rt_test_008_009_execute+0x94>)
 8005e6e:	4b22      	ldr	r3, [pc, #136]	; (8005ef8 <rt_test_008_009_execute+0x98>)
 8005e70:	6830      	ldr	r0, [r6, #0]
 8005e72:	4d22      	ldr	r5, [pc, #136]	; (8005efc <rt_test_008_009_execute+0x9c>)
static void rt_test_008_009_execute(void) {
 8005e74:	b083      	sub	sp, #12
  test_set_step(2);
 8005e76:	2202      	movs	r2, #2
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, prio+1, thread8, "A");
 8005e78:	9100      	str	r1, [sp, #0]
  test_set_step(2);
 8005e7a:	6022      	str	r2, [r4, #0]
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, prio+1, thread8, "A");
 8005e7c:	f44f 71b8 	mov.w	r1, #368	; 0x170
 8005e80:	1c7a      	adds	r2, r7, #1
 8005e82:	f7fb ff95 	bl	8001db0 <chThdCreateStatic>
  }
  test_end_step(2);

  /* [8.9.3] Thread C is created at priority P(+2), it enqueues on M1
     and boosts TA priority at P(+2).*/
  test_set_step(3);
 8005e86:	2303      	movs	r3, #3
 8005e88:	6023      	str	r3, [r4, #0]
  {
    threads[1] = chThdCreateStatic(wa[1], WA_SIZE, prio+2, thread6, "C");
 8005e8a:	4b1d      	ldr	r3, [pc, #116]	; (8005f00 <rt_test_008_009_execute+0xa0>)
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, prio+1, thread8, "A");
 8005e8c:	6028      	str	r0, [r5, #0]
    threads[1] = chThdCreateStatic(wa[1], WA_SIZE, prio+2, thread6, "C");
 8005e8e:	9300      	str	r3, [sp, #0]
 8005e90:	1cba      	adds	r2, r7, #2
 8005e92:	4b1c      	ldr	r3, [pc, #112]	; (8005f04 <rt_test_008_009_execute+0xa4>)
 8005e94:	6870      	ldr	r0, [r6, #4]
 8005e96:	f44f 71b8 	mov.w	r1, #368	; 0x170
 8005e9a:	f7fb ff89 	bl	8001db0 <chThdCreateStatic>
 8005e9e:	4603      	mov	r3, r0
 8005ea0:	606b      	str	r3, [r5, #4]
  }
  test_end_step(3);

  /* [8.9.4] Thread B is created at priority P(+3), it enqueues on M2
     and boosts TA priority at P(+3).*/
  test_set_step(4);
 8005ea2:	2304      	movs	r3, #4
 8005ea4:	6023      	str	r3, [r4, #0]
  {
    threads[2] = chThdCreateStatic(wa[2], WA_SIZE, prio+3, thread9, "B");
 8005ea6:	4b18      	ldr	r3, [pc, #96]	; (8005f08 <rt_test_008_009_execute+0xa8>)
 8005ea8:	9300      	str	r3, [sp, #0]
 8005eaa:	1cfa      	adds	r2, r7, #3
 8005eac:	f44f 71b8 	mov.w	r1, #368	; 0x170
 8005eb0:	68b0      	ldr	r0, [r6, #8]
 8005eb2:	4b16      	ldr	r3, [pc, #88]	; (8005f0c <rt_test_008_009_execute+0xac>)
  /* [8.9.5] Signaling C1: TA wakes up, unlocks M1 and priority goes to
     P(+2). TB locks M1, unlocks M1 and completes. TA unlocks M2 and
     priority goes to P(+1). TC waits on C1. TA completes.*/
  test_set_step(5);
  {
    chCondSignal(&c1);
 8005eb4:	4e16      	ldr	r6, [pc, #88]	; (8005f10 <rt_test_008_009_execute+0xb0>)
    threads[2] = chThdCreateStatic(wa[2], WA_SIZE, prio+3, thread9, "B");
 8005eb6:	f7fb ff7b 	bl	8001db0 <chThdCreateStatic>
  test_set_step(5);
 8005eba:	2305      	movs	r3, #5
    threads[2] = chThdCreateStatic(wa[2], WA_SIZE, prio+3, thread9, "B");
 8005ebc:	60a8      	str	r0, [r5, #8]
    chCondSignal(&c1);
 8005ebe:	4630      	mov	r0, r6
  test_set_step(5);
 8005ec0:	6023      	str	r3, [r4, #0]
    chCondSignal(&c1);
 8005ec2:	f7fc fbb5 	bl	8002630 <chCondSignal>
  test_end_step(5);

  /* [8.9.6] Signaling C1: TC wakes up, unlocks M1 and completes.*/
  test_set_step(6);
  {
    chCondSignal(&c1);
 8005ec6:	4630      	mov	r0, r6
  test_set_step(6);
 8005ec8:	2306      	movs	r3, #6
 8005eca:	6023      	str	r3, [r4, #0]
    chCondSignal(&c1);
 8005ecc:	f7fc fbb0 	bl	8002630 <chCondSignal>
  }
  test_end_step(6);

  /* [8.9.7] Checking the order of operations.*/
  test_set_step(7);
 8005ed0:	2307      	movs	r3, #7
 8005ed2:	6023      	str	r3, [r4, #0]
  {
    test_wait_threads();
 8005ed4:	f7fe fccc 	bl	8004870 <test_wait_threads>
    test_assert_sequence("ABC", "invalid sequence");
 8005ed8:	490e      	ldr	r1, [pc, #56]	; (8005f14 <rt_test_008_009_execute+0xb4>)
 8005eda:	480f      	ldr	r0, [pc, #60]	; (8005f18 <rt_test_008_009_execute+0xb8>)
  }
  test_end_step(7);
}
 8005edc:	b003      	add	sp, #12
 8005ede:	e8bd 40f0 	ldmia.w	sp!, {r4, r5, r6, r7, lr}
    test_assert_sequence("ABC", "invalid sequence");
 8005ee2:	f7fe ba2d 	b.w	8004340 <__test_assert_sequence>
 8005ee6:	bf00      	nop
 8005ee8:	20000a40 	.word	0x20000a40
 8005eec:	20000c70 	.word	0x20000c70
 8005ef0:	0800aab8 	.word	0x0800aab8
 8005ef4:	0800b660 	.word	0x0800b660
 8005ef8:	08005f91 	.word	0x08005f91
 8005efc:	200013c8 	.word	0x200013c8
 8005f00:	0800b658 	.word	0x0800b658
 8005f04:	08005f61 	.word	0x08005f61
 8005f08:	0800b65c 	.word	0x0800b65c
 8005f0c:	08005f21 	.word	0x08005f21
 8005f10:	20000800 	.word	0x20000800
 8005f14:	0800b664 	.word	0x0800b664
 8005f18:	0800ba28 	.word	0x0800ba28
 8005f1c:	00000000 	.word	0x00000000

08005f20 <thread9>:
static THD_FUNCTION(thread9, p) {
 8005f20:	b538      	push	{r3, r4, r5, lr}
  chMtxLock(&m2);
 8005f22:	4d06      	ldr	r5, [pc, #24]	; (8005f3c <thread9+0x1c>)
static THD_FUNCTION(thread9, p) {
 8005f24:	4604      	mov	r4, r0
  chMtxLock(&m2);
 8005f26:	4628      	mov	r0, r5
 8005f28:	f7fc faba 	bl	80024a0 <chMtxLock>
  test_emit_token(*(char *)p);
 8005f2c:	7820      	ldrb	r0, [r4, #0]
 8005f2e:	f7fe fa3f 	bl	80043b0 <test_emit_token>
  chMtxUnlock(&m2);
 8005f32:	4628      	mov	r0, r5
}
 8005f34:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
  chMtxUnlock(&m2);
 8005f38:	f7fc bada 	b.w	80024f0 <chMtxUnlock>
 8005f3c:	20000818 	.word	0x20000818

08005f40 <thread1>:
static THD_FUNCTION(thread1, p) {
 8005f40:	b538      	push	{r3, r4, r5, lr}
  chMtxLock(&m1);
 8005f42:	4d06      	ldr	r5, [pc, #24]	; (8005f5c <thread1+0x1c>)
static THD_FUNCTION(thread1, p) {
 8005f44:	4604      	mov	r4, r0
  chMtxLock(&m1);
 8005f46:	4628      	mov	r0, r5
 8005f48:	f7fc faaa 	bl	80024a0 <chMtxLock>
  test_emit_token(*(char *)p);
 8005f4c:	7820      	ldrb	r0, [r4, #0]
 8005f4e:	f7fe fa2f 	bl	80043b0 <test_emit_token>
  chMtxUnlock(&m1);
 8005f52:	4628      	mov	r0, r5
}
 8005f54:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
  chMtxUnlock(&m1);
 8005f58:	f7fc baca 	b.w	80024f0 <chMtxUnlock>
 8005f5c:	20000808 	.word	0x20000808

08005f60 <thread6>:
static THD_FUNCTION(thread6, p) {
 8005f60:	b538      	push	{r3, r4, r5, lr}
  chMtxLock(&m1);
 8005f62:	4d08      	ldr	r5, [pc, #32]	; (8005f84 <thread6+0x24>)
static THD_FUNCTION(thread6, p) {
 8005f64:	4604      	mov	r4, r0
  chMtxLock(&m1);
 8005f66:	4628      	mov	r0, r5
 8005f68:	f7fc fa9a 	bl	80024a0 <chMtxLock>
  chCondWait(&c1);
 8005f6c:	4806      	ldr	r0, [pc, #24]	; (8005f88 <thread6+0x28>)
 8005f6e:	f7fc fbcf 	bl	8002710 <chCondWait>
  test_emit_token(*(char *)p);
 8005f72:	7820      	ldrb	r0, [r4, #0]
 8005f74:	f7fe fa1c 	bl	80043b0 <test_emit_token>
  chMtxUnlock(&m1);
 8005f78:	4628      	mov	r0, r5
}
 8005f7a:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
  chMtxUnlock(&m1);
 8005f7e:	f7fc bab7 	b.w	80024f0 <chMtxUnlock>
 8005f82:	bf00      	nop
 8005f84:	20000808 	.word	0x20000808
 8005f88:	20000800 	.word	0x20000800
 8005f8c:	00000000 	.word	0x00000000

08005f90 <thread8>:
static THD_FUNCTION(thread8, p) {
 8005f90:	b570      	push	{r4, r5, r6, lr}
  chMtxLock(&m2);
 8005f92:	4d0c      	ldr	r5, [pc, #48]	; (8005fc4 <thread8+0x34>)
  chMtxLock(&m1);
 8005f94:	4e0c      	ldr	r6, [pc, #48]	; (8005fc8 <thread8+0x38>)
static THD_FUNCTION(thread8, p) {
 8005f96:	4604      	mov	r4, r0
  chMtxLock(&m2);
 8005f98:	4628      	mov	r0, r5
 8005f9a:	f7fc fa81 	bl	80024a0 <chMtxLock>
  chMtxLock(&m1);
 8005f9e:	4630      	mov	r0, r6
 8005fa0:	f7fc fa7e 	bl	80024a0 <chMtxLock>
  chCondWaitTimeout(&c1, TIME_INFINITE);
 8005fa4:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
 8005fa8:	4808      	ldr	r0, [pc, #32]	; (8005fcc <thread8+0x3c>)
 8005faa:	f7fc fbe9 	bl	8002780 <chCondWaitTimeout>
  test_emit_token(*(char *)p);
 8005fae:	7820      	ldrb	r0, [r4, #0]
 8005fb0:	f7fe f9fe 	bl	80043b0 <test_emit_token>
  chMtxUnlock(&m1);
 8005fb4:	4630      	mov	r0, r6
 8005fb6:	f7fc fa9b 	bl	80024f0 <chMtxUnlock>
  chMtxUnlock(&m2);
 8005fba:	4628      	mov	r0, r5
}
 8005fbc:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
  chMtxUnlock(&m2);
 8005fc0:	f7fc ba96 	b.w	80024f0 <chMtxUnlock>
 8005fc4:	20000818 	.word	0x20000818
 8005fc8:	20000808 	.word	0x20000808
 8005fcc:	20000800 	.word	0x20000800

08005fd0 <rt_test_008_009_setup>:
static void rt_test_008_009_setup(void) {
 8005fd0:	b508      	push	{r3, lr}
  chCondObjectInit(&c1);
 8005fd2:	4805      	ldr	r0, [pc, #20]	; (8005fe8 <rt_test_008_009_setup+0x18>)
 8005fd4:	f7fc fb24 	bl	8002620 <chCondObjectInit>
  chMtxObjectInit(&m1);
 8005fd8:	4804      	ldr	r0, [pc, #16]	; (8005fec <rt_test_008_009_setup+0x1c>)
 8005fda:	f7fc f9f1 	bl	80023c0 <chMtxObjectInit>
}
 8005fde:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  chMtxObjectInit(&m2);
 8005fe2:	4803      	ldr	r0, [pc, #12]	; (8005ff0 <rt_test_008_009_setup+0x20>)
 8005fe4:	f7fc b9ec 	b.w	80023c0 <chMtxObjectInit>
 8005fe8:	20000800 	.word	0x20000800
 8005fec:	20000808 	.word	0x20000808
 8005ff0:	20000818 	.word	0x20000818
	...

08006000 <rt_test_008_007_setup>:
static void rt_test_008_007_setup(void) {
 8006000:	b508      	push	{r3, lr}
  chCondObjectInit(&c1);
 8006002:	4804      	ldr	r0, [pc, #16]	; (8006014 <rt_test_008_007_setup+0x14>)
 8006004:	f7fc fb0c 	bl	8002620 <chCondObjectInit>
}
 8006008:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  chMtxObjectInit(&m1);
 800600c:	4802      	ldr	r0, [pc, #8]	; (8006018 <rt_test_008_007_setup+0x18>)
 800600e:	f7fc b9d7 	b.w	80023c0 <chMtxObjectInit>
 8006012:	bf00      	nop
 8006014:	20000800 	.word	0x20000800
 8006018:	20000808 	.word	0x20000808
 800601c:	00000000 	.word	0x00000000

08006020 <rt_test_008_004_setup>:
static void rt_test_008_004_setup(void) {
 8006020:	b508      	push	{r3, lr}
  chMtxObjectInit(&m1);
 8006022:	4804      	ldr	r0, [pc, #16]	; (8006034 <rt_test_008_004_setup+0x14>)
 8006024:	f7fc f9cc 	bl	80023c0 <chMtxObjectInit>
}
 8006028:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  chMtxObjectInit(&m2);
 800602c:	4802      	ldr	r0, [pc, #8]	; (8006038 <rt_test_008_004_setup+0x18>)
 800602e:	f7fc b9c7 	b.w	80023c0 <chMtxObjectInit>
 8006032:	bf00      	nop
 8006034:	20000808 	.word	0x20000808
 8006038:	20000818 	.word	0x20000818
 800603c:	00000000 	.word	0x00000000

08006040 <rt_test_008_001_setup>:
  chMtxObjectInit(&m1);
 8006040:	4801      	ldr	r0, [pc, #4]	; (8006048 <rt_test_008_001_setup+0x8>)
 8006042:	f7fc b9bd 	b.w	80023c0 <chMtxObjectInit>
 8006046:	bf00      	nop
 8006048:	20000808 	.word	0x20000808
 800604c:	00000000 	.word	0x00000000

08006050 <rt_test_008_008_execute>:
static void rt_test_008_008_execute(void) {
 8006050:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  return __sch_get_currthread();
 8006054:	4b26      	ldr	r3, [pc, #152]	; (80060f0 <rt_test_008_008_execute+0xa0>)
  test_set_step(1);
 8006056:	f8df 809c 	ldr.w	r8, [pc, #156]	; 80060f4 <rt_test_008_008_execute+0xa4>
  return chThdGetSelfX()->hdr.pqueue.prio;
 800605a:	68db      	ldr	r3, [r3, #12]
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, prio+1, thread6, "E");
 800605c:	4f26      	ldr	r7, [pc, #152]	; (80060f8 <rt_test_008_008_execute+0xa8>)
 800605e:	689e      	ldr	r6, [r3, #8]
 8006060:	4d26      	ldr	r5, [pc, #152]	; (80060fc <rt_test_008_008_execute+0xac>)
 8006062:	4c27      	ldr	r4, [pc, #156]	; (8006100 <rt_test_008_008_execute+0xb0>)
 8006064:	6828      	ldr	r0, [r5, #0]
static void rt_test_008_008_execute(void) {
 8006066:	b082      	sub	sp, #8
  test_set_step(1);
 8006068:	2301      	movs	r3, #1
 800606a:	f8c8 3000 	str.w	r3, [r8]
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, prio+1, thread6, "E");
 800606e:	4b25      	ldr	r3, [pc, #148]	; (8006104 <rt_test_008_008_execute+0xb4>)
 8006070:	9300      	str	r3, [sp, #0]
 8006072:	1c72      	adds	r2, r6, #1
 8006074:	463b      	mov	r3, r7
 8006076:	f44f 71b8 	mov.w	r1, #368	; 0x170
 800607a:	f7fb fe99 	bl	8001db0 <chThdCreateStatic>
    threads[1] = chThdCreateStatic(wa[1], WA_SIZE, prio+2, thread6, "D");
 800607e:	4b22      	ldr	r3, [pc, #136]	; (8006108 <rt_test_008_008_execute+0xb8>)
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, prio+1, thread6, "E");
 8006080:	6020      	str	r0, [r4, #0]
    threads[1] = chThdCreateStatic(wa[1], WA_SIZE, prio+2, thread6, "D");
 8006082:	9300      	str	r3, [sp, #0]
 8006084:	1cb2      	adds	r2, r6, #2
 8006086:	463b      	mov	r3, r7
 8006088:	6868      	ldr	r0, [r5, #4]
 800608a:	f44f 71b8 	mov.w	r1, #368	; 0x170
 800608e:	f7fb fe8f 	bl	8001db0 <chThdCreateStatic>
    threads[2] = chThdCreateStatic(wa[2], WA_SIZE, prio+3, thread6, "C");
 8006092:	4b1e      	ldr	r3, [pc, #120]	; (800610c <rt_test_008_008_execute+0xbc>)
    threads[1] = chThdCreateStatic(wa[1], WA_SIZE, prio+2, thread6, "D");
 8006094:	6060      	str	r0, [r4, #4]
    threads[2] = chThdCreateStatic(wa[2], WA_SIZE, prio+3, thread6, "C");
 8006096:	9300      	str	r3, [sp, #0]
 8006098:	1cf2      	adds	r2, r6, #3
 800609a:	463b      	mov	r3, r7
 800609c:	68a8      	ldr	r0, [r5, #8]
 800609e:	f44f 71b8 	mov.w	r1, #368	; 0x170
 80060a2:	f7fb fe85 	bl	8001db0 <chThdCreateStatic>
    threads[3] = chThdCreateStatic(wa[3], WA_SIZE, prio+4, thread6, "B");
 80060a6:	4b1a      	ldr	r3, [pc, #104]	; (8006110 <rt_test_008_008_execute+0xc0>)
    threads[2] = chThdCreateStatic(wa[2], WA_SIZE, prio+3, thread6, "C");
 80060a8:	60a0      	str	r0, [r4, #8]
    threads[3] = chThdCreateStatic(wa[3], WA_SIZE, prio+4, thread6, "B");
 80060aa:	9300      	str	r3, [sp, #0]
 80060ac:	1d32      	adds	r2, r6, #4
 80060ae:	463b      	mov	r3, r7
 80060b0:	68e8      	ldr	r0, [r5, #12]
 80060b2:	f44f 71b8 	mov.w	r1, #368	; 0x170
 80060b6:	f7fb fe7b 	bl	8001db0 <chThdCreateStatic>
    threads[4] = chThdCreateStatic(wa[4], WA_SIZE, prio+5, thread6, "A");
 80060ba:	4916      	ldr	r1, [pc, #88]	; (8006114 <rt_test_008_008_execute+0xc4>)
    threads[3] = chThdCreateStatic(wa[3], WA_SIZE, prio+4, thread6, "B");
 80060bc:	60e0      	str	r0, [r4, #12]
    threads[4] = chThdCreateStatic(wa[4], WA_SIZE, prio+5, thread6, "A");
 80060be:	463b      	mov	r3, r7
 80060c0:	1d72      	adds	r2, r6, #5
 80060c2:	9100      	str	r1, [sp, #0]
 80060c4:	6928      	ldr	r0, [r5, #16]
 80060c6:	f44f 71b8 	mov.w	r1, #368	; 0x170
 80060ca:	f7fb fe71 	bl	8001db0 <chThdCreateStatic>
  test_set_step(2);
 80060ce:	2302      	movs	r3, #2
    threads[4] = chThdCreateStatic(wa[4], WA_SIZE, prio+5, thread6, "A");
 80060d0:	4602      	mov	r2, r0
    chCondBroadcast(&c1);
 80060d2:	4811      	ldr	r0, [pc, #68]	; (8006118 <rt_test_008_008_execute+0xc8>)
    threads[4] = chThdCreateStatic(wa[4], WA_SIZE, prio+5, thread6, "A");
 80060d4:	6122      	str	r2, [r4, #16]
  test_set_step(2);
 80060d6:	f8c8 3000 	str.w	r3, [r8]
    chCondBroadcast(&c1);
 80060da:	f7fc fad1 	bl	8002680 <chCondBroadcast>
    test_wait_threads();
 80060de:	f7fe fbc7 	bl	8004870 <test_wait_threads>
    test_assert_sequence("ABCDE", "invalid sequence");
 80060e2:	490e      	ldr	r1, [pc, #56]	; (800611c <rt_test_008_008_execute+0xcc>)
 80060e4:	480e      	ldr	r0, [pc, #56]	; (8006120 <rt_test_008_008_execute+0xd0>)
}
 80060e6:	b002      	add	sp, #8
 80060e8:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
    test_assert_sequence("ABCDE", "invalid sequence");
 80060ec:	f7fe b928 	b.w	8004340 <__test_assert_sequence>
 80060f0:	20000a40 	.word	0x20000a40
 80060f4:	20000c70 	.word	0x20000c70
 80060f8:	08005f61 	.word	0x08005f61
 80060fc:	0800aab8 	.word	0x0800aab8
 8006100:	200013c8 	.word	0x200013c8
 8006104:	0800b67c 	.word	0x0800b67c
 8006108:	0800b654 	.word	0x0800b654
 800610c:	0800b658 	.word	0x0800b658
 8006110:	0800b65c 	.word	0x0800b65c
 8006114:	0800b660 	.word	0x0800b660
 8006118:	20000800 	.word	0x20000800
 800611c:	0800b664 	.word	0x0800b664
 8006120:	0800b678 	.word	0x0800b678
	...

08006130 <rt_test_008_007_execute>:
static void rt_test_008_007_execute(void) {
 8006130:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  return __sch_get_currthread();
 8006134:	4b30      	ldr	r3, [pc, #192]	; (80061f8 <rt_test_008_007_execute+0xc8>)
  test_set_step(1);
 8006136:	f8df 80c4 	ldr.w	r8, [pc, #196]	; 80061fc <rt_test_008_007_execute+0xcc>
  return chThdGetSelfX()->hdr.pqueue.prio;
 800613a:	68db      	ldr	r3, [r3, #12]
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, prio+1, thread6, "E");
 800613c:	4e30      	ldr	r6, [pc, #192]	; (8006200 <rt_test_008_007_execute+0xd0>)
 800613e:	689d      	ldr	r5, [r3, #8]
 8006140:	4f30      	ldr	r7, [pc, #192]	; (8006204 <rt_test_008_007_execute+0xd4>)
 8006142:	4c31      	ldr	r4, [pc, #196]	; (8006208 <rt_test_008_007_execute+0xd8>)
 8006144:	6838      	ldr	r0, [r7, #0]
static void rt_test_008_007_execute(void) {
 8006146:	b082      	sub	sp, #8
  test_set_step(1);
 8006148:	2301      	movs	r3, #1
 800614a:	f8c8 3000 	str.w	r3, [r8]
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, prio+1, thread6, "E");
 800614e:	4b2f      	ldr	r3, [pc, #188]	; (800620c <rt_test_008_007_execute+0xdc>)
 8006150:	9300      	str	r3, [sp, #0]
 8006152:	1c6a      	adds	r2, r5, #1
 8006154:	4633      	mov	r3, r6
 8006156:	f44f 71b8 	mov.w	r1, #368	; 0x170
 800615a:	f7fb fe29 	bl	8001db0 <chThdCreateStatic>
    threads[1] = chThdCreateStatic(wa[1], WA_SIZE, prio+2, thread6, "D");
 800615e:	4b2c      	ldr	r3, [pc, #176]	; (8006210 <rt_test_008_007_execute+0xe0>)
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, prio+1, thread6, "E");
 8006160:	6020      	str	r0, [r4, #0]
    threads[1] = chThdCreateStatic(wa[1], WA_SIZE, prio+2, thread6, "D");
 8006162:	1caa      	adds	r2, r5, #2
 8006164:	9300      	str	r3, [sp, #0]
 8006166:	6878      	ldr	r0, [r7, #4]
 8006168:	4633      	mov	r3, r6
 800616a:	f44f 71b8 	mov.w	r1, #368	; 0x170
 800616e:	f7fb fe1f 	bl	8001db0 <chThdCreateStatic>
    threads[2] = chThdCreateStatic(wa[2], WA_SIZE, prio+3, thread6, "C");
 8006172:	4b28      	ldr	r3, [pc, #160]	; (8006214 <rt_test_008_007_execute+0xe4>)
    threads[1] = chThdCreateStatic(wa[1], WA_SIZE, prio+2, thread6, "D");
 8006174:	6060      	str	r0, [r4, #4]
    threads[2] = chThdCreateStatic(wa[2], WA_SIZE, prio+3, thread6, "C");
 8006176:	1cea      	adds	r2, r5, #3
 8006178:	9300      	str	r3, [sp, #0]
 800617a:	68b8      	ldr	r0, [r7, #8]
 800617c:	4633      	mov	r3, r6
 800617e:	f44f 71b8 	mov.w	r1, #368	; 0x170
 8006182:	f7fb fe15 	bl	8001db0 <chThdCreateStatic>
    threads[3] = chThdCreateStatic(wa[3], WA_SIZE, prio+4, thread6, "B");
 8006186:	4b24      	ldr	r3, [pc, #144]	; (8006218 <rt_test_008_007_execute+0xe8>)
    threads[2] = chThdCreateStatic(wa[2], WA_SIZE, prio+3, thread6, "C");
 8006188:	60a0      	str	r0, [r4, #8]
    threads[3] = chThdCreateStatic(wa[3], WA_SIZE, prio+4, thread6, "B");
 800618a:	1d2a      	adds	r2, r5, #4
 800618c:	9300      	str	r3, [sp, #0]
 800618e:	68f8      	ldr	r0, [r7, #12]
 8006190:	4633      	mov	r3, r6
 8006192:	f44f 71b8 	mov.w	r1, #368	; 0x170
 8006196:	f7fb fe0b 	bl	8001db0 <chThdCreateStatic>
    threads[4] = chThdCreateStatic(wa[4], WA_SIZE, prio+5, thread6, "A");
 800619a:	4920      	ldr	r1, [pc, #128]	; (800621c <rt_test_008_007_execute+0xec>)
    threads[3] = chThdCreateStatic(wa[3], WA_SIZE, prio+4, thread6, "B");
 800619c:	60e0      	str	r0, [r4, #12]
    threads[4] = chThdCreateStatic(wa[4], WA_SIZE, prio+5, thread6, "A");
 800619e:	4633      	mov	r3, r6
 80061a0:	9100      	str	r1, [sp, #0]
 80061a2:	6938      	ldr	r0, [r7, #16]
 80061a4:	1d6a      	adds	r2, r5, #5
 80061a6:	f44f 71b8 	mov.w	r1, #368	; 0x170
 80061aa:	f7fb fe01 	bl	8001db0 <chThdCreateStatic>
  test_set_step(2);
 80061ae:	2302      	movs	r3, #2
 80061b0:	f8c8 3000 	str.w	r3, [r8]
    threads[4] = chThdCreateStatic(wa[4], WA_SIZE, prio+5, thread6, "A");
 80061b4:	6120      	str	r0, [r4, #16]
 80061b6:	2330      	movs	r3, #48	; 0x30
 80061b8:	f383 8811 	msr	BASEPRI, r3
    chCondSignalI(&c1);
 80061bc:	4c18      	ldr	r4, [pc, #96]	; (8006220 <rt_test_008_007_execute+0xf0>)
 80061be:	4620      	mov	r0, r4
 80061c0:	f7fc fa4e 	bl	8002660 <chCondSignalI>
    chCondSignalI(&c1);
 80061c4:	4620      	mov	r0, r4
 80061c6:	f7fc fa4b 	bl	8002660 <chCondSignalI>
    chCondSignalI(&c1);
 80061ca:	4620      	mov	r0, r4
 80061cc:	f7fc fa48 	bl	8002660 <chCondSignalI>
    chCondSignalI(&c1);
 80061d0:	4620      	mov	r0, r4
 80061d2:	f7fc fa45 	bl	8002660 <chCondSignalI>
    chCondSignalI(&c1);
 80061d6:	4620      	mov	r0, r4
 80061d8:	f7fc fa42 	bl	8002660 <chCondSignalI>
    chSchRescheduleS();
 80061dc:	f7fb fce0 	bl	8001ba0 <chSchRescheduleS>
 80061e0:	2300      	movs	r3, #0
 80061e2:	f383 8811 	msr	BASEPRI, r3
    test_wait_threads();
 80061e6:	f7fe fb43 	bl	8004870 <test_wait_threads>
    test_assert_sequence("ABCDE", "invalid sequence");
 80061ea:	490e      	ldr	r1, [pc, #56]	; (8006224 <rt_test_008_007_execute+0xf4>)
 80061ec:	480e      	ldr	r0, [pc, #56]	; (8006228 <rt_test_008_007_execute+0xf8>)
}
 80061ee:	b002      	add	sp, #8
 80061f0:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
    test_assert_sequence("ABCDE", "invalid sequence");
 80061f4:	f7fe b8a4 	b.w	8004340 <__test_assert_sequence>
 80061f8:	20000a40 	.word	0x20000a40
 80061fc:	20000c70 	.word	0x20000c70
 8006200:	08005f61 	.word	0x08005f61
 8006204:	0800aab8 	.word	0x0800aab8
 8006208:	200013c8 	.word	0x200013c8
 800620c:	0800b67c 	.word	0x0800b67c
 8006210:	0800b654 	.word	0x0800b654
 8006214:	0800b658 	.word	0x0800b658
 8006218:	0800b65c 	.word	0x0800b65c
 800621c:	0800b660 	.word	0x0800b660
 8006220:	20000800 	.word	0x20000800
 8006224:	0800b664 	.word	0x0800b664
 8006228:	0800b678 	.word	0x0800b678
 800622c:	00000000 	.word	0x00000000

08006230 <rt_test_008_001_execute>:
static void rt_test_008_001_execute(void) {
 8006230:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  return __sch_get_currthread();
 8006234:	f8df 80b8 	ldr.w	r8, [pc, #184]	; 80062f0 <rt_test_008_001_execute+0xc0>
  test_set_step(2);
 8006238:	4f2e      	ldr	r7, [pc, #184]	; (80062f4 <rt_test_008_001_execute+0xc4>)
  return chThdGetSelfX()->hdr.pqueue.prio;
 800623a:	f8d8 300c 	ldr.w	r3, [r8, #12]
    chMtxLock(&m1);
 800623e:	482e      	ldr	r0, [pc, #184]	; (80062f8 <rt_test_008_001_execute+0xc8>)
 8006240:	689c      	ldr	r4, [r3, #8]
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, prio+1, thread1, "E");
 8006242:	4e2e      	ldr	r6, [pc, #184]	; (80062fc <rt_test_008_001_execute+0xcc>)
 8006244:	4d2e      	ldr	r5, [pc, #184]	; (8006300 <rt_test_008_001_execute+0xd0>)
static void rt_test_008_001_execute(void) {
 8006246:	b082      	sub	sp, #8
  test_set_step(2);
 8006248:	2302      	movs	r3, #2
 800624a:	603b      	str	r3, [r7, #0]
    chMtxLock(&m1);
 800624c:	f7fc f928 	bl	80024a0 <chMtxLock>
  test_set_step(3);
 8006250:	2303      	movs	r3, #3
 8006252:	603b      	str	r3, [r7, #0]
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, prio+1, thread1, "E");
 8006254:	4b2b      	ldr	r3, [pc, #172]	; (8006304 <rt_test_008_001_execute+0xd4>)
 8006256:	9300      	str	r3, [sp, #0]
 8006258:	1c62      	adds	r2, r4, #1
 800625a:	4b2b      	ldr	r3, [pc, #172]	; (8006308 <rt_test_008_001_execute+0xd8>)
 800625c:	6830      	ldr	r0, [r6, #0]
 800625e:	f44f 71b8 	mov.w	r1, #368	; 0x170
 8006262:	f7fb fda5 	bl	8001db0 <chThdCreateStatic>
    threads[1] = chThdCreateStatic(wa[1], WA_SIZE, prio+2, thread1, "D");
 8006266:	4b29      	ldr	r3, [pc, #164]	; (800630c <rt_test_008_001_execute+0xdc>)
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, prio+1, thread1, "E");
 8006268:	6028      	str	r0, [r5, #0]
    threads[1] = chThdCreateStatic(wa[1], WA_SIZE, prio+2, thread1, "D");
 800626a:	9300      	str	r3, [sp, #0]
 800626c:	1ca2      	adds	r2, r4, #2
 800626e:	4b26      	ldr	r3, [pc, #152]	; (8006308 <rt_test_008_001_execute+0xd8>)
 8006270:	6870      	ldr	r0, [r6, #4]
 8006272:	f44f 71b8 	mov.w	r1, #368	; 0x170
 8006276:	f7fb fd9b 	bl	8001db0 <chThdCreateStatic>
    threads[2] = chThdCreateStatic(wa[2], WA_SIZE, prio+3, thread1, "C");
 800627a:	4b25      	ldr	r3, [pc, #148]	; (8006310 <rt_test_008_001_execute+0xe0>)
    threads[1] = chThdCreateStatic(wa[1], WA_SIZE, prio+2, thread1, "D");
 800627c:	6068      	str	r0, [r5, #4]
    threads[2] = chThdCreateStatic(wa[2], WA_SIZE, prio+3, thread1, "C");
 800627e:	9300      	str	r3, [sp, #0]
 8006280:	1ce2      	adds	r2, r4, #3
 8006282:	4b21      	ldr	r3, [pc, #132]	; (8006308 <rt_test_008_001_execute+0xd8>)
 8006284:	68b0      	ldr	r0, [r6, #8]
 8006286:	f44f 71b8 	mov.w	r1, #368	; 0x170
 800628a:	f7fb fd91 	bl	8001db0 <chThdCreateStatic>
    threads[3] = chThdCreateStatic(wa[3], WA_SIZE, prio+4, thread1, "B");
 800628e:	4b21      	ldr	r3, [pc, #132]	; (8006314 <rt_test_008_001_execute+0xe4>)
    threads[2] = chThdCreateStatic(wa[2], WA_SIZE, prio+3, thread1, "C");
 8006290:	60a8      	str	r0, [r5, #8]
    threads[3] = chThdCreateStatic(wa[3], WA_SIZE, prio+4, thread1, "B");
 8006292:	9300      	str	r3, [sp, #0]
 8006294:	1d22      	adds	r2, r4, #4
 8006296:	4b1c      	ldr	r3, [pc, #112]	; (8006308 <rt_test_008_001_execute+0xd8>)
 8006298:	68f0      	ldr	r0, [r6, #12]
 800629a:	f44f 71b8 	mov.w	r1, #368	; 0x170
 800629e:	f7fb fd87 	bl	8001db0 <chThdCreateStatic>
    threads[4] = chThdCreateStatic(wa[4], WA_SIZE, prio+5, thread1, "A");
 80062a2:	4b1d      	ldr	r3, [pc, #116]	; (8006318 <rt_test_008_001_execute+0xe8>)
    threads[3] = chThdCreateStatic(wa[3], WA_SIZE, prio+4, thread1, "B");
 80062a4:	60e8      	str	r0, [r5, #12]
    threads[4] = chThdCreateStatic(wa[4], WA_SIZE, prio+5, thread1, "A");
 80062a6:	f44f 71b8 	mov.w	r1, #368	; 0x170
 80062aa:	1d62      	adds	r2, r4, #5
 80062ac:	9300      	str	r3, [sp, #0]
 80062ae:	6930      	ldr	r0, [r6, #16]
 80062b0:	4b15      	ldr	r3, [pc, #84]	; (8006308 <rt_test_008_001_execute+0xd8>)
 80062b2:	f7fb fd7d 	bl	8001db0 <chThdCreateStatic>
  test_set_step(4);
 80062b6:	2304      	movs	r3, #4
    threads[4] = chThdCreateStatic(wa[4], WA_SIZE, prio+5, thread1, "A");
 80062b8:	6128      	str	r0, [r5, #16]
    chMtxUnlock(&m1);
 80062ba:	480f      	ldr	r0, [pc, #60]	; (80062f8 <rt_test_008_001_execute+0xc8>)
  test_set_step(4);
 80062bc:	603b      	str	r3, [r7, #0]
    chMtxUnlock(&m1);
 80062be:	f7fc f917 	bl	80024f0 <chMtxUnlock>
    test_wait_threads();
 80062c2:	f7fe fad5 	bl	8004870 <test_wait_threads>
 80062c6:	f8d8 300c 	ldr.w	r3, [r8, #12]
    test_assert(prio == chThdGetPriorityX(), "wrong priority level");
 80062ca:	4914      	ldr	r1, [pc, #80]	; (800631c <rt_test_008_001_execute+0xec>)
 80062cc:	6898      	ldr	r0, [r3, #8]
 80062ce:	1b00      	subs	r0, r0, r4
 80062d0:	fab0 f080 	clz	r0, r0
 80062d4:	0940      	lsrs	r0, r0, #5
 80062d6:	f7fe f823 	bl	8004320 <__test_assert>
 80062da:	b110      	cbz	r0, 80062e2 <rt_test_008_001_execute+0xb2>
}
 80062dc:	b002      	add	sp, #8
 80062de:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    test_assert_sequence("ABCDE", "invalid sequence");
 80062e2:	490f      	ldr	r1, [pc, #60]	; (8006320 <rt_test_008_001_execute+0xf0>)
 80062e4:	480f      	ldr	r0, [pc, #60]	; (8006324 <rt_test_008_001_execute+0xf4>)
}
 80062e6:	b002      	add	sp, #8
 80062e8:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
    test_assert_sequence("ABCDE", "invalid sequence");
 80062ec:	f7fe b828 	b.w	8004340 <__test_assert_sequence>
 80062f0:	20000a40 	.word	0x20000a40
 80062f4:	20000c70 	.word	0x20000c70
 80062f8:	20000808 	.word	0x20000808
 80062fc:	0800aab8 	.word	0x0800aab8
 8006300:	200013c8 	.word	0x200013c8
 8006304:	0800b67c 	.word	0x0800b67c
 8006308:	08005f41 	.word	0x08005f41
 800630c:	0800b654 	.word	0x0800b654
 8006310:	0800b658 	.word	0x0800b658
 8006314:	0800b65c 	.word	0x0800b65c
 8006318:	0800b660 	.word	0x0800b660
 800631c:	0800ba2c 	.word	0x0800ba2c
 8006320:	0800b664 	.word	0x0800b664
 8006324:	0800b678 	.word	0x0800b678
	...

08006330 <rt_test_008_005_execute>:
static void rt_test_008_005_execute(void) {
 8006330:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  return __sch_get_currthread();
 8006332:	4e3c      	ldr	r6, [pc, #240]	; (8006424 <rt_test_008_005_execute+0xf4>)
    b = chMtxTryLock(&m1);
 8006334:	4c3c      	ldr	r4, [pc, #240]	; (8006428 <rt_test_008_005_execute+0xf8>)
  return chThdGetSelfX()->hdr.pqueue.prio;
 8006336:	68f2      	ldr	r2, [r6, #12]
  test_set_step(2);
 8006338:	4d3c      	ldr	r5, [pc, #240]	; (800642c <rt_test_008_005_execute+0xfc>)
 800633a:	6897      	ldr	r7, [r2, #8]
 800633c:	2302      	movs	r3, #2
    b = chMtxTryLock(&m1);
 800633e:	4620      	mov	r0, r4
  test_set_step(2);
 8006340:	602b      	str	r3, [r5, #0]
    b = chMtxTryLock(&m1);
 8006342:	f7fc f8bd 	bl	80024c0 <chMtxTryLock>
    test_assert(b, "already locked");
 8006346:	493a      	ldr	r1, [pc, #232]	; (8006430 <rt_test_008_005_execute+0x100>)
 8006348:	f7fd ffea 	bl	8004320 <__test_assert>
 800634c:	b100      	cbz	r0, 8006350 <rt_test_008_005_execute+0x20>
}
 800634e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  test_set_step(3);
 8006350:	2303      	movs	r3, #3
    b = chMtxTryLock(&m1);
 8006352:	4620      	mov	r0, r4
  test_set_step(3);
 8006354:	602b      	str	r3, [r5, #0]
    b = chMtxTryLock(&m1);
 8006356:	f7fc f8b3 	bl	80024c0 <chMtxTryLock>
    test_assert(!b, "not locked");
 800635a:	f080 0001 	eor.w	r0, r0, #1
 800635e:	4935      	ldr	r1, [pc, #212]	; (8006434 <rt_test_008_005_execute+0x104>)
 8006360:	b2c0      	uxtb	r0, r0
 8006362:	f7fd ffdd 	bl	8004320 <__test_assert>
 8006366:	2800      	cmp	r0, #0
 8006368:	d1f1      	bne.n	800634e <rt_test_008_005_execute+0x1e>
  test_set_step(4);
 800636a:	2304      	movs	r3, #4
    chMtxUnlock(&m1);
 800636c:	4620      	mov	r0, r4
  test_set_step(4);
 800636e:	602b      	str	r3, [r5, #0]
    chMtxUnlock(&m1);
 8006370:	f7fc f8be 	bl	80024f0 <chMtxUnlock>
    test_assert(m1.owner == NULL, "still owned");
 8006374:	68a0      	ldr	r0, [r4, #8]
 8006376:	4930      	ldr	r1, [pc, #192]	; (8006438 <rt_test_008_005_execute+0x108>)
 8006378:	fab0 f080 	clz	r0, r0
 800637c:	0940      	lsrs	r0, r0, #5
 800637e:	f7fd ffcf 	bl	8004320 <__test_assert>
 8006382:	2800      	cmp	r0, #0
 8006384:	d1e3      	bne.n	800634e <rt_test_008_005_execute+0x1e>
 8006386:	6820      	ldr	r0, [r4, #0]
    test_assert(ch_queue_isempty(&m1.queue), "queue not empty");
 8006388:	492c      	ldr	r1, [pc, #176]	; (800643c <rt_test_008_005_execute+0x10c>)
 800638a:	1b00      	subs	r0, r0, r4
 800638c:	fab0 f080 	clz	r0, r0
 8006390:	0940      	lsrs	r0, r0, #5
 8006392:	f7fd ffc5 	bl	8004320 <__test_assert>
 8006396:	2800      	cmp	r0, #0
 8006398:	d1d9      	bne.n	800634e <rt_test_008_005_execute+0x1e>
  test_set_step(5);
 800639a:	2305      	movs	r3, #5
 800639c:	602b      	str	r3, [r5, #0]
 800639e:	68f3      	ldr	r3, [r6, #12]
    test_assert(chThdGetPriorityX() == prio, "wrong priority level");
 80063a0:	4927      	ldr	r1, [pc, #156]	; (8006440 <rt_test_008_005_execute+0x110>)
 80063a2:	6898      	ldr	r0, [r3, #8]
 80063a4:	1bc0      	subs	r0, r0, r7
 80063a6:	fab0 f080 	clz	r0, r0
 80063aa:	0940      	lsrs	r0, r0, #5
 80063ac:	f7fd ffb8 	bl	8004320 <__test_assert>
 80063b0:	2800      	cmp	r0, #0
 80063b2:	d1cc      	bne.n	800634e <rt_test_008_005_execute+0x1e>
  test_set_step(6);
 80063b4:	2306      	movs	r3, #6
    b = chMtxTryLock(&m1);
 80063b6:	4620      	mov	r0, r4
  test_set_step(6);
 80063b8:	602b      	str	r3, [r5, #0]
    b = chMtxTryLock(&m1);
 80063ba:	f7fc f881 	bl	80024c0 <chMtxTryLock>
    test_assert(b, "already locked");
 80063be:	491c      	ldr	r1, [pc, #112]	; (8006430 <rt_test_008_005_execute+0x100>)
 80063c0:	f7fd ffae 	bl	8004320 <__test_assert>
 80063c4:	2800      	cmp	r0, #0
 80063c6:	d1c2      	bne.n	800634e <rt_test_008_005_execute+0x1e>
    b = chMtxTryLock(&m1);
 80063c8:	4620      	mov	r0, r4
 80063ca:	f7fc f879 	bl	80024c0 <chMtxTryLock>
    test_assert(!b, "not locked");
 80063ce:	f080 0001 	eor.w	r0, r0, #1
 80063d2:	4918      	ldr	r1, [pc, #96]	; (8006434 <rt_test_008_005_execute+0x104>)
 80063d4:	b2c0      	uxtb	r0, r0
 80063d6:	f7fd ffa3 	bl	8004320 <__test_assert>
 80063da:	2800      	cmp	r0, #0
 80063dc:	d1b7      	bne.n	800634e <rt_test_008_005_execute+0x1e>
    chMtxUnlockAll();
 80063de:	f7fc f90f 	bl	8002600 <chMtxUnlockAll>
    test_assert(m1.owner == NULL, "still owned");
 80063e2:	68a0      	ldr	r0, [r4, #8]
 80063e4:	4914      	ldr	r1, [pc, #80]	; (8006438 <rt_test_008_005_execute+0x108>)
 80063e6:	fab0 f080 	clz	r0, r0
 80063ea:	0940      	lsrs	r0, r0, #5
 80063ec:	f7fd ff98 	bl	8004320 <__test_assert>
 80063f0:	2800      	cmp	r0, #0
 80063f2:	d1ac      	bne.n	800634e <rt_test_008_005_execute+0x1e>
 80063f4:	6820      	ldr	r0, [r4, #0]
    test_assert(ch_queue_isempty(&m1.queue), "queue not empty");
 80063f6:	4911      	ldr	r1, [pc, #68]	; (800643c <rt_test_008_005_execute+0x10c>)
 80063f8:	1b00      	subs	r0, r0, r4
 80063fa:	fab0 f080 	clz	r0, r0
 80063fe:	0940      	lsrs	r0, r0, #5
 8006400:	f7fd ff8e 	bl	8004320 <__test_assert>
 8006404:	2800      	cmp	r0, #0
 8006406:	d1a2      	bne.n	800634e <rt_test_008_005_execute+0x1e>
 8006408:	68f2      	ldr	r2, [r6, #12]
    test_assert(chThdGetPriorityX() == prio, "wrong priority level");
 800640a:	490d      	ldr	r1, [pc, #52]	; (8006440 <rt_test_008_005_execute+0x110>)
 800640c:	6890      	ldr	r0, [r2, #8]
 800640e:	1bc0      	subs	r0, r0, r7
  test_set_step(7);
 8006410:	2307      	movs	r3, #7
    test_assert(chThdGetPriorityX() == prio, "wrong priority level");
 8006412:	fab0 f080 	clz	r0, r0
  test_set_step(7);
 8006416:	602b      	str	r3, [r5, #0]
    test_assert(chThdGetPriorityX() == prio, "wrong priority level");
 8006418:	0940      	lsrs	r0, r0, #5
}
 800641a:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
    test_assert(chThdGetPriorityX() == prio, "wrong priority level");
 800641e:	f7fd bf7f 	b.w	8004320 <__test_assert>
 8006422:	bf00      	nop
 8006424:	20000a40 	.word	0x20000a40
 8006428:	20000808 	.word	0x20000808
 800642c:	20000c70 	.word	0x20000c70
 8006430:	0800ba44 	.word	0x0800ba44
 8006434:	0800ba54 	.word	0x0800ba54
 8006438:	0800ba60 	.word	0x0800ba60
 800643c:	0800b818 	.word	0x0800b818
 8006440:	0800ba2c 	.word	0x0800ba2c
	...

08006450 <rt_test_008_004_execute>:
static void rt_test_008_004_execute(void) {
 8006450:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
  return __sch_get_currthread();
 8006454:	4d46      	ldr	r5, [pc, #280]	; (8006570 <rt_test_008_004_execute+0x120>)
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, pa, thread4A, "A");
 8006456:	4f47      	ldr	r7, [pc, #284]	; (8006574 <rt_test_008_004_execute+0x124>)
  return chThdGetSelfX()->hdr.pqueue.prio;
 8006458:	68eb      	ldr	r3, [r5, #12]
  test_set_step(2);
 800645a:	4e47      	ldr	r6, [pc, #284]	; (8006578 <rt_test_008_004_execute+0x128>)
 800645c:	689c      	ldr	r4, [r3, #8]
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, pa, thread4A, "A");
 800645e:	4b47      	ldr	r3, [pc, #284]	; (800657c <rt_test_008_004_execute+0x12c>)
 8006460:	6838      	ldr	r0, [r7, #0]
static void rt_test_008_004_execute(void) {
 8006462:	b083      	sub	sp, #12
    pa = p + 1;
 8006464:	f104 0801 	add.w	r8, r4, #1
  test_set_step(2);
 8006468:	f04f 0c02 	mov.w	ip, #2
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, pa, thread4A, "A");
 800646c:	9300      	str	r3, [sp, #0]
 800646e:	4642      	mov	r2, r8
 8006470:	4b43      	ldr	r3, [pc, #268]	; (8006580 <rt_test_008_004_execute+0x130>)
  test_set_step(2);
 8006472:	f8c6 c000 	str.w	ip, [r6]
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, pa, thread4A, "A");
 8006476:	f44f 71b8 	mov.w	r1, #368	; 0x170
 800647a:	f7fb fc99 	bl	8001db0 <chThdCreateStatic>
 800647e:	4603      	mov	r3, r0
    threads[1] = chThdCreateStatic(wa[1], WA_SIZE, pb, thread4B, "B");
 8006480:	6878      	ldr	r0, [r7, #4]
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, pa, thread4A, "A");
 8006482:	4f40      	ldr	r7, [pc, #256]	; (8006584 <rt_test_008_004_execute+0x134>)
    pb = p + 2;
 8006484:	f104 0902 	add.w	r9, r4, #2
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, pa, thread4A, "A");
 8006488:	603b      	str	r3, [r7, #0]
    threads[1] = chThdCreateStatic(wa[1], WA_SIZE, pb, thread4B, "B");
 800648a:	4b3f      	ldr	r3, [pc, #252]	; (8006588 <rt_test_008_004_execute+0x138>)
 800648c:	9300      	str	r3, [sp, #0]
 800648e:	f44f 71b8 	mov.w	r1, #368	; 0x170
 8006492:	4b3e      	ldr	r3, [pc, #248]	; (800658c <rt_test_008_004_execute+0x13c>)
 8006494:	464a      	mov	r2, r9
 8006496:	f7fb fc8b 	bl	8001db0 <chThdCreateStatic>
  test_set_step(3);
 800649a:	2303      	movs	r3, #3
    threads[1] = chThdCreateStatic(wa[1], WA_SIZE, pb, thread4B, "B");
 800649c:	6078      	str	r0, [r7, #4]
    chMtxLock(&m1);
 800649e:	483c      	ldr	r0, [pc, #240]	; (8006590 <rt_test_008_004_execute+0x140>)
  test_set_step(3);
 80064a0:	6033      	str	r3, [r6, #0]
    chMtxLock(&m1);
 80064a2:	f7fb fffd 	bl	80024a0 <chMtxLock>
 80064a6:	68eb      	ldr	r3, [r5, #12]
    test_assert(chThdGetPriorityX() == p, "wrong priority level");
 80064a8:	493a      	ldr	r1, [pc, #232]	; (8006594 <rt_test_008_004_execute+0x144>)
 80064aa:	6898      	ldr	r0, [r3, #8]
 80064ac:	1b00      	subs	r0, r0, r4
 80064ae:	fab0 f080 	clz	r0, r0
 80064b2:	0940      	lsrs	r0, r0, #5
 80064b4:	f7fd ff34 	bl	8004320 <__test_assert>
 80064b8:	b110      	cbz	r0, 80064c0 <rt_test_008_004_execute+0x70>
}
 80064ba:	b003      	add	sp, #12
 80064bc:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
  test_set_step(4);
 80064c0:	2304      	movs	r3, #4
    chThdSleepMilliseconds(100);
 80064c2:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
  test_set_step(4);
 80064c6:	6033      	str	r3, [r6, #0]
    chThdSleepMilliseconds(100);
 80064c8:	f7fb fd72 	bl	8001fb0 <chThdSleep>
 80064cc:	68eb      	ldr	r3, [r5, #12]
    test_assert(chThdGetPriorityX() == pa, "wrong priority level");
 80064ce:	4931      	ldr	r1, [pc, #196]	; (8006594 <rt_test_008_004_execute+0x144>)
 80064d0:	6898      	ldr	r0, [r3, #8]
 80064d2:	eba0 0008 	sub.w	r0, r0, r8
 80064d6:	fab0 f080 	clz	r0, r0
 80064da:	0940      	lsrs	r0, r0, #5
 80064dc:	f7fd ff20 	bl	8004320 <__test_assert>
 80064e0:	2800      	cmp	r0, #0
 80064e2:	d1ea      	bne.n	80064ba <rt_test_008_004_execute+0x6a>
  test_set_step(5);
 80064e4:	2305      	movs	r3, #5
    chMtxLock(&m2);
 80064e6:	482c      	ldr	r0, [pc, #176]	; (8006598 <rt_test_008_004_execute+0x148>)
  test_set_step(5);
 80064e8:	6033      	str	r3, [r6, #0]
    chMtxLock(&m2);
 80064ea:	f7fb ffd9 	bl	80024a0 <chMtxLock>
 80064ee:	68eb      	ldr	r3, [r5, #12]
    test_assert(chThdGetPriorityX() == pa, "wrong priority level");
 80064f0:	4928      	ldr	r1, [pc, #160]	; (8006594 <rt_test_008_004_execute+0x144>)
 80064f2:	6898      	ldr	r0, [r3, #8]
 80064f4:	eba0 0008 	sub.w	r0, r0, r8
 80064f8:	fab0 f080 	clz	r0, r0
 80064fc:	0940      	lsrs	r0, r0, #5
 80064fe:	f7fd ff0f 	bl	8004320 <__test_assert>
 8006502:	2800      	cmp	r0, #0
 8006504:	d1d9      	bne.n	80064ba <rt_test_008_004_execute+0x6a>
  test_set_step(6);
 8006506:	2306      	movs	r3, #6
    chThdSleepMilliseconds(100);
 8006508:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
  test_set_step(6);
 800650c:	6033      	str	r3, [r6, #0]
    chThdSleepMilliseconds(100);
 800650e:	f7fb fd4f 	bl	8001fb0 <chThdSleep>
 8006512:	68eb      	ldr	r3, [r5, #12]
    test_assert(chThdGetPriorityX() == pb, "wrong priority level");
 8006514:	491f      	ldr	r1, [pc, #124]	; (8006594 <rt_test_008_004_execute+0x144>)
 8006516:	6898      	ldr	r0, [r3, #8]
 8006518:	eba0 0009 	sub.w	r0, r0, r9
 800651c:	fab0 f080 	clz	r0, r0
 8006520:	0940      	lsrs	r0, r0, #5
 8006522:	f7fd fefd 	bl	8004320 <__test_assert>
 8006526:	2800      	cmp	r0, #0
 8006528:	d1c7      	bne.n	80064ba <rt_test_008_004_execute+0x6a>
  test_set_step(7);
 800652a:	2307      	movs	r3, #7
    chMtxUnlock(&m2);
 800652c:	481a      	ldr	r0, [pc, #104]	; (8006598 <rt_test_008_004_execute+0x148>)
  test_set_step(7);
 800652e:	6033      	str	r3, [r6, #0]
    chMtxUnlock(&m2);
 8006530:	f7fb ffde 	bl	80024f0 <chMtxUnlock>
 8006534:	68eb      	ldr	r3, [r5, #12]
    test_assert(chThdGetPriorityX() == pa, "wrong priority level");
 8006536:	4917      	ldr	r1, [pc, #92]	; (8006594 <rt_test_008_004_execute+0x144>)
 8006538:	6898      	ldr	r0, [r3, #8]
 800653a:	eba0 0008 	sub.w	r0, r0, r8
 800653e:	fab0 f080 	clz	r0, r0
 8006542:	0940      	lsrs	r0, r0, #5
 8006544:	f7fd feec 	bl	8004320 <__test_assert>
 8006548:	2800      	cmp	r0, #0
 800654a:	d1b6      	bne.n	80064ba <rt_test_008_004_execute+0x6a>
  test_set_step(8);
 800654c:	2308      	movs	r3, #8
    chMtxUnlock(&m1);
 800654e:	4810      	ldr	r0, [pc, #64]	; (8006590 <rt_test_008_004_execute+0x140>)
  test_set_step(8);
 8006550:	6033      	str	r3, [r6, #0]
    chMtxUnlock(&m1);
 8006552:	f7fb ffcd 	bl	80024f0 <chMtxUnlock>
 8006556:	68eb      	ldr	r3, [r5, #12]
    test_assert(chThdGetPriorityX() == p, "wrong priority level");
 8006558:	490e      	ldr	r1, [pc, #56]	; (8006594 <rt_test_008_004_execute+0x144>)
 800655a:	6898      	ldr	r0, [r3, #8]
 800655c:	1b00      	subs	r0, r0, r4
 800655e:	fab0 f080 	clz	r0, r0
 8006562:	0940      	lsrs	r0, r0, #5
}
 8006564:	b003      	add	sp, #12
 8006566:	e8bd 43f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, lr}
    test_assert(chThdGetPriorityX() == p, "wrong priority level");
 800656a:	f7fd bed9 	b.w	8004320 <__test_assert>
 800656e:	bf00      	nop
 8006570:	20000a40 	.word	0x20000a40
 8006574:	0800aab8 	.word	0x0800aab8
 8006578:	20000c70 	.word	0x20000c70
 800657c:	0800b660 	.word	0x0800b660
 8006580:	080065a1 	.word	0x080065a1
 8006584:	200013c8 	.word	0x200013c8
 8006588:	0800b65c 	.word	0x0800b65c
 800658c:	080065c1 	.word	0x080065c1
 8006590:	20000808 	.word	0x20000808
 8006594:	0800ba2c 	.word	0x0800ba2c
 8006598:	20000818 	.word	0x20000818
 800659c:	00000000 	.word	0x00000000

080065a0 <thread4A>:
static THD_FUNCTION(thread4A, p) {
 80065a0:	b510      	push	{r4, lr}
  chMtxLock(&m1);
 80065a2:	4c06      	ldr	r4, [pc, #24]	; (80065bc <thread4A+0x1c>)
  chThdSleepMilliseconds(50);
 80065a4:	f44f 70fa 	mov.w	r0, #500	; 0x1f4
 80065a8:	f7fb fd02 	bl	8001fb0 <chThdSleep>
  chMtxLock(&m1);
 80065ac:	4620      	mov	r0, r4
 80065ae:	f7fb ff77 	bl	80024a0 <chMtxLock>
  chMtxUnlock(&m1);
 80065b2:	4620      	mov	r0, r4
}
 80065b4:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  chMtxUnlock(&m1);
 80065b8:	f7fb bf9a 	b.w	80024f0 <chMtxUnlock>
 80065bc:	20000808 	.word	0x20000808

080065c0 <thread4B>:
static THD_FUNCTION(thread4B, p) {
 80065c0:	b510      	push	{r4, lr}
  chThdSleepMilliseconds(150);
 80065c2:	f240 50dc 	movw	r0, #1500	; 0x5dc
 80065c6:	f7fb fcf3 	bl	8001fb0 <chThdSleep>
 80065ca:	2330      	movs	r3, #48	; 0x30
 80065cc:	f383 8811 	msr	BASEPRI, r3
  chMtxLockS(&m2);   /* For coverage of the chMtxLockS() function variant.*/
 80065d0:	4c06      	ldr	r4, [pc, #24]	; (80065ec <thread4B+0x2c>)
 80065d2:	4620      	mov	r0, r4
 80065d4:	f7fb fefc 	bl	80023d0 <chMtxLockS>
  chMtxUnlockS(&m2); /* For coverage of the chMtxUnlockS() function variant.*/
 80065d8:	4620      	mov	r0, r4
 80065da:	f7fb ffc1 	bl	8002560 <chMtxUnlockS>
  chSchRescheduleS();
 80065de:	f7fb fadf 	bl	8001ba0 <chSchRescheduleS>
 80065e2:	2300      	movs	r3, #0
 80065e4:	f383 8811 	msr	BASEPRI, r3
}
 80065e8:	bd10      	pop	{r4, pc}
 80065ea:	bf00      	nop
 80065ec:	20000818 	.word	0x20000818

080065f0 <rt_test_008_005_setup>:
 80065f0:	4801      	ldr	r0, [pc, #4]	; (80065f8 <rt_test_008_005_setup+0x8>)
 80065f2:	f7fb bee5 	b.w	80023c0 <chMtxObjectInit>
 80065f6:	bf00      	nop
 80065f8:	20000808 	.word	0x20000808
 80065fc:	00000000 	.word	0x00000000

08006600 <rt_test_008_008_setup>:
 8006600:	b508      	push	{r3, lr}
 8006602:	4804      	ldr	r0, [pc, #16]	; (8006614 <rt_test_008_008_setup+0x14>)
 8006604:	f7fc f80c 	bl	8002620 <chCondObjectInit>
 8006608:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
 800660c:	4802      	ldr	r0, [pc, #8]	; (8006618 <rt_test_008_008_setup+0x18>)
 800660e:	f7fb bed7 	b.w	80023c0 <chMtxObjectInit>
 8006612:	bf00      	nop
 8006614:	20000800 	.word	0x20000800
 8006618:	20000808 	.word	0x20000808
 800661c:	00000000 	.word	0x00000000

08006620 <msg_thread1>:

/****************************************************************************
 * Shared code.
 ****************************************************************************/

static THD_FUNCTION(msg_thread1, p) {
 8006620:	b510      	push	{r4, lr}

  chMsgSend(p, 'A');
 8006622:	2141      	movs	r1, #65	; 0x41
static THD_FUNCTION(msg_thread1, p) {
 8006624:	4604      	mov	r4, r0
  chMsgSend(p, 'A');
 8006626:	f7fc fa73 	bl	8002b10 <chMsgSend>
  chMsgSend(p, 'B');
 800662a:	2142      	movs	r1, #66	; 0x42
 800662c:	4620      	mov	r0, r4
 800662e:	f7fc fa6f 	bl	8002b10 <chMsgSend>
  chMsgSend(p, 'C');
 8006632:	2143      	movs	r1, #67	; 0x43
 8006634:	4620      	mov	r0, r4
 8006636:	f7fc fa6b 	bl	8002b10 <chMsgSend>
  chMsgSend(p, 'D');
 800663a:	4620      	mov	r0, r4
 800663c:	2144      	movs	r1, #68	; 0x44
}
 800663e:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  chMsgSend(p, 'D');
 8006642:	f7fc ba65 	b.w	8002b10 <chMsgSend>
 8006646:	bf00      	nop
	...

08006650 <rt_test_009_001_execute>:
 * - [9.1.1] Starting the messenger thread.
 * - [9.1.2] Waiting for four messages then testing the receive order.
 * .
 */

static void rt_test_009_001_execute(void) {
 8006650:	b5f0      	push	{r4, r5, r6, r7, lr}
  return __sch_get_currthread();
 8006652:	4b17      	ldr	r3, [pc, #92]	; (80066b0 <rt_test_009_001_execute+0x60>)
  thread_t *tp;
  msg_t msg;

  /* [9.1.1] Starting the messenger thread.*/
  test_set_step(1);
 8006654:	4c17      	ldr	r4, [pc, #92]	; (80066b4 <rt_test_009_001_execute+0x64>)
 8006656:	68d9      	ldr	r1, [r3, #12]
  {
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX() + 1,
 8006658:	4817      	ldr	r0, [pc, #92]	; (80066b8 <rt_test_009_001_execute+0x68>)
 800665a:	688a      	ldr	r2, [r1, #8]
 800665c:	4b17      	ldr	r3, [pc, #92]	; (80066bc <rt_test_009_001_execute+0x6c>)
 800665e:	6800      	ldr	r0, [r0, #0]
static void rt_test_009_001_execute(void) {
 8006660:	b083      	sub	sp, #12
  test_set_step(1);
 8006662:	2501      	movs	r5, #1
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX() + 1,
 8006664:	9100      	str	r1, [sp, #0]
 8006666:	442a      	add	r2, r5
  test_set_step(1);
 8006668:	6025      	str	r5, [r4, #0]
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX() + 1,
 800666a:	f44f 71b8 	mov.w	r1, #368	; 0x170
 800666e:	f7fb fb9f 	bl	8001db0 <chThdCreateStatic>
 8006672:	4a13      	ldr	r2, [pc, #76]	; (80066c0 <rt_test_009_001_execute+0x70>)
  }
  test_end_step(1);

  /* [9.1.2] Waiting for four messages then testing the receive
     order.*/
  test_set_step(2);
 8006674:	2302      	movs	r3, #2
 8006676:	6023      	str	r3, [r4, #0]
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX() + 1,
 8006678:	6010      	str	r0, [r2, #0]
  test_set_step(2);
 800667a:	2404      	movs	r4, #4
 800667c:	2730      	movs	r7, #48	; 0x30
 800667e:	2600      	movs	r6, #0
 8006680:	f387 8811 	msr	BASEPRI, r7
 8006684:	f7fc fa64 	bl	8002b50 <chMsgWaitS>
 8006688:	f386 8811 	msr	BASEPRI, r6
  return tp->u.sentmsg;
 800668c:	6a85      	ldr	r5, [r0, #40]	; 0x28
    unsigned i;

    for (i = 0; i < 4; i++) {
      tp = chMsgWait();
      msg = chMsgGet(tp);
      chMsgRelease(tp, msg);
 800668e:	4629      	mov	r1, r5
 8006690:	f7fc fa76 	bl	8002b80 <chMsgRelease>
      test_emit_token(msg);
 8006694:	b2e8      	uxtb	r0, r5
 8006696:	f7fd fe8b 	bl	80043b0 <test_emit_token>
    for (i = 0; i < 4; i++) {
 800669a:	3c01      	subs	r4, #1
 800669c:	d1f0      	bne.n	8006680 <rt_test_009_001_execute+0x30>
    }
    test_wait_threads();
 800669e:	f7fe f8e7 	bl	8004870 <test_wait_threads>
    test_assert_sequence("ABCD", "invalid sequence");
 80066a2:	4908      	ldr	r1, [pc, #32]	; (80066c4 <rt_test_009_001_execute+0x74>)
 80066a4:	4808      	ldr	r0, [pc, #32]	; (80066c8 <rt_test_009_001_execute+0x78>)
  }
  test_end_step(2);
}
 80066a6:	b003      	add	sp, #12
 80066a8:	e8bd 40f0 	ldmia.w	sp!, {r4, r5, r6, r7, lr}
    test_assert_sequence("ABCD", "invalid sequence");
 80066ac:	f7fd be48 	b.w	8004340 <__test_assert_sequence>
 80066b0:	20000a40 	.word	0x20000a40
 80066b4:	20000c70 	.word	0x20000c70
 80066b8:	0800aab8 	.word	0x0800aab8
 80066bc:	08006621 	.word	0x08006621
 80066c0:	200013c8 	.word	0x200013c8
 80066c4:	0800b664 	.word	0x0800b664
 80066c8:	0800bbf4 	.word	0x0800bbf4
 80066cc:	00000000 	.word	0x00000000

080066d0 <rt_test_010_007_setup>:
 *   has been emptied.
 * - [10.7.4] Unregistering from the Event Sources.
 * .
 */

static void rt_test_010_007_setup(void) {
 80066d0:	b508      	push	{r3, lr}
  chEvtGetAndClearEvents(ALL_EVENTS);
 80066d2:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
 80066d6:	f7fc f893 	bl	8002800 <chEvtGetAndClearEvents>
  esp->next = (event_listener_t *)esp;
 80066da:	4a02      	ldr	r2, [pc, #8]	; (80066e4 <rt_test_010_007_setup+0x14>)
 80066dc:	4b02      	ldr	r3, [pc, #8]	; (80066e8 <rt_test_010_007_setup+0x18>)
 80066de:	6012      	str	r2, [r2, #0]
 80066e0:	601b      	str	r3, [r3, #0]
  chEvtObjectInit(&es1);
  chEvtObjectInit(&es2);
}
 80066e2:	bd08      	pop	{r3, pc}
 80066e4:	20000828 	.word	0x20000828
 80066e8:	2000082c 	.word	0x2000082c
 80066ec:	00000000 	.word	0x00000000

080066f0 <rt_test_010_002_setup>:
  chEvtGetAndClearEvents(ALL_EVENTS);
 80066f0:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
 80066f4:	f7fc b884 	b.w	8002800 <chEvtGetAndClearEvents>
	...

08006700 <evt_thread7>:
static THD_FUNCTION(evt_thread7, p) {
 8006700:	b508      	push	{r3, lr}
  chEvtBroadcastFlags(esp, (eventflags_t)0);
 8006702:	2100      	movs	r1, #0
 8006704:	4806      	ldr	r0, [pc, #24]	; (8006720 <evt_thread7+0x20>)
 8006706:	f7fc f8fb 	bl	8002900 <chEvtBroadcastFlags>
  chThdSleepMilliseconds(50);
 800670a:	f44f 70fa 	mov.w	r0, #500	; 0x1f4
 800670e:	f7fb fc4f 	bl	8001fb0 <chThdSleep>
}
 8006712:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
 8006716:	4803      	ldr	r0, [pc, #12]	; (8006724 <evt_thread7+0x24>)
 8006718:	2100      	movs	r1, #0
 800671a:	f7fc b8f1 	b.w	8002900 <chEvtBroadcastFlags>
 800671e:	bf00      	nop
 8006720:	20000828 	.word	0x20000828
 8006724:	2000082c 	.word	0x2000082c
	...

08006730 <rt_test_010_007_execute>:

static void rt_test_010_007_execute(void) {
 8006730:	b5f0      	push	{r4, r5, r6, r7, lr}
  chEvtRegisterMaskWithFlags(esp, elp, events, (eventflags_t)-1);
 8006732:	4e30      	ldr	r6, [pc, #192]	; (80067f4 <rt_test_010_007_execute+0xc4>)
  event_listener_t el1, el2;
  systime_t target_time;

  /* [10.7.1] Registering on two event sources associating them with
     flags 1 and 4.*/
  test_set_step(1);
 8006734:	4d30      	ldr	r5, [pc, #192]	; (80067f8 <rt_test_010_007_execute+0xc8>)
 8006736:	4f31      	ldr	r7, [pc, #196]	; (80067fc <rt_test_010_007_execute+0xcc>)
static void rt_test_010_007_execute(void) {
 8006738:	b08d      	sub	sp, #52	; 0x34
  test_set_step(1);
 800673a:	2201      	movs	r2, #1
 800673c:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
 8006740:	a902      	add	r1, sp, #8
 8006742:	4630      	mov	r0, r6
 8006744:	602a      	str	r2, [r5, #0]
 8006746:	f7fc f82b 	bl	80027a0 <chEvtRegisterMaskWithFlags>
 800674a:	2204      	movs	r2, #4
 800674c:	a907      	add	r1, sp, #28
 800674e:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
 8006752:	4638      	mov	r0, r7
 8006754:	f7fc f824 	bl	80027a0 <chEvtRegisterMaskWithFlags>
  test_end_step(1);

  /* [10.7.2] Getting current time and starting a broadcaster thread,
     the thread broadcast the first Event Source immediately and the
     other after 50mS.*/
  test_set_step(2);
 8006758:	2302      	movs	r3, #2
 800675a:	602b      	str	r3, [r5, #0]
  {
    target_time = chTimeAddX(test_wait_tick(), TIME_MS2I(50));
 800675c:	f7fe f8a0 	bl	80048a0 <test_wait_tick>
 8006760:	4b27      	ldr	r3, [pc, #156]	; (8006800 <rt_test_010_007_execute+0xd0>)
  return chThdGetSelfX()->hdr.pqueue.prio;
 8006762:	68db      	ldr	r3, [r3, #12]
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX() - 1,
 8006764:	689a      	ldr	r2, [r3, #8]
 8006766:	4b27      	ldr	r3, [pc, #156]	; (8006804 <rt_test_010_007_execute+0xd4>)
    target_time = chTimeAddX(test_wait_tick(), TIME_MS2I(50));
 8006768:	4604      	mov	r4, r0
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX() - 1,
 800676a:	6818      	ldr	r0, [r3, #0]
 800676c:	4b26      	ldr	r3, [pc, #152]	; (8006808 <rt_test_010_007_execute+0xd8>)
 800676e:	9300      	str	r3, [sp, #0]
 8006770:	3a01      	subs	r2, #1
 8006772:	f44f 71b8 	mov.w	r1, #368	; 0x170
 8006776:	4b25      	ldr	r3, [pc, #148]	; (800680c <rt_test_010_007_execute+0xdc>)
 8006778:	f7fb fb1a 	bl	8001db0 <chThdCreateStatic>
 800677c:	4b24      	ldr	r3, [pc, #144]	; (8006810 <rt_test_010_007_execute+0xe0>)
 800677e:	6018      	str	r0, [r3, #0]
  test_end_step(2);

  /* [10.7.3] Calling chEvtWaitAll() then verifying that both event
     flags have been received after 50mS and that the event flags mask
     has been emptied.*/
  test_set_step(3);
 8006780:	2303      	movs	r3, #3
  {
    m = chEvtWaitAll(5);
 8006782:	2005      	movs	r0, #5
  test_set_step(3);
 8006784:	602b      	str	r3, [r5, #0]
    m = chEvtWaitAll(5);
 8006786:	f7fc f92b 	bl	80029e0 <chEvtWaitAll>
    test_assert_time_window(target_time,
 800678a:	4a22      	ldr	r2, [pc, #136]	; (8006814 <rt_test_010_007_execute+0xe4>)
 800678c:	f504 7102 	add.w	r1, r4, #520	; 0x208
 8006790:	f504 70fa 	add.w	r0, r4, #500	; 0x1f4
 8006794:	f7fd fdf4 	bl	8004380 <__test_assert_time_window>
 8006798:	b108      	cbz	r0, 800679e <rt_test_010_007_execute+0x6e>
    chEvtUnregister(&es2, &el2);
    test_assert(!chEvtIsListeningI(&es1), "stuck listener");
    test_assert(!chEvtIsListeningI(&es2), "stuck listener");
  }
  test_end_step(4);
}
 800679a:	b00d      	add	sp, #52	; 0x34
 800679c:	bdf0      	pop	{r4, r5, r6, r7, pc}
    m = chEvtGetAndClearEvents(ALL_EVENTS);
 800679e:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
 80067a2:	f7fc f82d 	bl	8002800 <chEvtGetAndClearEvents>
    test_assert(m == 0, "stuck event");
 80067a6:	fab0 f080 	clz	r0, r0
 80067aa:	491b      	ldr	r1, [pc, #108]	; (8006818 <rt_test_010_007_execute+0xe8>)
 80067ac:	0940      	lsrs	r0, r0, #5
 80067ae:	f7fd fdb7 	bl	8004320 <__test_assert>
 80067b2:	2800      	cmp	r0, #0
 80067b4:	d1f1      	bne.n	800679a <rt_test_010_007_execute+0x6a>
    test_wait_threads();
 80067b6:	f7fe f85b 	bl	8004870 <test_wait_threads>
  test_set_step(4);
 80067ba:	2304      	movs	r3, #4
    chEvtUnregister(&es1, &el1);
 80067bc:	a902      	add	r1, sp, #8
 80067be:	4630      	mov	r0, r6
  test_set_step(4);
 80067c0:	602b      	str	r3, [r5, #0]
    chEvtUnregister(&es1, &el1);
 80067c2:	f7fc f805 	bl	80027d0 <chEvtUnregister>
    chEvtUnregister(&es2, &el2);
 80067c6:	a907      	add	r1, sp, #28
 80067c8:	4638      	mov	r0, r7
 80067ca:	f7fc f801 	bl	80027d0 <chEvtUnregister>
    test_assert(!chEvtIsListeningI(&es1), "stuck listener");
 80067ce:	6830      	ldr	r0, [r6, #0]
 80067d0:	4912      	ldr	r1, [pc, #72]	; (800681c <rt_test_010_007_execute+0xec>)
 80067d2:	1b80      	subs	r0, r0, r6
 80067d4:	fab0 f080 	clz	r0, r0
 80067d8:	0940      	lsrs	r0, r0, #5
 80067da:	f7fd fda1 	bl	8004320 <__test_assert>
 80067de:	2800      	cmp	r0, #0
 80067e0:	d1db      	bne.n	800679a <rt_test_010_007_execute+0x6a>
    test_assert(!chEvtIsListeningI(&es2), "stuck listener");
 80067e2:	6838      	ldr	r0, [r7, #0]
 80067e4:	490d      	ldr	r1, [pc, #52]	; (800681c <rt_test_010_007_execute+0xec>)
 80067e6:	1bc0      	subs	r0, r0, r7
 80067e8:	fab0 f080 	clz	r0, r0
 80067ec:	0940      	lsrs	r0, r0, #5
 80067ee:	f7fd fd97 	bl	8004320 <__test_assert>
 80067f2:	e7d2      	b.n	800679a <rt_test_010_007_execute+0x6a>
 80067f4:	20000828 	.word	0x20000828
 80067f8:	20000c70 	.word	0x20000c70
 80067fc:	2000082c 	.word	0x2000082c
 8006800:	20000a40 	.word	0x20000a40
 8006804:	0800aab8 	.word	0x0800aab8
 8006808:	0800b660 	.word	0x0800b660
 800680c:	08006701 	.word	0x08006701
 8006810:	200013c8 	.word	0x200013c8
 8006814:	0800b680 	.word	0x0800b680
 8006818:	0800bc4c 	.word	0x0800bc4c
 800681c:	0800bc58 	.word	0x0800bc58

08006820 <rt_test_010_001_execute>:
static void rt_test_010_001_execute(void) {
 8006820:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  esp->next = (event_listener_t *)esp;
 8006824:	4c2c      	ldr	r4, [pc, #176]	; (80068d8 <rt_test_010_001_execute+0xb8>)
  test_set_step(2);
 8006826:	4f2d      	ldr	r7, [pc, #180]	; (80068dc <rt_test_010_001_execute+0xbc>)
 8006828:	6024      	str	r4, [r4, #0]
static void rt_test_010_001_execute(void) {
 800682a:	b08a      	sub	sp, #40	; 0x28
  test_set_step(2);
 800682c:	2502      	movs	r5, #2
  chEvtRegisterMaskWithFlags(esp, elp, events, (eventflags_t)-1);
 800682e:	4669      	mov	r1, sp
 8006830:	4620      	mov	r0, r4
 8006832:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
 8006836:	2201      	movs	r2, #1
 8006838:	603d      	str	r5, [r7, #0]
 800683a:	f7fb ffb1 	bl	80027a0 <chEvtRegisterMaskWithFlags>
 800683e:	462a      	mov	r2, r5
 8006840:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
 8006844:	a905      	add	r1, sp, #20
 8006846:	4620      	mov	r0, r4
 8006848:	f7fb ffaa 	bl	80027a0 <chEvtRegisterMaskWithFlags>
 800684c:	2630      	movs	r6, #48	; 0x30
 800684e:	f386 8811 	msr	BASEPRI, r6
  return (bool)(esp != (event_source_t *)esp->next);
 8006852:	6820      	ldr	r0, [r4, #0]
    test_assert_lock(chEvtIsListeningI(&es1), "no listener");
 8006854:	4922      	ldr	r1, [pc, #136]	; (80068e0 <rt_test_010_001_execute+0xc0>)
 8006856:	1b00      	subs	r0, r0, r4
 8006858:	bf18      	it	ne
 800685a:	2001      	movne	r0, #1
 800685c:	f7fd fd60 	bl	8004320 <__test_assert>
 8006860:	b128      	cbz	r0, 800686e <rt_test_010_001_execute+0x4e>
 8006862:	2300      	movs	r3, #0
 8006864:	f383 8811 	msr	BASEPRI, r3
}
 8006868:	b00a      	add	sp, #40	; 0x28
 800686a:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 800686e:	4605      	mov	r5, r0
 8006870:	f380 8811 	msr	BASEPRI, r0
  test_set_step(3);
 8006874:	2303      	movs	r3, #3
    chEvtUnregister(&es1, &el1);
 8006876:	4669      	mov	r1, sp
 8006878:	4620      	mov	r0, r4
  test_set_step(3);
 800687a:	603b      	str	r3, [r7, #0]
    chEvtUnregister(&es1, &el1);
 800687c:	f7fb ffa8 	bl	80027d0 <chEvtUnregister>
 8006880:	f386 8811 	msr	BASEPRI, r6
 8006884:	6820      	ldr	r0, [r4, #0]
    test_assert_lock(chEvtIsListeningI(&es1), "no listener");
 8006886:	4916      	ldr	r1, [pc, #88]	; (80068e0 <rt_test_010_001_execute+0xc0>)
 8006888:	1b00      	subs	r0, r0, r4
 800688a:	bf18      	it	ne
 800688c:	2001      	movne	r0, #1
 800688e:	f7fd fd47 	bl	8004320 <__test_assert>
 8006892:	4680      	mov	r8, r0
 8006894:	b120      	cbz	r0, 80068a0 <rt_test_010_001_execute+0x80>
 8006896:	f385 8811 	msr	BASEPRI, r5
}
 800689a:	b00a      	add	sp, #40	; 0x28
 800689c:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 80068a0:	f380 8811 	msr	BASEPRI, r0
  test_set_step(4);
 80068a4:	2304      	movs	r3, #4
    chEvtUnregister(&es1, &el2);
 80068a6:	a905      	add	r1, sp, #20
 80068a8:	4620      	mov	r0, r4
  test_set_step(4);
 80068aa:	603b      	str	r3, [r7, #0]
    chEvtUnregister(&es1, &el2);
 80068ac:	f7fb ff90 	bl	80027d0 <chEvtUnregister>
 80068b0:	f386 8811 	msr	BASEPRI, r6
    test_assert_lock(!chEvtIsListeningI(&es1), "stuck listener");
 80068b4:	6820      	ldr	r0, [r4, #0]
 80068b6:	490b      	ldr	r1, [pc, #44]	; (80068e4 <rt_test_010_001_execute+0xc4>)
 80068b8:	1b00      	subs	r0, r0, r4
 80068ba:	fab0 f080 	clz	r0, r0
 80068be:	0940      	lsrs	r0, r0, #5
 80068c0:	f7fd fd2e 	bl	8004320 <__test_assert>
 80068c4:	b920      	cbnz	r0, 80068d0 <rt_test_010_001_execute+0xb0>
 80068c6:	f380 8811 	msr	BASEPRI, r0
}
 80068ca:	b00a      	add	sp, #40	; 0x28
 80068cc:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 80068d0:	f388 8811 	msr	BASEPRI, r8
    test_assert_lock(!chEvtIsListeningI(&es1), "stuck listener");
 80068d4:	e7c8      	b.n	8006868 <rt_test_010_001_execute+0x48>
 80068d6:	bf00      	nop
 80068d8:	20000828 	.word	0x20000828
 80068dc:	20000c70 	.word	0x20000c70
 80068e0:	0800bc68 	.word	0x0800bc68
 80068e4:	0800bc58 	.word	0x0800bc58
	...

080068f0 <evt_thread3>:
static THD_FUNCTION(evt_thread3, p) {
 80068f0:	b510      	push	{r4, lr}
 80068f2:	4604      	mov	r4, r0
  chThdSleepMilliseconds(50);
 80068f4:	f44f 70fa 	mov.w	r0, #500	; 0x1f4
 80068f8:	f7fb fb5a 	bl	8001fb0 <chThdSleep>
  chEvtSignal((thread_t *)p, 1);
 80068fc:	4620      	mov	r0, r4
 80068fe:	2101      	movs	r1, #1
}
 8006900:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  chEvtSignal((thread_t *)p, 1);
 8006904:	f7fb bfa4 	b.w	8002850 <chEvtSignal>
	...

08006910 <rt_test_010_002_execute>:
static void rt_test_010_002_execute(void) {
 8006910:	b508      	push	{r3, lr}
  test_set_step(1);
 8006912:	4b06      	ldr	r3, [pc, #24]	; (800692c <rt_test_010_002_execute+0x1c>)
    chEvtDispatch(evhndl, 7);
 8006914:	4806      	ldr	r0, [pc, #24]	; (8006930 <rt_test_010_002_execute+0x20>)
 8006916:	2107      	movs	r1, #7
  test_set_step(1);
 8006918:	2201      	movs	r2, #1
 800691a:	601a      	str	r2, [r3, #0]
    chEvtDispatch(evhndl, 7);
 800691c:	f7fc f800 	bl	8002920 <chEvtDispatch>
}
 8006920:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
    test_assert_sequence("ABC", "invalid sequence");
 8006924:	4903      	ldr	r1, [pc, #12]	; (8006934 <rt_test_010_002_execute+0x24>)
 8006926:	4804      	ldr	r0, [pc, #16]	; (8006938 <rt_test_010_002_execute+0x28>)
 8006928:	f7fd bd0a 	b.w	8004340 <__test_assert_sequence>
 800692c:	20000c70 	.word	0x20000c70
 8006930:	0800bddc 	.word	0x0800bddc
 8006934:	0800b664 	.word	0x0800b664
 8006938:	0800ba28 	.word	0x0800ba28
 800693c:	00000000 	.word	0x00000000

08006940 <h3>:
static void h3(eventid_t id) {(void)id;test_emit_token('C');}
 8006940:	2043      	movs	r0, #67	; 0x43
 8006942:	f7fd bd35 	b.w	80043b0 <test_emit_token>
 8006946:	bf00      	nop
	...

08006950 <h2>:
static void h2(eventid_t id) {(void)id;test_emit_token('B');}
 8006950:	2042      	movs	r0, #66	; 0x42
 8006952:	f7fd bd2d 	b.w	80043b0 <test_emit_token>
 8006956:	bf00      	nop
	...

08006960 <h1>:
static void h1(eventid_t id) {(void)id;test_emit_token('A');}
 8006960:	2041      	movs	r0, #65	; 0x41
 8006962:	f7fd bd25 	b.w	80043b0 <test_emit_token>
 8006966:	bf00      	nop
	...

08006970 <rt_test_010_006_execute>:
static void rt_test_010_006_execute(void) {
 8006970:	b510      	push	{r4, lr}
  test_set_step(1);
 8006972:	4c2b      	ldr	r4, [pc, #172]	; (8006a20 <rt_test_010_006_execute+0xb0>)
    m = chEvtWaitOneTimeout(ALL_EVENTS, TIME_IMMEDIATE);
 8006974:	2100      	movs	r1, #0
  test_set_step(1);
 8006976:	2301      	movs	r3, #1
    m = chEvtWaitOneTimeout(ALL_EVENTS, TIME_IMMEDIATE);
 8006978:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
  test_set_step(1);
 800697c:	6023      	str	r3, [r4, #0]
    m = chEvtWaitOneTimeout(ALL_EVENTS, TIME_IMMEDIATE);
 800697e:	f7fc f84f 	bl	8002a20 <chEvtWaitOneTimeout>
    test_assert(m == 0, "spurious event");
 8006982:	fab0 f080 	clz	r0, r0
 8006986:	4927      	ldr	r1, [pc, #156]	; (8006a24 <rt_test_010_006_execute+0xb4>)
 8006988:	0940      	lsrs	r0, r0, #5
 800698a:	f7fd fcc9 	bl	8004320 <__test_assert>
 800698e:	b100      	cbz	r0, 8006992 <rt_test_010_006_execute+0x22>
}
 8006990:	bd10      	pop	{r4, pc}
    m = chEvtWaitAnyTimeout(ALL_EVENTS, TIME_IMMEDIATE);
 8006992:	4601      	mov	r1, r0
 8006994:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
 8006998:	f7fc f86a 	bl	8002a70 <chEvtWaitAnyTimeout>
    test_assert(m == 0, "spurious event");
 800699c:	fab0 f080 	clz	r0, r0
 80069a0:	4920      	ldr	r1, [pc, #128]	; (8006a24 <rt_test_010_006_execute+0xb4>)
 80069a2:	0940      	lsrs	r0, r0, #5
 80069a4:	f7fd fcbc 	bl	8004320 <__test_assert>
 80069a8:	2800      	cmp	r0, #0
 80069aa:	d1f1      	bne.n	8006990 <rt_test_010_006_execute+0x20>
    m = chEvtWaitAllTimeout(ALL_EVENTS, TIME_IMMEDIATE);
 80069ac:	4601      	mov	r1, r0
 80069ae:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
 80069b2:	f7fc f885 	bl	8002ac0 <chEvtWaitAllTimeout>
    test_assert(m == 0, "spurious event");
 80069b6:	fab0 f080 	clz	r0, r0
 80069ba:	491a      	ldr	r1, [pc, #104]	; (8006a24 <rt_test_010_006_execute+0xb4>)
 80069bc:	0940      	lsrs	r0, r0, #5
 80069be:	f7fd fcaf 	bl	8004320 <__test_assert>
 80069c2:	2800      	cmp	r0, #0
 80069c4:	d1e4      	bne.n	8006990 <rt_test_010_006_execute+0x20>
    m = chEvtWaitOneTimeout(ALL_EVENTS, TIME_MS2I(50));
 80069c6:	f44f 71fa 	mov.w	r1, #500	; 0x1f4
  test_set_step(2);
 80069ca:	2302      	movs	r3, #2
    m = chEvtWaitOneTimeout(ALL_EVENTS, TIME_MS2I(50));
 80069cc:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
  test_set_step(2);
 80069d0:	6023      	str	r3, [r4, #0]
    m = chEvtWaitOneTimeout(ALL_EVENTS, TIME_MS2I(50));
 80069d2:	f7fc f825 	bl	8002a20 <chEvtWaitOneTimeout>
    test_assert(m == 0, "spurious event");
 80069d6:	fab0 f080 	clz	r0, r0
 80069da:	4912      	ldr	r1, [pc, #72]	; (8006a24 <rt_test_010_006_execute+0xb4>)
 80069dc:	0940      	lsrs	r0, r0, #5
 80069de:	f7fd fc9f 	bl	8004320 <__test_assert>
 80069e2:	2800      	cmp	r0, #0
 80069e4:	d1d4      	bne.n	8006990 <rt_test_010_006_execute+0x20>
    m = chEvtWaitAnyTimeout(ALL_EVENTS, TIME_MS2I(50));
 80069e6:	f44f 71fa 	mov.w	r1, #500	; 0x1f4
 80069ea:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
 80069ee:	f7fc f83f 	bl	8002a70 <chEvtWaitAnyTimeout>
    test_assert(m == 0, "spurious event");
 80069f2:	fab0 f080 	clz	r0, r0
 80069f6:	490b      	ldr	r1, [pc, #44]	; (8006a24 <rt_test_010_006_execute+0xb4>)
 80069f8:	0940      	lsrs	r0, r0, #5
 80069fa:	f7fd fc91 	bl	8004320 <__test_assert>
 80069fe:	2800      	cmp	r0, #0
 8006a00:	d1c6      	bne.n	8006990 <rt_test_010_006_execute+0x20>
    m = chEvtWaitAllTimeout(ALL_EVENTS, TIME_MS2I(50));
 8006a02:	f44f 71fa 	mov.w	r1, #500	; 0x1f4
 8006a06:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
 8006a0a:	f7fc f859 	bl	8002ac0 <chEvtWaitAllTimeout>
    test_assert(m == 0, "spurious event");
 8006a0e:	fab0 f080 	clz	r0, r0
}
 8006a12:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    test_assert(m == 0, "spurious event");
 8006a16:	4903      	ldr	r1, [pc, #12]	; (8006a24 <rt_test_010_006_execute+0xb4>)
 8006a18:	0940      	lsrs	r0, r0, #5
 8006a1a:	f7fd bc81 	b.w	8004320 <__test_assert>
 8006a1e:	bf00      	nop
 8006a20:	20000c70 	.word	0x20000c70
 8006a24:	0800bc74 	.word	0x0800bc74
	...

08006a30 <rt_test_010_005_execute>:
static void rt_test_010_005_execute(void) {
 8006a30:	b530      	push	{r4, r5, lr}
  test_set_step(1);
 8006a32:	4c32      	ldr	r4, [pc, #200]	; (8006afc <rt_test_010_005_execute+0xcc>)
static void rt_test_010_005_execute(void) {
 8006a34:	b083      	sub	sp, #12
  test_set_step(1);
 8006a36:	2301      	movs	r3, #1
    chEvtAddEvents(5);
 8006a38:	2005      	movs	r0, #5
  test_set_step(1);
 8006a3a:	6023      	str	r3, [r4, #0]
    chEvtAddEvents(5);
 8006a3c:	f7fb fef8 	bl	8002830 <chEvtAddEvents>
  test_set_step(2);
 8006a40:	2302      	movs	r3, #2
    m = chEvtWaitAll(5);
 8006a42:	2005      	movs	r0, #5
  test_set_step(2);
 8006a44:	6023      	str	r3, [r4, #0]
    m = chEvtWaitAll(5);
 8006a46:	f7fb ffcb 	bl	80029e0 <chEvtWaitAll>
    test_assert(m == 5, "unexpected pending bit");
 8006a4a:	f1a0 0005 	sub.w	r0, r0, #5
 8006a4e:	fab0 f080 	clz	r0, r0
 8006a52:	492b      	ldr	r1, [pc, #172]	; (8006b00 <rt_test_010_005_execute+0xd0>)
 8006a54:	0940      	lsrs	r0, r0, #5
 8006a56:	f7fd fc63 	bl	8004320 <__test_assert>
 8006a5a:	b108      	cbz	r0, 8006a60 <rt_test_010_005_execute+0x30>
}
 8006a5c:	b003      	add	sp, #12
 8006a5e:	bd30      	pop	{r4, r5, pc}
    m = chEvtGetAndClearEvents(ALL_EVENTS);
 8006a60:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
 8006a64:	f7fb fecc 	bl	8002800 <chEvtGetAndClearEvents>
    test_assert(m == 0, "stuck event");
 8006a68:	fab0 f080 	clz	r0, r0
 8006a6c:	4925      	ldr	r1, [pc, #148]	; (8006b04 <rt_test_010_005_execute+0xd4>)
 8006a6e:	0940      	lsrs	r0, r0, #5
 8006a70:	f7fd fc56 	bl	8004320 <__test_assert>
 8006a74:	2800      	cmp	r0, #0
 8006a76:	d1f1      	bne.n	8006a5c <rt_test_010_005_execute+0x2c>
  test_set_step(3);
 8006a78:	2303      	movs	r3, #3
    chEvtAddEvents(4);
 8006a7a:	2004      	movs	r0, #4
  test_set_step(3);
 8006a7c:	6023      	str	r3, [r4, #0]
    chEvtAddEvents(4);
 8006a7e:	f7fb fed7 	bl	8002830 <chEvtAddEvents>
  test_set_step(4);
 8006a82:	2304      	movs	r3, #4
 8006a84:	6023      	str	r3, [r4, #0]
    target_time = chTimeAddX(test_wait_tick(), TIME_MS2I(50));
 8006a86:	f7fd ff0b 	bl	80048a0 <test_wait_tick>
  return __sch_get_currthread();
 8006a8a:	4b1f      	ldr	r3, [pc, #124]	; (8006b08 <rt_test_010_005_execute+0xd8>)
 8006a8c:	68d9      	ldr	r1, [r3, #12]
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX() - 1,
 8006a8e:	4b1f      	ldr	r3, [pc, #124]	; (8006b0c <rt_test_010_005_execute+0xdc>)
 8006a90:	688a      	ldr	r2, [r1, #8]
 8006a92:	9100      	str	r1, [sp, #0]
    target_time = chTimeAddX(test_wait_tick(), TIME_MS2I(50));
 8006a94:	4605      	mov	r5, r0
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX() - 1,
 8006a96:	481e      	ldr	r0, [pc, #120]	; (8006b10 <rt_test_010_005_execute+0xe0>)
 8006a98:	f44f 71b8 	mov.w	r1, #368	; 0x170
 8006a9c:	3a01      	subs	r2, #1
 8006a9e:	6800      	ldr	r0, [r0, #0]
 8006aa0:	f7fb f986 	bl	8001db0 <chThdCreateStatic>
 8006aa4:	4b1b      	ldr	r3, [pc, #108]	; (8006b14 <rt_test_010_005_execute+0xe4>)
 8006aa6:	4602      	mov	r2, r0
 8006aa8:	601a      	str	r2, [r3, #0]
  test_set_step(5);
 8006aaa:	2005      	movs	r0, #5
 8006aac:	6020      	str	r0, [r4, #0]
    m = chEvtWaitAll(5);
 8006aae:	f7fb ff97 	bl	80029e0 <chEvtWaitAll>
    test_assert_time_window(target_time,
 8006ab2:	4a19      	ldr	r2, [pc, #100]	; (8006b18 <rt_test_010_005_execute+0xe8>)
    m = chEvtWaitAll(5);
 8006ab4:	4604      	mov	r4, r0
    test_assert_time_window(target_time,
 8006ab6:	f505 7102 	add.w	r1, r5, #520	; 0x208
 8006aba:	f505 70fa 	add.w	r0, r5, #500	; 0x1f4
 8006abe:	f7fd fc5f 	bl	8004380 <__test_assert_time_window>
 8006ac2:	2800      	cmp	r0, #0
 8006ac4:	d1ca      	bne.n	8006a5c <rt_test_010_005_execute+0x2c>
    test_assert(m == 5, "event flags error");
 8006ac6:	f1a4 0005 	sub.w	r0, r4, #5
 8006aca:	fab0 f080 	clz	r0, r0
 8006ace:	4913      	ldr	r1, [pc, #76]	; (8006b1c <rt_test_010_005_execute+0xec>)
 8006ad0:	0940      	lsrs	r0, r0, #5
 8006ad2:	f7fd fc25 	bl	8004320 <__test_assert>
 8006ad6:	2800      	cmp	r0, #0
 8006ad8:	d1c0      	bne.n	8006a5c <rt_test_010_005_execute+0x2c>
    m = chEvtGetAndClearEvents(ALL_EVENTS);
 8006ada:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
 8006ade:	f7fb fe8f 	bl	8002800 <chEvtGetAndClearEvents>
    test_assert(m == 0, "stuck event");
 8006ae2:	fab0 f080 	clz	r0, r0
 8006ae6:	4907      	ldr	r1, [pc, #28]	; (8006b04 <rt_test_010_005_execute+0xd4>)
 8006ae8:	0940      	lsrs	r0, r0, #5
 8006aea:	f7fd fc19 	bl	8004320 <__test_assert>
 8006aee:	2800      	cmp	r0, #0
 8006af0:	d1b4      	bne.n	8006a5c <rt_test_010_005_execute+0x2c>
}
 8006af2:	b003      	add	sp, #12
 8006af4:	e8bd 4030 	ldmia.w	sp!, {r4, r5, lr}
    test_wait_threads();
 8006af8:	f7fd beba 	b.w	8004870 <test_wait_threads>
 8006afc:	20000c70 	.word	0x20000c70
 8006b00:	0800bc84 	.word	0x0800bc84
 8006b04:	0800bc4c 	.word	0x0800bc4c
 8006b08:	20000a40 	.word	0x20000a40
 8006b0c:	080068f1 	.word	0x080068f1
 8006b10:	0800aab8 	.word	0x0800aab8
 8006b14:	200013c8 	.word	0x200013c8
 8006b18:	0800b680 	.word	0x0800b680
 8006b1c:	0800bc9c 	.word	0x0800bc9c

08006b20 <rt_test_010_004_execute>:
static void rt_test_010_004_execute(void) {
 8006b20:	b530      	push	{r4, r5, lr}
  test_set_step(1);
 8006b22:	4c31      	ldr	r4, [pc, #196]	; (8006be8 <rt_test_010_004_execute+0xc8>)
static void rt_test_010_004_execute(void) {
 8006b24:	b083      	sub	sp, #12
  test_set_step(1);
 8006b26:	2301      	movs	r3, #1
    chEvtAddEvents(5);
 8006b28:	2005      	movs	r0, #5
  test_set_step(1);
 8006b2a:	6023      	str	r3, [r4, #0]
    chEvtAddEvents(5);
 8006b2c:	f7fb fe80 	bl	8002830 <chEvtAddEvents>
  test_set_step(2);
 8006b30:	2302      	movs	r3, #2
    m = chEvtWaitAny(ALL_EVENTS);
 8006b32:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
  test_set_step(2);
 8006b36:	6023      	str	r3, [r4, #0]
    m = chEvtWaitAny(ALL_EVENTS);
 8006b38:	f7fb ff32 	bl	80029a0 <chEvtWaitAny>
    test_assert(m == 5, "unexpected pending bit");
 8006b3c:	f1a0 0005 	sub.w	r0, r0, #5
 8006b40:	fab0 f080 	clz	r0, r0
 8006b44:	4929      	ldr	r1, [pc, #164]	; (8006bec <rt_test_010_004_execute+0xcc>)
 8006b46:	0940      	lsrs	r0, r0, #5
 8006b48:	f7fd fbea 	bl	8004320 <__test_assert>
 8006b4c:	b108      	cbz	r0, 8006b52 <rt_test_010_004_execute+0x32>
}
 8006b4e:	b003      	add	sp, #12
 8006b50:	bd30      	pop	{r4, r5, pc}
    m = chEvtGetAndClearEvents(ALL_EVENTS);
 8006b52:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
 8006b56:	f7fb fe53 	bl	8002800 <chEvtGetAndClearEvents>
    test_assert(m == 0, "stuck event");
 8006b5a:	fab0 f080 	clz	r0, r0
 8006b5e:	4924      	ldr	r1, [pc, #144]	; (8006bf0 <rt_test_010_004_execute+0xd0>)
 8006b60:	0940      	lsrs	r0, r0, #5
 8006b62:	f7fd fbdd 	bl	8004320 <__test_assert>
 8006b66:	2800      	cmp	r0, #0
 8006b68:	d1f1      	bne.n	8006b4e <rt_test_010_004_execute+0x2e>
  test_set_step(3);
 8006b6a:	2303      	movs	r3, #3
 8006b6c:	6023      	str	r3, [r4, #0]
    target_time = chTimeAddX(test_wait_tick(), TIME_MS2I(50));
 8006b6e:	f7fd fe97 	bl	80048a0 <test_wait_tick>
 8006b72:	4b20      	ldr	r3, [pc, #128]	; (8006bf4 <rt_test_010_004_execute+0xd4>)
 8006b74:	68d9      	ldr	r1, [r3, #12]
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX() - 1,
 8006b76:	4b20      	ldr	r3, [pc, #128]	; (8006bf8 <rt_test_010_004_execute+0xd8>)
 8006b78:	688a      	ldr	r2, [r1, #8]
 8006b7a:	9100      	str	r1, [sp, #0]
    target_time = chTimeAddX(test_wait_tick(), TIME_MS2I(50));
 8006b7c:	4605      	mov	r5, r0
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX() - 1,
 8006b7e:	481f      	ldr	r0, [pc, #124]	; (8006bfc <rt_test_010_004_execute+0xdc>)
 8006b80:	f44f 71b8 	mov.w	r1, #368	; 0x170
 8006b84:	3a01      	subs	r2, #1
 8006b86:	6800      	ldr	r0, [r0, #0]
 8006b88:	f7fb f912 	bl	8001db0 <chThdCreateStatic>
 8006b8c:	4a1c      	ldr	r2, [pc, #112]	; (8006c00 <rt_test_010_004_execute+0xe0>)
  test_set_step(4);
 8006b8e:	2304      	movs	r3, #4
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX() - 1,
 8006b90:	6010      	str	r0, [r2, #0]
    m = chEvtWaitAny(ALL_EVENTS);
 8006b92:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
  test_set_step(4);
 8006b96:	6023      	str	r3, [r4, #0]
    m = chEvtWaitAny(ALL_EVENTS);
 8006b98:	f7fb ff02 	bl	80029a0 <chEvtWaitAny>
    test_assert_time_window(target_time,
 8006b9c:	4a19      	ldr	r2, [pc, #100]	; (8006c04 <rt_test_010_004_execute+0xe4>)
    m = chEvtWaitAny(ALL_EVENTS);
 8006b9e:	4604      	mov	r4, r0
    test_assert_time_window(target_time,
 8006ba0:	f505 7102 	add.w	r1, r5, #520	; 0x208
 8006ba4:	f505 70fa 	add.w	r0, r5, #500	; 0x1f4
 8006ba8:	f7fd fbea 	bl	8004380 <__test_assert_time_window>
 8006bac:	2800      	cmp	r0, #0
 8006bae:	d1ce      	bne.n	8006b4e <rt_test_010_004_execute+0x2e>
    test_assert(m == 1, "event flag error");
 8006bb0:	f1a4 0001 	sub.w	r0, r4, #1
 8006bb4:	fab0 f080 	clz	r0, r0
 8006bb8:	4913      	ldr	r1, [pc, #76]	; (8006c08 <rt_test_010_004_execute+0xe8>)
 8006bba:	0940      	lsrs	r0, r0, #5
 8006bbc:	f7fd fbb0 	bl	8004320 <__test_assert>
 8006bc0:	2800      	cmp	r0, #0
 8006bc2:	d1c4      	bne.n	8006b4e <rt_test_010_004_execute+0x2e>
    m = chEvtGetAndClearEvents(ALL_EVENTS);
 8006bc4:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
 8006bc8:	f7fb fe1a 	bl	8002800 <chEvtGetAndClearEvents>
    test_assert(m == 0, "stuck event");
 8006bcc:	fab0 f080 	clz	r0, r0
 8006bd0:	4907      	ldr	r1, [pc, #28]	; (8006bf0 <rt_test_010_004_execute+0xd0>)
 8006bd2:	0940      	lsrs	r0, r0, #5
 8006bd4:	f7fd fba4 	bl	8004320 <__test_assert>
 8006bd8:	2800      	cmp	r0, #0
 8006bda:	d1b8      	bne.n	8006b4e <rt_test_010_004_execute+0x2e>
}
 8006bdc:	b003      	add	sp, #12
 8006bde:	e8bd 4030 	ldmia.w	sp!, {r4, r5, lr}
    test_wait_threads();
 8006be2:	f7fd be45 	b.w	8004870 <test_wait_threads>
 8006be6:	bf00      	nop
 8006be8:	20000c70 	.word	0x20000c70
 8006bec:	0800bc84 	.word	0x0800bc84
 8006bf0:	0800bc4c 	.word	0x0800bc4c
 8006bf4:	20000a40 	.word	0x20000a40
 8006bf8:	080068f1 	.word	0x080068f1
 8006bfc:	0800aab8 	.word	0x0800aab8
 8006c00:	200013c8 	.word	0x200013c8
 8006c04:	0800b680 	.word	0x0800b680
 8006c08:	0800bcb0 	.word	0x0800bcb0
 8006c0c:	00000000 	.word	0x00000000

08006c10 <rt_test_010_003_execute>:
static void rt_test_010_003_execute(void) {
 8006c10:	b530      	push	{r4, r5, lr}
  test_set_step(1);
 8006c12:	4c3f      	ldr	r4, [pc, #252]	; (8006d10 <rt_test_010_003_execute+0x100>)
static void rt_test_010_003_execute(void) {
 8006c14:	b083      	sub	sp, #12
  test_set_step(1);
 8006c16:	2301      	movs	r3, #1
    chEvtAddEvents(7);
 8006c18:	2007      	movs	r0, #7
  test_set_step(1);
 8006c1a:	6023      	str	r3, [r4, #0]
    chEvtAddEvents(7);
 8006c1c:	f7fb fe08 	bl	8002830 <chEvtAddEvents>
  test_set_step(2);
 8006c20:	2302      	movs	r3, #2
    m = chEvtWaitOne(ALL_EVENTS);
 8006c22:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
  test_set_step(2);
 8006c26:	6023      	str	r3, [r4, #0]
    m = chEvtWaitOne(ALL_EVENTS);
 8006c28:	f7fb fe9a 	bl	8002960 <chEvtWaitOne>
    test_assert(m == 1, "single event error");
 8006c2c:	f1a0 0001 	sub.w	r0, r0, #1
 8006c30:	fab0 f080 	clz	r0, r0
 8006c34:	4937      	ldr	r1, [pc, #220]	; (8006d14 <rt_test_010_003_execute+0x104>)
 8006c36:	0940      	lsrs	r0, r0, #5
 8006c38:	f7fd fb72 	bl	8004320 <__test_assert>
 8006c3c:	b108      	cbz	r0, 8006c42 <rt_test_010_003_execute+0x32>
}
 8006c3e:	b003      	add	sp, #12
 8006c40:	bd30      	pop	{r4, r5, pc}
    m = chEvtWaitOne(ALL_EVENTS);
 8006c42:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
 8006c46:	f7fb fe8b 	bl	8002960 <chEvtWaitOne>
    test_assert(m == 2, "single event error");
 8006c4a:	f1a0 0002 	sub.w	r0, r0, #2
 8006c4e:	fab0 f080 	clz	r0, r0
 8006c52:	4930      	ldr	r1, [pc, #192]	; (8006d14 <rt_test_010_003_execute+0x104>)
 8006c54:	0940      	lsrs	r0, r0, #5
 8006c56:	f7fd fb63 	bl	8004320 <__test_assert>
 8006c5a:	2800      	cmp	r0, #0
 8006c5c:	d1ef      	bne.n	8006c3e <rt_test_010_003_execute+0x2e>
    m = chEvtWaitOne(ALL_EVENTS);
 8006c5e:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
 8006c62:	f7fb fe7d 	bl	8002960 <chEvtWaitOne>
    test_assert(m == 4, "single event error");
 8006c66:	f1a0 0004 	sub.w	r0, r0, #4
 8006c6a:	fab0 f080 	clz	r0, r0
 8006c6e:	4929      	ldr	r1, [pc, #164]	; (8006d14 <rt_test_010_003_execute+0x104>)
 8006c70:	0940      	lsrs	r0, r0, #5
 8006c72:	f7fd fb55 	bl	8004320 <__test_assert>
 8006c76:	2800      	cmp	r0, #0
 8006c78:	d1e1      	bne.n	8006c3e <rt_test_010_003_execute+0x2e>
    m = chEvtGetAndClearEvents(ALL_EVENTS);
 8006c7a:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
 8006c7e:	f7fb fdbf 	bl	8002800 <chEvtGetAndClearEvents>
    test_assert(m == 0, "stuck event");
 8006c82:	fab0 f080 	clz	r0, r0
 8006c86:	4924      	ldr	r1, [pc, #144]	; (8006d18 <rt_test_010_003_execute+0x108>)
 8006c88:	0940      	lsrs	r0, r0, #5
 8006c8a:	f7fd fb49 	bl	8004320 <__test_assert>
 8006c8e:	2800      	cmp	r0, #0
 8006c90:	d1d5      	bne.n	8006c3e <rt_test_010_003_execute+0x2e>
  test_set_step(3);
 8006c92:	2303      	movs	r3, #3
 8006c94:	6023      	str	r3, [r4, #0]
    target_time = chTimeAddX(test_wait_tick(), TIME_MS2I(50));
 8006c96:	f7fd fe03 	bl	80048a0 <test_wait_tick>
 8006c9a:	4b20      	ldr	r3, [pc, #128]	; (8006d1c <rt_test_010_003_execute+0x10c>)
 8006c9c:	68d9      	ldr	r1, [r3, #12]
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX() - 1,
 8006c9e:	4b20      	ldr	r3, [pc, #128]	; (8006d20 <rt_test_010_003_execute+0x110>)
 8006ca0:	688a      	ldr	r2, [r1, #8]
 8006ca2:	9100      	str	r1, [sp, #0]
    target_time = chTimeAddX(test_wait_tick(), TIME_MS2I(50));
 8006ca4:	4605      	mov	r5, r0
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX() - 1,
 8006ca6:	481f      	ldr	r0, [pc, #124]	; (8006d24 <rt_test_010_003_execute+0x114>)
 8006ca8:	f44f 71b8 	mov.w	r1, #368	; 0x170
 8006cac:	3a01      	subs	r2, #1
 8006cae:	6800      	ldr	r0, [r0, #0]
 8006cb0:	f7fb f87e 	bl	8001db0 <chThdCreateStatic>
 8006cb4:	4a1c      	ldr	r2, [pc, #112]	; (8006d28 <rt_test_010_003_execute+0x118>)
  test_set_step(4);
 8006cb6:	2304      	movs	r3, #4
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX() - 1,
 8006cb8:	6010      	str	r0, [r2, #0]
    m = chEvtWaitOne(ALL_EVENTS);
 8006cba:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
  test_set_step(4);
 8006cbe:	6023      	str	r3, [r4, #0]
    m = chEvtWaitOne(ALL_EVENTS);
 8006cc0:	f7fb fe4e 	bl	8002960 <chEvtWaitOne>
    test_assert_time_window(target_time,
 8006cc4:	4a19      	ldr	r2, [pc, #100]	; (8006d2c <rt_test_010_003_execute+0x11c>)
    m = chEvtWaitOne(ALL_EVENTS);
 8006cc6:	4604      	mov	r4, r0
    test_assert_time_window(target_time,
 8006cc8:	f505 7102 	add.w	r1, r5, #520	; 0x208
 8006ccc:	f505 70fa 	add.w	r0, r5, #500	; 0x1f4
 8006cd0:	f7fd fb56 	bl	8004380 <__test_assert_time_window>
 8006cd4:	2800      	cmp	r0, #0
 8006cd6:	d1b2      	bne.n	8006c3e <rt_test_010_003_execute+0x2e>
    test_assert(m == 1, "event flag error");
 8006cd8:	f1a4 0001 	sub.w	r0, r4, #1
 8006cdc:	fab0 f080 	clz	r0, r0
 8006ce0:	4913      	ldr	r1, [pc, #76]	; (8006d30 <rt_test_010_003_execute+0x120>)
 8006ce2:	0940      	lsrs	r0, r0, #5
 8006ce4:	f7fd fb1c 	bl	8004320 <__test_assert>
 8006ce8:	2800      	cmp	r0, #0
 8006cea:	d1a8      	bne.n	8006c3e <rt_test_010_003_execute+0x2e>
    m = chEvtGetAndClearEvents(ALL_EVENTS);
 8006cec:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
 8006cf0:	f7fb fd86 	bl	8002800 <chEvtGetAndClearEvents>
    test_assert(m == 0, "stuck event");
 8006cf4:	fab0 f080 	clz	r0, r0
 8006cf8:	4907      	ldr	r1, [pc, #28]	; (8006d18 <rt_test_010_003_execute+0x108>)
 8006cfa:	0940      	lsrs	r0, r0, #5
 8006cfc:	f7fd fb10 	bl	8004320 <__test_assert>
 8006d00:	2800      	cmp	r0, #0
 8006d02:	d19c      	bne.n	8006c3e <rt_test_010_003_execute+0x2e>
}
 8006d04:	b003      	add	sp, #12
 8006d06:	e8bd 4030 	ldmia.w	sp!, {r4, r5, lr}
    test_wait_threads();
 8006d0a:	f7fd bdb1 	b.w	8004870 <test_wait_threads>
 8006d0e:	bf00      	nop
 8006d10:	20000c70 	.word	0x20000c70
 8006d14:	0800bcc4 	.word	0x0800bcc4
 8006d18:	0800bc4c 	.word	0x0800bc4c
 8006d1c:	20000a40 	.word	0x20000a40
 8006d20:	080068f1 	.word	0x080068f1
 8006d24:	0800aab8 	.word	0x0800aab8
 8006d28:	200013c8 	.word	0x200013c8
 8006d2c:	0800b680 	.word	0x0800b680
 8006d30:	0800bcb0 	.word	0x0800bcb0
	...

08006d40 <rt_test_010_006_setup>:
 8006d40:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
 8006d44:	f7fb bd5c 	b.w	8002800 <chEvtGetAndClearEvents>
	...

08006d50 <rt_test_010_003_setup>:
 8006d50:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
 8006d54:	f7fb bd54 	b.w	8002800 <chEvtGetAndClearEvents>
	...

08006d60 <rt_test_010_004_setup>:
 8006d60:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
 8006d64:	f7fb bd4c 	b.w	8002800 <chEvtGetAndClearEvents>
	...

08006d70 <rt_test_010_005_setup>:
 8006d70:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
 8006d74:	f7fb bd44 	b.w	8002800 <chEvtGetAndClearEvents>
	...

08006d80 <rt_test_011_002_execute>:

static void rt_test_011_002_setup(void) {
  chPoolObjectInit(&mp1, THD_WORKING_AREA_SIZE(THREADS_STACK_SIZE), NULL);
}

static void rt_test_011_002_execute(void) {
 8006d80:	b5f0      	push	{r4, r5, r6, r7, lr}
  unsigned i;
  tprio_t prio;

  /* [11.2.1] Adding four working areas to the pool.*/
  test_set_step(1);
 8006d82:	4d44      	ldr	r5, [pc, #272]	; (8006e94 <rt_test_011_002_execute+0x114>)
 8006d84:	4c44      	ldr	r4, [pc, #272]	; (8006e98 <rt_test_011_002_execute+0x118>)
  {
    for (i = 0; i < 4; i++)
      chPoolFree(&mp1, wa[i]);
 8006d86:	4f45      	ldr	r7, [pc, #276]	; (8006e9c <rt_test_011_002_execute+0x11c>)
  test_set_step(1);
 8006d88:	2301      	movs	r3, #1
static void rt_test_011_002_execute(void) {
 8006d8a:	b083      	sub	sp, #12
  test_set_step(1);
 8006d8c:	602b      	str	r3, [r5, #0]
    for (i = 0; i < 4; i++)
 8006d8e:	f104 0610 	add.w	r6, r4, #16
      chPoolFree(&mp1, wa[i]);
 8006d92:	f854 1b04 	ldr.w	r1, [r4], #4
 8006d96:	4638      	mov	r0, r7
 8006d98:	f7fc fa82 	bl	80032a0 <chPoolFree>
    for (i = 0; i < 4; i++)
 8006d9c:	42a6      	cmp	r6, r4
 8006d9e:	d1f8      	bne.n	8006d92 <rt_test_011_002_execute+0x12>
 8006da0:	4b3f      	ldr	r3, [pc, #252]	; (8006ea0 <rt_test_011_002_execute+0x120>)
  test_end_step(2);

  /* [11.2.3] Creating the five threads.*/
  test_set_step(3);
  {
    threads[0] = chThdCreateFromMemoryPool(&mp1, "dyn1", prio-1, dyn_thread1, "A");
 8006da2:	4a40      	ldr	r2, [pc, #256]	; (8006ea4 <rt_test_011_002_execute+0x124>)
  return chThdGetSelfX()->hdr.pqueue.prio;
 8006da4:	68d9      	ldr	r1, [r3, #12]
 8006da6:	483d      	ldr	r0, [pc, #244]	; (8006e9c <rt_test_011_002_execute+0x11c>)
 8006da8:	688e      	ldr	r6, [r1, #8]
 8006daa:	4b3f      	ldr	r3, [pc, #252]	; (8006ea8 <rt_test_011_002_execute+0x128>)
 8006dac:	9200      	str	r2, [sp, #0]
  test_set_step(3);
 8006dae:	2103      	movs	r1, #3
    threads[0] = chThdCreateFromMemoryPool(&mp1, "dyn1", prio-1, dyn_thread1, "A");
 8006db0:	1e72      	subs	r2, r6, #1
  test_set_step(3);
 8006db2:	6029      	str	r1, [r5, #0]
    threads[0] = chThdCreateFromMemoryPool(&mp1, "dyn1", prio-1, dyn_thread1, "A");
 8006db4:	493d      	ldr	r1, [pc, #244]	; (8006eac <rt_test_011_002_execute+0x12c>)
 8006db6:	4c3e      	ldr	r4, [pc, #248]	; (8006eb0 <rt_test_011_002_execute+0x130>)
 8006db8:	f7fb ff1a 	bl	8002bf0 <chThdCreateFromMemoryPool>
    threads[1] = chThdCreateFromMemoryPool(&mp1, "dyn2", prio-2, dyn_thread1, "B");
 8006dbc:	4b3d      	ldr	r3, [pc, #244]	; (8006eb4 <rt_test_011_002_execute+0x134>)
 8006dbe:	9300      	str	r3, [sp, #0]
 8006dc0:	493d      	ldr	r1, [pc, #244]	; (8006eb8 <rt_test_011_002_execute+0x138>)
 8006dc2:	4b39      	ldr	r3, [pc, #228]	; (8006ea8 <rt_test_011_002_execute+0x128>)
    threads[0] = chThdCreateFromMemoryPool(&mp1, "dyn1", prio-1, dyn_thread1, "A");
 8006dc4:	6020      	str	r0, [r4, #0]
    threads[1] = chThdCreateFromMemoryPool(&mp1, "dyn2", prio-2, dyn_thread1, "B");
 8006dc6:	1eb2      	subs	r2, r6, #2
 8006dc8:	4834      	ldr	r0, [pc, #208]	; (8006e9c <rt_test_011_002_execute+0x11c>)
 8006dca:	f7fb ff11 	bl	8002bf0 <chThdCreateFromMemoryPool>
    threads[2] = chThdCreateFromMemoryPool(&mp1, "dyn3", prio-3, dyn_thread1, "C");
 8006dce:	4b3b      	ldr	r3, [pc, #236]	; (8006ebc <rt_test_011_002_execute+0x13c>)
 8006dd0:	9300      	str	r3, [sp, #0]
 8006dd2:	493b      	ldr	r1, [pc, #236]	; (8006ec0 <rt_test_011_002_execute+0x140>)
 8006dd4:	4b34      	ldr	r3, [pc, #208]	; (8006ea8 <rt_test_011_002_execute+0x128>)
    threads[1] = chThdCreateFromMemoryPool(&mp1, "dyn2", prio-2, dyn_thread1, "B");
 8006dd6:	6060      	str	r0, [r4, #4]
    threads[2] = chThdCreateFromMemoryPool(&mp1, "dyn3", prio-3, dyn_thread1, "C");
 8006dd8:	1ef2      	subs	r2, r6, #3
 8006dda:	4830      	ldr	r0, [pc, #192]	; (8006e9c <rt_test_011_002_execute+0x11c>)
 8006ddc:	f7fb ff08 	bl	8002bf0 <chThdCreateFromMemoryPool>
    threads[3] = chThdCreateFromMemoryPool(&mp1, "dyn4", prio-4, dyn_thread1, "D");
 8006de0:	4b38      	ldr	r3, [pc, #224]	; (8006ec4 <rt_test_011_002_execute+0x144>)
 8006de2:	9300      	str	r3, [sp, #0]
 8006de4:	4938      	ldr	r1, [pc, #224]	; (8006ec8 <rt_test_011_002_execute+0x148>)
 8006de6:	4b30      	ldr	r3, [pc, #192]	; (8006ea8 <rt_test_011_002_execute+0x128>)
    threads[2] = chThdCreateFromMemoryPool(&mp1, "dyn3", prio-3, dyn_thread1, "C");
 8006de8:	60a0      	str	r0, [r4, #8]
    threads[3] = chThdCreateFromMemoryPool(&mp1, "dyn4", prio-4, dyn_thread1, "D");
 8006dea:	1f32      	subs	r2, r6, #4
 8006dec:	482b      	ldr	r0, [pc, #172]	; (8006e9c <rt_test_011_002_execute+0x11c>)
 8006dee:	f7fb feff 	bl	8002bf0 <chThdCreateFromMemoryPool>
    threads[4] = chThdCreateFromMemoryPool(&mp1, "dyn5", prio-5, dyn_thread1, "E");
 8006df2:	4b36      	ldr	r3, [pc, #216]	; (8006ecc <rt_test_011_002_execute+0x14c>)
 8006df4:	9300      	str	r3, [sp, #0]
 8006df6:	1f72      	subs	r2, r6, #5
 8006df8:	4b2b      	ldr	r3, [pc, #172]	; (8006ea8 <rt_test_011_002_execute+0x128>)
    threads[3] = chThdCreateFromMemoryPool(&mp1, "dyn4", prio-4, dyn_thread1, "D");
 8006dfa:	60e0      	str	r0, [r4, #12]
    threads[4] = chThdCreateFromMemoryPool(&mp1, "dyn5", prio-5, dyn_thread1, "E");
 8006dfc:	4934      	ldr	r1, [pc, #208]	; (8006ed0 <rt_test_011_002_execute+0x150>)
 8006dfe:	4827      	ldr	r0, [pc, #156]	; (8006e9c <rt_test_011_002_execute+0x11c>)
 8006e00:	f7fb fef6 	bl	8002bf0 <chThdCreateFromMemoryPool>
  test_end_step(3);

  /* [11.2.4] Testing that only the fifth thread creation failed.*/
  test_set_step(4);
  {
    test_assert((threads[0] != NULL) &&
 8006e04:	6823      	ldr	r3, [r4, #0]
    threads[4] = chThdCreateFromMemoryPool(&mp1, "dyn5", prio-5, dyn_thread1, "E");
 8006e06:	6120      	str	r0, [r4, #16]
  test_set_step(4);
 8006e08:	2204      	movs	r2, #4
 8006e0a:	602a      	str	r2, [r5, #0]
    test_assert((threads[0] != NULL) &&
 8006e0c:	2b00      	cmp	r3, #0
 8006e0e:	d03e      	beq.n	8006e8e <rt_test_011_002_execute+0x10e>
 8006e10:	6860      	ldr	r0, [r4, #4]
 8006e12:	b128      	cbz	r0, 8006e20 <rt_test_011_002_execute+0xa0>
 8006e14:	68a0      	ldr	r0, [r4, #8]
 8006e16:	b118      	cbz	r0, 8006e20 <rt_test_011_002_execute+0xa0>
 8006e18:	68e0      	ldr	r0, [r4, #12]
 8006e1a:	3800      	subs	r0, #0
 8006e1c:	bf18      	it	ne
 8006e1e:	2001      	movne	r0, #1
 8006e20:	492c      	ldr	r1, [pc, #176]	; (8006ed4 <rt_test_011_002_execute+0x154>)
 8006e22:	f7fd fa7d 	bl	8004320 <__test_assert>
 8006e26:	b108      	cbz	r0, 8006e2c <rt_test_011_002_execute+0xac>
    for (i = 0; i < 4; i++)
      test_assert(chPoolAlloc(&mp1) != NULL, "pool list empty");
    test_assert(chPoolAlloc(&mp1) == NULL, "pool list not empty");
  }
  test_end_step(6);
}
 8006e28:	b003      	add	sp, #12
 8006e2a:	bdf0      	pop	{r4, r5, r6, r7, pc}
    test_assert(threads[4] == NULL,
 8006e2c:	6920      	ldr	r0, [r4, #16]
 8006e2e:	492a      	ldr	r1, [pc, #168]	; (8006ed8 <rt_test_011_002_execute+0x158>)
 8006e30:	fab0 f080 	clz	r0, r0
 8006e34:	0940      	lsrs	r0, r0, #5
 8006e36:	f7fd fa73 	bl	8004320 <__test_assert>
 8006e3a:	2800      	cmp	r0, #0
 8006e3c:	d1f4      	bne.n	8006e28 <rt_test_011_002_execute+0xa8>
  test_set_step(5);
 8006e3e:	2305      	movs	r3, #5
 8006e40:	602b      	str	r3, [r5, #0]
    test_wait_threads();
 8006e42:	f7fd fd15 	bl	8004870 <test_wait_threads>
    test_assert_sequence("ABCD", "invalid sequence");
 8006e46:	4925      	ldr	r1, [pc, #148]	; (8006edc <rt_test_011_002_execute+0x15c>)
 8006e48:	4825      	ldr	r0, [pc, #148]	; (8006ee0 <rt_test_011_002_execute+0x160>)
 8006e4a:	f7fd fa79 	bl	8004340 <__test_assert_sequence>
 8006e4e:	2800      	cmp	r0, #0
 8006e50:	d1ea      	bne.n	8006e28 <rt_test_011_002_execute+0xa8>
  test_set_step(6);
 8006e52:	2306      	movs	r3, #6
      test_assert(chPoolAlloc(&mp1) != NULL, "pool list empty");
 8006e54:	4f11      	ldr	r7, [pc, #68]	; (8006e9c <rt_test_011_002_execute+0x11c>)
 8006e56:	4e23      	ldr	r6, [pc, #140]	; (8006ee4 <rt_test_011_002_execute+0x164>)
  test_set_step(6);
 8006e58:	602b      	str	r3, [r5, #0]
 8006e5a:	2404      	movs	r4, #4
      test_assert(chPoolAlloc(&mp1) != NULL, "pool list empty");
 8006e5c:	4638      	mov	r0, r7
 8006e5e:	f7fc fa07 	bl	8003270 <chPoolAlloc>
 8006e62:	3800      	subs	r0, #0
 8006e64:	bf18      	it	ne
 8006e66:	2001      	movne	r0, #1
 8006e68:	4631      	mov	r1, r6
 8006e6a:	f7fd fa59 	bl	8004320 <__test_assert>
 8006e6e:	2800      	cmp	r0, #0
 8006e70:	d1da      	bne.n	8006e28 <rt_test_011_002_execute+0xa8>
    for (i = 0; i < 4; i++)
 8006e72:	3c01      	subs	r4, #1
 8006e74:	d1f2      	bne.n	8006e5c <rt_test_011_002_execute+0xdc>
    test_assert(chPoolAlloc(&mp1) == NULL, "pool list not empty");
 8006e76:	4809      	ldr	r0, [pc, #36]	; (8006e9c <rt_test_011_002_execute+0x11c>)
 8006e78:	f7fc f9fa 	bl	8003270 <chPoolAlloc>
 8006e7c:	491a      	ldr	r1, [pc, #104]	; (8006ee8 <rt_test_011_002_execute+0x168>)
 8006e7e:	fab0 f080 	clz	r0, r0
 8006e82:	0940      	lsrs	r0, r0, #5
}
 8006e84:	b003      	add	sp, #12
 8006e86:	e8bd 40f0 	ldmia.w	sp!, {r4, r5, r6, r7, lr}
    test_assert(chPoolAlloc(&mp1) == NULL, "pool list not empty");
 8006e8a:	f7fd ba49 	b.w	8004320 <__test_assert>
 8006e8e:	4618      	mov	r0, r3
 8006e90:	e7c6      	b.n	8006e20 <rt_test_011_002_execute+0xa0>
 8006e92:	bf00      	nop
 8006e94:	20000c70 	.word	0x20000c70
 8006e98:	0800aab8 	.word	0x0800aab8
 8006e9c:	20001408 	.word	0x20001408
 8006ea0:	20000a40 	.word	0x20000a40
 8006ea4:	0800b660 	.word	0x0800b660
 8006ea8:	08006ef1 	.word	0x08006ef1
 8006eac:	0800be80 	.word	0x0800be80
 8006eb0:	200013c8 	.word	0x200013c8
 8006eb4:	0800b65c 	.word	0x0800b65c
 8006eb8:	0800be88 	.word	0x0800be88
 8006ebc:	0800b658 	.word	0x0800b658
 8006ec0:	0800be90 	.word	0x0800be90
 8006ec4:	0800b654 	.word	0x0800b654
 8006ec8:	0800be98 	.word	0x0800be98
 8006ecc:	0800b67c 	.word	0x0800b67c
 8006ed0:	0800bea0 	.word	0x0800bea0
 8006ed4:	0800bea8 	.word	0x0800bea8
 8006ed8:	0800bec0 	.word	0x0800bec0
 8006edc:	0800b664 	.word	0x0800b664
 8006ee0:	0800bbf4 	.word	0x0800bbf4
 8006ee4:	0800bedc 	.word	0x0800bedc
 8006ee8:	0800beec 	.word	0x0800beec
 8006eec:	00000000 	.word	0x00000000

08006ef0 <dyn_thread1>:
  test_emit_token(*(char *)p);
 8006ef0:	7800      	ldrb	r0, [r0, #0]
 8006ef2:	f7fd ba5d 	b.w	80043b0 <test_emit_token>
 8006ef6:	bf00      	nop
	...

08006f00 <rt_test_011_002_setup>:
 8006f00:	4803      	ldr	r0, [pc, #12]	; (8006f10 <rt_test_011_002_setup+0x10>)
 8006f02:	2300      	movs	r3, #0
 8006f04:	2204      	movs	r2, #4
 8006f06:	f44f 71b8 	mov.w	r1, #368	; 0x170
 8006f0a:	f7fc b991 	b.w	8003230 <chPoolObjectInitAligned>
 8006f0e:	bf00      	nop
 8006f10:	20001408 	.word	0x20001408
	...

08006f20 <rt_test_011_001_execute>:
static void rt_test_011_001_execute(void) {
 8006f20:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  return __sch_get_currthread();
 8006f24:	4b47      	ldr	r3, [pc, #284]	; (8007044 <rt_test_011_001_execute+0x124>)
  test_set_step(2);
 8006f26:	4d48      	ldr	r5, [pc, #288]	; (8007048 <rt_test_011_001_execute+0x128>)
  return chThdGetSelfX()->hdr.pqueue.prio;
 8006f28:	68db      	ldr	r3, [r3, #12]
    n1 = chHeapStatus(&heap1, &total1, &largest1);
 8006f2a:	4848      	ldr	r0, [pc, #288]	; (800704c <rt_test_011_001_execute+0x12c>)
 8006f2c:	689e      	ldr	r6, [r3, #8]
static void rt_test_011_001_execute(void) {
 8006f2e:	b086      	sub	sp, #24
    n1 = chHeapStatus(&heap1, &total1, &largest1);
 8006f30:	a902      	add	r1, sp, #8
  test_set_step(2);
 8006f32:	2402      	movs	r4, #2
    n1 = chHeapStatus(&heap1, &total1, &largest1);
 8006f34:	aa03      	add	r2, sp, #12
  test_set_step(2);
 8006f36:	602c      	str	r4, [r5, #0]
    n1 = chHeapStatus(&heap1, &total1, &largest1);
 8006f38:	f7fc f942 	bl	80031c0 <chHeapStatus>
 8006f3c:	4604      	mov	r4, r0
    test_assert(n1 == 1, "heap fragmented");
 8006f3e:	f1a0 0001 	sub.w	r0, r0, #1
 8006f42:	fab0 f080 	clz	r0, r0
 8006f46:	4942      	ldr	r1, [pc, #264]	; (8007050 <rt_test_011_001_execute+0x130>)
 8006f48:	0940      	lsrs	r0, r0, #5
 8006f4a:	f7fd f9e9 	bl	8004320 <__test_assert>
 8006f4e:	b110      	cbz	r0, 8006f56 <rt_test_011_001_execute+0x36>
}
 8006f50:	b006      	add	sp, #24
 8006f52:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    threads[0] = chThdCreateFromHeap(&heap1,
 8006f56:	4a3f      	ldr	r2, [pc, #252]	; (8007054 <rt_test_011_001_execute+0x134>)
 8006f58:	f8df 80fc 	ldr.w	r8, [pc, #252]	; 8007058 <rt_test_011_001_execute+0x138>
 8006f5c:	9201      	str	r2, [sp, #4]
  test_set_step(3);
 8006f5e:	2303      	movs	r3, #3
 8006f60:	602b      	str	r3, [r5, #0]
    threads[0] = chThdCreateFromHeap(&heap1,
 8006f62:	f44f 71b8 	mov.w	r1, #368	; 0x170
 8006f66:	4a3d      	ldr	r2, [pc, #244]	; (800705c <rt_test_011_001_execute+0x13c>)
 8006f68:	4838      	ldr	r0, [pc, #224]	; (800704c <rt_test_011_001_execute+0x12c>)
 8006f6a:	f8cd 8000 	str.w	r8, [sp]
 8006f6e:	1e73      	subs	r3, r6, #1
 8006f70:	f7fb fe16 	bl	8002ba0 <chThdCreateFromHeap>
 8006f74:	4f3a      	ldr	r7, [pc, #232]	; (8007060 <rt_test_011_001_execute+0x140>)
    test_assert(threads[0] != NULL, "thread creation failed");
 8006f76:	493b      	ldr	r1, [pc, #236]	; (8007064 <rt_test_011_001_execute+0x144>)
    threads[0] = chThdCreateFromHeap(&heap1,
 8006f78:	6038      	str	r0, [r7, #0]
    test_assert(threads[0] != NULL, "thread creation failed");
 8006f7a:	3800      	subs	r0, #0
 8006f7c:	bf18      	it	ne
 8006f7e:	2001      	movne	r0, #1
 8006f80:	f7fd f9ce 	bl	8004320 <__test_assert>
 8006f84:	2800      	cmp	r0, #0
 8006f86:	d1e3      	bne.n	8006f50 <rt_test_011_001_execute+0x30>
    threads[1] = chThdCreateFromHeap(&heap1,
 8006f88:	4b37      	ldr	r3, [pc, #220]	; (8007068 <rt_test_011_001_execute+0x148>)
 8006f8a:	9301      	str	r3, [sp, #4]
 8006f8c:	f44f 71b8 	mov.w	r1, #368	; 0x170
  test_set_step(4);
 8006f90:	f04f 0c04 	mov.w	ip, #4
    threads[1] = chThdCreateFromHeap(&heap1,
 8006f94:	4a35      	ldr	r2, [pc, #212]	; (800706c <rt_test_011_001_execute+0x14c>)
 8006f96:	482d      	ldr	r0, [pc, #180]	; (800704c <rt_test_011_001_execute+0x12c>)
 8006f98:	f8cd 8000 	str.w	r8, [sp]
 8006f9c:	1eb3      	subs	r3, r6, #2
  test_set_step(4);
 8006f9e:	f8c5 c000 	str.w	ip, [r5]
    threads[1] = chThdCreateFromHeap(&heap1,
 8006fa2:	f7fb fdfd 	bl	8002ba0 <chThdCreateFromHeap>
 8006fa6:	6078      	str	r0, [r7, #4]
    test_assert(threads[1] != NULL, "thread creation failed");
 8006fa8:	3800      	subs	r0, #0
 8006faa:	bf18      	it	ne
 8006fac:	2001      	movne	r0, #1
 8006fae:	492d      	ldr	r1, [pc, #180]	; (8007064 <rt_test_011_001_execute+0x144>)
 8006fb0:	f7fd f9b6 	bl	8004320 <__test_assert>
 8006fb4:	2800      	cmp	r0, #0
 8006fb6:	d1cb      	bne.n	8006f50 <rt_test_011_001_execute+0x30>
    threads[2] = chThdCreateFromHeap(&heap1,
 8006fb8:	492d      	ldr	r1, [pc, #180]	; (8007070 <rt_test_011_001_execute+0x150>)
 8006fba:	9101      	str	r1, [sp, #4]
 8006fbc:	1ef3      	subs	r3, r6, #3
 8006fbe:	f04f 4100 	mov.w	r1, #2147483648	; 0x80000000
  test_set_step(5);
 8006fc2:	2605      	movs	r6, #5
    threads[2] = chThdCreateFromHeap(&heap1,
 8006fc4:	4a2b      	ldr	r2, [pc, #172]	; (8007074 <rt_test_011_001_execute+0x154>)
 8006fc6:	4821      	ldr	r0, [pc, #132]	; (800704c <rt_test_011_001_execute+0x12c>)
 8006fc8:	f8cd 8000 	str.w	r8, [sp]
  test_set_step(5);
 8006fcc:	602e      	str	r6, [r5, #0]
    threads[2] = chThdCreateFromHeap(&heap1,
 8006fce:	f7fb fde7 	bl	8002ba0 <chThdCreateFromHeap>
 8006fd2:	4603      	mov	r3, r0
    test_assert(threads[2] == NULL, "thread creation not failed");
 8006fd4:	fab0 f080 	clz	r0, r0
 8006fd8:	4927      	ldr	r1, [pc, #156]	; (8007078 <rt_test_011_001_execute+0x158>)
    threads[2] = chThdCreateFromHeap(&heap1,
 8006fda:	60bb      	str	r3, [r7, #8]
    test_assert(threads[2] == NULL, "thread creation not failed");
 8006fdc:	40f0      	lsrs	r0, r6
 8006fde:	f7fd f99f 	bl	8004320 <__test_assert>
 8006fe2:	2800      	cmp	r0, #0
 8006fe4:	d1b4      	bne.n	8006f50 <rt_test_011_001_execute+0x30>
  test_set_step(6);
 8006fe6:	2306      	movs	r3, #6
 8006fe8:	602b      	str	r3, [r5, #0]
    test_wait_threads();
 8006fea:	f7fd fc41 	bl	8004870 <test_wait_threads>
    test_assert_sequence("AB", "invalid sequence");
 8006fee:	4923      	ldr	r1, [pc, #140]	; (800707c <rt_test_011_001_execute+0x15c>)
 8006ff0:	4823      	ldr	r0, [pc, #140]	; (8007080 <rt_test_011_001_execute+0x160>)
 8006ff2:	f7fd f9a5 	bl	8004340 <__test_assert_sequence>
 8006ff6:	2800      	cmp	r0, #0
 8006ff8:	d1aa      	bne.n	8006f50 <rt_test_011_001_execute+0x30>
    n2 = chHeapStatus(&heap1, &total2, &largest2);
 8006ffa:	a904      	add	r1, sp, #16
  test_set_step(7);
 8006ffc:	2307      	movs	r3, #7
    n2 = chHeapStatus(&heap1, &total2, &largest2);
 8006ffe:	4813      	ldr	r0, [pc, #76]	; (800704c <rt_test_011_001_execute+0x12c>)
  test_set_step(7);
 8007000:	602b      	str	r3, [r5, #0]
    n2 = chHeapStatus(&heap1, &total2, &largest2);
 8007002:	aa05      	add	r2, sp, #20
 8007004:	f7fc f8dc 	bl	80031c0 <chHeapStatus>
    test_assert(n1 == n2, "fragmentation changed");
 8007008:	1a20      	subs	r0, r4, r0
 800700a:	fab0 f080 	clz	r0, r0
 800700e:	491d      	ldr	r1, [pc, #116]	; (8007084 <rt_test_011_001_execute+0x164>)
 8007010:	0940      	lsrs	r0, r0, #5
 8007012:	f7fd f985 	bl	8004320 <__test_assert>
 8007016:	2800      	cmp	r0, #0
 8007018:	d19a      	bne.n	8006f50 <rt_test_011_001_execute+0x30>
    test_assert(total1 == total2, "total free space changed");
 800701a:	9802      	ldr	r0, [sp, #8]
 800701c:	9b04      	ldr	r3, [sp, #16]
 800701e:	491a      	ldr	r1, [pc, #104]	; (8007088 <rt_test_011_001_execute+0x168>)
 8007020:	1ac0      	subs	r0, r0, r3
 8007022:	fab0 f080 	clz	r0, r0
 8007026:	0940      	lsrs	r0, r0, #5
 8007028:	f7fd f97a 	bl	8004320 <__test_assert>
 800702c:	2800      	cmp	r0, #0
 800702e:	d18f      	bne.n	8006f50 <rt_test_011_001_execute+0x30>
    test_assert(largest1 == largest2, "largest fragment size changed");
 8007030:	9803      	ldr	r0, [sp, #12]
 8007032:	9b05      	ldr	r3, [sp, #20]
 8007034:	4915      	ldr	r1, [pc, #84]	; (800708c <rt_test_011_001_execute+0x16c>)
 8007036:	1ac0      	subs	r0, r0, r3
 8007038:	fab0 f080 	clz	r0, r0
 800703c:	0940      	lsrs	r0, r0, #5
 800703e:	f7fd f96f 	bl	8004320 <__test_assert>
 8007042:	e785      	b.n	8006f50 <rt_test_011_001_execute+0x30>
 8007044:	20000a40 	.word	0x20000a40
 8007048:	20000c70 	.word	0x20000c70
 800704c:	200013ec 	.word	0x200013ec
 8007050:	0800bf00 	.word	0x0800bf00
 8007054:	0800b660 	.word	0x0800b660
 8007058:	08006ef1 	.word	0x08006ef1
 800705c:	0800be80 	.word	0x0800be80
 8007060:	200013c8 	.word	0x200013c8
 8007064:	0800bea8 	.word	0x0800bea8
 8007068:	0800b65c 	.word	0x0800b65c
 800706c:	0800be88 	.word	0x0800be88
 8007070:	0800b658 	.word	0x0800b658
 8007074:	0800be90 	.word	0x0800be90
 8007078:	0800bec0 	.word	0x0800bec0
 800707c:	0800b664 	.word	0x0800b664
 8007080:	0800bf10 	.word	0x0800bf10
 8007084:	0800bf14 	.word	0x0800bf14
 8007088:	0800bf2c 	.word	0x0800bf2c
 800708c:	0800bf48 	.word	0x0800bf48

08007090 <rt_test_011_001_setup>:
  chHeapObjectInit(&heap1, test_buffer, sizeof test_buffer);
 8007090:	4902      	ldr	r1, [pc, #8]	; (800709c <rt_test_011_001_setup+0xc>)
 8007092:	4803      	ldr	r0, [pc, #12]	; (80070a0 <rt_test_011_001_setup+0x10>)
 8007094:	f44f 62e6 	mov.w	r2, #1840	; 0x730
 8007098:	f7fb bfaa 	b.w	8002ff0 <chHeapObjectInit>
 800709c:	20000c98 	.word	0x20000c98
 80070a0:	200013ec 	.word	0x200013ec
	...

080070b0 <tmo>:

static void tmo(virtual_timer_t *vtp, void *param) {

  (void)vtp;
  (void)param;
}
 80070b0:	4770      	bx	lr
 80070b2:	bf00      	nop
	...

080070c0 <rt_test_012_012_execute>:
 * - [12.12.8] The size of an event listener is printed.
 * - [12.12.9] The size of a mailbox is printed.
 * .
 */

static void rt_test_012_012_execute(void) {
 80070c0:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
  test_printf("%s", msgp);
 80070c4:	f8df 810c 	ldr.w	r8, [pc, #268]	; 80071d4 <rt_test_012_012_execute+0x114>

  /* [12.12.1] The size of the system area is printed.*/
  test_set_step(1);
 80070c8:	4f43      	ldr	r7, [pc, #268]	; (80071d8 <rt_test_012_012_execute+0x118>)
  test_printf("%u", n);
 80070ca:	4e44      	ldr	r6, [pc, #272]	; (80071dc <rt_test_012_012_execute+0x11c>)
  test_printf("%s" TEST_CFG_EOL_STRING, msgp);
 80070cc:	4d44      	ldr	r5, [pc, #272]	; (80071e0 <rt_test_012_012_execute+0x120>)
 80070ce:	4c45      	ldr	r4, [pc, #276]	; (80071e4 <rt_test_012_012_execute+0x124>)
  test_printf("%s", msgp);
 80070d0:	4945      	ldr	r1, [pc, #276]	; (80071e8 <rt_test_012_012_execute+0x128>)
 80070d2:	2301      	movs	r3, #1
 80070d4:	4640      	mov	r0, r8
 80070d6:	603b      	str	r3, [r7, #0]
 80070d8:	f7fd fbaa 	bl	8004830 <test_printf>
  test_printf("%u", n);
 80070dc:	2188      	movs	r1, #136	; 0x88
 80070de:	4630      	mov	r0, r6
 80070e0:	f7fd fba6 	bl	8004830 <test_printf>
  test_printf("%s" TEST_CFG_EOL_STRING, msgp);
 80070e4:	4629      	mov	r1, r5
 80070e6:	4620      	mov	r0, r4
 80070e8:	f7fd fba2 	bl	8004830 <test_printf>
    test_println(" bytes");
  }
  test_end_step(1);

  /* [12.12.2] The size of a thread structure is printed.*/
  test_set_step(2);
 80070ec:	2302      	movs	r3, #2
  test_printf("%s", msgp);
 80070ee:	493f      	ldr	r1, [pc, #252]	; (80071ec <rt_test_012_012_execute+0x12c>)
 80070f0:	603b      	str	r3, [r7, #0]
 80070f2:	4640      	mov	r0, r8
 80070f4:	f7fd fb9c 	bl	8004830 <test_printf>
  test_printf("%u", n);
 80070f8:	2148      	movs	r1, #72	; 0x48
 80070fa:	4630      	mov	r0, r6
 80070fc:	f7fd fb98 	bl	8004830 <test_printf>
  test_printf("%s" TEST_CFG_EOL_STRING, msgp);
 8007100:	4629      	mov	r1, r5
 8007102:	4620      	mov	r0, r4
 8007104:	f7fd fb94 	bl	8004830 <test_printf>
    test_println(" bytes");
  }
  test_end_step(2);

  /* [12.12.3] The size of a virtual timer structure is printed.*/
  test_set_step(3);
 8007108:	2303      	movs	r3, #3
  test_printf("%s", msgp);
 800710a:	4939      	ldr	r1, [pc, #228]	; (80071f0 <rt_test_012_012_execute+0x130>)
 800710c:	603b      	str	r3, [r7, #0]
 800710e:	4640      	mov	r0, r8
 8007110:	f7fd fb8e 	bl	8004830 <test_printf>
  test_printf("%u", n);
 8007114:	2118      	movs	r1, #24
 8007116:	4630      	mov	r0, r6
 8007118:	f7fd fb8a 	bl	8004830 <test_printf>
  test_printf("%s" TEST_CFG_EOL_STRING, msgp);
 800711c:	4629      	mov	r1, r5
 800711e:	4620      	mov	r0, r4
 8007120:	f7fd fb86 	bl	8004830 <test_printf>
    test_println(" bytes");
  }
  test_end_step(3);

  /* [12.12.4] The size of a semaphore structure is printed.*/
  test_set_step(4);
 8007124:	f04f 0904 	mov.w	r9, #4
  test_printf("%s", msgp);
 8007128:	4932      	ldr	r1, [pc, #200]	; (80071f4 <rt_test_012_012_execute+0x134>)
 800712a:	f8c7 9000 	str.w	r9, [r7]
 800712e:	4640      	mov	r0, r8
 8007130:	f7fd fb7e 	bl	8004830 <test_printf>
  test_printf("%u", n);
 8007134:	210c      	movs	r1, #12
 8007136:	4630      	mov	r0, r6
 8007138:	f7fd fb7a 	bl	8004830 <test_printf>
  test_printf("%s" TEST_CFG_EOL_STRING, msgp);
 800713c:	4629      	mov	r1, r5
 800713e:	4620      	mov	r0, r4
 8007140:	f7fd fb76 	bl	8004830 <test_printf>
#endif
  }
  test_end_step(4);

  /* [12.12.5] The size of a mutex is printed.*/
  test_set_step(5);
 8007144:	2305      	movs	r3, #5
  test_printf("%s", msgp);
 8007146:	492c      	ldr	r1, [pc, #176]	; (80071f8 <rt_test_012_012_execute+0x138>)
 8007148:	603b      	str	r3, [r7, #0]
 800714a:	4640      	mov	r0, r8
 800714c:	f7fd fb70 	bl	8004830 <test_printf>
  test_printf("%u", n);
 8007150:	2110      	movs	r1, #16
 8007152:	4630      	mov	r0, r6
 8007154:	f7fd fb6c 	bl	8004830 <test_printf>
  test_printf("%s" TEST_CFG_EOL_STRING, msgp);
 8007158:	4629      	mov	r1, r5
 800715a:	4620      	mov	r0, r4
 800715c:	f7fd fb68 	bl	8004830 <test_printf>
#endif
  }
  test_end_step(5);

  /* [12.12.6] The size of a condition variable is printed.*/
  test_set_step(6);
 8007160:	2306      	movs	r3, #6
  test_printf("%s", msgp);
 8007162:	4926      	ldr	r1, [pc, #152]	; (80071fc <rt_test_012_012_execute+0x13c>)
 8007164:	603b      	str	r3, [r7, #0]
 8007166:	4640      	mov	r0, r8
 8007168:	f7fd fb62 	bl	8004830 <test_printf>
  test_printf("%u", n);
 800716c:	2108      	movs	r1, #8
 800716e:	4630      	mov	r0, r6
 8007170:	f7fd fb5e 	bl	8004830 <test_printf>
  test_printf("%s" TEST_CFG_EOL_STRING, msgp);
 8007174:	4629      	mov	r1, r5
 8007176:	4620      	mov	r0, r4
 8007178:	f7fd fb5a 	bl	8004830 <test_printf>
#endif
  }
  test_end_step(6);

  /* [12.12.7] The size of an event source is printed.*/
  test_set_step(7);
 800717c:	2307      	movs	r3, #7
  test_printf("%s", msgp);
 800717e:	4920      	ldr	r1, [pc, #128]	; (8007200 <rt_test_012_012_execute+0x140>)
 8007180:	603b      	str	r3, [r7, #0]
 8007182:	4640      	mov	r0, r8
 8007184:	f7fd fb54 	bl	8004830 <test_printf>
  test_printf("%u", n);
 8007188:	4649      	mov	r1, r9
 800718a:	4630      	mov	r0, r6
 800718c:	f7fd fb50 	bl	8004830 <test_printf>
  test_printf("%s" TEST_CFG_EOL_STRING, msgp);
 8007190:	4629      	mov	r1, r5
 8007192:	4620      	mov	r0, r4
 8007194:	f7fd fb4c 	bl	8004830 <test_printf>
#endif
  }
  test_end_step(7);

  /* [12.12.8] The size of an event listener is printed.*/
  test_set_step(8);
 8007198:	2308      	movs	r3, #8
  test_printf("%s", msgp);
 800719a:	491a      	ldr	r1, [pc, #104]	; (8007204 <rt_test_012_012_execute+0x144>)
 800719c:	603b      	str	r3, [r7, #0]
 800719e:	4640      	mov	r0, r8
 80071a0:	f7fd fb46 	bl	8004830 <test_printf>
  test_printf("%u", n);
 80071a4:	2114      	movs	r1, #20
 80071a6:	4630      	mov	r0, r6
 80071a8:	f7fd fb42 	bl	8004830 <test_printf>
  test_printf("%s" TEST_CFG_EOL_STRING, msgp);
 80071ac:	4629      	mov	r1, r5
 80071ae:	4620      	mov	r0, r4
 80071b0:	f7fd fb3e 	bl	8004830 <test_printf>
#endif
  }
  test_end_step(8);

  /* [12.12.9] The size of a mailbox is printed.*/
  test_set_step(9);
 80071b4:	2309      	movs	r3, #9
  test_printf("%s", msgp);
 80071b6:	4914      	ldr	r1, [pc, #80]	; (8007208 <rt_test_012_012_execute+0x148>)
 80071b8:	603b      	str	r3, [r7, #0]
 80071ba:	4640      	mov	r0, r8
 80071bc:	f7fd fb38 	bl	8004830 <test_printf>
  test_printf("%u", n);
 80071c0:	2128      	movs	r1, #40	; 0x28
 80071c2:	4630      	mov	r0, r6
 80071c4:	f7fd fb34 	bl	8004830 <test_printf>
  test_printf("%s" TEST_CFG_EOL_STRING, msgp);
 80071c8:	4629      	mov	r1, r5
 80071ca:	4620      	mov	r0, r4
    test_printn(sizeof(mailbox_t));
    test_println(" bytes");
#endif
  }
  test_end_step(9);
}
 80071cc:	e8bd 43f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 80071d0:	f7fd bb2e 	b.w	8004830 <test_printf>
 80071d4:	0800aaf8 	.word	0x0800aaf8
 80071d8:	20000c70 	.word	0x20000c70
 80071dc:	0800aafc 	.word	0x0800aafc
 80071e0:	0800c004 	.word	0x0800c004
 80071e4:	0800a884 	.word	0x0800a884
 80071e8:	0800bff4 	.word	0x0800bff4
 80071ec:	0800c00c 	.word	0x0800c00c
 80071f0:	0800c01c 	.word	0x0800c01c
 80071f4:	0800c02c 	.word	0x0800c02c
 80071f8:	0800c03c 	.word	0x0800c03c
 80071fc:	0800c04c 	.word	0x0800c04c
 8007200:	0800c05c 	.word	0x0800c05c
 8007204:	0800c06c 	.word	0x0800c06c
 8007208:	0800c07c 	.word	0x0800c07c
 800720c:	00000000 	.word	0x00000000

08007210 <rt_test_012_011_execute>:
static void rt_test_012_011_execute(void) {
 8007210:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  test_set_step(1);
 8007214:	f8df 8074 	ldr.w	r8, [pc, #116]	; 800728c <rt_test_012_011_execute+0x7c>
      chMtxLock(&mtx1);
 8007218:	4c1d      	ldr	r4, [pc, #116]	; (8007290 <rt_test_012_011_execute+0x80>)
  test_set_step(1);
 800721a:	2301      	movs	r3, #1
 800721c:	f8c8 3000 	str.w	r3, [r8]
    start = test_wait_tick();
 8007220:	f7fd fb3e 	bl	80048a0 <test_wait_tick>
    n = 0;
 8007224:	2500      	movs	r5, #0
    start = test_wait_tick();
 8007226:	4606      	mov	r6, r0
    } while (chVTIsSystemTimeWithinX(start, end));
 8007228:	f242 770f 	movw	r7, #9999	; 0x270f
      chMtxLock(&mtx1);
 800722c:	4620      	mov	r0, r4
 800722e:	f7fb f937 	bl	80024a0 <chMtxLock>
      chMtxUnlock(&mtx1);
 8007232:	4620      	mov	r0, r4
 8007234:	f7fb f95c 	bl	80024f0 <chMtxUnlock>
      chMtxLock(&mtx1);
 8007238:	4620      	mov	r0, r4
 800723a:	f7fb f931 	bl	80024a0 <chMtxLock>
      chMtxUnlock(&mtx1);
 800723e:	4620      	mov	r0, r4
 8007240:	f7fb f956 	bl	80024f0 <chMtxUnlock>
      chMtxLock(&mtx1);
 8007244:	4620      	mov	r0, r4
 8007246:	f7fb f92b 	bl	80024a0 <chMtxLock>
      chMtxUnlock(&mtx1);
 800724a:	4620      	mov	r0, r4
 800724c:	f7fb f950 	bl	80024f0 <chMtxUnlock>
      chMtxLock(&mtx1);
 8007250:	4620      	mov	r0, r4
 8007252:	f7fb f925 	bl	80024a0 <chMtxLock>
      chMtxUnlock(&mtx1);
 8007256:	4620      	mov	r0, r4
 8007258:	f7fb f94a 	bl	80024f0 <chMtxUnlock>
 800725c:	f7f9 f930 	bl	80004c0 <stGetCounter>
  return (bool)((systime_t)((systime_t)time - (systime_t)start) <
 8007260:	1b80      	subs	r0, r0, r6
    } while (chVTIsSystemTimeWithinX(start, end));
 8007262:	42b8      	cmp	r0, r7
      n++;
 8007264:	f105 0501 	add.w	r5, r5, #1
    } while (chVTIsSystemTimeWithinX(start, end));
 8007268:	d9e0      	bls.n	800722c <rt_test_012_011_execute+0x1c>
  test_set_step(2);
 800726a:	2302      	movs	r3, #2
  test_printf("%s", msgp);
 800726c:	4909      	ldr	r1, [pc, #36]	; (8007294 <rt_test_012_011_execute+0x84>)
 800726e:	480a      	ldr	r0, [pc, #40]	; (8007298 <rt_test_012_011_execute+0x88>)
 8007270:	f8c8 3000 	str.w	r3, [r8]
 8007274:	f7fd fadc 	bl	8004830 <test_printf>
  test_printf("%u", n);
 8007278:	00a9      	lsls	r1, r5, #2
 800727a:	4808      	ldr	r0, [pc, #32]	; (800729c <rt_test_012_011_execute+0x8c>)
 800727c:	f7fd fad8 	bl	8004830 <test_printf>
}
 8007280:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
  test_printf("%s" TEST_CFG_EOL_STRING, msgp);
 8007284:	4906      	ldr	r1, [pc, #24]	; (80072a0 <rt_test_012_011_execute+0x90>)
 8007286:	4807      	ldr	r0, [pc, #28]	; (80072a4 <rt_test_012_011_execute+0x94>)
 8007288:	f7fd bad2 	b.w	8004830 <test_printf>
 800728c:	20000c70 	.word	0x20000c70
 8007290:	20001418 	.word	0x20001418
 8007294:	0800c08c 	.word	0x0800c08c
 8007298:	0800aaf8 	.word	0x0800aaf8
 800729c:	0800aafc 	.word	0x0800aafc
 80072a0:	0800c09c 	.word	0x0800c09c
 80072a4:	0800a884 	.word	0x0800a884
	...

080072b0 <rt_test_012_011_setup>:
  chMtxObjectInit(&mtx1);
 80072b0:	4801      	ldr	r0, [pc, #4]	; (80072b8 <rt_test_012_011_setup+0x8>)
 80072b2:	f7fb b885 	b.w	80023c0 <chMtxObjectInit>
 80072b6:	bf00      	nop
 80072b8:	20001418 	.word	0x20001418
 80072bc:	00000000 	.word	0x00000000

080072c0 <bmk_thread7>:
static THD_FUNCTION(bmk_thread7, p) {
 80072c0:	b538      	push	{r3, r4, r5, lr}
  return __sch_get_currthread();
 80072c2:	4c08      	ldr	r4, [pc, #32]	; (80072e4 <bmk_thread7+0x24>)
  return (bool)((chThdGetSelfX()->flags & CH_FLAG_TERMINATE) != (tmode_t)0);
 80072c4:	68e3      	ldr	r3, [r4, #12]
  while (!chThdShouldTerminateX())
 80072c6:	f893 3025 	ldrb.w	r3, [r3, #37]	; 0x25
 80072ca:	075a      	lsls	r2, r3, #29
 80072cc:	d408      	bmi.n	80072e0 <bmk_thread7+0x20>
    chSemWait(&sem1);
 80072ce:	4d06      	ldr	r5, [pc, #24]	; (80072e8 <bmk_thread7+0x28>)
 80072d0:	4628      	mov	r0, r5
 80072d2:	f7fa ff6d 	bl	80021b0 <chSemWait>
 80072d6:	68e3      	ldr	r3, [r4, #12]
  while (!chThdShouldTerminateX())
 80072d8:	f893 3025 	ldrb.w	r3, [r3, #37]	; 0x25
 80072dc:	075b      	lsls	r3, r3, #29
 80072de:	d5f7      	bpl.n	80072d0 <bmk_thread7+0x10>
}
 80072e0:	bd38      	pop	{r3, r4, r5, pc}
 80072e2:	bf00      	nop
 80072e4:	20000a40 	.word	0x20000a40
 80072e8:	20001428 	.word	0x20001428
 80072ec:	00000000 	.word	0x00000000

080072f0 <rt_test_012_010_execute>:
static void rt_test_012_010_execute(void) {
 80072f0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  test_set_step(1);
 80072f4:	f8df 8074 	ldr.w	r8, [pc, #116]	; 800736c <rt_test_012_010_execute+0x7c>
      chSemWait(&sem1);
 80072f8:	4c1d      	ldr	r4, [pc, #116]	; (8007370 <rt_test_012_010_execute+0x80>)
  test_set_step(1);
 80072fa:	2301      	movs	r3, #1
 80072fc:	f8c8 3000 	str.w	r3, [r8]
    start = test_wait_tick();
 8007300:	f7fd face 	bl	80048a0 <test_wait_tick>
    n = 0;
 8007304:	2500      	movs	r5, #0
    start = test_wait_tick();
 8007306:	4606      	mov	r6, r0
    } while (chVTIsSystemTimeWithinX(start, end));
 8007308:	f242 770f 	movw	r7, #9999	; 0x270f
      chSemWait(&sem1);
 800730c:	4620      	mov	r0, r4
 800730e:	f7fa ff4f 	bl	80021b0 <chSemWait>
      chSemSignal(&sem1);
 8007312:	4620      	mov	r0, r4
 8007314:	f7fa ffd4 	bl	80022c0 <chSemSignal>
      chSemWait(&sem1);
 8007318:	4620      	mov	r0, r4
 800731a:	f7fa ff49 	bl	80021b0 <chSemWait>
      chSemSignal(&sem1);
 800731e:	4620      	mov	r0, r4
 8007320:	f7fa ffce 	bl	80022c0 <chSemSignal>
      chSemWait(&sem1);
 8007324:	4620      	mov	r0, r4
 8007326:	f7fa ff43 	bl	80021b0 <chSemWait>
      chSemSignal(&sem1);
 800732a:	4620      	mov	r0, r4
 800732c:	f7fa ffc8 	bl	80022c0 <chSemSignal>
      chSemWait(&sem1);
 8007330:	4620      	mov	r0, r4
 8007332:	f7fa ff3d 	bl	80021b0 <chSemWait>
      chSemSignal(&sem1);
 8007336:	4620      	mov	r0, r4
 8007338:	f7fa ffc2 	bl	80022c0 <chSemSignal>
 800733c:	f7f9 f8c0 	bl	80004c0 <stGetCounter>
 8007340:	1b80      	subs	r0, r0, r6
    } while (chVTIsSystemTimeWithinX(start, end));
 8007342:	42b8      	cmp	r0, r7
      n++;
 8007344:	f105 0501 	add.w	r5, r5, #1
    } while (chVTIsSystemTimeWithinX(start, end));
 8007348:	d9e0      	bls.n	800730c <rt_test_012_010_execute+0x1c>
  test_set_step(2);
 800734a:	2302      	movs	r3, #2
  test_printf("%s", msgp);
 800734c:	4909      	ldr	r1, [pc, #36]	; (8007374 <rt_test_012_010_execute+0x84>)
 800734e:	480a      	ldr	r0, [pc, #40]	; (8007378 <rt_test_012_010_execute+0x88>)
 8007350:	f8c8 3000 	str.w	r3, [r8]
 8007354:	f7fd fa6c 	bl	8004830 <test_printf>
  test_printf("%u", n);
 8007358:	00a9      	lsls	r1, r5, #2
 800735a:	4808      	ldr	r0, [pc, #32]	; (800737c <rt_test_012_010_execute+0x8c>)
 800735c:	f7fd fa68 	bl	8004830 <test_printf>
}
 8007360:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
  test_printf("%s" TEST_CFG_EOL_STRING, msgp);
 8007364:	4906      	ldr	r1, [pc, #24]	; (8007380 <rt_test_012_010_execute+0x90>)
 8007366:	4807      	ldr	r0, [pc, #28]	; (8007384 <rt_test_012_010_execute+0x94>)
 8007368:	f7fd ba62 	b.w	8004830 <test_printf>
 800736c:	20000c70 	.word	0x20000c70
 8007370:	20001428 	.word	0x20001428
 8007374:	0800c08c 	.word	0x0800c08c
 8007378:	0800aaf8 	.word	0x0800aaf8
 800737c:	0800aafc 	.word	0x0800aafc
 8007380:	0800c0ac 	.word	0x0800c0ac
 8007384:	0800a884 	.word	0x0800a884
	...

08007390 <rt_test_012_010_setup>:
  chSemObjectInit(&sem1, 1);
 8007390:	4801      	ldr	r0, [pc, #4]	; (8007398 <rt_test_012_010_setup+0x8>)
 8007392:	2101      	movs	r1, #1
 8007394:	f7fa bee4 	b.w	8002160 <chSemObjectInit>
 8007398:	20001428 	.word	0x20001428
 800739c:	00000000 	.word	0x00000000

080073a0 <rt_test_012_007_setup>:
  chSemObjectInit(&sem1, 0);
 80073a0:	4801      	ldr	r0, [pc, #4]	; (80073a8 <rt_test_012_007_setup+0x8>)
 80073a2:	2100      	movs	r1, #0
 80073a4:	f7fa bedc 	b.w	8002160 <chSemObjectInit>
 80073a8:	20001428 	.word	0x20001428
 80073ac:	00000000 	.word	0x00000000

080073b0 <rt_test_012_009_execute>:
static void rt_test_012_009_execute(void) {
 80073b0:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
  test_set_step(1);
 80073b4:	f8df a080 	ldr.w	sl, [pc, #128]	; 8007438 <rt_test_012_009_execute+0x88>
      chVTDoSetI(&vt1, 1, tmo, NULL);
 80073b8:	f8df b080 	ldr.w	fp, [pc, #128]	; 800743c <rt_test_012_009_execute+0x8c>
 80073bc:	4e20      	ldr	r6, [pc, #128]	; (8007440 <rt_test_012_009_execute+0x90>)
      chVTDoSetI(&vt2, 10000, tmo, NULL);
 80073be:	4d21      	ldr	r5, [pc, #132]	; (8007444 <rt_test_012_009_execute+0x94>)
  test_set_step(1);
 80073c0:	2301      	movs	r3, #1
 80073c2:	f8ca 3000 	str.w	r3, [sl]
    start = test_wait_tick();
 80073c6:	f7fd fa6b 	bl	80048a0 <test_wait_tick>
    n = 0;
 80073ca:	2400      	movs	r4, #0
    start = test_wait_tick();
 80073cc:	4607      	mov	r7, r0
 80073ce:	f04f 0930 	mov.w	r9, #48	; 0x30
      chVTDoSetI(&vt1, 1, tmo, NULL);
 80073d2:	46a0      	mov	r8, r4
 80073d4:	f389 8811 	msr	BASEPRI, r9
 80073d8:	2300      	movs	r3, #0
 80073da:	465a      	mov	r2, fp
 80073dc:	4630      	mov	r0, r6
 80073de:	2101      	movs	r1, #1
 80073e0:	f7fa f9fe 	bl	80017e0 <chVTDoSetI>
      chVTDoSetI(&vt2, 10000, tmo, NULL);
 80073e4:	2300      	movs	r3, #0
 80073e6:	465a      	mov	r2, fp
 80073e8:	f242 7110 	movw	r1, #10000	; 0x2710
 80073ec:	4628      	mov	r0, r5
 80073ee:	f7fa f9f7 	bl	80017e0 <chVTDoSetI>
      chVTDoResetI(&vt1);
 80073f2:	4630      	mov	r0, r6
 80073f4:	f7fa f9fc 	bl	80017f0 <chVTDoResetI>
      chVTDoResetI(&vt2);
 80073f8:	4628      	mov	r0, r5
 80073fa:	f7fa f9f9 	bl	80017f0 <chVTDoResetI>
 80073fe:	f388 8811 	msr	BASEPRI, r8
 8007402:	f7f9 f85d 	bl	80004c0 <stGetCounter>
    } while (chVTIsSystemTimeWithinX(start, end));
 8007406:	f242 730f 	movw	r3, #9999	; 0x270f
 800740a:	1bc0      	subs	r0, r0, r7
 800740c:	4298      	cmp	r0, r3
      n++;
 800740e:	f104 0401 	add.w	r4, r4, #1
    } while (chVTIsSystemTimeWithinX(start, end));
 8007412:	d9df      	bls.n	80073d4 <rt_test_012_009_execute+0x24>
  test_set_step(2);
 8007414:	2302      	movs	r3, #2
  test_printf("%s", msgp);
 8007416:	490c      	ldr	r1, [pc, #48]	; (8007448 <rt_test_012_009_execute+0x98>)
 8007418:	480c      	ldr	r0, [pc, #48]	; (800744c <rt_test_012_009_execute+0x9c>)
 800741a:	f8ca 3000 	str.w	r3, [sl]
 800741e:	f7fd fa07 	bl	8004830 <test_printf>
  test_printf("%u", n);
 8007422:	0061      	lsls	r1, r4, #1
 8007424:	480a      	ldr	r0, [pc, #40]	; (8007450 <rt_test_012_009_execute+0xa0>)
 8007426:	f7fd fa03 	bl	8004830 <test_printf>
}
 800742a:	e8bd 4ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
  test_printf("%s" TEST_CFG_EOL_STRING, msgp);
 800742e:	4909      	ldr	r1, [pc, #36]	; (8007454 <rt_test_012_009_execute+0xa4>)
 8007430:	4809      	ldr	r0, [pc, #36]	; (8007458 <rt_test_012_009_execute+0xa8>)
 8007432:	f7fd b9fd 	b.w	8004830 <test_printf>
 8007436:	bf00      	nop
 8007438:	20000c70 	.word	0x20000c70
 800743c:	080070b1 	.word	0x080070b1
 8007440:	20001434 	.word	0x20001434
 8007444:	2000144c 	.word	0x2000144c
 8007448:	0800c08c 	.word	0x0800c08c
 800744c:	0800aaf8 	.word	0x0800aaf8
 8007450:	0800aafc 	.word	0x0800aafc
 8007454:	0800c0bc 	.word	0x0800c0bc
 8007458:	0800a884 	.word	0x0800a884
 800745c:	00000000 	.word	0x00000000

08007460 <rt_test_012_008_execute>:
static void rt_test_012_008_execute(void) {
 8007460:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
  return __sch_get_currthread();
 8007464:	f8df 80d0 	ldr.w	r8, [pc, #208]	; 8007538 <rt_test_012_008_execute+0xd8>
  test_set_step(1);
 8007468:	f8df 90d0 	ldr.w	r9, [pc, #208]	; 800753c <rt_test_012_008_execute+0xdc>
    test_wait_tick();threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()-1, bmk_thread8, (void *)&n);
 800746c:	4f34      	ldr	r7, [pc, #208]	; (8007540 <rt_test_012_008_execute+0xe0>)
 800746e:	4d35      	ldr	r5, [pc, #212]	; (8007544 <rt_test_012_008_execute+0xe4>)
 8007470:	4c35      	ldr	r4, [pc, #212]	; (8007548 <rt_test_012_008_execute+0xe8>)
static void rt_test_012_008_execute(void) {
 8007472:	b085      	sub	sp, #20
  test_set_step(1);
 8007474:	2201      	movs	r2, #1
    n = 0;
 8007476:	2300      	movs	r3, #0
  test_set_step(1);
 8007478:	f8c9 2000 	str.w	r2, [r9]
    n = 0;
 800747c:	9303      	str	r3, [sp, #12]
    test_wait_tick();threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()-1, bmk_thread8, (void *)&n);
 800747e:	f7fd fa0f 	bl	80048a0 <test_wait_tick>
  return chThdGetSelfX()->hdr.pqueue.prio;
 8007482:	f8d8 300c 	ldr.w	r3, [r8, #12]
 8007486:	6828      	ldr	r0, [r5, #0]
 8007488:	689a      	ldr	r2, [r3, #8]
 800748a:	ae03      	add	r6, sp, #12
 800748c:	463b      	mov	r3, r7
 800748e:	3a01      	subs	r2, #1
 8007490:	9600      	str	r6, [sp, #0]
 8007492:	f44f 71b8 	mov.w	r1, #368	; 0x170
 8007496:	f7fa fc8b 	bl	8001db0 <chThdCreateStatic>
 800749a:	f8d8 300c 	ldr.w	r3, [r8, #12]
 800749e:	6020      	str	r0, [r4, #0]
    threads[1] = chThdCreateStatic(wa[1], WA_SIZE, chThdGetPriorityX()-1, bmk_thread8, (void *)&n);
 80074a0:	689a      	ldr	r2, [r3, #8]
 80074a2:	6868      	ldr	r0, [r5, #4]
 80074a4:	9600      	str	r6, [sp, #0]
 80074a6:	463b      	mov	r3, r7
 80074a8:	3a01      	subs	r2, #1
 80074aa:	f44f 71b8 	mov.w	r1, #368	; 0x170
 80074ae:	f7fa fc7f 	bl	8001db0 <chThdCreateStatic>
 80074b2:	f8d8 300c 	ldr.w	r3, [r8, #12]
 80074b6:	6060      	str	r0, [r4, #4]
    threads[2] = chThdCreateStatic(wa[2], WA_SIZE, chThdGetPriorityX()-1, bmk_thread8, (void *)&n);
 80074b8:	689a      	ldr	r2, [r3, #8]
 80074ba:	68a8      	ldr	r0, [r5, #8]
 80074bc:	9600      	str	r6, [sp, #0]
 80074be:	463b      	mov	r3, r7
 80074c0:	3a01      	subs	r2, #1
 80074c2:	f44f 71b8 	mov.w	r1, #368	; 0x170
 80074c6:	f7fa fc73 	bl	8001db0 <chThdCreateStatic>
 80074ca:	f8d8 300c 	ldr.w	r3, [r8, #12]
 80074ce:	60a0      	str	r0, [r4, #8]
    threads[3] = chThdCreateStatic(wa[3], WA_SIZE, chThdGetPriorityX()-1, bmk_thread8, (void *)&n);
 80074d0:	689a      	ldr	r2, [r3, #8]
 80074d2:	68e8      	ldr	r0, [r5, #12]
 80074d4:	9600      	str	r6, [sp, #0]
 80074d6:	463b      	mov	r3, r7
 80074d8:	3a01      	subs	r2, #1
 80074da:	f44f 71b8 	mov.w	r1, #368	; 0x170
 80074de:	f7fa fc67 	bl	8001db0 <chThdCreateStatic>
 80074e2:	f8d8 200c 	ldr.w	r2, [r8, #12]
 80074e6:	60e0      	str	r0, [r4, #12]
    threads[4] = chThdCreateStatic(wa[4], WA_SIZE, chThdGetPriorityX()-1, bmk_thread8, (void *)&n);
 80074e8:	6892      	ldr	r2, [r2, #8]
 80074ea:	6928      	ldr	r0, [r5, #16]
 80074ec:	9600      	str	r6, [sp, #0]
 80074ee:	f44f 71b8 	mov.w	r1, #368	; 0x170
 80074f2:	463b      	mov	r3, r7
 80074f4:	3a01      	subs	r2, #1
 80074f6:	f7fa fc5b 	bl	8001db0 <chThdCreateStatic>
  test_set_step(2);
 80074fa:	2302      	movs	r3, #2
    threads[4] = chThdCreateStatic(wa[4], WA_SIZE, chThdGetPriorityX()-1, bmk_thread8, (void *)&n);
 80074fc:	4602      	mov	r2, r0
    chThdSleepSeconds(1);
 80074fe:	f242 7010 	movw	r0, #10000	; 0x2710
    threads[4] = chThdCreateStatic(wa[4], WA_SIZE, chThdGetPriorityX()-1, bmk_thread8, (void *)&n);
 8007502:	6122      	str	r2, [r4, #16]
  test_set_step(2);
 8007504:	f8c9 3000 	str.w	r3, [r9]
    chThdSleepSeconds(1);
 8007508:	f7fa fd52 	bl	8001fb0 <chThdSleep>
    test_terminate_threads();
 800750c:	f7fd f9a0 	bl	8004850 <test_terminate_threads>
    test_wait_threads();
 8007510:	f7fd f9ae 	bl	8004870 <test_wait_threads>
  test_set_step(3);
 8007514:	2303      	movs	r3, #3
  test_printf("%s", msgp);
 8007516:	490d      	ldr	r1, [pc, #52]	; (800754c <rt_test_012_008_execute+0xec>)
 8007518:	480d      	ldr	r0, [pc, #52]	; (8007550 <rt_test_012_008_execute+0xf0>)
 800751a:	f8c9 3000 	str.w	r3, [r9]
 800751e:	f7fd f987 	bl	8004830 <test_printf>
  test_printf("%u", n);
 8007522:	9903      	ldr	r1, [sp, #12]
 8007524:	480b      	ldr	r0, [pc, #44]	; (8007554 <rt_test_012_008_execute+0xf4>)
 8007526:	f7fd f983 	bl	8004830 <test_printf>
  test_printf("%s" TEST_CFG_EOL_STRING, msgp);
 800752a:	490b      	ldr	r1, [pc, #44]	; (8007558 <rt_test_012_008_execute+0xf8>)
 800752c:	480b      	ldr	r0, [pc, #44]	; (800755c <rt_test_012_008_execute+0xfc>)
 800752e:	f7fd f97f 	bl	8004830 <test_printf>
}
 8007532:	b005      	add	sp, #20
 8007534:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
 8007538:	20000a40 	.word	0x20000a40
 800753c:	20000c70 	.word	0x20000c70
 8007540:	08007561 	.word	0x08007561
 8007544:	0800aab8 	.word	0x0800aab8
 8007548:	200013c8 	.word	0x200013c8
 800754c:	0800c08c 	.word	0x0800c08c
 8007550:	0800aaf8 	.word	0x0800aaf8
 8007554:	0800aafc 	.word	0x0800aafc
 8007558:	0800c0c8 	.word	0x0800c0c8
 800755c:	0800a884 	.word	0x0800a884

08007560 <bmk_thread8>:
static THD_FUNCTION(bmk_thread8, p) {
 8007560:	b538      	push	{r3, r4, r5, lr}
 8007562:	4d09      	ldr	r5, [pc, #36]	; (8007588 <bmk_thread8+0x28>)
 8007564:	4604      	mov	r4, r0
    chThdYield();
 8007566:	f7fa fd43 	bl	8001ff0 <chThdYield>
    chThdYield();
 800756a:	f7fa fd41 	bl	8001ff0 <chThdYield>
    chThdYield();
 800756e:	f7fa fd3f 	bl	8001ff0 <chThdYield>
    chThdYield();
 8007572:	f7fa fd3d 	bl	8001ff0 <chThdYield>
    (*(uint32_t *)p) += 4;
 8007576:	6823      	ldr	r3, [r4, #0]
  return (bool)((chThdGetSelfX()->flags & CH_FLAG_TERMINATE) != (tmode_t)0);
 8007578:	68ea      	ldr	r2, [r5, #12]
 800757a:	3304      	adds	r3, #4
 800757c:	6023      	str	r3, [r4, #0]
  } while(!chThdShouldTerminateX());
 800757e:	f892 3025 	ldrb.w	r3, [r2, #37]	; 0x25
 8007582:	075b      	lsls	r3, r3, #29
 8007584:	d5ef      	bpl.n	8007566 <bmk_thread8+0x6>
}
 8007586:	bd38      	pop	{r3, r4, r5, pc}
 8007588:	20000a40 	.word	0x20000a40
 800758c:	00000000 	.word	0x00000000

08007590 <rt_test_012_007_execute>:
static void rt_test_012_007_execute(void) {
 8007590:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  return __sch_get_currthread();
 8007594:	f8df 8100 	ldr.w	r8, [pc, #256]	; 8007698 <rt_test_012_007_execute+0x108>
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()+5, bmk_thread7, NULL);
 8007598:	4e40      	ldr	r6, [pc, #256]	; (800769c <rt_test_012_007_execute+0x10c>)
  return chThdGetSelfX()->hdr.pqueue.prio;
 800759a:	f8d8 300c 	ldr.w	r3, [r8, #12]
  test_set_step(1);
 800759e:	4f40      	ldr	r7, [pc, #256]	; (80076a0 <rt_test_012_007_execute+0x110>)
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()+5, bmk_thread7, NULL);
 80075a0:	689a      	ldr	r2, [r3, #8]
 80075a2:	6830      	ldr	r0, [r6, #0]
 80075a4:	4b3f      	ldr	r3, [pc, #252]	; (80076a4 <rt_test_012_007_execute+0x114>)
static void rt_test_012_007_execute(void) {
 80075a6:	b082      	sub	sp, #8
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()+5, bmk_thread7, NULL);
 80075a8:	2400      	movs	r4, #0
 80075aa:	3205      	adds	r2, #5
 80075ac:	f44f 71b8 	mov.w	r1, #368	; 0x170
  test_set_step(1);
 80075b0:	2501      	movs	r5, #1
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()+5, bmk_thread7, NULL);
 80075b2:	9400      	str	r4, [sp, #0]
  test_set_step(1);
 80075b4:	603d      	str	r5, [r7, #0]
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()+5, bmk_thread7, NULL);
 80075b6:	f7fa fbfb 	bl	8001db0 <chThdCreateStatic>
 80075ba:	f8d8 300c 	ldr.w	r3, [r8, #12]
 80075be:	4d3a      	ldr	r5, [pc, #232]	; (80076a8 <rt_test_012_007_execute+0x118>)
    threads[1] = chThdCreateStatic(wa[1], WA_SIZE, chThdGetPriorityX()+4, bmk_thread7, NULL);
 80075c0:	689a      	ldr	r2, [r3, #8]
 80075c2:	4b38      	ldr	r3, [pc, #224]	; (80076a4 <rt_test_012_007_execute+0x114>)
 80075c4:	9400      	str	r4, [sp, #0]
 80075c6:	3204      	adds	r2, #4
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()+5, bmk_thread7, NULL);
 80075c8:	6028      	str	r0, [r5, #0]
    threads[1] = chThdCreateStatic(wa[1], WA_SIZE, chThdGetPriorityX()+4, bmk_thread7, NULL);
 80075ca:	f44f 71b8 	mov.w	r1, #368	; 0x170
 80075ce:	6870      	ldr	r0, [r6, #4]
 80075d0:	f7fa fbee 	bl	8001db0 <chThdCreateStatic>
 80075d4:	f8d8 300c 	ldr.w	r3, [r8, #12]
 80075d8:	6068      	str	r0, [r5, #4]
    threads[2] = chThdCreateStatic(wa[2], WA_SIZE, chThdGetPriorityX()+3, bmk_thread7, NULL);
 80075da:	689a      	ldr	r2, [r3, #8]
 80075dc:	68b0      	ldr	r0, [r6, #8]
 80075de:	4b31      	ldr	r3, [pc, #196]	; (80076a4 <rt_test_012_007_execute+0x114>)
 80075e0:	9400      	str	r4, [sp, #0]
 80075e2:	3203      	adds	r2, #3
 80075e4:	f44f 71b8 	mov.w	r1, #368	; 0x170
 80075e8:	f7fa fbe2 	bl	8001db0 <chThdCreateStatic>
 80075ec:	f8d8 300c 	ldr.w	r3, [r8, #12]
 80075f0:	60a8      	str	r0, [r5, #8]
    threads[3] = chThdCreateStatic(wa[3], WA_SIZE, chThdGetPriorityX()+2, bmk_thread7, NULL);
 80075f2:	689a      	ldr	r2, [r3, #8]
 80075f4:	68f0      	ldr	r0, [r6, #12]
 80075f6:	4b2b      	ldr	r3, [pc, #172]	; (80076a4 <rt_test_012_007_execute+0x114>)
 80075f8:	9400      	str	r4, [sp, #0]
 80075fa:	3202      	adds	r2, #2
 80075fc:	f44f 71b8 	mov.w	r1, #368	; 0x170
 8007600:	f7fa fbd6 	bl	8001db0 <chThdCreateStatic>
 8007604:	f8d8 300c 	ldr.w	r3, [r8, #12]
 8007608:	60e8      	str	r0, [r5, #12]
    threads[4] = chThdCreateStatic(wa[4], WA_SIZE, chThdGetPriorityX()+1, bmk_thread7, NULL);
 800760a:	689a      	ldr	r2, [r3, #8]
 800760c:	6930      	ldr	r0, [r6, #16]
 800760e:	4b25      	ldr	r3, [pc, #148]	; (80076a4 <rt_test_012_007_execute+0x114>)
 8007610:	9400      	str	r4, [sp, #0]
 8007612:	3201      	adds	r2, #1
 8007614:	f44f 71b8 	mov.w	r1, #368	; 0x170
 8007618:	f7fa fbca 	bl	8001db0 <chThdCreateStatic>
  test_set_step(2);
 800761c:	2302      	movs	r3, #2
    threads[4] = chThdCreateStatic(wa[4], WA_SIZE, chThdGetPriorityX()+1, bmk_thread7, NULL);
 800761e:	6128      	str	r0, [r5, #16]
  test_set_step(2);
 8007620:	603b      	str	r3, [r7, #0]
    start = test_wait_tick();
 8007622:	f7fd f93d 	bl	80048a0 <test_wait_tick>
 8007626:	4e21      	ldr	r6, [pc, #132]	; (80076ac <rt_test_012_007_execute+0x11c>)
 8007628:	4605      	mov	r5, r0
 800762a:	f06f 0201 	mvn.w	r2, #1
 800762e:	2100      	movs	r1, #0
 8007630:	4630      	mov	r0, r6
 8007632:	f7fa fd9d 	bl	8002170 <chSemResetWithMessage>
 8007636:	f7f8 ff43 	bl	80004c0 <stGetCounter>
    } while (chVTIsSystemTimeWithinX(start, end));
 800763a:	f242 730f 	movw	r3, #9999	; 0x270f
 800763e:	1b40      	subs	r0, r0, r5
 8007640:	4298      	cmp	r0, r3
      n++;
 8007642:	f104 0401 	add.w	r4, r4, #1
    } while (chVTIsSystemTimeWithinX(start, end));
 8007646:	d9f0      	bls.n	800762a <rt_test_012_007_execute+0x9a>
  test_set_step(3);
 8007648:	2303      	movs	r3, #3
 800764a:	603b      	str	r3, [r7, #0]
    test_terminate_threads();
 800764c:	f7fd f900 	bl	8004850 <test_terminate_threads>
 8007650:	f06f 0201 	mvn.w	r2, #1
 8007654:	4815      	ldr	r0, [pc, #84]	; (80076ac <rt_test_012_007_execute+0x11c>)
 8007656:	2100      	movs	r1, #0
 8007658:	f7fa fd8a 	bl	8002170 <chSemResetWithMessage>
    test_wait_threads();
 800765c:	f7fd f908 	bl	8004870 <test_wait_threads>
  test_set_step(4);
 8007660:	2304      	movs	r3, #4
  test_printf("%s", msgp);
 8007662:	4913      	ldr	r1, [pc, #76]	; (80076b0 <rt_test_012_007_execute+0x120>)
 8007664:	4813      	ldr	r0, [pc, #76]	; (80076b4 <rt_test_012_007_execute+0x124>)
 8007666:	603b      	str	r3, [r7, #0]
 8007668:	f7fd f8e2 	bl	8004830 <test_printf>
  test_printf("%u", n);
 800766c:	4621      	mov	r1, r4
 800766e:	4812      	ldr	r0, [pc, #72]	; (80076b8 <rt_test_012_007_execute+0x128>)
 8007670:	f7fd f8de 	bl	8004830 <test_printf>
    test_printn(n * 6);
 8007674:	eb04 0444 	add.w	r4, r4, r4, lsl #1
  test_printf("%s", msgp);
 8007678:	4910      	ldr	r1, [pc, #64]	; (80076bc <rt_test_012_007_execute+0x12c>)
 800767a:	480e      	ldr	r0, [pc, #56]	; (80076b4 <rt_test_012_007_execute+0x124>)
 800767c:	f7fd f8d8 	bl	8004830 <test_printf>
  test_printf("%u", n);
 8007680:	0061      	lsls	r1, r4, #1
 8007682:	480d      	ldr	r0, [pc, #52]	; (80076b8 <rt_test_012_007_execute+0x128>)
 8007684:	f7fd f8d4 	bl	8004830 <test_printf>
  test_printf("%s" TEST_CFG_EOL_STRING, msgp);
 8007688:	490d      	ldr	r1, [pc, #52]	; (80076c0 <rt_test_012_007_execute+0x130>)
 800768a:	480e      	ldr	r0, [pc, #56]	; (80076c4 <rt_test_012_007_execute+0x134>)
}
 800768c:	b002      	add	sp, #8
 800768e:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
 8007692:	f7fd b8cd 	b.w	8004830 <test_printf>
 8007696:	bf00      	nop
 8007698:	20000a40 	.word	0x20000a40
 800769c:	0800aab8 	.word	0x0800aab8
 80076a0:	20000c70 	.word	0x20000c70
 80076a4:	080072c1 	.word	0x080072c1
 80076a8:	200013c8 	.word	0x200013c8
 80076ac:	20001428 	.word	0x20001428
 80076b0:	0800c08c 	.word	0x0800c08c
 80076b4:	0800aaf8 	.word	0x0800aaf8
 80076b8:	0800aafc 	.word	0x0800aafc
 80076bc:	0800c0d4 	.word	0x0800c0d4
 80076c0:	0800c0c8 	.word	0x0800c0c8
 80076c4:	0800a884 	.word	0x0800a884
	...

080076d0 <rt_test_012_006_execute>:
static void rt_test_012_006_execute(void) {
 80076d0:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
  return __sch_get_currthread();
 80076d4:	4b1c      	ldr	r3, [pc, #112]	; (8007748 <rt_test_012_006_execute+0x78>)
  test_set_step(1);
 80076d6:	f8df 9074 	ldr.w	r9, [pc, #116]	; 800774c <rt_test_012_006_execute+0x7c>
  return chThdGetSelfX()->hdr.pqueue.prio;
 80076da:	68da      	ldr	r2, [r3, #12]
      chThdRelease(chThdCreateStatic(wa[0], WA_SIZE, prio, bmk_thread3, NULL));
 80076dc:	f8df a070 	ldr.w	sl, [pc, #112]	; 8007750 <rt_test_012_006_execute+0x80>
  tprio_t prio = chThdGetPriorityX() + 1;
 80076e0:	6896      	ldr	r6, [r2, #8]
  test_set_step(1);
 80076e2:	2301      	movs	r3, #1
static void rt_test_012_006_execute(void) {
 80076e4:	b082      	sub	sp, #8
  test_set_step(1);
 80076e6:	f8c9 3000 	str.w	r3, [r9]
  tprio_t prio = chThdGetPriorityX() + 1;
 80076ea:	441e      	add	r6, r3
    start = test_wait_tick();
 80076ec:	f7fd f8d8 	bl	80048a0 <test_wait_tick>
      chThdRelease(chThdCreateStatic(wa[0], WA_SIZE, prio, bmk_thread3, NULL));
 80076f0:	4b18      	ldr	r3, [pc, #96]	; (8007754 <rt_test_012_006_execute+0x84>)
    n = 0;
 80076f2:	2400      	movs	r4, #0
      chThdRelease(chThdCreateStatic(wa[0], WA_SIZE, prio, bmk_thread3, NULL));
 80076f4:	f8d3 8000 	ldr.w	r8, [r3]
    start = test_wait_tick();
 80076f8:	4605      	mov	r5, r0
      chThdRelease(chThdCreateStatic(wa[0], WA_SIZE, prio, bmk_thread3, NULL));
 80076fa:	4627      	mov	r7, r4
 80076fc:	4653      	mov	r3, sl
 80076fe:	4632      	mov	r2, r6
 8007700:	f44f 71b8 	mov.w	r1, #368	; 0x170
 8007704:	9700      	str	r7, [sp, #0]
 8007706:	4640      	mov	r0, r8
 8007708:	f7fa fb52 	bl	8001db0 <chThdCreateStatic>
 800770c:	f7fa fb90 	bl	8001e30 <chThdRelease>
 8007710:	f7f8 fed6 	bl	80004c0 <stGetCounter>
    } while (chVTIsSystemTimeWithinX(start, end));
 8007714:	f242 730f 	movw	r3, #9999	; 0x270f
 8007718:	1b40      	subs	r0, r0, r5
 800771a:	4298      	cmp	r0, r3
      n++;
 800771c:	f104 0401 	add.w	r4, r4, #1
    } while (chVTIsSystemTimeWithinX(start, end));
 8007720:	d9ec      	bls.n	80076fc <rt_test_012_006_execute+0x2c>
  test_set_step(2);
 8007722:	2302      	movs	r3, #2
  test_printf("%s", msgp);
 8007724:	490c      	ldr	r1, [pc, #48]	; (8007758 <rt_test_012_006_execute+0x88>)
 8007726:	480d      	ldr	r0, [pc, #52]	; (800775c <rt_test_012_006_execute+0x8c>)
 8007728:	f8c9 3000 	str.w	r3, [r9]
 800772c:	f7fd f880 	bl	8004830 <test_printf>
  test_printf("%u", n);
 8007730:	4621      	mov	r1, r4
 8007732:	480b      	ldr	r0, [pc, #44]	; (8007760 <rt_test_012_006_execute+0x90>)
 8007734:	f7fd f87c 	bl	8004830 <test_printf>
  test_printf("%s" TEST_CFG_EOL_STRING, msgp);
 8007738:	490a      	ldr	r1, [pc, #40]	; (8007764 <rt_test_012_006_execute+0x94>)
 800773a:	480b      	ldr	r0, [pc, #44]	; (8007768 <rt_test_012_006_execute+0x98>)
}
 800773c:	b002      	add	sp, #8
 800773e:	e8bd 47f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 8007742:	f7fd b875 	b.w	8004830 <test_printf>
 8007746:	bf00      	nop
 8007748:	20000a40 	.word	0x20000a40
 800774c:	20000c70 	.word	0x20000c70
 8007750:	08007771 	.word	0x08007771
 8007754:	0800aab8 	.word	0x0800aab8
 8007758:	0800c08c 	.word	0x0800c08c
 800775c:	0800aaf8 	.word	0x0800aaf8
 8007760:	0800aafc 	.word	0x0800aafc
 8007764:	0800c0e8 	.word	0x0800c0e8
 8007768:	0800a884 	.word	0x0800a884
 800776c:	00000000 	.word	0x00000000

08007770 <bmk_thread3>:
  chThdExit((msg_t)p);
 8007770:	f7fa bb86 	b.w	8001e80 <chThdExit>
	...

08007780 <rt_test_012_005_execute>:
static void rt_test_012_005_execute(void) {
 8007780:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
  return __sch_get_currthread();
 8007784:	4b1c      	ldr	r3, [pc, #112]	; (80077f8 <rt_test_012_005_execute+0x78>)
  test_set_step(1);
 8007786:	f8df 9074 	ldr.w	r9, [pc, #116]	; 80077fc <rt_test_012_005_execute+0x7c>
  return chThdGetSelfX()->hdr.pqueue.prio;
 800778a:	68da      	ldr	r2, [r3, #12]
      chThdWait(chThdCreateStatic(wa[0], WA_SIZE, prio, bmk_thread3, NULL));
 800778c:	f8df a070 	ldr.w	sl, [pc, #112]	; 8007800 <rt_test_012_005_execute+0x80>
  tprio_t prio = chThdGetPriorityX() - 1;
 8007790:	6896      	ldr	r6, [r2, #8]
  test_set_step(1);
 8007792:	2301      	movs	r3, #1
static void rt_test_012_005_execute(void) {
 8007794:	b082      	sub	sp, #8
  test_set_step(1);
 8007796:	f8c9 3000 	str.w	r3, [r9]
    start = test_wait_tick();
 800779a:	f7fd f881 	bl	80048a0 <test_wait_tick>
      chThdWait(chThdCreateStatic(wa[0], WA_SIZE, prio, bmk_thread3, NULL));
 800779e:	4b19      	ldr	r3, [pc, #100]	; (8007804 <rt_test_012_005_execute+0x84>)
    n = 0;
 80077a0:	2400      	movs	r4, #0
      chThdWait(chThdCreateStatic(wa[0], WA_SIZE, prio, bmk_thread3, NULL));
 80077a2:	f8d3 8000 	ldr.w	r8, [r3]
  tprio_t prio = chThdGetPriorityX() - 1;
 80077a6:	3e01      	subs	r6, #1
    start = test_wait_tick();
 80077a8:	4605      	mov	r5, r0
      chThdWait(chThdCreateStatic(wa[0], WA_SIZE, prio, bmk_thread3, NULL));
 80077aa:	4627      	mov	r7, r4
 80077ac:	4653      	mov	r3, sl
 80077ae:	4632      	mov	r2, r6
 80077b0:	f44f 71b8 	mov.w	r1, #368	; 0x170
 80077b4:	9700      	str	r7, [sp, #0]
 80077b6:	4640      	mov	r0, r8
 80077b8:	f7fa fafa 	bl	8001db0 <chThdCreateStatic>
 80077bc:	f7fa fb90 	bl	8001ee0 <chThdWait>
 80077c0:	f7f8 fe7e 	bl	80004c0 <stGetCounter>
    } while (chVTIsSystemTimeWithinX(start, end));
 80077c4:	f242 730f 	movw	r3, #9999	; 0x270f
 80077c8:	1b40      	subs	r0, r0, r5
 80077ca:	4298      	cmp	r0, r3
      n++;
 80077cc:	f104 0401 	add.w	r4, r4, #1
    } while (chVTIsSystemTimeWithinX(start, end));
 80077d0:	d9ec      	bls.n	80077ac <rt_test_012_005_execute+0x2c>
  test_set_step(2);
 80077d2:	2302      	movs	r3, #2
  test_printf("%s", msgp);
 80077d4:	490c      	ldr	r1, [pc, #48]	; (8007808 <rt_test_012_005_execute+0x88>)
 80077d6:	480d      	ldr	r0, [pc, #52]	; (800780c <rt_test_012_005_execute+0x8c>)
 80077d8:	f8c9 3000 	str.w	r3, [r9]
 80077dc:	f7fd f828 	bl	8004830 <test_printf>
  test_printf("%u", n);
 80077e0:	4621      	mov	r1, r4
 80077e2:	480b      	ldr	r0, [pc, #44]	; (8007810 <rt_test_012_005_execute+0x90>)
 80077e4:	f7fd f824 	bl	8004830 <test_printf>
  test_printf("%s" TEST_CFG_EOL_STRING, msgp);
 80077e8:	490a      	ldr	r1, [pc, #40]	; (8007814 <rt_test_012_005_execute+0x94>)
 80077ea:	480b      	ldr	r0, [pc, #44]	; (8007818 <rt_test_012_005_execute+0x98>)
}
 80077ec:	b002      	add	sp, #8
 80077ee:	e8bd 47f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 80077f2:	f7fd b81d 	b.w	8004830 <test_printf>
 80077f6:	bf00      	nop
 80077f8:	20000a40 	.word	0x20000a40
 80077fc:	20000c70 	.word	0x20000c70
 8007800:	08007771 	.word	0x08007771
 8007804:	0800aab8 	.word	0x0800aab8
 8007808:	0800c08c 	.word	0x0800c08c
 800780c:	0800aaf8 	.word	0x0800aaf8
 8007810:	0800aafc 	.word	0x0800aafc
 8007814:	0800c0e8 	.word	0x0800c0e8
 8007818:	0800a884 	.word	0x0800a884
 800781c:	00000000 	.word	0x00000000

08007820 <rt_test_012_004_execute>:
static void rt_test_012_004_execute(void) {
 8007820:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
  return __sch_get_currthread();
 8007824:	4b2d      	ldr	r3, [pc, #180]	; (80078dc <rt_test_012_004_execute+0xbc>)
    tp = threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()+1,
 8007826:	492e      	ldr	r1, [pc, #184]	; (80078e0 <rt_test_012_004_execute+0xc0>)
  return chThdGetSelfX()->hdr.pqueue.prio;
 8007828:	68db      	ldr	r3, [r3, #12]
  test_set_step(1);
 800782a:	f8df a0b8 	ldr.w	sl, [pc, #184]	; 80078e4 <rt_test_012_004_execute+0xc4>
    tp = threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()+1,
 800782e:	689a      	ldr	r2, [r3, #8]
 8007830:	6808      	ldr	r0, [r1, #0]
 8007832:	4b2d      	ldr	r3, [pc, #180]	; (80078e8 <rt_test_012_004_execute+0xc8>)
static void rt_test_012_004_execute(void) {
 8007834:	b082      	sub	sp, #8
    tp = threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()+1,
 8007836:	2500      	movs	r5, #0
  test_set_step(1);
 8007838:	2101      	movs	r1, #1
    tp = threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()+1,
 800783a:	3201      	adds	r2, #1
  test_set_step(1);
 800783c:	f8ca 1000 	str.w	r1, [sl]
    tp = threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()+1,
 8007840:	9500      	str	r5, [sp, #0]
 8007842:	f44f 71b8 	mov.w	r1, #368	; 0x170
 8007846:	f7fa fab3 	bl	8001db0 <chThdCreateStatic>
 800784a:	4a28      	ldr	r2, [pc, #160]	; (80078ec <rt_test_012_004_execute+0xcc>)
  test_set_step(2);
 800784c:	2302      	movs	r3, #2
    tp = threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()+1,
 800784e:	6010      	str	r0, [r2, #0]
 8007850:	4604      	mov	r4, r0
  test_set_step(2);
 8007852:	f8ca 3000 	str.w	r3, [sl]
    start = test_wait_tick();
 8007856:	f7fd f823 	bl	80048a0 <test_wait_tick>
 800785a:	f04f 0830 	mov.w	r8, #48	; 0x30
 800785e:	4606      	mov	r6, r0
      chSchWakeupS(tp, MSG_OK);
 8007860:	462f      	mov	r7, r5
    } while (chVTIsSystemTimeWithinX(start, end));
 8007862:	f242 790f 	movw	r9, #9999	; 0x270f
 8007866:	f388 8811 	msr	BASEPRI, r8
      chSchWakeupS(tp, MSG_OK);
 800786a:	2100      	movs	r1, #0
 800786c:	4620      	mov	r0, r4
 800786e:	f7fa f937 	bl	8001ae0 <chSchWakeupS>
      chSchWakeupS(tp, MSG_OK);
 8007872:	4620      	mov	r0, r4
 8007874:	2100      	movs	r1, #0
 8007876:	f7fa f933 	bl	8001ae0 <chSchWakeupS>
      chSchWakeupS(tp, MSG_OK);
 800787a:	4620      	mov	r0, r4
 800787c:	2100      	movs	r1, #0
 800787e:	f7fa f92f 	bl	8001ae0 <chSchWakeupS>
      chSchWakeupS(tp, MSG_OK);
 8007882:	2100      	movs	r1, #0
 8007884:	4620      	mov	r0, r4
 8007886:	f7fa f92b 	bl	8001ae0 <chSchWakeupS>
 800788a:	f387 8811 	msr	BASEPRI, r7
 800788e:	f7f8 fe17 	bl	80004c0 <stGetCounter>
 8007892:	1b80      	subs	r0, r0, r6
    } while (chVTIsSystemTimeWithinX(start, end));
 8007894:	4548      	cmp	r0, r9
      n += 4;
 8007896:	f105 0504 	add.w	r5, r5, #4
    } while (chVTIsSystemTimeWithinX(start, end));
 800789a:	d9e4      	bls.n	8007866 <rt_test_012_004_execute+0x46>
  test_set_step(3);
 800789c:	2303      	movs	r3, #3
 800789e:	f8ca 3000 	str.w	r3, [sl]
 80078a2:	f388 8811 	msr	BASEPRI, r8
    chSchWakeupS(tp, MSG_TIMEOUT);
 80078a6:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
 80078aa:	4620      	mov	r0, r4
 80078ac:	f7fa f918 	bl	8001ae0 <chSchWakeupS>
 80078b0:	f387 8811 	msr	BASEPRI, r7
    test_wait_threads();
 80078b4:	f7fc ffdc 	bl	8004870 <test_wait_threads>
  test_set_step(4);
 80078b8:	2304      	movs	r3, #4
  test_printf("%s", msgp);
 80078ba:	490d      	ldr	r1, [pc, #52]	; (80078f0 <rt_test_012_004_execute+0xd0>)
 80078bc:	480d      	ldr	r0, [pc, #52]	; (80078f4 <rt_test_012_004_execute+0xd4>)
 80078be:	f8ca 3000 	str.w	r3, [sl]
 80078c2:	f7fc ffb5 	bl	8004830 <test_printf>
  test_printf("%u", n);
 80078c6:	0069      	lsls	r1, r5, #1
 80078c8:	480b      	ldr	r0, [pc, #44]	; (80078f8 <rt_test_012_004_execute+0xd8>)
 80078ca:	f7fc ffb1 	bl	8004830 <test_printf>
  test_printf("%s" TEST_CFG_EOL_STRING, msgp);
 80078ce:	490b      	ldr	r1, [pc, #44]	; (80078fc <rt_test_012_004_execute+0xdc>)
 80078d0:	480b      	ldr	r0, [pc, #44]	; (8007900 <rt_test_012_004_execute+0xe0>)
}
 80078d2:	b002      	add	sp, #8
 80078d4:	e8bd 47f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 80078d8:	f7fc bfaa 	b.w	8004830 <test_printf>
 80078dc:	20000a40 	.word	0x20000a40
 80078e0:	0800aab8 	.word	0x0800aab8
 80078e4:	20000c70 	.word	0x20000c70
 80078e8:	08007911 	.word	0x08007911
 80078ec:	200013c8 	.word	0x200013c8
 80078f0:	0800c08c 	.word	0x0800c08c
 80078f4:	0800aaf8 	.word	0x0800aaf8
 80078f8:	0800aafc 	.word	0x0800aafc
 80078fc:	0800c0c8 	.word	0x0800c0c8
 8007900:	0800a884 	.word	0x0800a884
	...

08007910 <bmk_thread4>:
  return __sch_get_currthread();
 8007910:	4a07      	ldr	r2, [pc, #28]	; (8007930 <bmk_thread4+0x20>)
static THD_FUNCTION(bmk_thread4, p) {
 8007912:	b510      	push	{r4, lr}
 8007914:	2330      	movs	r3, #48	; 0x30
 8007916:	68d4      	ldr	r4, [r2, #12]
 8007918:	f383 8811 	msr	BASEPRI, r3
    chSchGoSleepS(CH_STATE_SUSPENDED);
 800791c:	2003      	movs	r0, #3
 800791e:	f7fa f88f 	bl	8001a40 <chSchGoSleepS>
  } while (msg == MSG_OK);
 8007922:	6aa3      	ldr	r3, [r4, #40]	; 0x28
 8007924:	2b00      	cmp	r3, #0
 8007926:	d0f9      	beq.n	800791c <bmk_thread4+0xc>
 8007928:	2300      	movs	r3, #0
 800792a:	f383 8811 	msr	BASEPRI, r3
}
 800792e:	bd10      	pop	{r4, pc}
 8007930:	20000a40 	.word	0x20000a40
	...

08007940 <bmk_thread1>:
static THD_FUNCTION(bmk_thread1, p) {
 8007940:	b570      	push	{r4, r5, r6, lr}
 8007942:	2630      	movs	r6, #48	; 0x30
 8007944:	2500      	movs	r5, #0
 8007946:	f386 8811 	msr	BASEPRI, r6
  tp = chMsgWaitS();
 800794a:	f7fb f901 	bl	8002b50 <chMsgWaitS>
 800794e:	f385 8811 	msr	BASEPRI, r5
  return tp->u.sentmsg;
 8007952:	6a84      	ldr	r4, [r0, #40]	; 0x28
    chMsgRelease(tp, msg);
 8007954:	4621      	mov	r1, r4
 8007956:	f7fb f913 	bl	8002b80 <chMsgRelease>
  } while (msg);
 800795a:	2c00      	cmp	r4, #0
 800795c:	d1f3      	bne.n	8007946 <bmk_thread1+0x6>
}
 800795e:	bd70      	pop	{r4, r5, r6, pc}

08007960 <msg_loop_test>:
NOINLINE static unsigned int msg_loop_test(thread_t *tp) {
 8007960:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8007962:	4605      	mov	r5, r0
  start = test_wait_tick();
 8007964:	f7fc ff9c 	bl	80048a0 <test_wait_tick>
  uint32_t n = 0;
 8007968:	2400      	movs	r4, #0
  start = test_wait_tick();
 800796a:	4606      	mov	r6, r0
  } while (chVTIsSystemTimeWithinX(start, end));
 800796c:	f242 770f 	movw	r7, #9999	; 0x270f
    (void)chMsgSend(tp, 1);
 8007970:	2101      	movs	r1, #1
 8007972:	4628      	mov	r0, r5
 8007974:	f7fb f8cc 	bl	8002b10 <chMsgSend>
 8007978:	f7f8 fda2 	bl	80004c0 <stGetCounter>
 800797c:	1b80      	subs	r0, r0, r6
  } while (chVTIsSystemTimeWithinX(start, end));
 800797e:	42b8      	cmp	r0, r7
    n++;
 8007980:	f104 0401 	add.w	r4, r4, #1
  } while (chVTIsSystemTimeWithinX(start, end));
 8007984:	d9f4      	bls.n	8007970 <msg_loop_test+0x10>
  (void)chMsgSend(tp, 0);
 8007986:	2100      	movs	r1, #0
 8007988:	4628      	mov	r0, r5
 800798a:	f7fb f8c1 	bl	8002b10 <chMsgSend>
}
 800798e:	4620      	mov	r0, r4
 8007990:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8007992:	bf00      	nop
	...

080079a0 <rt_test_012_003_execute>:
static void rt_test_012_003_execute(void) {
 80079a0:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 80079a4:	4f36      	ldr	r7, [pc, #216]	; (8007a80 <rt_test_012_003_execute+0xe0>)
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()+1, bmk_thread1, NULL);
 80079a6:	4d37      	ldr	r5, [pc, #220]	; (8007a84 <rt_test_012_003_execute+0xe4>)
  return chThdGetSelfX()->hdr.pqueue.prio;
 80079a8:	68fb      	ldr	r3, [r7, #12]
  test_set_step(1);
 80079aa:	f8df 80dc 	ldr.w	r8, [pc, #220]	; 8007a88 <rt_test_012_003_execute+0xe8>
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()+1, bmk_thread1, NULL);
 80079ae:	689a      	ldr	r2, [r3, #8]
 80079b0:	6828      	ldr	r0, [r5, #0]
 80079b2:	4b36      	ldr	r3, [pc, #216]	; (8007a8c <rt_test_012_003_execute+0xec>)
    threads[1] = chThdCreateStatic(wa[1], WA_SIZE, chThdGetPriorityX()-2, bmk_thread3, NULL);
 80079b4:	f8df 90d8 	ldr.w	r9, [pc, #216]	; 8007a90 <rt_test_012_003_execute+0xf0>
static void rt_test_012_003_execute(void) {
 80079b8:	b083      	sub	sp, #12
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()+1, bmk_thread1, NULL);
 80079ba:	2600      	movs	r6, #0
 80079bc:	9600      	str	r6, [sp, #0]
 80079be:	3201      	adds	r2, #1
 80079c0:	f44f 71b8 	mov.w	r1, #368	; 0x170
  test_set_step(1);
 80079c4:	2401      	movs	r4, #1
 80079c6:	f8c8 4000 	str.w	r4, [r8]
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()+1, bmk_thread1, NULL);
 80079ca:	f7fa f9f1 	bl	8001db0 <chThdCreateStatic>
 80079ce:	68fb      	ldr	r3, [r7, #12]
 80079d0:	4c30      	ldr	r4, [pc, #192]	; (8007a94 <rt_test_012_003_execute+0xf4>)
    threads[1] = chThdCreateStatic(wa[1], WA_SIZE, chThdGetPriorityX()-2, bmk_thread3, NULL);
 80079d2:	689a      	ldr	r2, [r3, #8]
 80079d4:	9600      	str	r6, [sp, #0]
  test_set_step(2);
 80079d6:	f04f 0c02 	mov.w	ip, #2
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()+1, bmk_thread1, NULL);
 80079da:	6020      	str	r0, [r4, #0]
    threads[1] = chThdCreateStatic(wa[1], WA_SIZE, chThdGetPriorityX()-2, bmk_thread3, NULL);
 80079dc:	464b      	mov	r3, r9
 80079de:	6868      	ldr	r0, [r5, #4]
  test_set_step(2);
 80079e0:	f8c8 c000 	str.w	ip, [r8]
    threads[1] = chThdCreateStatic(wa[1], WA_SIZE, chThdGetPriorityX()-2, bmk_thread3, NULL);
 80079e4:	3a02      	subs	r2, #2
 80079e6:	f44f 71b8 	mov.w	r1, #368	; 0x170
 80079ea:	f7fa f9e1 	bl	8001db0 <chThdCreateStatic>
 80079ee:	68fb      	ldr	r3, [r7, #12]
 80079f0:	6060      	str	r0, [r4, #4]
    threads[2] = chThdCreateStatic(wa[2], WA_SIZE, chThdGetPriorityX()-3, bmk_thread3, NULL);
 80079f2:	689a      	ldr	r2, [r3, #8]
 80079f4:	68a8      	ldr	r0, [r5, #8]
 80079f6:	9600      	str	r6, [sp, #0]
 80079f8:	464b      	mov	r3, r9
 80079fa:	3a03      	subs	r2, #3
 80079fc:	f44f 71b8 	mov.w	r1, #368	; 0x170
 8007a00:	f7fa f9d6 	bl	8001db0 <chThdCreateStatic>
 8007a04:	68fb      	ldr	r3, [r7, #12]
 8007a06:	60a0      	str	r0, [r4, #8]
    threads[3] = chThdCreateStatic(wa[3], WA_SIZE, chThdGetPriorityX()-4, bmk_thread3, NULL);
 8007a08:	689a      	ldr	r2, [r3, #8]
 8007a0a:	68e8      	ldr	r0, [r5, #12]
 8007a0c:	9600      	str	r6, [sp, #0]
 8007a0e:	464b      	mov	r3, r9
 8007a10:	3a04      	subs	r2, #4
 8007a12:	f44f 71b8 	mov.w	r1, #368	; 0x170
 8007a16:	f7fa f9cb 	bl	8001db0 <chThdCreateStatic>
 8007a1a:	68fa      	ldr	r2, [r7, #12]
 8007a1c:	60e0      	str	r0, [r4, #12]
    threads[4] = chThdCreateStatic(wa[4], WA_SIZE, chThdGetPriorityX()-5, bmk_thread3, NULL);
 8007a1e:	6892      	ldr	r2, [r2, #8]
 8007a20:	6928      	ldr	r0, [r5, #16]
 8007a22:	9600      	str	r6, [sp, #0]
 8007a24:	f44f 71b8 	mov.w	r1, #368	; 0x170
 8007a28:	464b      	mov	r3, r9
 8007a2a:	3a05      	subs	r2, #5
 8007a2c:	f7fa f9c0 	bl	8001db0 <chThdCreateStatic>
 8007a30:	4603      	mov	r3, r0
  test_set_step(3);
 8007a32:	2203      	movs	r2, #3
    threads[4] = chThdCreateStatic(wa[4], WA_SIZE, chThdGetPriorityX()-5, bmk_thread3, NULL);
 8007a34:	6123      	str	r3, [r4, #16]
    n = msg_loop_test(threads[0]);
 8007a36:	6820      	ldr	r0, [r4, #0]
  test_set_step(3);
 8007a38:	f8c8 2000 	str.w	r2, [r8]
    n = msg_loop_test(threads[0]);
 8007a3c:	f7ff ff90 	bl	8007960 <msg_loop_test>
  test_printf("%s", msgp);
 8007a40:	4e15      	ldr	r6, [pc, #84]	; (8007a98 <rt_test_012_003_execute+0xf8>)
  test_printf("%u", n);
 8007a42:	4d16      	ldr	r5, [pc, #88]	; (8007a9c <rt_test_012_003_execute+0xfc>)
 8007a44:	4604      	mov	r4, r0
    test_wait_threads();
 8007a46:	f7fc ff13 	bl	8004870 <test_wait_threads>
  test_set_step(4);
 8007a4a:	2304      	movs	r3, #4
  test_printf("%s", msgp);
 8007a4c:	4914      	ldr	r1, [pc, #80]	; (8007aa0 <rt_test_012_003_execute+0x100>)
 8007a4e:	f8c8 3000 	str.w	r3, [r8]
 8007a52:	4630      	mov	r0, r6
 8007a54:	f7fc feec 	bl	8004830 <test_printf>
  test_printf("%u", n);
 8007a58:	4621      	mov	r1, r4
 8007a5a:	4628      	mov	r0, r5
 8007a5c:	f7fc fee8 	bl	8004830 <test_printf>
  test_printf("%s", msgp);
 8007a60:	4910      	ldr	r1, [pc, #64]	; (8007aa4 <rt_test_012_003_execute+0x104>)
 8007a62:	4630      	mov	r0, r6
 8007a64:	f7fc fee4 	bl	8004830 <test_printf>
  test_printf("%u", n);
 8007a68:	0061      	lsls	r1, r4, #1
 8007a6a:	4628      	mov	r0, r5
 8007a6c:	f7fc fee0 	bl	8004830 <test_printf>
  test_printf("%s" TEST_CFG_EOL_STRING, msgp);
 8007a70:	490d      	ldr	r1, [pc, #52]	; (8007aa8 <rt_test_012_003_execute+0x108>)
 8007a72:	480e      	ldr	r0, [pc, #56]	; (8007aac <rt_test_012_003_execute+0x10c>)
}
 8007a74:	b003      	add	sp, #12
 8007a76:	e8bd 43f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, lr}
 8007a7a:	f7fc bed9 	b.w	8004830 <test_printf>
 8007a7e:	bf00      	nop
 8007a80:	20000a40 	.word	0x20000a40
 8007a84:	0800aab8 	.word	0x0800aab8
 8007a88:	20000c70 	.word	0x20000c70
 8007a8c:	08007941 	.word	0x08007941
 8007a90:	08007771 	.word	0x08007771
 8007a94:	200013c8 	.word	0x200013c8
 8007a98:	0800aaf8 	.word	0x0800aaf8
 8007a9c:	0800aafc 	.word	0x0800aafc
 8007aa0:	0800c08c 	.word	0x0800c08c
 8007aa4:	0800c0f4 	.word	0x0800c0f4
 8007aa8:	0800c0c8 	.word	0x0800c0c8
 8007aac:	0800a884 	.word	0x0800a884

08007ab0 <rt_test_012_002_execute>:
static void rt_test_012_002_execute(void) {
 8007ab0:	b5f0      	push	{r4, r5, r6, r7, lr}
  return __sch_get_currthread();
 8007ab2:	4b1a      	ldr	r3, [pc, #104]	; (8007b1c <rt_test_012_002_execute+0x6c>)
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()+1, bmk_thread1, NULL);
 8007ab4:	491a      	ldr	r1, [pc, #104]	; (8007b20 <rt_test_012_002_execute+0x70>)
  return chThdGetSelfX()->hdr.pqueue.prio;
 8007ab6:	68db      	ldr	r3, [r3, #12]
  test_set_step(1);
 8007ab8:	4d1a      	ldr	r5, [pc, #104]	; (8007b24 <rt_test_012_002_execute+0x74>)
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()+1, bmk_thread1, NULL);
 8007aba:	689a      	ldr	r2, [r3, #8]
 8007abc:	6808      	ldr	r0, [r1, #0]
 8007abe:	4b1a      	ldr	r3, [pc, #104]	; (8007b28 <rt_test_012_002_execute+0x78>)
  test_printf("%s", msgp);
 8007ac0:	4f1a      	ldr	r7, [pc, #104]	; (8007b2c <rt_test_012_002_execute+0x7c>)
  test_printf("%u", n);
 8007ac2:	4e1b      	ldr	r6, [pc, #108]	; (8007b30 <rt_test_012_002_execute+0x80>)
static void rt_test_012_002_execute(void) {
 8007ac4:	b083      	sub	sp, #12
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()+1, bmk_thread1, NULL);
 8007ac6:	2400      	movs	r4, #0
  test_set_step(1);
 8007ac8:	2101      	movs	r1, #1
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()+1, bmk_thread1, NULL);
 8007aca:	9400      	str	r4, [sp, #0]
  test_set_step(1);
 8007acc:	6029      	str	r1, [r5, #0]
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()+1, bmk_thread1, NULL);
 8007ace:	3201      	adds	r2, #1
 8007ad0:	f44f 71b8 	mov.w	r1, #368	; 0x170
 8007ad4:	f7fa f96c 	bl	8001db0 <chThdCreateStatic>
 8007ad8:	4b16      	ldr	r3, [pc, #88]	; (8007b34 <rt_test_012_002_execute+0x84>)
  test_set_step(2);
 8007ada:	2202      	movs	r2, #2
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()+1, bmk_thread1, NULL);
 8007adc:	6018      	str	r0, [r3, #0]
  test_set_step(2);
 8007ade:	602a      	str	r2, [r5, #0]
    n = msg_loop_test(threads[0]);
 8007ae0:	f7ff ff3e 	bl	8007960 <msg_loop_test>
 8007ae4:	4604      	mov	r4, r0
    test_wait_threads();
 8007ae6:	f7fc fec3 	bl	8004870 <test_wait_threads>
  test_set_step(3);
 8007aea:	2303      	movs	r3, #3
  test_printf("%s", msgp);
 8007aec:	4912      	ldr	r1, [pc, #72]	; (8007b38 <rt_test_012_002_execute+0x88>)
 8007aee:	602b      	str	r3, [r5, #0]
 8007af0:	4638      	mov	r0, r7
 8007af2:	f7fc fe9d 	bl	8004830 <test_printf>
  test_printf("%u", n);
 8007af6:	4621      	mov	r1, r4
 8007af8:	4630      	mov	r0, r6
 8007afa:	f7fc fe99 	bl	8004830 <test_printf>
  test_printf("%s", msgp);
 8007afe:	490f      	ldr	r1, [pc, #60]	; (8007b3c <rt_test_012_002_execute+0x8c>)
 8007b00:	4638      	mov	r0, r7
 8007b02:	f7fc fe95 	bl	8004830 <test_printf>
  test_printf("%u", n);
 8007b06:	0061      	lsls	r1, r4, #1
 8007b08:	4630      	mov	r0, r6
 8007b0a:	f7fc fe91 	bl	8004830 <test_printf>
  test_printf("%s" TEST_CFG_EOL_STRING, msgp);
 8007b0e:	490c      	ldr	r1, [pc, #48]	; (8007b40 <rt_test_012_002_execute+0x90>)
 8007b10:	480c      	ldr	r0, [pc, #48]	; (8007b44 <rt_test_012_002_execute+0x94>)
}
 8007b12:	b003      	add	sp, #12
 8007b14:	e8bd 40f0 	ldmia.w	sp!, {r4, r5, r6, r7, lr}
 8007b18:	f7fc be8a 	b.w	8004830 <test_printf>
 8007b1c:	20000a40 	.word	0x20000a40
 8007b20:	0800aab8 	.word	0x0800aab8
 8007b24:	20000c70 	.word	0x20000c70
 8007b28:	08007941 	.word	0x08007941
 8007b2c:	0800aaf8 	.word	0x0800aaf8
 8007b30:	0800aafc 	.word	0x0800aafc
 8007b34:	200013c8 	.word	0x200013c8
 8007b38:	0800c08c 	.word	0x0800c08c
 8007b3c:	0800c0f4 	.word	0x0800c0f4
 8007b40:	0800c0c8 	.word	0x0800c0c8
 8007b44:	0800a884 	.word	0x0800a884
	...

08007b50 <rt_test_012_001_execute>:
static void rt_test_012_001_execute(void) {
 8007b50:	b5f0      	push	{r4, r5, r6, r7, lr}
  return __sch_get_currthread();
 8007b52:	4b1a      	ldr	r3, [pc, #104]	; (8007bbc <rt_test_012_001_execute+0x6c>)
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()-1, bmk_thread1, NULL);
 8007b54:	491a      	ldr	r1, [pc, #104]	; (8007bc0 <rt_test_012_001_execute+0x70>)
  return chThdGetSelfX()->hdr.pqueue.prio;
 8007b56:	68db      	ldr	r3, [r3, #12]
  test_set_step(1);
 8007b58:	4d1a      	ldr	r5, [pc, #104]	; (8007bc4 <rt_test_012_001_execute+0x74>)
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()-1, bmk_thread1, NULL);
 8007b5a:	689a      	ldr	r2, [r3, #8]
 8007b5c:	6808      	ldr	r0, [r1, #0]
 8007b5e:	4b1a      	ldr	r3, [pc, #104]	; (8007bc8 <rt_test_012_001_execute+0x78>)
  test_printf("%s", msgp);
 8007b60:	4f1a      	ldr	r7, [pc, #104]	; (8007bcc <rt_test_012_001_execute+0x7c>)
  test_printf("%u", n);
 8007b62:	4e1b      	ldr	r6, [pc, #108]	; (8007bd0 <rt_test_012_001_execute+0x80>)
static void rt_test_012_001_execute(void) {
 8007b64:	b083      	sub	sp, #12
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()-1, bmk_thread1, NULL);
 8007b66:	2400      	movs	r4, #0
  test_set_step(1);
 8007b68:	2101      	movs	r1, #1
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()-1, bmk_thread1, NULL);
 8007b6a:	9400      	str	r4, [sp, #0]
  test_set_step(1);
 8007b6c:	6029      	str	r1, [r5, #0]
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()-1, bmk_thread1, NULL);
 8007b6e:	3a01      	subs	r2, #1
 8007b70:	f44f 71b8 	mov.w	r1, #368	; 0x170
 8007b74:	f7fa f91c 	bl	8001db0 <chThdCreateStatic>
 8007b78:	4b16      	ldr	r3, [pc, #88]	; (8007bd4 <rt_test_012_001_execute+0x84>)
  test_set_step(2);
 8007b7a:	2202      	movs	r2, #2
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()-1, bmk_thread1, NULL);
 8007b7c:	6018      	str	r0, [r3, #0]
  test_set_step(2);
 8007b7e:	602a      	str	r2, [r5, #0]
    n = msg_loop_test(threads[0]);
 8007b80:	f7ff feee 	bl	8007960 <msg_loop_test>
 8007b84:	4604      	mov	r4, r0
    test_wait_threads();
 8007b86:	f7fc fe73 	bl	8004870 <test_wait_threads>
  test_set_step(3);
 8007b8a:	2303      	movs	r3, #3
  test_printf("%s", msgp);
 8007b8c:	4912      	ldr	r1, [pc, #72]	; (8007bd8 <rt_test_012_001_execute+0x88>)
 8007b8e:	602b      	str	r3, [r5, #0]
 8007b90:	4638      	mov	r0, r7
 8007b92:	f7fc fe4d 	bl	8004830 <test_printf>
  test_printf("%u", n);
 8007b96:	4621      	mov	r1, r4
 8007b98:	4630      	mov	r0, r6
 8007b9a:	f7fc fe49 	bl	8004830 <test_printf>
  test_printf("%s", msgp);
 8007b9e:	490f      	ldr	r1, [pc, #60]	; (8007bdc <rt_test_012_001_execute+0x8c>)
 8007ba0:	4638      	mov	r0, r7
 8007ba2:	f7fc fe45 	bl	8004830 <test_printf>
  test_printf("%u", n);
 8007ba6:	0061      	lsls	r1, r4, #1
 8007ba8:	4630      	mov	r0, r6
 8007baa:	f7fc fe41 	bl	8004830 <test_printf>
  test_printf("%s" TEST_CFG_EOL_STRING, msgp);
 8007bae:	490c      	ldr	r1, [pc, #48]	; (8007be0 <rt_test_012_001_execute+0x90>)
 8007bb0:	480c      	ldr	r0, [pc, #48]	; (8007be4 <rt_test_012_001_execute+0x94>)
}
 8007bb2:	b003      	add	sp, #12
 8007bb4:	e8bd 40f0 	ldmia.w	sp!, {r4, r5, r6, r7, lr}
 8007bb8:	f7fc be3a 	b.w	8004830 <test_printf>
 8007bbc:	20000a40 	.word	0x20000a40
 8007bc0:	0800aab8 	.word	0x0800aab8
 8007bc4:	20000c70 	.word	0x20000c70
 8007bc8:	08007941 	.word	0x08007941
 8007bcc:	0800aaf8 	.word	0x0800aaf8
 8007bd0:	0800aafc 	.word	0x0800aafc
 8007bd4:	200013c8 	.word	0x200013c8
 8007bd8:	0800c08c 	.word	0x0800c08c
 8007bdc:	0800c0f4 	.word	0x0800c0f4
 8007be0:	0800c0c8 	.word	0x0800c0c8
 8007be4:	0800a884 	.word	0x0800a884
	...

08007bf0 <oslib_test_001_003_execute>:
 * <h2>Test Steps</h2>
 * - [1.3.1] Prints the configuration options settings.
 * .
 */

static void oslib_test_001_003_execute(void) {
 8007bf0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  test_printf("%s", msgp);
 8007bf4:	f8df 8190 	ldr.w	r8, [pc, #400]	; 8007d88 <oslib_test_001_003_execute+0x198>

  /* [1.3.1] Prints the configuration options settings.*/
  test_set_step(1);
 8007bf8:	4b64      	ldr	r3, [pc, #400]	; (8007d8c <oslib_test_001_003_execute+0x19c>)
  test_printf("%u", n);
 8007bfa:	4e65      	ldr	r6, [pc, #404]	; (8007d90 <oslib_test_001_003_execute+0x1a0>)
  test_printf("%s" TEST_CFG_EOL_STRING, msgp);
 8007bfc:	4d65      	ldr	r5, [pc, #404]	; (8007d94 <oslib_test_001_003_execute+0x1a4>)
 8007bfe:	4c66      	ldr	r4, [pc, #408]	; (8007d98 <oslib_test_001_003_execute+0x1a8>)
  test_printf("%s", msgp);
 8007c00:	4966      	ldr	r1, [pc, #408]	; (8007d9c <oslib_test_001_003_execute+0x1ac>)
 8007c02:	2701      	movs	r7, #1
 8007c04:	4640      	mov	r0, r8
 8007c06:	601f      	str	r7, [r3, #0]
 8007c08:	f7fc fe12 	bl	8004830 <test_printf>
  test_printf("%u", n);
 8007c0c:	4639      	mov	r1, r7
 8007c0e:	4630      	mov	r0, r6
 8007c10:	f7fc fe0e 	bl	8004830 <test_printf>
  test_printf("%s" TEST_CFG_EOL_STRING, msgp);
 8007c14:	4629      	mov	r1, r5
 8007c16:	4620      	mov	r0, r4
 8007c18:	f7fc fe0a 	bl	8004830 <test_printf>
  test_printf("%s", msgp);
 8007c1c:	4960      	ldr	r1, [pc, #384]	; (8007da0 <oslib_test_001_003_execute+0x1b0>)
 8007c1e:	4640      	mov	r0, r8
 8007c20:	f7fc fe06 	bl	8004830 <test_printf>
  test_printf("%u", n);
 8007c24:	4639      	mov	r1, r7
 8007c26:	4630      	mov	r0, r6
 8007c28:	f7fc fe02 	bl	8004830 <test_printf>
  test_printf("%s" TEST_CFG_EOL_STRING, msgp);
 8007c2c:	4629      	mov	r1, r5
 8007c2e:	4620      	mov	r0, r4
 8007c30:	f7fc fdfe 	bl	8004830 <test_printf>
  test_printf("%s", msgp);
 8007c34:	495b      	ldr	r1, [pc, #364]	; (8007da4 <oslib_test_001_003_execute+0x1b4>)
 8007c36:	4640      	mov	r0, r8
 8007c38:	f7fc fdfa 	bl	8004830 <test_printf>
  test_printf("%u", n);
 8007c3c:	4639      	mov	r1, r7
 8007c3e:	4630      	mov	r0, r6
 8007c40:	f7fc fdf6 	bl	8004830 <test_printf>
  test_printf("%s" TEST_CFG_EOL_STRING, msgp);
 8007c44:	4629      	mov	r1, r5
 8007c46:	4620      	mov	r0, r4
 8007c48:	f7fc fdf2 	bl	8004830 <test_printf>
  test_printf("%s", msgp);
 8007c4c:	4956      	ldr	r1, [pc, #344]	; (8007da8 <oslib_test_001_003_execute+0x1b8>)
 8007c4e:	4640      	mov	r0, r8
 8007c50:	f7fc fdee 	bl	8004830 <test_printf>
  test_printf("%u", n);
 8007c54:	4639      	mov	r1, r7
 8007c56:	4630      	mov	r0, r6
 8007c58:	f7fc fdea 	bl	8004830 <test_printf>
  test_printf("%s" TEST_CFG_EOL_STRING, msgp);
 8007c5c:	4629      	mov	r1, r5
 8007c5e:	4620      	mov	r0, r4
 8007c60:	f7fc fde6 	bl	8004830 <test_printf>
  test_printf("%s", msgp);
 8007c64:	4951      	ldr	r1, [pc, #324]	; (8007dac <oslib_test_001_003_execute+0x1bc>)
 8007c66:	4640      	mov	r0, r8
 8007c68:	f7fc fde2 	bl	8004830 <test_printf>
  test_printf("%u", n);
 8007c6c:	4639      	mov	r1, r7
 8007c6e:	4630      	mov	r0, r6
 8007c70:	f7fc fdde 	bl	8004830 <test_printf>
  test_printf("%s" TEST_CFG_EOL_STRING, msgp);
 8007c74:	4629      	mov	r1, r5
 8007c76:	4620      	mov	r0, r4
 8007c78:	f7fc fdda 	bl	8004830 <test_printf>
  test_printf("%s", msgp);
 8007c7c:	494c      	ldr	r1, [pc, #304]	; (8007db0 <oslib_test_001_003_execute+0x1c0>)
 8007c7e:	4640      	mov	r0, r8
 8007c80:	f7fc fdd6 	bl	8004830 <test_printf>
  test_printf("%u", n);
 8007c84:	4639      	mov	r1, r7
 8007c86:	4630      	mov	r0, r6
 8007c88:	f7fc fdd2 	bl	8004830 <test_printf>
  test_printf("%s" TEST_CFG_EOL_STRING, msgp);
 8007c8c:	4629      	mov	r1, r5
 8007c8e:	4620      	mov	r0, r4
 8007c90:	f7fc fdce 	bl	8004830 <test_printf>
  test_printf("%s", msgp);
 8007c94:	4947      	ldr	r1, [pc, #284]	; (8007db4 <oslib_test_001_003_execute+0x1c4>)
 8007c96:	4640      	mov	r0, r8
 8007c98:	f7fc fdca 	bl	8004830 <test_printf>
  test_printf("%u", n);
 8007c9c:	4639      	mov	r1, r7
 8007c9e:	4630      	mov	r0, r6
 8007ca0:	f7fc fdc6 	bl	8004830 <test_printf>
  test_printf("%s" TEST_CFG_EOL_STRING, msgp);
 8007ca4:	4629      	mov	r1, r5
 8007ca6:	4620      	mov	r0, r4
 8007ca8:	f7fc fdc2 	bl	8004830 <test_printf>
  test_printf("%s", msgp);
 8007cac:	4942      	ldr	r1, [pc, #264]	; (8007db8 <oslib_test_001_003_execute+0x1c8>)
 8007cae:	4640      	mov	r0, r8
 8007cb0:	f7fc fdbe 	bl	8004830 <test_printf>
  test_printf("%u", n);
 8007cb4:	4639      	mov	r1, r7
 8007cb6:	4630      	mov	r0, r6
 8007cb8:	f7fc fdba 	bl	8004830 <test_printf>
  test_printf("%s" TEST_CFG_EOL_STRING, msgp);
 8007cbc:	4629      	mov	r1, r5
 8007cbe:	4620      	mov	r0, r4
 8007cc0:	f7fc fdb6 	bl	8004830 <test_printf>
  test_printf("%s", msgp);
 8007cc4:	493d      	ldr	r1, [pc, #244]	; (8007dbc <oslib_test_001_003_execute+0x1cc>)
 8007cc6:	4640      	mov	r0, r8
 8007cc8:	f7fc fdb2 	bl	8004830 <test_printf>
  test_printf("%u", n);
 8007ccc:	4639      	mov	r1, r7
 8007cce:	4630      	mov	r0, r6
 8007cd0:	f7fc fdae 	bl	8004830 <test_printf>
  test_printf("%s" TEST_CFG_EOL_STRING, msgp);
 8007cd4:	4629      	mov	r1, r5
 8007cd6:	4620      	mov	r0, r4
 8007cd8:	f7fc fdaa 	bl	8004830 <test_printf>
  test_printf("%s", msgp);
 8007cdc:	4938      	ldr	r1, [pc, #224]	; (8007dc0 <oslib_test_001_003_execute+0x1d0>)
 8007cde:	4640      	mov	r0, r8
 8007ce0:	f7fc fda6 	bl	8004830 <test_printf>
  test_printf("%u", n);
 8007ce4:	2108      	movs	r1, #8
 8007ce6:	4630      	mov	r0, r6
 8007ce8:	f7fc fda2 	bl	8004830 <test_printf>
  test_printf("%s" TEST_CFG_EOL_STRING, msgp);
 8007cec:	4629      	mov	r1, r5
 8007cee:	4620      	mov	r0, r4
 8007cf0:	f7fc fd9e 	bl	8004830 <test_printf>
  test_printf("%s", msgp);
 8007cf4:	4933      	ldr	r1, [pc, #204]	; (8007dc4 <oslib_test_001_003_execute+0x1d4>)
 8007cf6:	4640      	mov	r0, r8
 8007cf8:	f7fc fd9a 	bl	8004830 <test_printf>
  test_printf("%u", n);
 8007cfc:	4639      	mov	r1, r7
 8007cfe:	4630      	mov	r0, r6
 8007d00:	f7fc fd96 	bl	8004830 <test_printf>
  test_printf("%s" TEST_CFG_EOL_STRING, msgp);
 8007d04:	4629      	mov	r1, r5
 8007d06:	4620      	mov	r0, r4
 8007d08:	f7fc fd92 	bl	8004830 <test_printf>
  test_printf("%s", msgp);
 8007d0c:	492e      	ldr	r1, [pc, #184]	; (8007dc8 <oslib_test_001_003_execute+0x1d8>)
 8007d0e:	4640      	mov	r0, r8
 8007d10:	f7fc fd8e 	bl	8004830 <test_printf>
  test_printf("%u", n);
 8007d14:	4639      	mov	r1, r7
 8007d16:	4630      	mov	r0, r6
 8007d18:	f7fc fd8a 	bl	8004830 <test_printf>
  test_printf("%s" TEST_CFG_EOL_STRING, msgp);
 8007d1c:	4629      	mov	r1, r5
 8007d1e:	4620      	mov	r0, r4
 8007d20:	f7fc fd86 	bl	8004830 <test_printf>
  test_printf("%s", msgp);
 8007d24:	4929      	ldr	r1, [pc, #164]	; (8007dcc <oslib_test_001_003_execute+0x1dc>)
 8007d26:	4640      	mov	r0, r8
 8007d28:	f7fc fd82 	bl	8004830 <test_printf>
  test_printf("%u", n);
 8007d2c:	4639      	mov	r1, r7
 8007d2e:	4630      	mov	r0, r6
 8007d30:	f7fc fd7e 	bl	8004830 <test_printf>
  test_printf("%s" TEST_CFG_EOL_STRING, msgp);
 8007d34:	4629      	mov	r1, r5
 8007d36:	4620      	mov	r0, r4
 8007d38:	f7fc fd7a 	bl	8004830 <test_printf>
  test_printf("%s", msgp);
 8007d3c:	4924      	ldr	r1, [pc, #144]	; (8007dd0 <oslib_test_001_003_execute+0x1e0>)
 8007d3e:	4640      	mov	r0, r8
 8007d40:	f7fc fd76 	bl	8004830 <test_printf>
  test_printf("%u", n);
 8007d44:	4639      	mov	r1, r7
 8007d46:	4630      	mov	r0, r6
 8007d48:	f7fc fd72 	bl	8004830 <test_printf>
  test_printf("%s" TEST_CFG_EOL_STRING, msgp);
 8007d4c:	4629      	mov	r1, r5
 8007d4e:	4620      	mov	r0, r4
 8007d50:	f7fc fd6e 	bl	8004830 <test_printf>
  test_printf("%s", msgp);
 8007d54:	491f      	ldr	r1, [pc, #124]	; (8007dd4 <oslib_test_001_003_execute+0x1e4>)
 8007d56:	4640      	mov	r0, r8
 8007d58:	f7fc fd6a 	bl	8004830 <test_printf>
  test_printf("%u", n);
 8007d5c:	4639      	mov	r1, r7
 8007d5e:	4630      	mov	r0, r6
 8007d60:	f7fc fd66 	bl	8004830 <test_printf>
  test_printf("%s" TEST_CFG_EOL_STRING, msgp);
 8007d64:	4629      	mov	r1, r5
 8007d66:	4620      	mov	r0, r4
 8007d68:	f7fc fd62 	bl	8004830 <test_printf>
  test_printf("%s", msgp);
 8007d6c:	491a      	ldr	r1, [pc, #104]	; (8007dd8 <oslib_test_001_003_execute+0x1e8>)
 8007d6e:	4640      	mov	r0, r8
 8007d70:	f7fc fd5e 	bl	8004830 <test_printf>
  test_printf("%u", n);
 8007d74:	4639      	mov	r1, r7
 8007d76:	4630      	mov	r0, r6
 8007d78:	f7fc fd5a 	bl	8004830 <test_printf>
  test_printf("%s" TEST_CFG_EOL_STRING, msgp);
 8007d7c:	4629      	mov	r1, r5
 8007d7e:	4620      	mov	r0, r4
    test_print("--- CH_CFG_FACTORY_PIPES:               ");
    test_printn(CH_CFG_FACTORY_PIPES);
    test_println("");
  }
  test_end_step(1);
}
 8007d80:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
 8007d84:	f7fc bd54 	b.w	8004830 <test_printf>
 8007d88:	0800aaf8 	.word	0x0800aaf8
 8007d8c:	20000c70 	.word	0x20000c70
 8007d90:	0800aafc 	.word	0x0800aafc
 8007d94:	0800a89c 	.word	0x0800a89c
 8007d98:	0800a884 	.word	0x0800a884
 8007d9c:	0800c3c0 	.word	0x0800c3c0
 8007da0:	0800c3ec 	.word	0x0800c3ec
 8007da4:	0800c418 	.word	0x0800c418
 8007da8:	0800c444 	.word	0x0800c444
 8007dac:	0800c470 	.word	0x0800c470
 8007db0:	0800c49c 	.word	0x0800c49c
 8007db4:	0800c4c8 	.word	0x0800c4c8
 8007db8:	0800c4f4 	.word	0x0800c4f4
 8007dbc:	0800c520 	.word	0x0800c520
 8007dc0:	0800c54c 	.word	0x0800c54c
 8007dc4:	0800c578 	.word	0x0800c578
 8007dc8:	0800c5a4 	.word	0x0800c5a4
 8007dcc:	0800c5d0 	.word	0x0800c5d0
 8007dd0:	0800c5fc 	.word	0x0800c5fc
 8007dd4:	0800c628 	.word	0x0800c628
 8007dd8:	0800c654 	.word	0x0800c654
 8007ddc:	00000000 	.word	0x00000000

08007de0 <oslib_test_001_002_execute>:
static void oslib_test_001_002_execute(void) {
 8007de0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8007de4:	4c23      	ldr	r4, [pc, #140]	; (8007e74 <oslib_test_001_002_execute+0x94>)
  test_set_step(1);
 8007de6:	4b24      	ldr	r3, [pc, #144]	; (8007e78 <oslib_test_001_002_execute+0x98>)
  test_printf("%s", msgp);
 8007de8:	4d24      	ldr	r5, [pc, #144]	; (8007e7c <oslib_test_001_002_execute+0x9c>)
  test_printf("%u", n);
 8007dea:	4f25      	ldr	r7, [pc, #148]	; (8007e80 <oslib_test_001_002_execute+0xa0>)
  test_printf("%s" TEST_CFG_EOL_STRING, msgp);
 8007dec:	4925      	ldr	r1, [pc, #148]	; (8007e84 <oslib_test_001_002_execute+0xa4>)
 8007dee:	4e26      	ldr	r6, [pc, #152]	; (8007e88 <oslib_test_001_002_execute+0xa8>)
 8007df0:	f04f 0801 	mov.w	r8, #1
 8007df4:	4620      	mov	r0, r4
 8007df6:	f8c3 8000 	str.w	r8, [r3]
 8007dfa:	f7fc fd19 	bl	8004830 <test_printf>
  test_printf("%s", msgp);
 8007dfe:	4923      	ldr	r1, [pc, #140]	; (8007e8c <oslib_test_001_002_execute+0xac>)
 8007e00:	4628      	mov	r0, r5
 8007e02:	f7fc fd15 	bl	8004830 <test_printf>
  test_printf("%u", n);
 8007e06:	2100      	movs	r1, #0
 8007e08:	4638      	mov	r0, r7
 8007e0a:	f7fc fd11 	bl	8004830 <test_printf>
  test_printf("%s" TEST_CFG_EOL_STRING, msgp);
 8007e0e:	4631      	mov	r1, r6
 8007e10:	4620      	mov	r0, r4
 8007e12:	f7fc fd0d 	bl	8004830 <test_printf>
  test_printf("%s", msgp);
 8007e16:	491e      	ldr	r1, [pc, #120]	; (8007e90 <oslib_test_001_002_execute+0xb0>)
 8007e18:	4628      	mov	r0, r5
 8007e1a:	f7fc fd09 	bl	8004830 <test_printf>
  test_printf("%s" TEST_CFG_EOL_STRING, msgp);
 8007e1e:	491d      	ldr	r1, [pc, #116]	; (8007e94 <oslib_test_001_002_execute+0xb4>)
 8007e20:	4620      	mov	r0, r4
 8007e22:	f7fc fd05 	bl	8004830 <test_printf>
  test_printf("%s", msgp);
 8007e26:	491c      	ldr	r1, [pc, #112]	; (8007e98 <oslib_test_001_002_execute+0xb8>)
 8007e28:	4628      	mov	r0, r5
 8007e2a:	f7fc fd01 	bl	8004830 <test_printf>
  test_printf("%u", n);
 8007e2e:	4641      	mov	r1, r8
 8007e30:	4638      	mov	r0, r7
 8007e32:	f7fc fcfd 	bl	8004830 <test_printf>
  test_printf("%s" TEST_CFG_EOL_STRING, msgp);
 8007e36:	4631      	mov	r1, r6
 8007e38:	4620      	mov	r0, r4
 8007e3a:	f7fc fcf9 	bl	8004830 <test_printf>
  test_printf("%s", msgp);
 8007e3e:	4917      	ldr	r1, [pc, #92]	; (8007e9c <oslib_test_001_002_execute+0xbc>)
 8007e40:	4628      	mov	r0, r5
 8007e42:	f7fc fcf5 	bl	8004830 <test_printf>
  test_printf("%u", n);
 8007e46:	2103      	movs	r1, #3
 8007e48:	4638      	mov	r0, r7
 8007e4a:	f7fc fcf1 	bl	8004830 <test_printf>
  test_printf("%s" TEST_CFG_EOL_STRING, msgp);
 8007e4e:	4631      	mov	r1, r6
 8007e50:	4620      	mov	r0, r4
 8007e52:	f7fc fced 	bl	8004830 <test_printf>
  test_printf("%s", msgp);
 8007e56:	4912      	ldr	r1, [pc, #72]	; (8007ea0 <oslib_test_001_002_execute+0xc0>)
 8007e58:	4628      	mov	r0, r5
 8007e5a:	f7fc fce9 	bl	8004830 <test_printf>
  test_printf("%u", n);
 8007e5e:	2100      	movs	r1, #0
 8007e60:	4638      	mov	r0, r7
 8007e62:	f7fc fce5 	bl	8004830 <test_printf>
  test_printf("%s" TEST_CFG_EOL_STRING, msgp);
 8007e66:	4631      	mov	r1, r6
 8007e68:	4620      	mov	r0, r4
}
 8007e6a:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
 8007e6e:	f7fc bcdf 	b.w	8004830 <test_printf>
 8007e72:	bf00      	nop
 8007e74:	0800a884 	.word	0x0800a884
 8007e78:	20000c70 	.word	0x20000c70
 8007e7c:	0800aaf8 	.word	0x0800aaf8
 8007e80:	0800aafc 	.word	0x0800aafc
 8007e84:	0800c680 	.word	0x0800c680
 8007e88:	0800a89c 	.word	0x0800a89c
 8007e8c:	0800b088 	.word	0x0800b088
 8007e90:	0800b0b4 	.word	0x0800b0b4
 8007e94:	0800c6b4 	.word	0x0800c6b4
 8007e98:	0800b0e8 	.word	0x0800b0e8
 8007e9c:	0800b114 	.word	0x0800b114
 8007ea0:	0800b140 	.word	0x0800b140
	...

08007eb0 <oslib_test_001_001_execute>:
static void oslib_test_001_001_execute(void) {
 8007eb0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  test_printf("%s", msgp);
 8007eb2:	4d26      	ldr	r5, [pc, #152]	; (8007f4c <oslib_test_001_001_execute+0x9c>)
  test_set_step(1);
 8007eb4:	4b26      	ldr	r3, [pc, #152]	; (8007f50 <oslib_test_001_001_execute+0xa0>)
  test_printf("%s" TEST_CFG_EOL_STRING, msgp);
 8007eb6:	4c27      	ldr	r4, [pc, #156]	; (8007f54 <oslib_test_001_001_execute+0xa4>)
  test_printf("%s", msgp);
 8007eb8:	4927      	ldr	r1, [pc, #156]	; (8007f58 <oslib_test_001_001_execute+0xa8>)
  test_printf("%u", n);
 8007eba:	4f28      	ldr	r7, [pc, #160]	; (8007f5c <oslib_test_001_001_execute+0xac>)
  test_printf("%s" TEST_CFG_EOL_STRING, msgp);
 8007ebc:	4e28      	ldr	r6, [pc, #160]	; (8007f60 <oslib_test_001_001_execute+0xb0>)
 8007ebe:	2201      	movs	r2, #1
  test_printf("%s", msgp);
 8007ec0:	4628      	mov	r0, r5
 8007ec2:	601a      	str	r2, [r3, #0]
 8007ec4:	f7fc fcb4 	bl	8004830 <test_printf>
  test_printf("%s" TEST_CFG_EOL_STRING, msgp);
 8007ec8:	4926      	ldr	r1, [pc, #152]	; (8007f64 <oslib_test_001_001_execute+0xb4>)
 8007eca:	4620      	mov	r0, r4
 8007ecc:	f7fc fcb0 	bl	8004830 <test_printf>
  test_printf("%s", msgp);
 8007ed0:	4925      	ldr	r1, [pc, #148]	; (8007f68 <oslib_test_001_001_execute+0xb8>)
 8007ed2:	4628      	mov	r0, r5
 8007ed4:	f7fc fcac 	bl	8004830 <test_printf>
  test_printf("%s" TEST_CFG_EOL_STRING, msgp);
 8007ed8:	4924      	ldr	r1, [pc, #144]	; (8007f6c <oslib_test_001_001_execute+0xbc>)
 8007eda:	4620      	mov	r0, r4
 8007edc:	f7fc fca8 	bl	8004830 <test_printf>
  test_printf("%s", msgp);
 8007ee0:	4923      	ldr	r1, [pc, #140]	; (8007f70 <oslib_test_001_001_execute+0xc0>)
 8007ee2:	4628      	mov	r0, r5
 8007ee4:	f7fc fca4 	bl	8004830 <test_printf>
  test_printf("%s" TEST_CFG_EOL_STRING, msgp);
 8007ee8:	4922      	ldr	r1, [pc, #136]	; (8007f74 <oslib_test_001_001_execute+0xc4>)
 8007eea:	4620      	mov	r0, r4
 8007eec:	f7fc fca0 	bl	8004830 <test_printf>
  test_printf("%s", msgp);
 8007ef0:	4921      	ldr	r1, [pc, #132]	; (8007f78 <oslib_test_001_001_execute+0xc8>)
 8007ef2:	4628      	mov	r0, r5
 8007ef4:	f7fc fc9c 	bl	8004830 <test_printf>
  test_printf("%s" TEST_CFG_EOL_STRING, msgp);
 8007ef8:	4920      	ldr	r1, [pc, #128]	; (8007f7c <oslib_test_001_001_execute+0xcc>)
 8007efa:	4620      	mov	r0, r4
 8007efc:	f7fc fc98 	bl	8004830 <test_printf>
  test_printf("%s", msgp);
 8007f00:	491f      	ldr	r1, [pc, #124]	; (8007f80 <oslib_test_001_001_execute+0xd0>)
 8007f02:	4628      	mov	r0, r5
 8007f04:	f7fc fc94 	bl	8004830 <test_printf>
  test_printf("%u", n);
 8007f08:	2104      	movs	r1, #4
 8007f0a:	4638      	mov	r0, r7
 8007f0c:	f7fc fc90 	bl	8004830 <test_printf>
  test_printf("%s" TEST_CFG_EOL_STRING, msgp);
 8007f10:	4631      	mov	r1, r6
 8007f12:	4620      	mov	r0, r4
 8007f14:	f7fc fc8c 	bl	8004830 <test_printf>
  test_printf("%s", msgp);
 8007f18:	491a      	ldr	r1, [pc, #104]	; (8007f84 <oslib_test_001_001_execute+0xd4>)
 8007f1a:	4628      	mov	r0, r5
 8007f1c:	f7fc fc88 	bl	8004830 <test_printf>
  test_printf("%u", n);
 8007f20:	2108      	movs	r1, #8
 8007f22:	4638      	mov	r0, r7
 8007f24:	f7fc fc84 	bl	8004830 <test_printf>
  test_printf("%s" TEST_CFG_EOL_STRING, msgp);
 8007f28:	4631      	mov	r1, r6
 8007f2a:	4620      	mov	r0, r4
 8007f2c:	f7fc fc80 	bl	8004830 <test_printf>
  test_printf("%s", msgp);
 8007f30:	4915      	ldr	r1, [pc, #84]	; (8007f88 <oslib_test_001_001_execute+0xd8>)
 8007f32:	4628      	mov	r0, r5
 8007f34:	f7fc fc7c 	bl	8004830 <test_printf>
  test_printf("%u", n);
 8007f38:	2108      	movs	r1, #8
 8007f3a:	4638      	mov	r0, r7
 8007f3c:	f7fc fc78 	bl	8004830 <test_printf>
  test_printf("%s" TEST_CFG_EOL_STRING, msgp);
 8007f40:	4631      	mov	r1, r6
 8007f42:	4620      	mov	r0, r4
}
 8007f44:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
 8007f48:	f7fc bc72 	b.w	8004830 <test_printf>
 8007f4c:	0800aaf8 	.word	0x0800aaf8
 8007f50:	20000c70 	.word	0x20000c70
 8007f54:	0800a884 	.word	0x0800a884
 8007f58:	0800b16c 	.word	0x0800b16c
 8007f5c:	0800aafc 	.word	0x0800aafc
 8007f60:	0800a89c 	.word	0x0800a89c
 8007f64:	0800b198 	.word	0x0800b198
 8007f68:	0800b1a4 	.word	0x0800b1a4
 8007f6c:	0800b1d0 	.word	0x0800b1d0
 8007f70:	0800b1dc 	.word	0x0800b1dc
 8007f74:	0800b208 	.word	0x0800b208
 8007f78:	0800b228 	.word	0x0800b228
 8007f7c:	0800b254 	.word	0x0800b254
 8007f80:	0800b26c 	.word	0x0800b26c
 8007f84:	0800b298 	.word	0x0800b298
 8007f88:	0800b2c4 	.word	0x0800b2c4
 8007f8c:	00000000 	.word	0x00000000

08007f90 <oslib_test_002_001_teardown>:
static void oslib_test_002_001_setup(void) {
  chMBObjectInit(&mb1, mb_buffer, MB_SIZE);
}

static void oslib_test_002_001_teardown(void) {
  chMBReset(&mb1);
 8007f90:	4801      	ldr	r0, [pc, #4]	; (8007f98 <oslib_test_002_001_teardown+0x8>)
 8007f92:	f7fa be75 	b.w	8002c80 <chMBReset>
 8007f96:	bf00      	nop
 8007f98:	20000830 	.word	0x20000830
 8007f9c:	00000000 	.word	0x00000000

08007fa0 <oslib_test_002_003_execute>:

static void oslib_test_002_003_teardown(void) {
  chMBReset(&mb1);
}

static void oslib_test_002_003_execute(void) {
 8007fa0:	b5f0      	push	{r4, r5, r6, r7, lr}
  msg_t msg1, msg2;
  unsigned i;

  /* [2.3.1] Filling the mailbox.*/
  test_set_step(1);
 8007fa2:	4f45      	ldr	r7, [pc, #276]	; (80080b8 <oslib_test_002_003_execute+0x118>)
 8007fa4:	4d45      	ldr	r5, [pc, #276]	; (80080bc <oslib_test_002_003_execute+0x11c>)
  {
    for (i = 0; i < MB_SIZE; i++) {
      msg1 = chMBPostTimeout(&mb1, 'B' + i, TIME_INFINITE);
      test_assert(msg1 == MSG_OK, "wrong wake-up message");
 8007fa6:	4e46      	ldr	r6, [pc, #280]	; (80080c0 <oslib_test_002_003_execute+0x120>)
  test_set_step(1);
 8007fa8:	2301      	movs	r3, #1
static void oslib_test_002_003_execute(void) {
 8007faa:	b083      	sub	sp, #12
  test_set_step(1);
 8007fac:	603b      	str	r3, [r7, #0]
 8007fae:	2442      	movs	r4, #66	; 0x42
      msg1 = chMBPostTimeout(&mb1, 'B' + i, TIME_INFINITE);
 8007fb0:	4621      	mov	r1, r4
 8007fb2:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
 8007fb6:	4628      	mov	r0, r5
 8007fb8:	f7fa feca 	bl	8002d50 <chMBPostTimeout>
      test_assert(msg1 == MSG_OK, "wrong wake-up message");
 8007fbc:	fab0 f080 	clz	r0, r0
 8007fc0:	4631      	mov	r1, r6
 8007fc2:	0940      	lsrs	r0, r0, #5
    for (i = 0; i < MB_SIZE; i++) {
 8007fc4:	3401      	adds	r4, #1
      test_assert(msg1 == MSG_OK, "wrong wake-up message");
 8007fc6:	f7fc f9ab 	bl	8004320 <__test_assert>
 8007fca:	b990      	cbnz	r0, 8007ff2 <oslib_test_002_003_execute+0x52>
    for (i = 0; i < MB_SIZE; i++) {
 8007fcc:	2c46      	cmp	r4, #70	; 0x46
 8007fce:	d1ef      	bne.n	8007fb0 <oslib_test_002_003_execute+0x10>
  }
  test_end_step(1);

  /* [2.3.2] Testing chMBPostTimeout(), chMBPostI(),
     chMBPostAheadTimeout() and chMBPostAheadI() timeout.*/
  test_set_step(2);
 8007fd0:	2302      	movs	r3, #2
  {
    msg1 = chMBPostTimeout(&mb1, 'X', 1);
 8007fd2:	2201      	movs	r2, #1
 8007fd4:	2158      	movs	r1, #88	; 0x58
 8007fd6:	4839      	ldr	r0, [pc, #228]	; (80080bc <oslib_test_002_003_execute+0x11c>)
  test_set_step(2);
 8007fd8:	603b      	str	r3, [r7, #0]
    msg1 = chMBPostTimeout(&mb1, 'X', 1);
 8007fda:	f7fa feb9 	bl	8002d50 <chMBPostTimeout>
    test_assert(msg1 == MSG_TIMEOUT, "wrong wake-up message");
 8007fde:	f1a0 30ff 	sub.w	r0, r0, #4294967295	; 0xffffffff
 8007fe2:	fab0 f080 	clz	r0, r0
 8007fe6:	4936      	ldr	r1, [pc, #216]	; (80080c0 <oslib_test_002_003_execute+0x120>)
 8007fe8:	0940      	lsrs	r0, r0, #5
 8007fea:	f7fc f999 	bl	8004320 <__test_assert>
 8007fee:	4604      	mov	r4, r0
 8007ff0:	b108      	cbz	r0, 8007ff6 <oslib_test_002_003_execute+0x56>
    msg1 = chMBFetchI(&mb1, &msg2);
    chSysUnlock();
    test_assert(msg1 == MSG_TIMEOUT, "wrong wake-up message");
  }
  test_end_step(4);
}
 8007ff2:	b003      	add	sp, #12
 8007ff4:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8007ff6:	2630      	movs	r6, #48	; 0x30
 8007ff8:	f386 8811 	msr	BASEPRI, r6
    msg1 = chMBPostI(&mb1, 'X');
 8007ffc:	2158      	movs	r1, #88	; 0x58
 8007ffe:	482f      	ldr	r0, [pc, #188]	; (80080bc <oslib_test_002_003_execute+0x11c>)
 8008000:	f7fa feb6 	bl	8002d70 <chMBPostI>
 8008004:	f384 8811 	msr	BASEPRI, r4
    test_assert(msg1 == MSG_TIMEOUT, "wrong wake-up message");
 8008008:	f1a0 30ff 	sub.w	r0, r0, #4294967295	; 0xffffffff
 800800c:	fab0 f080 	clz	r0, r0
 8008010:	492b      	ldr	r1, [pc, #172]	; (80080c0 <oslib_test_002_003_execute+0x120>)
 8008012:	0940      	lsrs	r0, r0, #5
 8008014:	f7fc f984 	bl	8004320 <__test_assert>
 8008018:	2800      	cmp	r0, #0
 800801a:	d1ea      	bne.n	8007ff2 <oslib_test_002_003_execute+0x52>
    msg1 = chMBPostAheadTimeout(&mb1, 'X', 1);
 800801c:	2201      	movs	r2, #1
 800801e:	2158      	movs	r1, #88	; 0x58
 8008020:	4826      	ldr	r0, [pc, #152]	; (80080bc <oslib_test_002_003_execute+0x11c>)
 8008022:	f7fa fefd 	bl	8002e20 <chMBPostAheadTimeout>
    test_assert(msg1 == MSG_TIMEOUT, "wrong wake-up message");
 8008026:	f1a0 30ff 	sub.w	r0, r0, #4294967295	; 0xffffffff
 800802a:	fab0 f080 	clz	r0, r0
 800802e:	4924      	ldr	r1, [pc, #144]	; (80080c0 <oslib_test_002_003_execute+0x120>)
 8008030:	0940      	lsrs	r0, r0, #5
 8008032:	f7fc f975 	bl	8004320 <__test_assert>
 8008036:	4604      	mov	r4, r0
 8008038:	2800      	cmp	r0, #0
 800803a:	d1da      	bne.n	8007ff2 <oslib_test_002_003_execute+0x52>
 800803c:	f386 8811 	msr	BASEPRI, r6
    msg1 = chMBPostAheadI(&mb1, 'X');
 8008040:	2158      	movs	r1, #88	; 0x58
 8008042:	481e      	ldr	r0, [pc, #120]	; (80080bc <oslib_test_002_003_execute+0x11c>)
 8008044:	f7fa fefc 	bl	8002e40 <chMBPostAheadI>
 8008048:	f384 8811 	msr	BASEPRI, r4
    test_assert(msg1 == MSG_TIMEOUT, "wrong wake-up message");
 800804c:	f1a0 30ff 	sub.w	r0, r0, #4294967295	; 0xffffffff
 8008050:	fab0 f080 	clz	r0, r0
 8008054:	491a      	ldr	r1, [pc, #104]	; (80080c0 <oslib_test_002_003_execute+0x120>)
 8008056:	0940      	lsrs	r0, r0, #5
 8008058:	f7fc f962 	bl	8004320 <__test_assert>
 800805c:	4604      	mov	r4, r0
 800805e:	2800      	cmp	r0, #0
 8008060:	d1c7      	bne.n	8007ff2 <oslib_test_002_003_execute+0x52>
  test_set_step(3);
 8008062:	2303      	movs	r3, #3
    chMBReset(&mb1);
 8008064:	4815      	ldr	r0, [pc, #84]	; (80080bc <oslib_test_002_003_execute+0x11c>)
  test_set_step(3);
 8008066:	603b      	str	r3, [r7, #0]
    chMBReset(&mb1);
 8008068:	f7fa fe0a 	bl	8002c80 <chMBReset>
  test_set_step(4);
 800806c:	2304      	movs	r3, #4
    msg1 = chMBFetchTimeout(&mb1, &msg2, 1);
 800806e:	eb0d 0103 	add.w	r1, sp, r3
 8008072:	2201      	movs	r2, #1
 8008074:	4811      	ldr	r0, [pc, #68]	; (80080bc <oslib_test_002_003_execute+0x11c>)
  test_set_step(4);
 8008076:	603b      	str	r3, [r7, #0]
 *
 * @xclass
 */
static inline void chMBResumeX(mailbox_t *mbp) {

  mbp->reset = false;
 8008078:	752c      	strb	r4, [r5, #20]
    msg1 = chMBFetchTimeout(&mb1, &msg2, 1);
 800807a:	f7fa ff31 	bl	8002ee0 <chMBFetchTimeout>
    test_assert(msg1 == MSG_TIMEOUT, "wrong wake-up message");
 800807e:	f1a0 30ff 	sub.w	r0, r0, #4294967295	; 0xffffffff
 8008082:	fab0 f080 	clz	r0, r0
 8008086:	490e      	ldr	r1, [pc, #56]	; (80080c0 <oslib_test_002_003_execute+0x120>)
 8008088:	0940      	lsrs	r0, r0, #5
 800808a:	f7fc f949 	bl	8004320 <__test_assert>
 800808e:	4604      	mov	r4, r0
 8008090:	2800      	cmp	r0, #0
 8008092:	d1ae      	bne.n	8007ff2 <oslib_test_002_003_execute+0x52>
 8008094:	f386 8811 	msr	BASEPRI, r6
    msg1 = chMBFetchI(&mb1, &msg2);
 8008098:	4808      	ldr	r0, [pc, #32]	; (80080bc <oslib_test_002_003_execute+0x11c>)
 800809a:	a901      	add	r1, sp, #4
 800809c:	f7fa ff30 	bl	8002f00 <chMBFetchI>
 80080a0:	f384 8811 	msr	BASEPRI, r4
    test_assert(msg1 == MSG_TIMEOUT, "wrong wake-up message");
 80080a4:	f1a0 30ff 	sub.w	r0, r0, #4294967295	; 0xffffffff
 80080a8:	fab0 f080 	clz	r0, r0
 80080ac:	4904      	ldr	r1, [pc, #16]	; (80080c0 <oslib_test_002_003_execute+0x120>)
 80080ae:	0940      	lsrs	r0, r0, #5
 80080b0:	f7fc f936 	bl	8004320 <__test_assert>
 80080b4:	e79d      	b.n	8007ff2 <oslib_test_002_003_execute+0x52>
 80080b6:	bf00      	nop
 80080b8:	20000c70 	.word	0x20000c70
 80080bc:	20000830 	.word	0x20000830
 80080c0:	0800b860 	.word	0x0800b860
	...

080080d0 <oslib_test_002_001_setup>:
  chMBObjectInit(&mb1, mb_buffer, MB_SIZE);
 80080d0:	4902      	ldr	r1, [pc, #8]	; (80080dc <oslib_test_002_001_setup+0xc>)
 80080d2:	4803      	ldr	r0, [pc, #12]	; (80080e0 <oslib_test_002_001_setup+0x10>)
 80080d4:	2204      	movs	r2, #4
 80080d6:	f7fa bdbb 	b.w	8002c50 <chMBObjectInit>
 80080da:	bf00      	nop
 80080dc:	20001464 	.word	0x20001464
 80080e0:	20000830 	.word	0x20000830
	...

080080f0 <oslib_test_002_002_execute>:
static void oslib_test_002_002_execute(void) {
 80080f0:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
  test_set_step(1);
 80080f4:	4fab      	ldr	r7, [pc, #684]	; (80083a4 <oslib_test_002_002_execute+0x2b4>)
 80080f6:	2301      	movs	r3, #1
static void oslib_test_002_002_execute(void) {
 80080f8:	b083      	sub	sp, #12
  test_set_step(1);
 80080fa:	603b      	str	r3, [r7, #0]
 80080fc:	2630      	movs	r6, #48	; 0x30
 80080fe:	f386 8811 	msr	BASEPRI, r6
  return (size_t)(mbp->top - mbp->buffer);
 8008102:	4ca9      	ldr	r4, [pc, #676]	; (80083a8 <oslib_test_002_002_execute+0x2b8>)
    test_assert_lock(chMBGetFreeCountI(&mb1) == MB_SIZE, "wrong size");
 8008104:	49a9      	ldr	r1, [pc, #676]	; (80083ac <oslib_test_002_002_execute+0x2bc>)
 8008106:	e9d4 3000 	ldrd	r3, r0, [r4]
 800810a:	1ac3      	subs	r3, r0, r3
  return chMBGetSizeI(mbp) - chMBGetUsedCountI(mbp);
 800810c:	6920      	ldr	r0, [r4, #16]
 800810e:	ebc0 00a3 	rsb	r0, r0, r3, asr #2
 8008112:	f1a0 0004 	sub.w	r0, r0, #4
 8008116:	fab0 f080 	clz	r0, r0
 800811a:	0940      	lsrs	r0, r0, #5
 800811c:	f7fc f900 	bl	8004320 <__test_assert>
 8008120:	b128      	cbz	r0, 800812e <oslib_test_002_002_execute+0x3e>
 8008122:	2300      	movs	r3, #0
 8008124:	f383 8811 	msr	BASEPRI, r3
}
 8008128:	b003      	add	sp, #12
 800812a:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
 800812e:	4605      	mov	r5, r0
 8008130:	f380 8811 	msr	BASEPRI, r0
  test_set_step(2);
 8008134:	2302      	movs	r3, #2
 8008136:	603b      	str	r3, [r7, #0]
 8008138:	f386 8811 	msr	BASEPRI, r6
    chMBResetI(&mb1);
 800813c:	4620      	mov	r0, r4
 800813e:	f7fa fdbf 	bl	8002cc0 <chMBResetI>
 8008142:	f385 8811 	msr	BASEPRI, r5
 8008146:	f386 8811 	msr	BASEPRI, r6
  return (size_t)(mbp->top - mbp->buffer);
 800814a:	e9d4 3000 	ldrd	r3, r0, [r4]
 800814e:	1ac3      	subs	r3, r0, r3
  return chMBGetSizeI(mbp) - chMBGetUsedCountI(mbp);
 8008150:	6920      	ldr	r0, [r4, #16]
    test_assert_lock(chMBGetFreeCountI(&mb1) == MB_SIZE, "not empty");
 8008152:	4997      	ldr	r1, [pc, #604]	; (80083b0 <oslib_test_002_002_execute+0x2c0>)
 8008154:	ebc0 00a3 	rsb	r0, r0, r3, asr #2
 8008158:	f1a0 0004 	sub.w	r0, r0, #4
 800815c:	fab0 f080 	clz	r0, r0
 8008160:	0940      	lsrs	r0, r0, #5
 8008162:	f7fc f8dd 	bl	8004320 <__test_assert>
 8008166:	4680      	mov	r8, r0
 8008168:	b988      	cbnz	r0, 800818e <oslib_test_002_002_execute+0x9e>
 800816a:	f380 8811 	msr	BASEPRI, r0
 800816e:	f386 8811 	msr	BASEPRI, r6
    test_assert_lock(chMBGetUsedCountI(&mb1) == 0, "still full");
 8008172:	6920      	ldr	r0, [r4, #16]
 8008174:	498f      	ldr	r1, [pc, #572]	; (80083b4 <oslib_test_002_002_execute+0x2c4>)
 8008176:	fab0 f080 	clz	r0, r0
 800817a:	0940      	lsrs	r0, r0, #5
 800817c:	f7fc f8d0 	bl	8004320 <__test_assert>
 8008180:	4605      	mov	r5, r0
 8008182:	b148      	cbz	r0, 8008198 <oslib_test_002_002_execute+0xa8>
 8008184:	f388 8811 	msr	BASEPRI, r8
}
 8008188:	b003      	add	sp, #12
 800818a:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
 800818e:	f385 8811 	msr	BASEPRI, r5
 8008192:	b003      	add	sp, #12
 8008194:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
 8008198:	f380 8811 	msr	BASEPRI, r0
 800819c:	f386 8811 	msr	BASEPRI, r6
    test_assert_lock(mb1.buffer == mb1.wrptr, "write pointer not aligned to base");
 80081a0:	6820      	ldr	r0, [r4, #0]
 80081a2:	68a3      	ldr	r3, [r4, #8]
 80081a4:	4984      	ldr	r1, [pc, #528]	; (80083b8 <oslib_test_002_002_execute+0x2c8>)
 80081a6:	1ac0      	subs	r0, r0, r3
 80081a8:	fab0 f080 	clz	r0, r0
 80081ac:	0940      	lsrs	r0, r0, #5
 80081ae:	f7fc f8b7 	bl	8004320 <__test_assert>
 80081b2:	4680      	mov	r8, r0
 80081b4:	2800      	cmp	r0, #0
 80081b6:	d1ea      	bne.n	800818e <oslib_test_002_002_execute+0x9e>
 80081b8:	f380 8811 	msr	BASEPRI, r0
 80081bc:	f386 8811 	msr	BASEPRI, r6
    test_assert_lock(mb1.buffer == mb1.rdptr, "read pointer not aligned to base");
 80081c0:	6820      	ldr	r0, [r4, #0]
 80081c2:	68e3      	ldr	r3, [r4, #12]
 80081c4:	497d      	ldr	r1, [pc, #500]	; (80083bc <oslib_test_002_002_execute+0x2cc>)
 80081c6:	1ac0      	subs	r0, r0, r3
 80081c8:	fab0 f080 	clz	r0, r0
 80081cc:	0940      	lsrs	r0, r0, #5
 80081ce:	f7fc f8a7 	bl	8004320 <__test_assert>
 80081d2:	2800      	cmp	r0, #0
 80081d4:	d1d6      	bne.n	8008184 <oslib_test_002_002_execute+0x94>
 80081d6:	f380 8811 	msr	BASEPRI, r0
  test_set_step(3);
 80081da:	2303      	movs	r3, #3
      test_assert(msg1 == MSG_OK, "wrong wake-up message");
 80081dc:	f8df 91e0 	ldr.w	r9, [pc, #480]	; 80083c0 <oslib_test_002_002_execute+0x2d0>
  mbp->reset = false;
 80081e0:	7520      	strb	r0, [r4, #20]
  test_set_step(3);
 80081e2:	603b      	str	r3, [r7, #0]
 80081e4:	f04f 0842 	mov.w	r8, #66	; 0x42
 80081e8:	f386 8811 	msr	BASEPRI, r6
      msg1 = chMBPostI(&mb1, 'B' + i);
 80081ec:	4641      	mov	r1, r8
 80081ee:	4620      	mov	r0, r4
 80081f0:	f7fa fdbe 	bl	8002d70 <chMBPostI>
 80081f4:	2300      	movs	r3, #0
 80081f6:	f383 8811 	msr	BASEPRI, r3
      test_assert(msg1 == MSG_OK, "wrong wake-up message");
 80081fa:	fab0 f080 	clz	r0, r0
 80081fe:	0940      	lsrs	r0, r0, #5
 8008200:	4649      	mov	r1, r9
 8008202:	f7fc f88d 	bl	8004320 <__test_assert>
    for (i = 0; i < MB_SIZE - 1; i++) {
 8008206:	f108 0801 	add.w	r8, r8, #1
      test_assert(msg1 == MSG_OK, "wrong wake-up message");
 800820a:	4605      	mov	r5, r0
 800820c:	2800      	cmp	r0, #0
 800820e:	d18b      	bne.n	8008128 <oslib_test_002_002_execute+0x38>
    for (i = 0; i < MB_SIZE - 1; i++) {
 8008210:	f1b8 0f45 	cmp.w	r8, #69	; 0x45
 8008214:	d1e8      	bne.n	80081e8 <oslib_test_002_002_execute+0xf8>
 8008216:	f386 8811 	msr	BASEPRI, r6
    msg1 = chMBPostAheadI(&mb1, 'A');
 800821a:	2141      	movs	r1, #65	; 0x41
 800821c:	4862      	ldr	r0, [pc, #392]	; (80083a8 <oslib_test_002_002_execute+0x2b8>)
 800821e:	f7fa fe0f 	bl	8002e40 <chMBPostAheadI>
 8008222:	f385 8811 	msr	BASEPRI, r5
    test_assert(msg1 == MSG_OK, "wrong wake-up message");
 8008226:	fab0 f080 	clz	r0, r0
 800822a:	4965      	ldr	r1, [pc, #404]	; (80083c0 <oslib_test_002_002_execute+0x2d0>)
 800822c:	0940      	lsrs	r0, r0, #5
 800822e:	f7fc f877 	bl	8004320 <__test_assert>
 8008232:	4605      	mov	r5, r0
 8008234:	2800      	cmp	r0, #0
 8008236:	f47f af77 	bne.w	8008128 <oslib_test_002_002_execute+0x38>
  test_set_step(4);
 800823a:	f04f 0904 	mov.w	r9, #4
 800823e:	f8c7 9000 	str.w	r9, [r7]
 8008242:	f386 8811 	msr	BASEPRI, r6
  return (size_t)(mbp->top - mbp->buffer);
 8008246:	e9d4 2300 	ldrd	r2, r3, [r4]
 800824a:	1a9b      	subs	r3, r3, r2
    test_assert_lock(chMBGetFreeCountI(&mb1) == 0, "still empty");
 800824c:	6922      	ldr	r2, [r4, #16]
 800824e:	495d      	ldr	r1, [pc, #372]	; (80083c4 <oslib_test_002_002_execute+0x2d4>)
 8008250:	ebb2 0fa3 	cmp.w	r2, r3, asr #2
 8008254:	bf0c      	ite	eq
 8008256:	2001      	moveq	r0, #1
 8008258:	2000      	movne	r0, #0
 800825a:	f7fc f861 	bl	8004320 <__test_assert>
 800825e:	4680      	mov	r8, r0
 8008260:	2800      	cmp	r0, #0
 8008262:	d194      	bne.n	800818e <oslib_test_002_002_execute+0x9e>
 8008264:	f380 8811 	msr	BASEPRI, r0
 8008268:	f386 8811 	msr	BASEPRI, r6
    test_assert_lock(chMBGetUsedCountI(&mb1) == MB_SIZE, "not full");
 800826c:	6920      	ldr	r0, [r4, #16]
 800826e:	4956      	ldr	r1, [pc, #344]	; (80083c8 <oslib_test_002_002_execute+0x2d8>)
 8008270:	f1a0 0004 	sub.w	r0, r0, #4
 8008274:	fab0 f080 	clz	r0, r0
 8008278:	0940      	lsrs	r0, r0, #5
 800827a:	f7fc f851 	bl	8004320 <__test_assert>
 800827e:	4605      	mov	r5, r0
 8008280:	2800      	cmp	r0, #0
 8008282:	f47f af7f 	bne.w	8008184 <oslib_test_002_002_execute+0x94>
 8008286:	f380 8811 	msr	BASEPRI, r0
 800828a:	f386 8811 	msr	BASEPRI, r6
    test_assert_lock(mb1.rdptr == mb1.wrptr, "pointers not aligned");
 800828e:	e9d4 3002 	ldrd	r3, r0, [r4, #8]
 8008292:	1ac0      	subs	r0, r0, r3
 8008294:	fab0 f080 	clz	r0, r0
 8008298:	494c      	ldr	r1, [pc, #304]	; (80083cc <oslib_test_002_002_execute+0x2dc>)
 800829a:	0940      	lsrs	r0, r0, #5
 800829c:	f7fc f840 	bl	8004320 <__test_assert>
 80082a0:	2800      	cmp	r0, #0
 80082a2:	f47f af74 	bne.w	800818e <oslib_test_002_002_execute+0x9e>
 80082a6:	f380 8811 	msr	BASEPRI, r0
  test_set_step(5);
 80082aa:	2305      	movs	r3, #5
      msg1 = chMBFetchI(&mb1, &msg2);
 80082ac:	f8df 80f8 	ldr.w	r8, [pc, #248]	; 80083a8 <oslib_test_002_002_execute+0x2b8>
      test_assert(msg1 == MSG_OK, "wrong wake-up message");
 80082b0:	4e43      	ldr	r6, [pc, #268]	; (80083c0 <oslib_test_002_002_execute+0x2d0>)
  test_set_step(5);
 80082b2:	603b      	str	r3, [r7, #0]
 80082b4:	2530      	movs	r5, #48	; 0x30
 80082b6:	f385 8811 	msr	BASEPRI, r5
      msg1 = chMBFetchI(&mb1, &msg2);
 80082ba:	a901      	add	r1, sp, #4
 80082bc:	4640      	mov	r0, r8
 80082be:	f7fa fe1f 	bl	8002f00 <chMBFetchI>
 80082c2:	2300      	movs	r3, #0
 80082c4:	f383 8811 	msr	BASEPRI, r3
      test_assert(msg1 == MSG_OK, "wrong wake-up message");
 80082c8:	fab0 f080 	clz	r0, r0
 80082cc:	0940      	lsrs	r0, r0, #5
 80082ce:	4631      	mov	r1, r6
 80082d0:	f7fc f826 	bl	8004320 <__test_assert>
 80082d4:	2800      	cmp	r0, #0
 80082d6:	f47f af27 	bne.w	8008128 <oslib_test_002_002_execute+0x38>
      test_emit_token(msg2);
 80082da:	f89d 0004 	ldrb.w	r0, [sp, #4]
 80082de:	f7fc f867 	bl	80043b0 <test_emit_token>
    for (i = 0; i < MB_SIZE; i++) {
 80082e2:	f1b9 0901 	subs.w	r9, r9, #1
 80082e6:	d1e6      	bne.n	80082b6 <oslib_test_002_002_execute+0x1c6>
    test_assert_sequence("ABCD", "wrong get sequence");
 80082e8:	4939      	ldr	r1, [pc, #228]	; (80083d0 <oslib_test_002_002_execute+0x2e0>)
 80082ea:	483a      	ldr	r0, [pc, #232]	; (80083d4 <oslib_test_002_002_execute+0x2e4>)
 80082ec:	f7fc f828 	bl	8004340 <__test_assert_sequence>
 80082f0:	2800      	cmp	r0, #0
 80082f2:	f47f af19 	bne.w	8008128 <oslib_test_002_002_execute+0x38>
    msg1 = chMBPostTimeout(&mb1, 'B' + i, TIME_INFINITE);
 80082f6:	2146      	movs	r1, #70	; 0x46
  test_set_step(6);
 80082f8:	2306      	movs	r3, #6
    msg1 = chMBPostTimeout(&mb1, 'B' + i, TIME_INFINITE);
 80082fa:	482b      	ldr	r0, [pc, #172]	; (80083a8 <oslib_test_002_002_execute+0x2b8>)
  test_set_step(6);
 80082fc:	603b      	str	r3, [r7, #0]
    msg1 = chMBPostTimeout(&mb1, 'B' + i, TIME_INFINITE);
 80082fe:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
 8008302:	f7fa fd25 	bl	8002d50 <chMBPostTimeout>
    test_assert(msg1 == MSG_OK, "wrong wake-up message");
 8008306:	fab0 f080 	clz	r0, r0
 800830a:	492d      	ldr	r1, [pc, #180]	; (80083c0 <oslib_test_002_002_execute+0x2d0>)
 800830c:	0940      	lsrs	r0, r0, #5
 800830e:	f7fc f807 	bl	8004320 <__test_assert>
 8008312:	2800      	cmp	r0, #0
 8008314:	f47f af08 	bne.w	8008128 <oslib_test_002_002_execute+0x38>
    msg1 = chMBFetchTimeout(&mb1, &msg2, TIME_INFINITE);
 8008318:	a901      	add	r1, sp, #4
 800831a:	4823      	ldr	r0, [pc, #140]	; (80083a8 <oslib_test_002_002_execute+0x2b8>)
 800831c:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
 8008320:	f7fa fdde 	bl	8002ee0 <chMBFetchTimeout>
    test_assert(msg1 == MSG_OK, "wrong wake-up message");
 8008324:	fab0 f080 	clz	r0, r0
 8008328:	4925      	ldr	r1, [pc, #148]	; (80083c0 <oslib_test_002_002_execute+0x2d0>)
 800832a:	0940      	lsrs	r0, r0, #5
 800832c:	f7fb fff8 	bl	8004320 <__test_assert>
 8008330:	2800      	cmp	r0, #0
 8008332:	f47f aef9 	bne.w	8008128 <oslib_test_002_002_execute+0x38>
  test_set_step(7);
 8008336:	2307      	movs	r3, #7
 8008338:	603b      	str	r3, [r7, #0]
 800833a:	f385 8811 	msr	BASEPRI, r5
 800833e:	e9d4 2300 	ldrd	r2, r3, [r4]
 8008342:	1a9a      	subs	r2, r3, r2
  return chMBGetSizeI(mbp) - chMBGetUsedCountI(mbp);
 8008344:	6923      	ldr	r3, [r4, #16]
    test_assert_lock(chMBGetFreeCountI(&mb1) == MB_SIZE, "not empty");
 8008346:	491a      	ldr	r1, [pc, #104]	; (80083b0 <oslib_test_002_002_execute+0x2c0>)
 8008348:	ebc3 03a2 	rsb	r3, r3, r2, asr #2
 800834c:	1f1e      	subs	r6, r3, #4
 800834e:	4270      	negs	r0, r6
 8008350:	4170      	adcs	r0, r6
 8008352:	f7fb ffe5 	bl	8004320 <__test_assert>
 8008356:	bb08      	cbnz	r0, 800839c <oslib_test_002_002_execute+0x2ac>
 8008358:	f389 8811 	msr	BASEPRI, r9
 800835c:	f385 8811 	msr	BASEPRI, r5
    test_assert_lock(chMBGetUsedCountI(&mb1) == 0, "still full");
 8008360:	6920      	ldr	r0, [r4, #16]
 8008362:	4914      	ldr	r1, [pc, #80]	; (80083b4 <oslib_test_002_002_execute+0x2c4>)
 8008364:	fab0 f080 	clz	r0, r0
 8008368:	0940      	lsrs	r0, r0, #5
 800836a:	f7fb ffd9 	bl	8004320 <__test_assert>
 800836e:	b9a8      	cbnz	r0, 800839c <oslib_test_002_002_execute+0x2ac>
 8008370:	f389 8811 	msr	BASEPRI, r9
    test_assert(mb1.buffer == mb1.wrptr, "write pointer not aligned to base");
 8008374:	6820      	ldr	r0, [r4, #0]
 8008376:	68a3      	ldr	r3, [r4, #8]
 8008378:	490f      	ldr	r1, [pc, #60]	; (80083b8 <oslib_test_002_002_execute+0x2c8>)
 800837a:	1ac2      	subs	r2, r0, r3
 800837c:	4250      	negs	r0, r2
 800837e:	4150      	adcs	r0, r2
 8008380:	f7fb ffce 	bl	8004320 <__test_assert>
 8008384:	2800      	cmp	r0, #0
 8008386:	f47f aecf 	bne.w	8008128 <oslib_test_002_002_execute+0x38>
    test_assert(mb1.buffer == mb1.rdptr, "read pointer not aligned to base");
 800838a:	6820      	ldr	r0, [r4, #0]
 800838c:	68e3      	ldr	r3, [r4, #12]
 800838e:	490b      	ldr	r1, [pc, #44]	; (80083bc <oslib_test_002_002_execute+0x2cc>)
 8008390:	1ac3      	subs	r3, r0, r3
 8008392:	4258      	negs	r0, r3
 8008394:	4158      	adcs	r0, r3
 8008396:	f7fb ffc3 	bl	8004320 <__test_assert>
 800839a:	e6c5      	b.n	8008128 <oslib_test_002_002_execute+0x38>
 800839c:	f389 8811 	msr	BASEPRI, r9
    test_assert_lock(chMBGetUsedCountI(&mb1) == 0, "still full");
 80083a0:	e6c2      	b.n	8008128 <oslib_test_002_002_execute+0x38>
 80083a2:	bf00      	nop
 80083a4:	20000c70 	.word	0x20000c70
 80083a8:	20000830 	.word	0x20000830
 80083ac:	0800c728 	.word	0x0800c728
 80083b0:	0800c734 	.word	0x0800c734
 80083b4:	0800c740 	.word	0x0800c740
 80083b8:	0800c74c 	.word	0x0800c74c
 80083bc:	0800c770 	.word	0x0800c770
 80083c0:	0800b860 	.word	0x0800b860
 80083c4:	0800c794 	.word	0x0800c794
 80083c8:	0800c7a0 	.word	0x0800c7a0
 80083cc:	0800c7ac 	.word	0x0800c7ac
 80083d0:	0800c7c4 	.word	0x0800c7c4
 80083d4:	0800bbf4 	.word	0x0800bbf4
	...

080083e0 <oslib_test_002_001_execute>:
static void oslib_test_002_001_execute(void) {
 80083e0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  test_set_step(1);
 80083e4:	4fbe      	ldr	r7, [pc, #760]	; (80086e0 <oslib_test_002_001_execute+0x300>)
 80083e6:	2301      	movs	r3, #1
static void oslib_test_002_001_execute(void) {
 80083e8:	b082      	sub	sp, #8
  test_set_step(1);
 80083ea:	603b      	str	r3, [r7, #0]
 80083ec:	2630      	movs	r6, #48	; 0x30
 80083ee:	f386 8811 	msr	BASEPRI, r6
  return (size_t)(mbp->top - mbp->buffer);
 80083f2:	4cbc      	ldr	r4, [pc, #752]	; (80086e4 <oslib_test_002_001_execute+0x304>)
    test_assert_lock(chMBGetFreeCountI(&mb1) == MB_SIZE, "wrong size");
 80083f4:	49bc      	ldr	r1, [pc, #752]	; (80086e8 <oslib_test_002_001_execute+0x308>)
 80083f6:	e9d4 3000 	ldrd	r3, r0, [r4]
 80083fa:	1ac3      	subs	r3, r0, r3
  return chMBGetSizeI(mbp) - chMBGetUsedCountI(mbp);
 80083fc:	6920      	ldr	r0, [r4, #16]
 80083fe:	ebc0 00a3 	rsb	r0, r0, r3, asr #2
 8008402:	f1a0 0004 	sub.w	r0, r0, #4
 8008406:	fab0 f080 	clz	r0, r0
 800840a:	0940      	lsrs	r0, r0, #5
 800840c:	f7fb ff88 	bl	8004320 <__test_assert>
 8008410:	b128      	cbz	r0, 800841e <oslib_test_002_001_execute+0x3e>
 8008412:	2300      	movs	r3, #0
 8008414:	f383 8811 	msr	BASEPRI, r3
}
 8008418:	b002      	add	sp, #8
 800841a:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 800841e:	4605      	mov	r5, r0
 8008420:	f380 8811 	msr	BASEPRI, r0
  test_set_step(2);
 8008424:	2302      	movs	r3, #2
    chMBReset(&mb1);
 8008426:	4620      	mov	r0, r4
  test_set_step(2);
 8008428:	603b      	str	r3, [r7, #0]
    chMBReset(&mb1);
 800842a:	f7fa fc29 	bl	8002c80 <chMBReset>
 800842e:	f386 8811 	msr	BASEPRI, r6
  return (size_t)(mbp->top - mbp->buffer);
 8008432:	e9d4 3000 	ldrd	r3, r0, [r4]
 8008436:	1ac3      	subs	r3, r0, r3
  return chMBGetSizeI(mbp) - chMBGetUsedCountI(mbp);
 8008438:	6920      	ldr	r0, [r4, #16]
    test_assert_lock(chMBGetFreeCountI(&mb1) == MB_SIZE, "not empty");
 800843a:	49ac      	ldr	r1, [pc, #688]	; (80086ec <oslib_test_002_001_execute+0x30c>)
 800843c:	ebc0 00a3 	rsb	r0, r0, r3, asr #2
 8008440:	f1a0 0004 	sub.w	r0, r0, #4
 8008444:	fab0 f080 	clz	r0, r0
 8008448:	0940      	lsrs	r0, r0, #5
 800844a:	f7fb ff69 	bl	8004320 <__test_assert>
 800844e:	4680      	mov	r8, r0
 8008450:	b988      	cbnz	r0, 8008476 <oslib_test_002_001_execute+0x96>
 8008452:	f380 8811 	msr	BASEPRI, r0
 8008456:	f386 8811 	msr	BASEPRI, r6
    test_assert_lock(chMBGetUsedCountI(&mb1) == 0, "still full");
 800845a:	6920      	ldr	r0, [r4, #16]
 800845c:	49a4      	ldr	r1, [pc, #656]	; (80086f0 <oslib_test_002_001_execute+0x310>)
 800845e:	fab0 f080 	clz	r0, r0
 8008462:	0940      	lsrs	r0, r0, #5
 8008464:	f7fb ff5c 	bl	8004320 <__test_assert>
 8008468:	4605      	mov	r5, r0
 800846a:	b148      	cbz	r0, 8008480 <oslib_test_002_001_execute+0xa0>
 800846c:	f388 8811 	msr	BASEPRI, r8
}
 8008470:	b002      	add	sp, #8
 8008472:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 8008476:	f385 8811 	msr	BASEPRI, r5
 800847a:	b002      	add	sp, #8
 800847c:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 8008480:	f380 8811 	msr	BASEPRI, r0
 8008484:	f386 8811 	msr	BASEPRI, r6
    test_assert_lock(mb1.buffer == mb1.wrptr, "write pointer not aligned to base");
 8008488:	6820      	ldr	r0, [r4, #0]
 800848a:	68a3      	ldr	r3, [r4, #8]
 800848c:	4999      	ldr	r1, [pc, #612]	; (80086f4 <oslib_test_002_001_execute+0x314>)
 800848e:	1ac0      	subs	r0, r0, r3
 8008490:	fab0 f080 	clz	r0, r0
 8008494:	0940      	lsrs	r0, r0, #5
 8008496:	f7fb ff43 	bl	8004320 <__test_assert>
 800849a:	4680      	mov	r8, r0
 800849c:	2800      	cmp	r0, #0
 800849e:	d1ea      	bne.n	8008476 <oslib_test_002_001_execute+0x96>
 80084a0:	f380 8811 	msr	BASEPRI, r0
 80084a4:	f386 8811 	msr	BASEPRI, r6
    test_assert_lock(mb1.buffer == mb1.rdptr, "read pointer not aligned to base");
 80084a8:	6820      	ldr	r0, [r4, #0]
 80084aa:	68e3      	ldr	r3, [r4, #12]
 80084ac:	4992      	ldr	r1, [pc, #584]	; (80086f8 <oslib_test_002_001_execute+0x318>)
 80084ae:	1ac0      	subs	r0, r0, r3
 80084b0:	fab0 f080 	clz	r0, r0
 80084b4:	0940      	lsrs	r0, r0, #5
 80084b6:	f7fb ff33 	bl	8004320 <__test_assert>
 80084ba:	2800      	cmp	r0, #0
 80084bc:	d1d6      	bne.n	800846c <oslib_test_002_001_execute+0x8c>
 80084be:	f380 8811 	msr	BASEPRI, r0
  test_set_step(3);
 80084c2:	2303      	movs	r3, #3
    msg1 = chMBPostTimeout(&mb1, (msg_t)0, TIME_INFINITE);
 80084c4:	4601      	mov	r1, r0
 80084c6:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
 80084ca:	4620      	mov	r0, r4
  test_set_step(3);
 80084cc:	603b      	str	r3, [r7, #0]
    msg1 = chMBPostTimeout(&mb1, (msg_t)0, TIME_INFINITE);
 80084ce:	f7fa fc3f 	bl	8002d50 <chMBPostTimeout>
    test_assert(msg1 == MSG_RESET, "not in reset state");
 80084d2:	1c85      	adds	r5, r0, #2
 80084d4:	bf14      	ite	ne
 80084d6:	2000      	movne	r0, #0
 80084d8:	2001      	moveq	r0, #1
 80084da:	4988      	ldr	r1, [pc, #544]	; (80086fc <oslib_test_002_001_execute+0x31c>)
 80084dc:	f7fb ff20 	bl	8004320 <__test_assert>
 80084e0:	2800      	cmp	r0, #0
 80084e2:	d199      	bne.n	8008418 <oslib_test_002_001_execute+0x38>
    msg1 = chMBPostAheadTimeout(&mb1, (msg_t)0, TIME_INFINITE);
 80084e4:	4601      	mov	r1, r0
 80084e6:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
 80084ea:	4620      	mov	r0, r4
 80084ec:	f7fa fc98 	bl	8002e20 <chMBPostAheadTimeout>
    test_assert(msg1 == MSG_RESET, "not in reset state");
 80084f0:	1c82      	adds	r2, r0, #2
 80084f2:	bf14      	ite	ne
 80084f4:	2000      	movne	r0, #0
 80084f6:	2001      	moveq	r0, #1
 80084f8:	4980      	ldr	r1, [pc, #512]	; (80086fc <oslib_test_002_001_execute+0x31c>)
 80084fa:	f7fb ff11 	bl	8004320 <__test_assert>
 80084fe:	2800      	cmp	r0, #0
 8008500:	d18a      	bne.n	8008418 <oslib_test_002_001_execute+0x38>
    msg1 = chMBFetchTimeout(&mb1, &msg2, TIME_INFINITE);
 8008502:	a901      	add	r1, sp, #4
 8008504:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
 8008508:	4620      	mov	r0, r4
 800850a:	f7fa fce9 	bl	8002ee0 <chMBFetchTimeout>
    test_assert(msg1 == MSG_RESET, "not in reset state");
 800850e:	1c83      	adds	r3, r0, #2
 8008510:	bf14      	ite	ne
 8008512:	2000      	movne	r0, #0
 8008514:	2001      	moveq	r0, #1
 8008516:	4979      	ldr	r1, [pc, #484]	; (80086fc <oslib_test_002_001_execute+0x31c>)
 8008518:	f7fb ff02 	bl	8004320 <__test_assert>
 800851c:	2800      	cmp	r0, #0
 800851e:	f47f af7b 	bne.w	8008418 <oslib_test_002_001_execute+0x38>
  test_set_step(4);
 8008522:	2304      	movs	r3, #4
      test_assert(msg1 == MSG_OK, "wrong wake-up message");
 8008524:	4e76      	ldr	r6, [pc, #472]	; (8008700 <oslib_test_002_001_execute+0x320>)
  mbp->reset = false;
 8008526:	7520      	strb	r0, [r4, #20]
  test_set_step(4);
 8008528:	603b      	str	r3, [r7, #0]
 800852a:	2542      	movs	r5, #66	; 0x42
      msg1 = chMBPostTimeout(&mb1, 'B' + i, TIME_INFINITE);
 800852c:	4629      	mov	r1, r5
 800852e:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
 8008532:	4620      	mov	r0, r4
 8008534:	f7fa fc0c 	bl	8002d50 <chMBPostTimeout>
      test_assert(msg1 == MSG_OK, "wrong wake-up message");
 8008538:	fab0 f080 	clz	r0, r0
 800853c:	4631      	mov	r1, r6
 800853e:	0940      	lsrs	r0, r0, #5
    for (i = 0; i < MB_SIZE - 1; i++) {
 8008540:	3501      	adds	r5, #1
      test_assert(msg1 == MSG_OK, "wrong wake-up message");
 8008542:	f7fb feed 	bl	8004320 <__test_assert>
 8008546:	2800      	cmp	r0, #0
 8008548:	f47f af66 	bne.w	8008418 <oslib_test_002_001_execute+0x38>
    for (i = 0; i < MB_SIZE - 1; i++) {
 800854c:	2d45      	cmp	r5, #69	; 0x45
 800854e:	d1ed      	bne.n	800852c <oslib_test_002_001_execute+0x14c>
    msg1 = chMBPostAheadTimeout(&mb1, 'A', TIME_INFINITE);
 8008550:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
 8008554:	2141      	movs	r1, #65	; 0x41
 8008556:	4863      	ldr	r0, [pc, #396]	; (80086e4 <oslib_test_002_001_execute+0x304>)
 8008558:	f7fa fc62 	bl	8002e20 <chMBPostAheadTimeout>
    test_assert(msg1 == MSG_OK, "wrong wake-up message");
 800855c:	fab0 f080 	clz	r0, r0
 8008560:	4967      	ldr	r1, [pc, #412]	; (8008700 <oslib_test_002_001_execute+0x320>)
 8008562:	0940      	lsrs	r0, r0, #5
 8008564:	f7fb fedc 	bl	8004320 <__test_assert>
 8008568:	4605      	mov	r5, r0
 800856a:	2800      	cmp	r0, #0
 800856c:	f47f af54 	bne.w	8008418 <oslib_test_002_001_execute+0x38>
  test_set_step(5);
 8008570:	2305      	movs	r3, #5
 8008572:	603b      	str	r3, [r7, #0]
 8008574:	f04f 0830 	mov.w	r8, #48	; 0x30
 8008578:	f388 8811 	msr	BASEPRI, r8
  return (size_t)(mbp->top - mbp->buffer);
 800857c:	e9d4 2300 	ldrd	r2, r3, [r4]
 8008580:	1a9b      	subs	r3, r3, r2
    test_assert_lock(chMBGetFreeCountI(&mb1) == 0, "still empty");
 8008582:	6922      	ldr	r2, [r4, #16]
 8008584:	495f      	ldr	r1, [pc, #380]	; (8008704 <oslib_test_002_001_execute+0x324>)
 8008586:	ebb2 0fa3 	cmp.w	r2, r3, asr #2
 800858a:	bf0c      	ite	eq
 800858c:	2001      	moveq	r0, #1
 800858e:	2000      	movne	r0, #0
 8008590:	f7fb fec6 	bl	8004320 <__test_assert>
 8008594:	4606      	mov	r6, r0
 8008596:	2800      	cmp	r0, #0
 8008598:	f47f af6d 	bne.w	8008476 <oslib_test_002_001_execute+0x96>
 800859c:	f380 8811 	msr	BASEPRI, r0
 80085a0:	f388 8811 	msr	BASEPRI, r8
    test_assert_lock(chMBGetUsedCountI(&mb1) == MB_SIZE, "not full");
 80085a4:	6920      	ldr	r0, [r4, #16]
 80085a6:	4958      	ldr	r1, [pc, #352]	; (8008708 <oslib_test_002_001_execute+0x328>)
 80085a8:	f1a0 0e04 	sub.w	lr, r0, #4
 80085ac:	f1de 0000 	rsbs	r0, lr, #0
 80085b0:	eb40 000e 	adc.w	r0, r0, lr
 80085b4:	f7fb feb4 	bl	8004320 <__test_assert>
 80085b8:	4605      	mov	r5, r0
 80085ba:	b110      	cbz	r0, 80085c2 <oslib_test_002_001_execute+0x1e2>
 80085bc:	f386 8811 	msr	BASEPRI, r6
 80085c0:	e72a      	b.n	8008418 <oslib_test_002_001_execute+0x38>
 80085c2:	f380 8811 	msr	BASEPRI, r0
 80085c6:	f388 8811 	msr	BASEPRI, r8
    test_assert_lock(mb1.rdptr == mb1.wrptr, "pointers not aligned");
 80085ca:	e9d4 3002 	ldrd	r3, r0, [r4, #8]
 80085ce:	eba0 0c03 	sub.w	ip, r0, r3
 80085d2:	f1dc 0000 	rsbs	r0, ip, #0
 80085d6:	eb40 000c 	adc.w	r0, r0, ip
 80085da:	494c      	ldr	r1, [pc, #304]	; (800870c <oslib_test_002_001_execute+0x32c>)
 80085dc:	f7fb fea0 	bl	8004320 <__test_assert>
 80085e0:	2800      	cmp	r0, #0
 80085e2:	f47f af48 	bne.w	8008476 <oslib_test_002_001_execute+0x96>
 80085e6:	f380 8811 	msr	BASEPRI, r0
  test_set_step(6);
 80085ea:	2306      	movs	r3, #6
      msg1 = chMBFetchTimeout(&mb1, &msg2, TIME_INFINITE);
 80085ec:	f8df 80f4 	ldr.w	r8, [pc, #244]	; 80086e4 <oslib_test_002_001_execute+0x304>
      test_assert(msg1 == MSG_OK, "wrong wake-up message");
 80085f0:	4e43      	ldr	r6, [pc, #268]	; (8008700 <oslib_test_002_001_execute+0x320>)
  test_set_step(6);
 80085f2:	603b      	str	r3, [r7, #0]
 80085f4:	2504      	movs	r5, #4
      msg1 = chMBFetchTimeout(&mb1, &msg2, TIME_INFINITE);
 80085f6:	a901      	add	r1, sp, #4
 80085f8:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
 80085fc:	4640      	mov	r0, r8
 80085fe:	f7fa fc6f 	bl	8002ee0 <chMBFetchTimeout>
      test_assert(msg1 == MSG_OK, "wrong wake-up message");
 8008602:	fab0 f080 	clz	r0, r0
 8008606:	4631      	mov	r1, r6
 8008608:	0940      	lsrs	r0, r0, #5
 800860a:	f7fb fe89 	bl	8004320 <__test_assert>
 800860e:	2800      	cmp	r0, #0
 8008610:	f47f af02 	bne.w	8008418 <oslib_test_002_001_execute+0x38>
      test_emit_token(msg2);
 8008614:	f89d 0004 	ldrb.w	r0, [sp, #4]
 8008618:	f7fb feca 	bl	80043b0 <test_emit_token>
    for (i = 0; i < MB_SIZE; i++) {
 800861c:	3d01      	subs	r5, #1
 800861e:	d1ea      	bne.n	80085f6 <oslib_test_002_001_execute+0x216>
    test_assert_sequence("ABCD", "wrong get sequence");
 8008620:	493b      	ldr	r1, [pc, #236]	; (8008710 <oslib_test_002_001_execute+0x330>)
 8008622:	483c      	ldr	r0, [pc, #240]	; (8008714 <oslib_test_002_001_execute+0x334>)
 8008624:	f7fb fe8c 	bl	8004340 <__test_assert_sequence>
 8008628:	2800      	cmp	r0, #0
 800862a:	f47f aef5 	bne.w	8008418 <oslib_test_002_001_execute+0x38>
  test_set_step(7);
 800862e:	2307      	movs	r3, #7
    msg1 = chMBPostTimeout(&mb1, 'B' + i, TIME_INFINITE);
 8008630:	2146      	movs	r1, #70	; 0x46
 8008632:	482c      	ldr	r0, [pc, #176]	; (80086e4 <oslib_test_002_001_execute+0x304>)
  test_set_step(7);
 8008634:	603b      	str	r3, [r7, #0]
    msg1 = chMBPostTimeout(&mb1, 'B' + i, TIME_INFINITE);
 8008636:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
 800863a:	f7fa fb89 	bl	8002d50 <chMBPostTimeout>
    test_assert(msg1 == MSG_OK, "wrong wake-up message");
 800863e:	fab0 f080 	clz	r0, r0
 8008642:	492f      	ldr	r1, [pc, #188]	; (8008700 <oslib_test_002_001_execute+0x320>)
 8008644:	0940      	lsrs	r0, r0, #5
 8008646:	f7fb fe6b 	bl	8004320 <__test_assert>
 800864a:	2800      	cmp	r0, #0
 800864c:	f47f aee4 	bne.w	8008418 <oslib_test_002_001_execute+0x38>
    msg1 = chMBFetchTimeout(&mb1, &msg2, TIME_INFINITE);
 8008650:	a901      	add	r1, sp, #4
 8008652:	4824      	ldr	r0, [pc, #144]	; (80086e4 <oslib_test_002_001_execute+0x304>)
 8008654:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
 8008658:	f7fa fc42 	bl	8002ee0 <chMBFetchTimeout>
    test_assert(msg1 == MSG_OK, "wrong wake-up message");
 800865c:	fab0 f080 	clz	r0, r0
 8008660:	4927      	ldr	r1, [pc, #156]	; (8008700 <oslib_test_002_001_execute+0x320>)
 8008662:	0940      	lsrs	r0, r0, #5
 8008664:	f7fb fe5c 	bl	8004320 <__test_assert>
 8008668:	2800      	cmp	r0, #0
 800866a:	f47f aed5 	bne.w	8008418 <oslib_test_002_001_execute+0x38>
  test_set_step(8);
 800866e:	2308      	movs	r3, #8
 8008670:	603b      	str	r3, [r7, #0]
 8008672:	2630      	movs	r6, #48	; 0x30
 8008674:	f386 8811 	msr	BASEPRI, r6
 8008678:	e9d4 2300 	ldrd	r2, r3, [r4]
 800867c:	1a9a      	subs	r2, r3, r2
  return chMBGetSizeI(mbp) - chMBGetUsedCountI(mbp);
 800867e:	6923      	ldr	r3, [r4, #16]
    test_assert_lock(chMBGetFreeCountI(&mb1) == MB_SIZE, "not empty");
 8008680:	491a      	ldr	r1, [pc, #104]	; (80086ec <oslib_test_002_001_execute+0x30c>)
 8008682:	ebc3 03a2 	rsb	r3, r3, r2, asr #2
 8008686:	1f1f      	subs	r7, r3, #4
 8008688:	4278      	negs	r0, r7
 800868a:	4178      	adcs	r0, r7
 800868c:	f7fb fe48 	bl	8004320 <__test_assert>
 8008690:	2800      	cmp	r0, #0
 8008692:	f47f aef0 	bne.w	8008476 <oslib_test_002_001_execute+0x96>
 8008696:	f385 8811 	msr	BASEPRI, r5
 800869a:	f386 8811 	msr	BASEPRI, r6
    test_assert_lock(chMBGetUsedCountI(&mb1) == 0, "still full");
 800869e:	6920      	ldr	r0, [r4, #16]
 80086a0:	4913      	ldr	r1, [pc, #76]	; (80086f0 <oslib_test_002_001_execute+0x310>)
 80086a2:	fab0 f080 	clz	r0, r0
 80086a6:	0940      	lsrs	r0, r0, #5
 80086a8:	f7fb fe3a 	bl	8004320 <__test_assert>
 80086ac:	2800      	cmp	r0, #0
 80086ae:	f47f aee2 	bne.w	8008476 <oslib_test_002_001_execute+0x96>
 80086b2:	f385 8811 	msr	BASEPRI, r5
    test_assert(mb1.buffer == mb1.wrptr, "write pointer not aligned to base");
 80086b6:	6820      	ldr	r0, [r4, #0]
 80086b8:	68a3      	ldr	r3, [r4, #8]
 80086ba:	490e      	ldr	r1, [pc, #56]	; (80086f4 <oslib_test_002_001_execute+0x314>)
 80086bc:	1ac2      	subs	r2, r0, r3
 80086be:	4250      	negs	r0, r2
 80086c0:	4150      	adcs	r0, r2
 80086c2:	f7fb fe2d 	bl	8004320 <__test_assert>
 80086c6:	2800      	cmp	r0, #0
 80086c8:	f47f aea6 	bne.w	8008418 <oslib_test_002_001_execute+0x38>
    test_assert(mb1.buffer == mb1.rdptr, "read pointer not aligned to base");
 80086cc:	6820      	ldr	r0, [r4, #0]
 80086ce:	68e3      	ldr	r3, [r4, #12]
 80086d0:	4909      	ldr	r1, [pc, #36]	; (80086f8 <oslib_test_002_001_execute+0x318>)
 80086d2:	1ac3      	subs	r3, r0, r3
 80086d4:	4258      	negs	r0, r3
 80086d6:	4158      	adcs	r0, r3
 80086d8:	f7fb fe22 	bl	8004320 <__test_assert>
 80086dc:	e69c      	b.n	8008418 <oslib_test_002_001_execute+0x38>
 80086de:	bf00      	nop
 80086e0:	20000c70 	.word	0x20000c70
 80086e4:	20000830 	.word	0x20000830
 80086e8:	0800c728 	.word	0x0800c728
 80086ec:	0800c734 	.word	0x0800c734
 80086f0:	0800c740 	.word	0x0800c740
 80086f4:	0800c74c 	.word	0x0800c74c
 80086f8:	0800c770 	.word	0x0800c770
 80086fc:	0800c7d8 	.word	0x0800c7d8
 8008700:	0800b860 	.word	0x0800b860
 8008704:	0800c794 	.word	0x0800c794
 8008708:	0800c7a0 	.word	0x0800c7a0
 800870c:	0800c7ac 	.word	0x0800c7ac
 8008710:	0800c7c4 	.word	0x0800c7c4
 8008714:	0800bbf4 	.word	0x0800bbf4
	...

08008720 <oslib_test_002_003_teardown>:
 8008720:	4801      	ldr	r0, [pc, #4]	; (8008728 <oslib_test_002_003_teardown+0x8>)
 8008722:	f7fa baad 	b.w	8002c80 <chMBReset>
 8008726:	bf00      	nop
 8008728:	20000830 	.word	0x20000830
 800872c:	00000000 	.word	0x00000000

08008730 <oslib_test_002_002_teardown>:
 8008730:	4801      	ldr	r0, [pc, #4]	; (8008738 <oslib_test_002_002_teardown+0x8>)
 8008732:	f7fa baa5 	b.w	8002c80 <chMBReset>
 8008736:	bf00      	nop
 8008738:	20000830 	.word	0x20000830
 800873c:	00000000 	.word	0x00000000

08008740 <oslib_test_002_002_setup>:
 8008740:	4902      	ldr	r1, [pc, #8]	; (800874c <oslib_test_002_002_setup+0xc>)
 8008742:	4803      	ldr	r0, [pc, #12]	; (8008750 <oslib_test_002_002_setup+0x10>)
 8008744:	2204      	movs	r2, #4
 8008746:	f7fa ba83 	b.w	8002c50 <chMBObjectInit>
 800874a:	bf00      	nop
 800874c:	20001464 	.word	0x20001464
 8008750:	20000830 	.word	0x20000830
	...

08008760 <oslib_test_002_003_setup>:
 8008760:	4902      	ldr	r1, [pc, #8]	; (800876c <oslib_test_002_003_setup+0xc>)
 8008762:	4803      	ldr	r0, [pc, #12]	; (8008770 <oslib_test_002_003_setup+0x10>)
 8008764:	2204      	movs	r2, #4
 8008766:	f7fa ba73 	b.w	8002c50 <chMBObjectInit>
 800876a:	bf00      	nop
 800876c:	20001464 	.word	0x20001464
 8008770:	20000830 	.word	0x20000830
	...

08008780 <oslib_test_003_002_execute>:

static void oslib_test_003_002_setup(void) {
  chPipeObjectInit(&pipe1, buffer, PIPE_SIZE / 2);
}

static void oslib_test_003_002_execute(void) {
 8008780:	b530      	push	{r4, r5, lr}
  test_set_step(1);
  {
    size_t n;
    uint8_t buf[PIPE_SIZE];

    n = chPipeReadTimeout(&pipe1, buf, PIPE_SIZE, TIME_IMMEDIATE);
 8008782:	4c25      	ldr	r4, [pc, #148]	; (8008818 <oslib_test_003_002_execute+0x98>)
  test_set_step(1);
 8008784:	4d25      	ldr	r5, [pc, #148]	; (800881c <oslib_test_003_002_execute+0x9c>)
static void oslib_test_003_002_execute(void) {
 8008786:	b085      	sub	sp, #20
  test_set_step(1);
 8008788:	2001      	movs	r0, #1
    n = chPipeReadTimeout(&pipe1, buf, PIPE_SIZE, TIME_IMMEDIATE);
 800878a:	4669      	mov	r1, sp
  test_set_step(1);
 800878c:	6028      	str	r0, [r5, #0]
    n = chPipeReadTimeout(&pipe1, buf, PIPE_SIZE, TIME_IMMEDIATE);
 800878e:	2300      	movs	r3, #0
 8008790:	2210      	movs	r2, #16
 8008792:	4620      	mov	r0, r4
 8008794:	f7fa feac 	bl	80034f0 <chPipeReadTimeout>
    test_assert(n == 0, "wrong size");
 8008798:	fab0 f080 	clz	r0, r0
 800879c:	4920      	ldr	r1, [pc, #128]	; (8008820 <oslib_test_003_002_execute+0xa0>)
 800879e:	0940      	lsrs	r0, r0, #5
 80087a0:	f7fb fdbe 	bl	8004320 <__test_assert>
 80087a4:	b938      	cbnz	r0, 80087b6 <oslib_test_003_002_execute+0x36>
    test_assert((pipe1.rdptr == pipe1.buffer) &&
 80087a6:	6822      	ldr	r2, [r4, #0]
 80087a8:	68e3      	ldr	r3, [r4, #12]
 80087aa:	4293      	cmp	r3, r2
 80087ac:	d021      	beq.n	80087f2 <oslib_test_003_002_execute+0x72>
 80087ae:	491d      	ldr	r1, [pc, #116]	; (8008824 <oslib_test_003_002_execute+0xa4>)
 80087b0:	f7fb fdb6 	bl	8004320 <__test_assert>
 80087b4:	b108      	cbz	r0, 80087ba <oslib_test_003_002_execute+0x3a>
                (pipe1.wrptr == pipe1.buffer) &&
                (pipe1.cnt == PIPE_SIZE / 2),
                "invalid pipe state");
  }
  test_end_step(2);
}
 80087b6:	b005      	add	sp, #20
 80087b8:	bd30      	pop	{r4, r5, pc}
    n = chPipeWriteTimeout(&pipe1, pipe_pattern, PIPE_SIZE, TIME_IMMEDIATE);
 80087ba:	4603      	mov	r3, r0
  test_set_step(2);
 80087bc:	2002      	movs	r0, #2
    n = chPipeWriteTimeout(&pipe1, pipe_pattern, PIPE_SIZE, TIME_IMMEDIATE);
 80087be:	491a      	ldr	r1, [pc, #104]	; (8008828 <oslib_test_003_002_execute+0xa8>)
  test_set_step(2);
 80087c0:	6028      	str	r0, [r5, #0]
    n = chPipeWriteTimeout(&pipe1, pipe_pattern, PIPE_SIZE, TIME_IMMEDIATE);
 80087c2:	2210      	movs	r2, #16
 80087c4:	4814      	ldr	r0, [pc, #80]	; (8008818 <oslib_test_003_002_execute+0x98>)
 80087c6:	f7fa fe23 	bl	8003410 <chPipeWriteTimeout>
    test_assert(n == PIPE_SIZE / 2, "wrong size");
 80087ca:	f1a0 0008 	sub.w	r0, r0, #8
 80087ce:	fab0 f080 	clz	r0, r0
 80087d2:	4913      	ldr	r1, [pc, #76]	; (8008820 <oslib_test_003_002_execute+0xa0>)
 80087d4:	0940      	lsrs	r0, r0, #5
 80087d6:	f7fb fda3 	bl	8004320 <__test_assert>
 80087da:	2800      	cmp	r0, #0
 80087dc:	d1eb      	bne.n	80087b6 <oslib_test_003_002_execute+0x36>
    test_assert((pipe1.rdptr == pipe1.wrptr) &&
 80087de:	e9d4 2302 	ldrd	r2, r3, [r4, #8]
 80087e2:	4293      	cmp	r3, r2
 80087e4:	d00d      	beq.n	8008802 <oslib_test_003_002_execute+0x82>
 80087e6:	490f      	ldr	r1, [pc, #60]	; (8008824 <oslib_test_003_002_execute+0xa4>)
}
 80087e8:	b005      	add	sp, #20
 80087ea:	e8bd 4030 	ldmia.w	sp!, {r4, r5, lr}
    test_assert((pipe1.rdptr == pipe1.wrptr) &&
 80087ee:	f7fb bd97 	b.w	8004320 <__test_assert>
    test_assert((pipe1.rdptr == pipe1.buffer) &&
 80087f2:	68a2      	ldr	r2, [r4, #8]
 80087f4:	4293      	cmp	r3, r2
 80087f6:	d1da      	bne.n	80087ae <oslib_test_003_002_execute+0x2e>
 80087f8:	6920      	ldr	r0, [r4, #16]
 80087fa:	fab0 f080 	clz	r0, r0
 80087fe:	0940      	lsrs	r0, r0, #5
 8008800:	e7d5      	b.n	80087ae <oslib_test_003_002_execute+0x2e>
    test_assert((pipe1.rdptr == pipe1.wrptr) &&
 8008802:	6822      	ldr	r2, [r4, #0]
 8008804:	4293      	cmp	r3, r2
 8008806:	d1ee      	bne.n	80087e6 <oslib_test_003_002_execute+0x66>
 8008808:	6920      	ldr	r0, [r4, #16]
 800880a:	f1a0 0008 	sub.w	r0, r0, #8
 800880e:	fab0 f080 	clz	r0, r0
 8008812:	0940      	lsrs	r0, r0, #5
 8008814:	e7e7      	b.n	80087e6 <oslib_test_003_002_execute+0x66>
 8008816:	bf00      	nop
 8008818:	20000858 	.word	0x20000858
 800881c:	20000c70 	.word	0x20000c70
 8008820:	0800c728 	.word	0x0800c728
 8008824:	0800c8a4 	.word	0x0800c8a4
 8008828:	0800c94c 	.word	0x0800c94c
 800882c:	00000000 	.word	0x00000000

08008830 <oslib_test_003_002_setup>:
  chPipeObjectInit(&pipe1, buffer, PIPE_SIZE / 2);
 8008830:	4902      	ldr	r1, [pc, #8]	; (800883c <oslib_test_003_002_setup+0xc>)
 8008832:	4803      	ldr	r0, [pc, #12]	; (8008840 <oslib_test_003_002_setup+0x10>)
 8008834:	2208      	movs	r2, #8
 8008836:	f7fa bda3 	b.w	8003380 <chPipeObjectInit>
 800883a:	bf00      	nop
 800883c:	20001474 	.word	0x20001474
 8008840:	20000858 	.word	0x20000858
	...

08008850 <oslib_test_003_001_setup>:
  chPipeObjectInit(&pipe1, buffer, PIPE_SIZE);
 8008850:	4902      	ldr	r1, [pc, #8]	; (800885c <oslib_test_003_001_setup+0xc>)
 8008852:	4803      	ldr	r0, [pc, #12]	; (8008860 <oslib_test_003_001_setup+0x10>)
 8008854:	2210      	movs	r2, #16
 8008856:	f7fa bd93 	b.w	8003380 <chPipeObjectInit>
 800885a:	bf00      	nop
 800885c:	20001474 	.word	0x20001474
 8008860:	20000858 	.word	0x20000858
	...

08008870 <oslib_test_003_001_execute>:
static void oslib_test_003_001_execute(void) {
 8008870:	b530      	push	{r4, r5, lr}
    chPipeReset(&pipe1);
 8008872:	4c0a      	ldr	r4, [pc, #40]	; (800889c <oslib_test_003_001_execute+0x2c>)
  test_set_step(1);
 8008874:	4d0a      	ldr	r5, [pc, #40]	; (80088a0 <oslib_test_003_001_execute+0x30>)
 8008876:	2301      	movs	r3, #1
static void oslib_test_003_001_execute(void) {
 8008878:	b085      	sub	sp, #20
    chPipeReset(&pipe1);
 800887a:	4620      	mov	r0, r4
  test_set_step(1);
 800887c:	602b      	str	r3, [r5, #0]
    chPipeReset(&pipe1);
 800887e:	f7fa fd9f 	bl	80033c0 <chPipeReset>
    test_assert((pipe1.rdptr == pipe1.buffer) &&
 8008882:	6822      	ldr	r2, [r4, #0]
 8008884:	68e3      	ldr	r3, [r4, #12]
 8008886:	4293      	cmp	r3, r2
 8008888:	f000 81d4 	beq.w	8008c34 <oslib_test_003_001_execute+0x3c4>
 800888c:	2000      	movs	r0, #0
 800888e:	4905      	ldr	r1, [pc, #20]	; (80088a4 <oslib_test_003_001_execute+0x34>)
 8008890:	f7fb fd46 	bl	8004320 <__test_assert>
 8008894:	b140      	cbz	r0, 80088a8 <oslib_test_003_001_execute+0x38>
}
 8008896:	b005      	add	sp, #20
 8008898:	bd30      	pop	{r4, r5, pc}
 800889a:	bf00      	nop
 800889c:	20000858 	.word	0x20000858
 80088a0:	20000c70 	.word	0x20000c70
 80088a4:	0800c8a4 	.word	0x0800c8a4
    n = chPipeWriteTimeout(&pipe1, pipe_pattern, PIPE_SIZE, TIME_IMMEDIATE);
 80088a8:	4603      	mov	r3, r0
  test_set_step(2);
 80088aa:	2002      	movs	r0, #2
    n = chPipeWriteTimeout(&pipe1, pipe_pattern, PIPE_SIZE, TIME_IMMEDIATE);
 80088ac:	49bb      	ldr	r1, [pc, #748]	; (8008b9c <oslib_test_003_001_execute+0x32c>)
  test_set_step(2);
 80088ae:	6028      	str	r0, [r5, #0]
    n = chPipeWriteTimeout(&pipe1, pipe_pattern, PIPE_SIZE, TIME_IMMEDIATE);
 80088b0:	2210      	movs	r2, #16
 80088b2:	48bb      	ldr	r0, [pc, #748]	; (8008ba0 <oslib_test_003_001_execute+0x330>)
 80088b4:	f7fa fdac 	bl	8003410 <chPipeWriteTimeout>
    test_assert(n == 0, "not reset");
 80088b8:	fab0 f080 	clz	r0, r0
 80088bc:	49b9      	ldr	r1, [pc, #740]	; (8008ba4 <oslib_test_003_001_execute+0x334>)
 80088be:	0940      	lsrs	r0, r0, #5
 80088c0:	f7fb fd2e 	bl	8004320 <__test_assert>
 80088c4:	2800      	cmp	r0, #0
 80088c6:	d1e6      	bne.n	8008896 <oslib_test_003_001_execute+0x26>
    test_assert((pipe1.rdptr == pipe1.buffer) &&
 80088c8:	6822      	ldr	r2, [r4, #0]
 80088ca:	68e3      	ldr	r3, [r4, #12]
 80088cc:	4293      	cmp	r3, r2
 80088ce:	f000 81ba 	beq.w	8008c46 <oslib_test_003_001_execute+0x3d6>
 80088d2:	49b5      	ldr	r1, [pc, #724]	; (8008ba8 <oslib_test_003_001_execute+0x338>)
 80088d4:	f7fb fd24 	bl	8004320 <__test_assert>
 80088d8:	2800      	cmp	r0, #0
 80088da:	d1dc      	bne.n	8008896 <oslib_test_003_001_execute+0x26>
  test_set_step(3);
 80088dc:	2103      	movs	r1, #3
    n = chPipeReadTimeout(&pipe1, buf, PIPE_SIZE, TIME_IMMEDIATE);
 80088de:	4603      	mov	r3, r0
  test_set_step(3);
 80088e0:	6029      	str	r1, [r5, #0]
    n = chPipeReadTimeout(&pipe1, buf, PIPE_SIZE, TIME_IMMEDIATE);
 80088e2:	48af      	ldr	r0, [pc, #700]	; (8008ba0 <oslib_test_003_001_execute+0x330>)
 80088e4:	4669      	mov	r1, sp
 80088e6:	2210      	movs	r2, #16
 80088e8:	f7fa fe02 	bl	80034f0 <chPipeReadTimeout>
    test_assert(n == 0, "not reset");
 80088ec:	fab0 f080 	clz	r0, r0
 80088f0:	49ac      	ldr	r1, [pc, #688]	; (8008ba4 <oslib_test_003_001_execute+0x334>)
 80088f2:	0940      	lsrs	r0, r0, #5
 80088f4:	f7fb fd14 	bl	8004320 <__test_assert>
 80088f8:	2800      	cmp	r0, #0
 80088fa:	d1cc      	bne.n	8008896 <oslib_test_003_001_execute+0x26>
    test_assert((pipe1.rdptr == pipe1.buffer) &&
 80088fc:	6822      	ldr	r2, [r4, #0]
 80088fe:	68e3      	ldr	r3, [r4, #12]
 8008900:	4293      	cmp	r3, r2
 8008902:	f000 81b2 	beq.w	8008c6a <oslib_test_003_001_execute+0x3fa>
 8008906:	49a8      	ldr	r1, [pc, #672]	; (8008ba8 <oslib_test_003_001_execute+0x338>)
 8008908:	f7fb fd0a 	bl	8004320 <__test_assert>
 800890c:	2800      	cmp	r0, #0
 800890e:	d1c2      	bne.n	8008896 <oslib_test_003_001_execute+0x26>
  test_set_step(4);
 8008910:	2304      	movs	r3, #4
    test_assert((pipe1.rdptr == pipe1.buffer) &&
 8008912:	6822      	ldr	r2, [r4, #0]
  test_set_step(4);
 8008914:	602b      	str	r3, [r5, #0]
    test_assert((pipe1.rdptr == pipe1.buffer) &&
 8008916:	68e3      	ldr	r3, [r4, #12]
 *
 * @api
 */
static inline void chPipeResume(pipe_t *pp) {

  pp->reset = false;
 8008918:	7520      	strb	r0, [r4, #20]
 800891a:	4293      	cmp	r3, r2
 800891c:	f000 819c 	beq.w	8008c58 <oslib_test_003_001_execute+0x3e8>
 8008920:	49a1      	ldr	r1, [pc, #644]	; (8008ba8 <oslib_test_003_001_execute+0x338>)
 8008922:	f7fb fcfd 	bl	8004320 <__test_assert>
 8008926:	2800      	cmp	r0, #0
 8008928:	d1b5      	bne.n	8008896 <oslib_test_003_001_execute+0x26>
  test_set_step(5);
 800892a:	2205      	movs	r2, #5
    n = chPipeWriteTimeout(&pipe1, pipe_pattern, PIPE_SIZE, TIME_IMMEDIATE);
 800892c:	499b      	ldr	r1, [pc, #620]	; (8008b9c <oslib_test_003_001_execute+0x32c>)
  test_set_step(5);
 800892e:	602a      	str	r2, [r5, #0]
    n = chPipeWriteTimeout(&pipe1, pipe_pattern, PIPE_SIZE, TIME_IMMEDIATE);
 8008930:	4603      	mov	r3, r0
 8008932:	2210      	movs	r2, #16
 8008934:	489a      	ldr	r0, [pc, #616]	; (8008ba0 <oslib_test_003_001_execute+0x330>)
 8008936:	f7fa fd6b 	bl	8003410 <chPipeWriteTimeout>
    test_assert(n == PIPE_SIZE, "wrong size");
 800893a:	f1a0 0010 	sub.w	r0, r0, #16
 800893e:	fab0 f080 	clz	r0, r0
 8008942:	499a      	ldr	r1, [pc, #616]	; (8008bac <oslib_test_003_001_execute+0x33c>)
 8008944:	0940      	lsrs	r0, r0, #5
 8008946:	f7fb fceb 	bl	8004320 <__test_assert>
 800894a:	2800      	cmp	r0, #0
 800894c:	d1a3      	bne.n	8008896 <oslib_test_003_001_execute+0x26>
    test_assert((pipe1.rdptr == pipe1.buffer) &&
 800894e:	6822      	ldr	r2, [r4, #0]
 8008950:	68e3      	ldr	r3, [r4, #12]
 8008952:	4293      	cmp	r3, r2
 8008954:	f000 8192 	beq.w	8008c7c <oslib_test_003_001_execute+0x40c>
 8008958:	4993      	ldr	r1, [pc, #588]	; (8008ba8 <oslib_test_003_001_execute+0x338>)
 800895a:	f7fb fce1 	bl	8004320 <__test_assert>
 800895e:	2800      	cmp	r0, #0
 8008960:	d199      	bne.n	8008896 <oslib_test_003_001_execute+0x26>
  test_set_step(6);
 8008962:	2206      	movs	r2, #6
    n = chPipeReadTimeout(&pipe1, buf, PIPE_SIZE, TIME_IMMEDIATE);
 8008964:	4603      	mov	r3, r0
  test_set_step(6);
 8008966:	602a      	str	r2, [r5, #0]
    n = chPipeReadTimeout(&pipe1, buf, PIPE_SIZE, TIME_IMMEDIATE);
 8008968:	4669      	mov	r1, sp
 800896a:	488d      	ldr	r0, [pc, #564]	; (8008ba0 <oslib_test_003_001_execute+0x330>)
 800896c:	2210      	movs	r2, #16
 800896e:	f7fa fdbf 	bl	80034f0 <chPipeReadTimeout>
    test_assert(n == PIPE_SIZE, "wrong size");
 8008972:	f1a0 0010 	sub.w	r0, r0, #16
 8008976:	fab0 f080 	clz	r0, r0
 800897a:	498c      	ldr	r1, [pc, #560]	; (8008bac <oslib_test_003_001_execute+0x33c>)
 800897c:	0940      	lsrs	r0, r0, #5
 800897e:	f7fb fccf 	bl	8004320 <__test_assert>
 8008982:	2800      	cmp	r0, #0
 8008984:	d187      	bne.n	8008896 <oslib_test_003_001_execute+0x26>
    test_assert((pipe1.rdptr == pipe1.buffer) &&
 8008986:	6822      	ldr	r2, [r4, #0]
 8008988:	68e3      	ldr	r3, [r4, #12]
 800898a:	4293      	cmp	r3, r2
 800898c:	f000 8181 	beq.w	8008c92 <oslib_test_003_001_execute+0x422>
 8008990:	4985      	ldr	r1, [pc, #532]	; (8008ba8 <oslib_test_003_001_execute+0x338>)
 8008992:	f7fb fcc5 	bl	8004320 <__test_assert>
 8008996:	2800      	cmp	r0, #0
 8008998:	f47f af7d 	bne.w	8008896 <oslib_test_003_001_execute+0x26>
    test_assert(memcmp(pipe_pattern, buf, PIPE_SIZE) == 0, "content mismatch");
 800899c:	4b84      	ldr	r3, [pc, #528]	; (8008bb0 <oslib_test_003_001_execute+0x340>)
 800899e:	9a00      	ldr	r2, [sp, #0]
 80089a0:	429a      	cmp	r2, r3
 80089a2:	f000 817f 	beq.w	8008ca4 <oslib_test_003_001_execute+0x434>
 80089a6:	2001      	movs	r0, #1
 80089a8:	4982      	ldr	r1, [pc, #520]	; (8008bb4 <oslib_test_003_001_execute+0x344>)
 80089aa:	f080 0001 	eor.w	r0, r0, #1
 80089ae:	f7fb fcb7 	bl	8004320 <__test_assert>
 80089b2:	2800      	cmp	r0, #0
 80089b4:	f47f af6f 	bne.w	8008896 <oslib_test_003_001_execute+0x26>
  test_set_step(7);
 80089b8:	2207      	movs	r2, #7
    n = chPipeWriteTimeout(&pipe1, pipe_pattern, 4, TIME_IMMEDIATE);
 80089ba:	4978      	ldr	r1, [pc, #480]	; (8008b9c <oslib_test_003_001_execute+0x32c>)
  test_set_step(7);
 80089bc:	602a      	str	r2, [r5, #0]
    n = chPipeWriteTimeout(&pipe1, pipe_pattern, 4, TIME_IMMEDIATE);
 80089be:	4603      	mov	r3, r0
 80089c0:	2204      	movs	r2, #4
 80089c2:	4877      	ldr	r0, [pc, #476]	; (8008ba0 <oslib_test_003_001_execute+0x330>)
 80089c4:	f7fa fd24 	bl	8003410 <chPipeWriteTimeout>
    test_assert(n == 4, "wrong size");
 80089c8:	f1a0 0004 	sub.w	r0, r0, #4
 80089cc:	fab0 f080 	clz	r0, r0
 80089d0:	4976      	ldr	r1, [pc, #472]	; (8008bac <oslib_test_003_001_execute+0x33c>)
 80089d2:	0940      	lsrs	r0, r0, #5
 80089d4:	f7fb fca4 	bl	8004320 <__test_assert>
 80089d8:	2800      	cmp	r0, #0
 80089da:	f47f af5c 	bne.w	8008896 <oslib_test_003_001_execute+0x26>
    test_assert((pipe1.rdptr != pipe1.wrptr) &&
 80089de:	e9d4 2302 	ldrd	r2, r3, [r4, #8]
 80089e2:	4293      	cmp	r3, r2
 80089e4:	d003      	beq.n	80089ee <oslib_test_003_001_execute+0x17e>
 80089e6:	6822      	ldr	r2, [r4, #0]
 80089e8:	4293      	cmp	r3, r2
 80089ea:	f000 8176 	beq.w	8008cda <oslib_test_003_001_execute+0x46a>
 80089ee:	496e      	ldr	r1, [pc, #440]	; (8008ba8 <oslib_test_003_001_execute+0x338>)
 80089f0:	f7fb fc96 	bl	8004320 <__test_assert>
 80089f4:	4603      	mov	r3, r0
 80089f6:	2800      	cmp	r0, #0
 80089f8:	f47f af4d 	bne.w	8008896 <oslib_test_003_001_execute+0x26>
  test_set_step(8);
 80089fc:	2208      	movs	r2, #8
    n = chPipeWriteTimeout(&pipe1, pipe_pattern, PIPE_SIZE - 4, TIME_IMMEDIATE);
 80089fe:	4967      	ldr	r1, [pc, #412]	; (8008b9c <oslib_test_003_001_execute+0x32c>)
  test_set_step(8);
 8008a00:	602a      	str	r2, [r5, #0]
    n = chPipeWriteTimeout(&pipe1, pipe_pattern, PIPE_SIZE - 4, TIME_IMMEDIATE);
 8008a02:	4867      	ldr	r0, [pc, #412]	; (8008ba0 <oslib_test_003_001_execute+0x330>)
 8008a04:	220c      	movs	r2, #12
 8008a06:	f7fa fd03 	bl	8003410 <chPipeWriteTimeout>
    test_assert(n == PIPE_SIZE - 4, "wrong size");
 8008a0a:	f1a0 0c0c 	sub.w	ip, r0, #12
 8008a0e:	f1dc 0000 	rsbs	r0, ip, #0
 8008a12:	eb40 000c 	adc.w	r0, r0, ip
 8008a16:	4965      	ldr	r1, [pc, #404]	; (8008bac <oslib_test_003_001_execute+0x33c>)
 8008a18:	f7fb fc82 	bl	8004320 <__test_assert>
 8008a1c:	2800      	cmp	r0, #0
 8008a1e:	f47f af3a 	bne.w	8008896 <oslib_test_003_001_execute+0x26>
    test_assert((pipe1.rdptr == pipe1.buffer) &&
 8008a22:	6822      	ldr	r2, [r4, #0]
 8008a24:	68e3      	ldr	r3, [r4, #12]
 8008a26:	4293      	cmp	r3, r2
 8008a28:	f000 815f 	beq.w	8008cea <oslib_test_003_001_execute+0x47a>
 8008a2c:	495e      	ldr	r1, [pc, #376]	; (8008ba8 <oslib_test_003_001_execute+0x338>)
 8008a2e:	f7fb fc77 	bl	8004320 <__test_assert>
 8008a32:	4603      	mov	r3, r0
 8008a34:	2800      	cmp	r0, #0
 8008a36:	f47f af2e 	bne.w	8008896 <oslib_test_003_001_execute+0x26>
  test_set_step(9);
 8008a3a:	2209      	movs	r2, #9
 8008a3c:	602a      	str	r2, [r5, #0]
    n = chPipeReadTimeout(&pipe1, buf, 4, TIME_IMMEDIATE);
 8008a3e:	4669      	mov	r1, sp
 8008a40:	4857      	ldr	r0, [pc, #348]	; (8008ba0 <oslib_test_003_001_execute+0x330>)
 8008a42:	2204      	movs	r2, #4
 8008a44:	f7fa fd54 	bl	80034f0 <chPipeReadTimeout>
    test_assert(n == 4, "wrong size");
 8008a48:	1f03      	subs	r3, r0, #4
 8008a4a:	4258      	negs	r0, r3
 8008a4c:	4158      	adcs	r0, r3
 8008a4e:	4957      	ldr	r1, [pc, #348]	; (8008bac <oslib_test_003_001_execute+0x33c>)
 8008a50:	f7fb fc66 	bl	8004320 <__test_assert>
 8008a54:	2800      	cmp	r0, #0
 8008a56:	f47f af1e 	bne.w	8008896 <oslib_test_003_001_execute+0x26>
    test_assert((pipe1.rdptr != pipe1.buffer) &&
 8008a5a:	6823      	ldr	r3, [r4, #0]
 8008a5c:	68e2      	ldr	r2, [r4, #12]
 8008a5e:	429a      	cmp	r2, r3
 8008a60:	d003      	beq.n	8008a6a <oslib_test_003_001_execute+0x1fa>
 8008a62:	68a2      	ldr	r2, [r4, #8]
 8008a64:	4293      	cmp	r3, r2
 8008a66:	f000 8161 	beq.w	8008d2c <oslib_test_003_001_execute+0x4bc>
 8008a6a:	494f      	ldr	r1, [pc, #316]	; (8008ba8 <oslib_test_003_001_execute+0x338>)
 8008a6c:	f7fb fc58 	bl	8004320 <__test_assert>
 8008a70:	2800      	cmp	r0, #0
 8008a72:	f47f af10 	bne.w	8008896 <oslib_test_003_001_execute+0x26>
    test_assert(memcmp(pipe_pattern, buf, 4) == 0, "content mismatch");
 8008a76:	2204      	movs	r2, #4
 8008a78:	4669      	mov	r1, sp
 8008a7a:	4848      	ldr	r0, [pc, #288]	; (8008b9c <oslib_test_003_001_execute+0x32c>)
 8008a7c:	f001 fd1a 	bl	800a4b4 <memcmp>
 8008a80:	fab0 f080 	clz	r0, r0
 8008a84:	494b      	ldr	r1, [pc, #300]	; (8008bb4 <oslib_test_003_001_execute+0x344>)
 8008a86:	0940      	lsrs	r0, r0, #5
 8008a88:	f7fb fc4a 	bl	8004320 <__test_assert>
 8008a8c:	4603      	mov	r3, r0
 8008a8e:	2800      	cmp	r0, #0
 8008a90:	f47f af01 	bne.w	8008896 <oslib_test_003_001_execute+0x26>
  test_set_step(10);
 8008a94:	220a      	movs	r2, #10
 8008a96:	602a      	str	r2, [r5, #0]
    n = chPipeReadTimeout(&pipe1, buf, PIPE_SIZE - 4, TIME_IMMEDIATE);
 8008a98:	4669      	mov	r1, sp
 8008a9a:	4841      	ldr	r0, [pc, #260]	; (8008ba0 <oslib_test_003_001_execute+0x330>)
 8008a9c:	220c      	movs	r2, #12
 8008a9e:	f7fa fd27 	bl	80034f0 <chPipeReadTimeout>
    test_assert(n == PIPE_SIZE - 4, "wrong size");
 8008aa2:	f1a0 0c0c 	sub.w	ip, r0, #12
 8008aa6:	f1dc 0000 	rsbs	r0, ip, #0
 8008aaa:	eb40 000c 	adc.w	r0, r0, ip
 8008aae:	493f      	ldr	r1, [pc, #252]	; (8008bac <oslib_test_003_001_execute+0x33c>)
 8008ab0:	f7fb fc36 	bl	8004320 <__test_assert>
 8008ab4:	2800      	cmp	r0, #0
 8008ab6:	f47f aeee 	bne.w	8008896 <oslib_test_003_001_execute+0x26>
    test_assert((pipe1.rdptr == pipe1.buffer) &&
 8008aba:	6822      	ldr	r2, [r4, #0]
 8008abc:	68e3      	ldr	r3, [r4, #12]
 8008abe:	4293      	cmp	r3, r2
 8008ac0:	f000 811d 	beq.w	8008cfe <oslib_test_003_001_execute+0x48e>
 8008ac4:	4938      	ldr	r1, [pc, #224]	; (8008ba8 <oslib_test_003_001_execute+0x338>)
 8008ac6:	f7fb fc2b 	bl	8004320 <__test_assert>
 8008aca:	2800      	cmp	r0, #0
 8008acc:	f47f aee3 	bne.w	8008896 <oslib_test_003_001_execute+0x26>
    test_assert(memcmp(pipe_pattern, buf, PIPE_SIZE - 4) == 0, "content mismatch");
 8008ad0:	220c      	movs	r2, #12
 8008ad2:	4669      	mov	r1, sp
 8008ad4:	4831      	ldr	r0, [pc, #196]	; (8008b9c <oslib_test_003_001_execute+0x32c>)
 8008ad6:	f001 fced 	bl	800a4b4 <memcmp>
 8008ada:	fab0 f080 	clz	r0, r0
 8008ade:	4935      	ldr	r1, [pc, #212]	; (8008bb4 <oslib_test_003_001_execute+0x344>)
 8008ae0:	0940      	lsrs	r0, r0, #5
 8008ae2:	f7fb fc1d 	bl	8004320 <__test_assert>
 8008ae6:	4603      	mov	r3, r0
 8008ae8:	2800      	cmp	r0, #0
 8008aea:	f47f aed4 	bne.w	8008896 <oslib_test_003_001_execute+0x26>
  test_set_step(11);
 8008aee:	220b      	movs	r2, #11
    n = chPipeWriteTimeout(&pipe1, pipe_pattern, 5, TIME_IMMEDIATE);
 8008af0:	492a      	ldr	r1, [pc, #168]	; (8008b9c <oslib_test_003_001_execute+0x32c>)
  test_set_step(11);
 8008af2:	602a      	str	r2, [r5, #0]
    n = chPipeWriteTimeout(&pipe1, pipe_pattern, 5, TIME_IMMEDIATE);
 8008af4:	482a      	ldr	r0, [pc, #168]	; (8008ba0 <oslib_test_003_001_execute+0x330>)
 8008af6:	2205      	movs	r2, #5
 8008af8:	f7fa fc8a 	bl	8003410 <chPipeWriteTimeout>
    test_assert(n == 5, "wrong size");
 8008afc:	1f42      	subs	r2, r0, #5
 8008afe:	4250      	negs	r0, r2
 8008b00:	4150      	adcs	r0, r2
 8008b02:	492a      	ldr	r1, [pc, #168]	; (8008bac <oslib_test_003_001_execute+0x33c>)
 8008b04:	f7fb fc0c 	bl	8004320 <__test_assert>
 8008b08:	2800      	cmp	r0, #0
 8008b0a:	f47f aec4 	bne.w	8008896 <oslib_test_003_001_execute+0x26>
    test_assert((pipe1.rdptr != pipe1.wrptr) &&
 8008b0e:	e9d4 2302 	ldrd	r2, r3, [r4, #8]
 8008b12:	4293      	cmp	r3, r2
 8008b14:	d003      	beq.n	8008b1e <oslib_test_003_001_execute+0x2ae>
 8008b16:	6822      	ldr	r2, [r4, #0]
 8008b18:	4293      	cmp	r3, r2
 8008b1a:	f000 80f9 	beq.w	8008d10 <oslib_test_003_001_execute+0x4a0>
 8008b1e:	4922      	ldr	r1, [pc, #136]	; (8008ba8 <oslib_test_003_001_execute+0x338>)
 8008b20:	f7fb fbfe 	bl	8004320 <__test_assert>
 8008b24:	4603      	mov	r3, r0
 8008b26:	2800      	cmp	r0, #0
 8008b28:	f47f aeb5 	bne.w	8008896 <oslib_test_003_001_execute+0x26>
  test_set_step(12);
 8008b2c:	220c      	movs	r2, #12
 8008b2e:	602a      	str	r2, [r5, #0]
    n = chPipeReadTimeout(&pipe1, buf, 5, TIME_IMMEDIATE);
 8008b30:	4669      	mov	r1, sp
 8008b32:	481b      	ldr	r0, [pc, #108]	; (8008ba0 <oslib_test_003_001_execute+0x330>)
 8008b34:	2205      	movs	r2, #5
 8008b36:	f7fa fcdb 	bl	80034f0 <chPipeReadTimeout>
    test_assert(n == 5, "wrong size");
 8008b3a:	f1a0 0e05 	sub.w	lr, r0, #5
 8008b3e:	f1de 0000 	rsbs	r0, lr, #0
 8008b42:	eb40 000e 	adc.w	r0, r0, lr
 8008b46:	4919      	ldr	r1, [pc, #100]	; (8008bac <oslib_test_003_001_execute+0x33c>)
 8008b48:	f7fb fbea 	bl	8004320 <__test_assert>
 8008b4c:	2800      	cmp	r0, #0
 8008b4e:	f47f aea2 	bne.w	8008896 <oslib_test_003_001_execute+0x26>
    test_assert((pipe1.rdptr == pipe1.wrptr) &&
 8008b52:	e9d4 2302 	ldrd	r2, r3, [r4, #8]
 8008b56:	4293      	cmp	r3, r2
 8008b58:	f000 80fa 	beq.w	8008d50 <oslib_test_003_001_execute+0x4e0>
 8008b5c:	4912      	ldr	r1, [pc, #72]	; (8008ba8 <oslib_test_003_001_execute+0x338>)
 8008b5e:	f7fb fbdf 	bl	8004320 <__test_assert>
 8008b62:	2800      	cmp	r0, #0
 8008b64:	f47f ae97 	bne.w	8008896 <oslib_test_003_001_execute+0x26>
    test_assert(memcmp(pipe_pattern, buf, 5) == 0, "content mismatch");
 8008b68:	2205      	movs	r2, #5
 8008b6a:	4669      	mov	r1, sp
 8008b6c:	480b      	ldr	r0, [pc, #44]	; (8008b9c <oslib_test_003_001_execute+0x32c>)
 8008b6e:	f001 fca1 	bl	800a4b4 <memcmp>
 8008b72:	fab0 f080 	clz	r0, r0
 8008b76:	490f      	ldr	r1, [pc, #60]	; (8008bb4 <oslib_test_003_001_execute+0x344>)
 8008b78:	0940      	lsrs	r0, r0, #5
 8008b7a:	f7fb fbd1 	bl	8004320 <__test_assert>
 8008b7e:	4603      	mov	r3, r0
 8008b80:	2800      	cmp	r0, #0
 8008b82:	f47f ae88 	bne.w	8008896 <oslib_test_003_001_execute+0x26>
  test_set_step(13);
 8008b86:	220d      	movs	r2, #13
    n = chPipeWriteTimeout(&pipe1, pipe_pattern, PIPE_SIZE, TIME_IMMEDIATE);
 8008b88:	4904      	ldr	r1, [pc, #16]	; (8008b9c <oslib_test_003_001_execute+0x32c>)
  test_set_step(13);
 8008b8a:	602a      	str	r2, [r5, #0]
    n = chPipeWriteTimeout(&pipe1, pipe_pattern, PIPE_SIZE, TIME_IMMEDIATE);
 8008b8c:	4804      	ldr	r0, [pc, #16]	; (8008ba0 <oslib_test_003_001_execute+0x330>)
 8008b8e:	2210      	movs	r2, #16
 8008b90:	f7fa fc3e 	bl	8003410 <chPipeWriteTimeout>
    test_assert(n == PIPE_SIZE, "wrong size");
 8008b94:	f1a0 0c10 	sub.w	ip, r0, #16
 8008b98:	e00e      	b.n	8008bb8 <oslib_test_003_001_execute+0x348>
 8008b9a:	bf00      	nop
 8008b9c:	0800c94c 	.word	0x0800c94c
 8008ba0:	20000858 	.word	0x20000858
 8008ba4:	0800c8b8 	.word	0x0800c8b8
 8008ba8:	0800c8a4 	.word	0x0800c8a4
 8008bac:	0800c728 	.word	0x0800c728
 8008bb0:	33323130 	.word	0x33323130
 8008bb4:	0800c8c4 	.word	0x0800c8c4
 8008bb8:	f1dc 0000 	rsbs	r0, ip, #0
 8008bbc:	eb40 000c 	adc.w	r0, r0, ip
 8008bc0:	4968      	ldr	r1, [pc, #416]	; (8008d64 <oslib_test_003_001_execute+0x4f4>)
 8008bc2:	f7fb fbad 	bl	8004320 <__test_assert>
 8008bc6:	2800      	cmp	r0, #0
 8008bc8:	f47f ae65 	bne.w	8008896 <oslib_test_003_001_execute+0x26>
    test_assert((pipe1.rdptr == pipe1.wrptr) &&
 8008bcc:	e9d4 2302 	ldrd	r2, r3, [r4, #8]
 8008bd0:	4293      	cmp	r3, r2
 8008bd2:	f000 80b3 	beq.w	8008d3c <oslib_test_003_001_execute+0x4cc>
 8008bd6:	4964      	ldr	r1, [pc, #400]	; (8008d68 <oslib_test_003_001_execute+0x4f8>)
 8008bd8:	f7fb fba2 	bl	8004320 <__test_assert>
 8008bdc:	4603      	mov	r3, r0
 8008bde:	2800      	cmp	r0, #0
 8008be0:	f47f ae59 	bne.w	8008896 <oslib_test_003_001_execute+0x26>
  test_set_step(14);
 8008be4:	220e      	movs	r2, #14
 8008be6:	602a      	str	r2, [r5, #0]
    n = chPipeReadTimeout(&pipe1, buf, PIPE_SIZE, TIME_IMMEDIATE);
 8008be8:	4669      	mov	r1, sp
 8008bea:	4860      	ldr	r0, [pc, #384]	; (8008d6c <oslib_test_003_001_execute+0x4fc>)
 8008bec:	2210      	movs	r2, #16
 8008bee:	f7fa fc7f 	bl	80034f0 <chPipeReadTimeout>
    test_assert(n == PIPE_SIZE, "wrong size");
 8008bf2:	f1a0 0310 	sub.w	r3, r0, #16
 8008bf6:	4258      	negs	r0, r3
 8008bf8:	4158      	adcs	r0, r3
 8008bfa:	495a      	ldr	r1, [pc, #360]	; (8008d64 <oslib_test_003_001_execute+0x4f4>)
 8008bfc:	f7fb fb90 	bl	8004320 <__test_assert>
 8008c00:	2800      	cmp	r0, #0
 8008c02:	f47f ae48 	bne.w	8008896 <oslib_test_003_001_execute+0x26>
    test_assert((pipe1.rdptr == pipe1.wrptr) &&
 8008c06:	e9d4 2302 	ldrd	r2, r3, [r4, #8]
 8008c0a:	4293      	cmp	r3, r2
 8008c0c:	f000 8085 	beq.w	8008d1a <oslib_test_003_001_execute+0x4aa>
 8008c10:	4955      	ldr	r1, [pc, #340]	; (8008d68 <oslib_test_003_001_execute+0x4f8>)
 8008c12:	f7fb fb85 	bl	8004320 <__test_assert>
 8008c16:	2800      	cmp	r0, #0
 8008c18:	f47f ae3d 	bne.w	8008896 <oslib_test_003_001_execute+0x26>
    test_assert(memcmp(pipe_pattern, buf, PIPE_SIZE) == 0, "content mismatch");
 8008c1c:	4669      	mov	r1, sp
 8008c1e:	2210      	movs	r2, #16
 8008c20:	4853      	ldr	r0, [pc, #332]	; (8008d70 <oslib_test_003_001_execute+0x500>)
 8008c22:	f001 fc47 	bl	800a4b4 <memcmp>
 8008c26:	fab0 f080 	clz	r0, r0
 8008c2a:	4952      	ldr	r1, [pc, #328]	; (8008d74 <oslib_test_003_001_execute+0x504>)
 8008c2c:	0940      	lsrs	r0, r0, #5
 8008c2e:	f7fb fb77 	bl	8004320 <__test_assert>
 8008c32:	e630      	b.n	8008896 <oslib_test_003_001_execute+0x26>
    test_assert((pipe1.rdptr == pipe1.buffer) &&
 8008c34:	68a2      	ldr	r2, [r4, #8]
 8008c36:	4293      	cmp	r3, r2
 8008c38:	f47f ae28 	bne.w	800888c <oslib_test_003_001_execute+0x1c>
 8008c3c:	6920      	ldr	r0, [r4, #16]
 8008c3e:	fab0 f080 	clz	r0, r0
 8008c42:	0940      	lsrs	r0, r0, #5
 8008c44:	e623      	b.n	800888e <oslib_test_003_001_execute+0x1e>
    test_assert((pipe1.rdptr == pipe1.buffer) &&
 8008c46:	68a2      	ldr	r2, [r4, #8]
 8008c48:	4293      	cmp	r3, r2
 8008c4a:	f47f ae42 	bne.w	80088d2 <oslib_test_003_001_execute+0x62>
 8008c4e:	6920      	ldr	r0, [r4, #16]
 8008c50:	fab0 f080 	clz	r0, r0
 8008c54:	0940      	lsrs	r0, r0, #5
 8008c56:	e63c      	b.n	80088d2 <oslib_test_003_001_execute+0x62>
    test_assert((pipe1.rdptr == pipe1.buffer) &&
 8008c58:	68a2      	ldr	r2, [r4, #8]
 8008c5a:	4293      	cmp	r3, r2
 8008c5c:	f47f ae60 	bne.w	8008920 <oslib_test_003_001_execute+0xb0>
 8008c60:	6920      	ldr	r0, [r4, #16]
 8008c62:	fab0 f080 	clz	r0, r0
 8008c66:	0940      	lsrs	r0, r0, #5
 8008c68:	e65a      	b.n	8008920 <oslib_test_003_001_execute+0xb0>
    test_assert((pipe1.rdptr == pipe1.buffer) &&
 8008c6a:	68a2      	ldr	r2, [r4, #8]
 8008c6c:	4293      	cmp	r3, r2
 8008c6e:	f47f ae4a 	bne.w	8008906 <oslib_test_003_001_execute+0x96>
 8008c72:	6920      	ldr	r0, [r4, #16]
 8008c74:	fab0 f080 	clz	r0, r0
 8008c78:	0940      	lsrs	r0, r0, #5
 8008c7a:	e644      	b.n	8008906 <oslib_test_003_001_execute+0x96>
    test_assert((pipe1.rdptr == pipe1.buffer) &&
 8008c7c:	68a2      	ldr	r2, [r4, #8]
 8008c7e:	4293      	cmp	r3, r2
 8008c80:	f47f ae6a 	bne.w	8008958 <oslib_test_003_001_execute+0xe8>
 8008c84:	6920      	ldr	r0, [r4, #16]
 8008c86:	f1a0 0010 	sub.w	r0, r0, #16
 8008c8a:	fab0 f080 	clz	r0, r0
 8008c8e:	0940      	lsrs	r0, r0, #5
 8008c90:	e662      	b.n	8008958 <oslib_test_003_001_execute+0xe8>
    test_assert((pipe1.rdptr == pipe1.buffer) &&
 8008c92:	68a2      	ldr	r2, [r4, #8]
 8008c94:	4293      	cmp	r3, r2
 8008c96:	f47f ae7b 	bne.w	8008990 <oslib_test_003_001_execute+0x120>
 8008c9a:	6920      	ldr	r0, [r4, #16]
 8008c9c:	fab0 f080 	clz	r0, r0
 8008ca0:	0940      	lsrs	r0, r0, #5
 8008ca2:	e675      	b.n	8008990 <oslib_test_003_001_execute+0x120>
    test_assert(memcmp(pipe_pattern, buf, PIPE_SIZE) == 0, "content mismatch");
 8008ca4:	9a01      	ldr	r2, [sp, #4]
 8008ca6:	f103 3304 	add.w	r3, r3, #67372036	; 0x4040404
 8008caa:	429a      	cmp	r2, r3
 8008cac:	f47f ae7b 	bne.w	80089a6 <oslib_test_003_001_execute+0x136>
 8008cb0:	f103 6330 	add.w	r3, r3, #184549376	; 0xb000000
 8008cb4:	9a02      	ldr	r2, [sp, #8]
 8008cb6:	f503 2330 	add.w	r3, r3, #720896	; 0xb0000
 8008cba:	f203 4304 	addw	r3, r3, #1028	; 0x404
 8008cbe:	429a      	cmp	r2, r3
 8008cc0:	f47f ae71 	bne.w	80089a6 <oslib_test_003_001_execute+0x136>
 8008cc4:	f103 6380 	add.w	r3, r3, #67108864	; 0x4000000
 8008cc8:	9a03      	ldr	r2, [sp, #12]
 8008cca:	f503 2381 	add.w	r3, r3, #264192	; 0x40800
 8008cce:	f203 330b 	addw	r3, r3, #779	; 0x30b
 8008cd2:	429a      	cmp	r2, r3
 8008cd4:	f47f ae67 	bne.w	80089a6 <oslib_test_003_001_execute+0x136>
 8008cd8:	e666      	b.n	80089a8 <oslib_test_003_001_execute+0x138>
    test_assert((pipe1.rdptr != pipe1.wrptr) &&
 8008cda:	6920      	ldr	r0, [r4, #16]
 8008cdc:	f1a0 0e04 	sub.w	lr, r0, #4
 8008ce0:	f1de 0000 	rsbs	r0, lr, #0
 8008ce4:	eb40 000e 	adc.w	r0, r0, lr
 8008ce8:	e681      	b.n	80089ee <oslib_test_003_001_execute+0x17e>
    test_assert((pipe1.rdptr == pipe1.buffer) &&
 8008cea:	68a2      	ldr	r2, [r4, #8]
 8008cec:	4293      	cmp	r3, r2
 8008cee:	f47f ae9d 	bne.w	8008a2c <oslib_test_003_001_execute+0x1bc>
 8008cf2:	6920      	ldr	r0, [r4, #16]
 8008cf4:	f1a0 0210 	sub.w	r2, r0, #16
 8008cf8:	4250      	negs	r0, r2
 8008cfa:	4150      	adcs	r0, r2
 8008cfc:	e696      	b.n	8008a2c <oslib_test_003_001_execute+0x1bc>
    test_assert((pipe1.rdptr == pipe1.buffer) &&
 8008cfe:	68a2      	ldr	r2, [r4, #8]
 8008d00:	4293      	cmp	r3, r2
 8008d02:	f47f aedf 	bne.w	8008ac4 <oslib_test_003_001_execute+0x254>
 8008d06:	6920      	ldr	r0, [r4, #16]
 8008d08:	fab0 f080 	clz	r0, r0
 8008d0c:	0940      	lsrs	r0, r0, #5
 8008d0e:	e6d9      	b.n	8008ac4 <oslib_test_003_001_execute+0x254>
    test_assert((pipe1.rdptr != pipe1.wrptr) &&
 8008d10:	6920      	ldr	r0, [r4, #16]
 8008d12:	1f43      	subs	r3, r0, #5
 8008d14:	4258      	negs	r0, r3
 8008d16:	4158      	adcs	r0, r3
 8008d18:	e701      	b.n	8008b1e <oslib_test_003_001_execute+0x2ae>
    test_assert((pipe1.rdptr == pipe1.wrptr) &&
 8008d1a:	6822      	ldr	r2, [r4, #0]
 8008d1c:	4293      	cmp	r3, r2
 8008d1e:	f43f af77 	beq.w	8008c10 <oslib_test_003_001_execute+0x3a0>
 8008d22:	6920      	ldr	r0, [r4, #16]
 8008d24:	fab0 f080 	clz	r0, r0
 8008d28:	0940      	lsrs	r0, r0, #5
 8008d2a:	e771      	b.n	8008c10 <oslib_test_003_001_execute+0x3a0>
    test_assert((pipe1.rdptr != pipe1.buffer) &&
 8008d2c:	6920      	ldr	r0, [r4, #16]
 8008d2e:	f1a0 0e0c 	sub.w	lr, r0, #12
 8008d32:	f1de 0000 	rsbs	r0, lr, #0
 8008d36:	eb40 000e 	adc.w	r0, r0, lr
 8008d3a:	e696      	b.n	8008a6a <oslib_test_003_001_execute+0x1fa>
    test_assert((pipe1.rdptr == pipe1.wrptr) &&
 8008d3c:	6822      	ldr	r2, [r4, #0]
 8008d3e:	4293      	cmp	r3, r2
 8008d40:	f43f af49 	beq.w	8008bd6 <oslib_test_003_001_execute+0x366>
 8008d44:	6920      	ldr	r0, [r4, #16]
 8008d46:	f1a0 0210 	sub.w	r2, r0, #16
 8008d4a:	4250      	negs	r0, r2
 8008d4c:	4150      	adcs	r0, r2
 8008d4e:	e742      	b.n	8008bd6 <oslib_test_003_001_execute+0x366>
    test_assert((pipe1.rdptr == pipe1.wrptr) &&
 8008d50:	6822      	ldr	r2, [r4, #0]
 8008d52:	4293      	cmp	r3, r2
 8008d54:	f43f af02 	beq.w	8008b5c <oslib_test_003_001_execute+0x2ec>
 8008d58:	6920      	ldr	r0, [r4, #16]
 8008d5a:	fab0 f080 	clz	r0, r0
 8008d5e:	0940      	lsrs	r0, r0, #5
 8008d60:	e6fc      	b.n	8008b5c <oslib_test_003_001_execute+0x2ec>
 8008d62:	bf00      	nop
 8008d64:	0800c728 	.word	0x0800c728
 8008d68:	0800c8a4 	.word	0x0800c8a4
 8008d6c:	20000858 	.word	0x20000858
 8008d70:	0800c94c 	.word	0x0800c94c
 8008d74:	0800c8c4 	.word	0x0800c8c4
	...

08008d80 <job_slow>:

static jobs_queue_t jq;
static job_descriptor_t jobs[JOBS_QUEUE_SIZE];
static msg_t msg_queue[JOBS_QUEUE_SIZE];

static void job_slow(void *arg) {
 8008d80:	b508      	push	{r3, lr}

  test_emit_token((int)arg);
 8008d82:	b2c0      	uxtb	r0, r0
 8008d84:	f7fb fb14 	bl	80043b0 <test_emit_token>
  chThdSleepMilliseconds(10);
}
 8008d88:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  chThdSleepMilliseconds(10);
 8008d8c:	2064      	movs	r0, #100	; 0x64
 8008d8e:	f7f9 b90f 	b.w	8001fb0 <chThdSleep>
 8008d92:	bf00      	nop
	...

08008da0 <Thread1>:

static THD_WORKING_AREA(wa1Thread1, 256);
static THD_WORKING_AREA(wa2Thread1, 256);
static THD_FUNCTION(Thread1, arg) {
 8008da0:	b570      	push	{r4, r5, r6, lr}
 */
static inline msg_t chJobDispatch(jobs_queue_t *jqp) {
  msg_t msg, jmsg;

  /* Waiting for a job.*/
  msg = chMBFetchTimeout(&jqp->mbx, &jmsg, TIME_INFINITE);
 8008da2:	4d0c      	ldr	r5, [pc, #48]	; (8008dd4 <Thread1+0x34>)
 8008da4:	b082      	sub	sp, #8

      /* Invoking the job function.*/
      jp->jobfunc(jp->jobarg);

      /* Returning the job descriptor object.*/
      chGuardedPoolFree(&jqp->free, (void *)jp);
 8008da6:	f1a5 061c 	sub.w	r6, r5, #28
  msg = chMBFetchTimeout(&jqp->mbx, &jmsg, TIME_INFINITE);
 8008daa:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
 8008dae:	a901      	add	r1, sp, #4
 8008db0:	4628      	mov	r0, r5
 8008db2:	f7fa f895 	bl	8002ee0 <chMBFetchTimeout>
  if (msg == MSG_OK) {
 8008db6:	b108      	cbz	r0, 8008dbc <Thread1+0x1c>
  (void)arg;

  do {
    msg = chJobDispatch(&jq);
  } while (msg == MSG_OK);
}
 8008db8:	b002      	add	sp, #8
 8008dba:	bd70      	pop	{r4, r5, r6, pc}
    job_descriptor_t *jp = (job_descriptor_t *)jmsg;
 8008dbc:	9c01      	ldr	r4, [sp, #4]
    if (jp->jobfunc != NULL) {
 8008dbe:	6823      	ldr	r3, [r4, #0]
 8008dc0:	2b00      	cmp	r3, #0
 8008dc2:	d0f9      	beq.n	8008db8 <Thread1+0x18>
      jp->jobfunc(jp->jobarg);
 8008dc4:	6860      	ldr	r0, [r4, #4]
 8008dc6:	4798      	blx	r3
      chGuardedPoolFree(&jqp->free, (void *)jp);
 8008dc8:	4621      	mov	r1, r4
 8008dca:	4630      	mov	r0, r6
 8008dcc:	f7fa fac8 	bl	8003360 <chGuardedPoolFree>
  } while (msg == MSG_OK);
 8008dd0:	e7eb      	b.n	8008daa <Thread1+0xa>
 8008dd2:	bf00      	nop
 8008dd4:	200014c0 	.word	0x200014c0
	...

08008de0 <oslib_test_004_001_execute>:
 * - [4.1.3] Sending jobs with various timings.
 * - [4.1.4] Sending two null jobs to make threads exit.
 * .
 */

static void oslib_test_004_001_execute(void) {
 8008de0:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
  thread_t *tp1, *tp2;

  /* [4.1.1] Initializing the Jobs Queue object.*/
  test_set_step(1);
 8008de4:	f8df 80f8 	ldr.w	r8, [pc, #248]	; 8008ee0 <oslib_test_004_001_execute+0x100>
  chGuardedPoolObjectInitAligned(gmp, size, PORT_NATURAL_ALIGN);
 8008de8:	483e      	ldr	r0, [pc, #248]	; (8008ee4 <oslib_test_004_001_execute+0x104>)
  return __sch_get_currthread();
 8008dea:	4e3f      	ldr	r6, [pc, #252]	; (8008ee8 <oslib_test_004_001_execute+0x108>)
  test_end_step(1);

  /* [4.1.2] Starting the dispatcher threads.*/
  test_set_step(2);
  {
    thread_descriptor_t td1 = {
 8008dec:	4d3f      	ldr	r5, [pc, #252]	; (8008eec <oslib_test_004_001_execute+0x10c>)
 8008dee:	4f40      	ldr	r7, [pc, #256]	; (8008ef0 <oslib_test_004_001_execute+0x110>)
static void oslib_test_004_001_execute(void) {
 8008df0:	b08c      	sub	sp, #48	; 0x30
  test_set_step(1);
 8008df2:	2301      	movs	r3, #1
 8008df4:	2204      	movs	r2, #4
 8008df6:	2108      	movs	r1, #8
 8008df8:	f8c8 3000 	str.w	r3, [r8]
 8008dfc:	f7fa fa60 	bl	80032c0 <chGuardedPoolObjectInitAligned>
  chGuardedPoolLoadArray(&jqp->free, (void *)jobsbuf, jobsn);
 8008e00:	493c      	ldr	r1, [pc, #240]	; (8008ef4 <oslib_test_004_001_execute+0x114>)
 8008e02:	4838      	ldr	r0, [pc, #224]	; (8008ee4 <oslib_test_004_001_execute+0x104>)
 8008e04:	2204      	movs	r2, #4
 8008e06:	f7fa fa6b 	bl	80032e0 <chGuardedPoolLoadArray>
  chMBObjectInit(&jqp->mbx, msgbuf, jobsn);
 8008e0a:	493b      	ldr	r1, [pc, #236]	; (8008ef8 <oslib_test_004_001_execute+0x118>)
 8008e0c:	483b      	ldr	r0, [pc, #236]	; (8008efc <oslib_test_004_001_execute+0x11c>)
 8008e0e:	2204      	movs	r2, #4
 8008e10:	f7f9 ff1e 	bl	8002c50 <chMBObjectInit>
  return chThdGetSelfX()->hdr.pqueue.prio;
 8008e14:	68f3      	ldr	r3, [r6, #12]
    thread_descriptor_t td1 = {
 8008e16:	4a3a      	ldr	r2, [pc, #232]	; (8008f00 <oslib_test_004_001_execute+0x120>)
      .name  = "dispatcher1",
      .wbase = wa1Thread1,
      .wend  = THD_WORKING_AREA_END(wa1Thread1),
      .prio  = chThdGetPriorityX() - 1,
 8008e18:	689b      	ldr	r3, [r3, #8]
    thread_descriptor_t td1 = {
 8008e1a:	483a      	ldr	r0, [pc, #232]	; (8008f04 <oslib_test_004_001_execute+0x124>)
 8008e1c:	9000      	str	r0, [sp, #0]
  test_set_step(2);
 8008e1e:	2002      	movs	r0, #2
    thread_descriptor_t td1 = {
 8008e20:	f502 71f8 	add.w	r1, r2, #496	; 0x1f0
      .prio  = chThdGetPriorityX() - 1,
 8008e24:	3b01      	subs	r3, #1
    thread_descriptor_t td1 = {
 8008e26:	2400      	movs	r4, #0
  test_set_step(2);
 8008e28:	f8c8 0000 	str.w	r0, [r8]
      .funcp = Thread1,
      .arg   = NULL
    };
    tp1 = chThdCreate(&td1);
 8008e2c:	4668      	mov	r0, sp
    thread_descriptor_t td1 = {
 8008e2e:	e9cd 1302 	strd	r1, r3, [sp, #8]
 8008e32:	e9cd 5404 	strd	r5, r4, [sp, #16]
 8008e36:	9201      	str	r2, [sp, #4]
    tp1 = chThdCreate(&td1);
 8008e38:	f7f8 ffaa 	bl	8001d90 <chThdCreate>
 8008e3c:	68f3      	ldr	r3, [r6, #12]

    thread_descriptor_t td2 = {
      .name  = "dispatcher2",
      .wbase = wa2Thread1,
      .wend  = THD_WORKING_AREA_END(wa2Thread1),
      .prio  = chThdGetPriorityX() - 2,
 8008e3e:	689b      	ldr	r3, [r3, #8]
    thread_descriptor_t td2 = {
 8008e40:	950a      	str	r5, [sp, #40]	; 0x28
      .prio  = chThdGetPriorityX() - 2,
 8008e42:	3b02      	subs	r3, #2
    thread_descriptor_t td2 = {
 8008e44:	9309      	str	r3, [sp, #36]	; 0x24
 8008e46:	4b30      	ldr	r3, [pc, #192]	; (8008f08 <oslib_test_004_001_execute+0x128>)
 8008e48:	9307      	str	r3, [sp, #28]
 8008e4a:	f503 73f8 	add.w	r3, r3, #496	; 0x1f0
 8008e4e:	9308      	str	r3, [sp, #32]
    tp1 = chThdCreate(&td1);
 8008e50:	4682      	mov	sl, r0
    thread_descriptor_t td2 = {
 8008e52:	4b2e      	ldr	r3, [pc, #184]	; (8008f0c <oslib_test_004_001_execute+0x12c>)
 8008e54:	940b      	str	r4, [sp, #44]	; 0x2c
      .funcp = Thread1,
      .arg   = NULL
    };
    tp2 = chThdCreate(&td2);
 8008e56:	a806      	add	r0, sp, #24
    thread_descriptor_t td2 = {
 8008e58:	9306      	str	r3, [sp, #24]
    tp2 = chThdCreate(&td2);
 8008e5a:	f7f8 ff99 	bl	8001d90 <chThdCreate>
  return (job_descriptor_t *)chGuardedPoolAllocTimeout(&jqp->free, TIME_INFINITE);
 8008e5e:	4d21      	ldr	r5, [pc, #132]	; (8008ee4 <oslib_test_004_001_execute+0x104>)
  }
  test_end_step(2);

  /* [4.1.3] Sending jobs with various timings.*/
  test_set_step(3);
 8008e60:	2303      	movs	r3, #3
 8008e62:	2461      	movs	r4, #97	; 0x61
    tp2 = chThdCreate(&td2);
 8008e64:	4681      	mov	r9, r0
  test_set_step(3);
 8008e66:	f8c8 3000 	str.w	r3, [r8]
  msg = chMBPostTimeout(&jqp->mbx, (msg_t)jp, TIME_IMMEDIATE);
 8008e6a:	f105 061c 	add.w	r6, r5, #28
  return (job_descriptor_t *)chGuardedPoolAllocTimeout(&jqp->free, TIME_INFINITE);
 8008e6e:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
 8008e72:	4628      	mov	r0, r5
 8008e74:	f7fa fa54 	bl	8003320 <chGuardedPoolAllocTimeout>
  msg = chMBPostTimeout(&jqp->mbx, (msg_t)jp, TIME_IMMEDIATE);
 8008e78:	2200      	movs	r2, #0
    unsigned i;
    job_descriptor_t *jdp;

    for (i = 0; i < 8; i++) {
      jdp = chJobGet(&jq);
      jdp->jobfunc = job_slow;
 8008e7a:	e9c0 7400 	strd	r7, r4, [r0]
  return (job_descriptor_t *)chGuardedPoolAllocTimeout(&jqp->free, TIME_INFINITE);
 8008e7e:	4601      	mov	r1, r0
    for (i = 0; i < 8; i++) {
 8008e80:	3401      	adds	r4, #1
  msg = chMBPostTimeout(&jqp->mbx, (msg_t)jp, TIME_IMMEDIATE);
 8008e82:	4630      	mov	r0, r6
 8008e84:	f7f9 ff64 	bl	8002d50 <chMBPostTimeout>
 8008e88:	2c69      	cmp	r4, #105	; 0x69
 8008e8a:	d1f0      	bne.n	8008e6e <oslib_test_004_001_execute+0x8e>
    }
  }
  test_end_step(3);

  /* [4.1.4] Sending two null jobs to make threads exit.*/
  test_set_step(4);
 8008e8c:	2304      	movs	r3, #4
  return (job_descriptor_t *)chGuardedPoolAllocTimeout(&jqp->free, TIME_INFINITE);
 8008e8e:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
 8008e92:	4814      	ldr	r0, [pc, #80]	; (8008ee4 <oslib_test_004_001_execute+0x104>)
 8008e94:	f8c8 3000 	str.w	r3, [r8]
 8008e98:	f7fa fa42 	bl	8003320 <chGuardedPoolAllocTimeout>
  {
    job_descriptor_t *jdp;

    jdp = chJobGet(&jq);
    jdp->jobfunc = NULL;
 8008e9c:	2400      	movs	r4, #0
  msg = chMBPostTimeout(&jqp->mbx, (msg_t)jp, TIME_IMMEDIATE);
 8008e9e:	4622      	mov	r2, r4
    jdp->jobarg  = NULL;
 8008ea0:	e9c0 4400 	strd	r4, r4, [r0]
  return (job_descriptor_t *)chGuardedPoolAllocTimeout(&jqp->free, TIME_INFINITE);
 8008ea4:	4601      	mov	r1, r0
  msg = chMBPostTimeout(&jqp->mbx, (msg_t)jp, TIME_IMMEDIATE);
 8008ea6:	4815      	ldr	r0, [pc, #84]	; (8008efc <oslib_test_004_001_execute+0x11c>)
 8008ea8:	f7f9 ff52 	bl	8002d50 <chMBPostTimeout>
  return (job_descriptor_t *)chGuardedPoolAllocTimeout(&jqp->free, TIME_INFINITE);
 8008eac:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
 8008eb0:	480c      	ldr	r0, [pc, #48]	; (8008ee4 <oslib_test_004_001_execute+0x104>)
 8008eb2:	f7fa fa35 	bl	8003320 <chGuardedPoolAllocTimeout>
  msg = chMBPostTimeout(&jqp->mbx, (msg_t)jp, TIME_IMMEDIATE);
 8008eb6:	4622      	mov	r2, r4
  return (job_descriptor_t *)chGuardedPoolAllocTimeout(&jqp->free, TIME_INFINITE);
 8008eb8:	4601      	mov	r1, r0
    chJobPost(&jq, jdp);
    jdp = chJobGet(&jq);
    jdp->jobfunc = NULL;
    jdp->jobarg  = NULL;
 8008eba:	e9c0 4400 	strd	r4, r4, [r0]
  msg = chMBPostTimeout(&jqp->mbx, (msg_t)jp, TIME_IMMEDIATE);
 8008ebe:	480f      	ldr	r0, [pc, #60]	; (8008efc <oslib_test_004_001_execute+0x11c>)
 8008ec0:	f7f9 ff46 	bl	8002d50 <chMBPostTimeout>
    chJobPost(&jq, jdp);
    (void) chThdWait(tp1);
 8008ec4:	4650      	mov	r0, sl
 8008ec6:	f7f9 f80b 	bl	8001ee0 <chThdWait>
    (void) chThdWait(tp2);
 8008eca:	4648      	mov	r0, r9
 8008ecc:	f7f9 f808 	bl	8001ee0 <chThdWait>
    test_assert_sequence("abcdefgh", "unexpected tokens");
 8008ed0:	490f      	ldr	r1, [pc, #60]	; (8008f10 <oslib_test_004_001_execute+0x130>)
 8008ed2:	4810      	ldr	r0, [pc, #64]	; (8008f14 <oslib_test_004_001_execute+0x134>)
  }
  test_end_step(4);
}
 8008ed4:	b00c      	add	sp, #48	; 0x30
 8008ed6:	e8bd 47f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    test_assert_sequence("abcdefgh", "unexpected tokens");
 8008eda:	f7fb ba31 	b.w	8004340 <__test_assert_sequence>
 8008ede:	bf00      	nop
 8008ee0:	20000c70 	.word	0x20000c70
 8008ee4:	200014a4 	.word	0x200014a4
 8008ee8:	20000a40 	.word	0x20000a40
 8008eec:	08008da1 	.word	0x08008da1
 8008ef0:	08008d81 	.word	0x08008d81
 8008ef4:	20001484 	.word	0x20001484
 8008ef8:	200014e8 	.word	0x200014e8
 8008efc:	200014c0 	.word	0x200014c0
 8008f00:	200014f8 	.word	0x200014f8
 8008f04:	0800c960 	.word	0x0800c960
 8008f08:	200016e8 	.word	0x200016e8
 8008f0c:	0800c96c 	.word	0x0800c96c
 8008f10:	0800c978 	.word	0x0800c978
 8008f14:	0800c98c 	.word	0x0800c98c
	...

08008f20 <dis_func_end>:
  test_emit_token((char)d);

  return (msg_t)a;
}

static int dis_func_end(void) {
 8008f20:	b508      	push	{r3, lr}

  test_emit_token('Z');
 8008f22:	205a      	movs	r0, #90	; 0x5a
 8008f24:	f7fb fa44 	bl	80043b0 <test_emit_token>
  exit_flag = true;
 8008f28:	4b02      	ldr	r3, [pc, #8]	; (8008f34 <dis_func_end+0x14>)
 8008f2a:	2201      	movs	r2, #1
 8008f2c:	701a      	strb	r2, [r3, #0]

  return (msg_t)0xAA55;
}
 8008f2e:	f64a 2055 	movw	r0, #43605	; 0xaa55
 8008f32:	bd08      	pop	{r3, pc}
 8008f34:	200018d8 	.word	0x200018d8
	...

08008f40 <dis_func4>:
static msg_t dis_func4(msg_t a, msg_t b, msg_t c, msg_t d) {
 8008f40:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8008f42:	460f      	mov	r7, r1
 8008f44:	4604      	mov	r4, r0
  test_emit_token((char)a);
 8008f46:	b2c0      	uxtb	r0, r0
static msg_t dis_func4(msg_t a, msg_t b, msg_t c, msg_t d) {
 8008f48:	4616      	mov	r6, r2
 8008f4a:	461d      	mov	r5, r3
  test_emit_token((char)a);
 8008f4c:	f7fb fa30 	bl	80043b0 <test_emit_token>
  test_emit_token((char)b);
 8008f50:	b2f8      	uxtb	r0, r7
 8008f52:	f7fb fa2d 	bl	80043b0 <test_emit_token>
  test_emit_token((char)c);
 8008f56:	b2f0      	uxtb	r0, r6
 8008f58:	f7fb fa2a 	bl	80043b0 <test_emit_token>
  test_emit_token((char)d);
 8008f5c:	b2e8      	uxtb	r0, r5
 8008f5e:	f7fb fa27 	bl	80043b0 <test_emit_token>
}
 8008f62:	4620      	mov	r0, r4
 8008f64:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8008f66:	bf00      	nop
	...

08008f70 <dis_func3>:
static msg_t dis_func3(msg_t a, msg_t b, msg_t c) {
 8008f70:	b570      	push	{r4, r5, r6, lr}
 8008f72:	460e      	mov	r6, r1
 8008f74:	4604      	mov	r4, r0
  test_emit_token((char)a);
 8008f76:	b2c0      	uxtb	r0, r0
static msg_t dis_func3(msg_t a, msg_t b, msg_t c) {
 8008f78:	4615      	mov	r5, r2
  test_emit_token((char)a);
 8008f7a:	f7fb fa19 	bl	80043b0 <test_emit_token>
  test_emit_token((char)b);
 8008f7e:	b2f0      	uxtb	r0, r6
 8008f80:	f7fb fa16 	bl	80043b0 <test_emit_token>
  test_emit_token((char)c);
 8008f84:	b2e8      	uxtb	r0, r5
 8008f86:	f7fb fa13 	bl	80043b0 <test_emit_token>
}
 8008f8a:	4620      	mov	r0, r4
 8008f8c:	bd70      	pop	{r4, r5, r6, pc}
 8008f8e:	bf00      	nop

08008f90 <dis_func2>:
static msg_t dis_func2(msg_t a, msg_t b) {
 8008f90:	b538      	push	{r3, r4, r5, lr}
 8008f92:	460d      	mov	r5, r1
 8008f94:	4604      	mov	r4, r0
  test_emit_token((char)a);
 8008f96:	b2c0      	uxtb	r0, r0
 8008f98:	f7fb fa0a 	bl	80043b0 <test_emit_token>
  test_emit_token((char)b);
 8008f9c:	b2e8      	uxtb	r0, r5
 8008f9e:	f7fb fa07 	bl	80043b0 <test_emit_token>
}
 8008fa2:	4620      	mov	r0, r4
 8008fa4:	bd38      	pop	{r3, r4, r5, pc}
 8008fa6:	bf00      	nop
	...

08008fb0 <dis_func1>:
static msg_t dis_func1(msg_t a) {
 8008fb0:	b510      	push	{r4, lr}
 8008fb2:	4604      	mov	r4, r0
  test_emit_token((char)a);
 8008fb4:	b2c0      	uxtb	r0, r0
 8008fb6:	f7fb f9fb 	bl	80043b0 <test_emit_token>
}
 8008fba:	4620      	mov	r0, r4
 8008fbc:	bd10      	pop	{r4, pc}
 8008fbe:	bf00      	nop

08008fc0 <dis_func0>:
static int dis_func0(void) {
 8008fc0:	b508      	push	{r3, lr}
  test_emit_token('0');
 8008fc2:	2030      	movs	r0, #48	; 0x30
 8008fc4:	f7fb f9f4 	bl	80043b0 <test_emit_token>
}
 8008fc8:	f245 50aa 	movw	r0, #21930	; 0x55aa
 8008fcc:	bd08      	pop	{r3, pc}
 8008fce:	bf00      	nop

08008fd0 <Thread1>:

static THD_WORKING_AREA(waThread1, 256);
static THD_FUNCTION(Thread1, arg) {
 8008fd0:	b510      	push	{r4, lr}

  (void)arg;

  exit_flag = false;
 8008fd2:	4c07      	ldr	r4, [pc, #28]	; (8008ff0 <Thread1+0x20>)
 8008fd4:	2300      	movs	r3, #0
 8008fd6:	7023      	strb	r3, [r4, #0]
  do {
    chDelegateDispatch();
 8008fd8:	f7fa fc72 	bl	80038c0 <chDelegateDispatch>
  } while (!exit_flag);
 8008fdc:	7823      	ldrb	r3, [r4, #0]
 8008fde:	2b00      	cmp	r3, #0
 8008fe0:	d0fa      	beq.n	8008fd8 <Thread1+0x8>

  chThdExit(0x0FA5);
}
 8008fe2:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  chThdExit(0x0FA5);
 8008fe6:	f640 70a5 	movw	r0, #4005	; 0xfa5
 8008fea:	f7f8 bf49 	b.w	8001e80 <chThdExit>
 8008fee:	bf00      	nop
 8008ff0:	200018d8 	.word	0x200018d8
	...

08009000 <oslib_test_005_001_execute>:
 *   emitted tokens.
 * - [5.1.3] Waiting for the thread to terminate-.
 * .
 */

static void oslib_test_005_001_execute(void) {
 8009000:	b530      	push	{r4, r5, lr}
  return __sch_get_currthread();
 8009002:	4b4e      	ldr	r3, [pc, #312]	; (800913c <oslib_test_005_001_execute+0x13c>)
  thread_t *tp;

  /* [5.1.1] Starting the dispatcher thread.*/
  test_set_step(1);
  {
    thread_descriptor_t td = {
 8009004:	4a4e      	ldr	r2, [pc, #312]	; (8009140 <oslib_test_005_001_execute+0x140>)
  return chThdGetSelfX()->hdr.pqueue.prio;
 8009006:	68db      	ldr	r3, [r3, #12]
 8009008:	494e      	ldr	r1, [pc, #312]	; (8009144 <oslib_test_005_001_execute+0x144>)
      .name  = "dispatcher",
      .wbase = waThread1,
      .wend  = THD_WORKING_AREA_END(waThread1),
      .prio  = chThdGetPriorityX() + 1,
 800900a:	689b      	ldr	r3, [r3, #8]
  test_set_step(1);
 800900c:	4c4e      	ldr	r4, [pc, #312]	; (8009148 <oslib_test_005_001_execute+0x148>)
static void oslib_test_005_001_execute(void) {
 800900e:	b08b      	sub	sp, #44	; 0x2c
    thread_descriptor_t td = {
 8009010:	f502 70f8 	add.w	r0, r2, #496	; 0x1f0
      .prio  = chThdGetPriorityX() + 1,
 8009014:	3301      	adds	r3, #1
    thread_descriptor_t td = {
 8009016:	9104      	str	r1, [sp, #16]
 8009018:	494c      	ldr	r1, [pc, #304]	; (800914c <oslib_test_005_001_execute+0x14c>)
 800901a:	9307      	str	r3, [sp, #28]
 800901c:	e9cd 2005 	strd	r2, r0, [sp, #20]
 8009020:	2300      	movs	r3, #0
  test_set_step(1);
 8009022:	2501      	movs	r5, #1
      .funcp = Thread1,
      .arg   = NULL
    };
    tp = chThdCreate(&td);
 8009024:	a804      	add	r0, sp, #16
    thread_descriptor_t td = {
 8009026:	e9cd 1308 	strd	r1, r3, [sp, #32]
  test_set_step(1);
 800902a:	6025      	str	r5, [r4, #0]
    tp = chThdCreate(&td);
 800902c:	f7f8 feb0 	bl	8001d90 <chThdCreate>
  }
  test_end_step(1);

  /* [5.1.2] Calling the default veneers, checking the result and the
     emitted tokens.*/
  test_set_step(2);
 8009030:	2302      	movs	r3, #2
 * @param[in] func      pointer to the function to be called
 * @return              The function return value as a @p msg_t.
 */
static inline msg_t chDelegateCallDirect0(thread_t *tp, delegate_fn0_t func) {

  return chDelegateCallVeneer(tp, __ch_delegate_fn0, func);
 8009032:	4947      	ldr	r1, [pc, #284]	; (8009150 <oslib_test_005_001_execute+0x150>)
 8009034:	4a47      	ldr	r2, [pc, #284]	; (8009154 <oslib_test_005_001_execute+0x154>)
 8009036:	6023      	str	r3, [r4, #0]
    tp = chThdCreate(&td);
 8009038:	4605      	mov	r5, r0
 800903a:	f7fa fc29 	bl	8003890 <chDelegateCallVeneer>
  {
    int retval;

    retval = chDelegateCallDirect0(tp, (delegate_fn0_t)dis_func0);
    test_assert(retval == 0x55AA, "invalid return value");
 800903e:	f245 53aa 	movw	r3, #21930	; 0x55aa
 8009042:	1ac0      	subs	r0, r0, r3
 8009044:	fab0 f080 	clz	r0, r0
 8009048:	4943      	ldr	r1, [pc, #268]	; (8009158 <oslib_test_005_001_execute+0x158>)
 800904a:	0940      	lsrs	r0, r0, #5
 800904c:	f7fb f968 	bl	8004320 <__test_assert>
 8009050:	b108      	cbz	r0, 8009056 <oslib_test_005_001_execute+0x56>
  {
    msg_t msg = chThdWait(tp);
    test_assert(msg == 0x0FA5, "invalid exit code");
  }
  test_end_step(3);
}
 8009052:	b00b      	add	sp, #44	; 0x2c
 8009054:	bd30      	pop	{r4, r5, pc}
 * @return              The function return value as a @p msg_t.
 */
static inline msg_t chDelegateCallDirect1(thread_t *tp, delegate_fn1_t func,
                                          msg_t p1) {

  return chDelegateCallVeneer(tp, __ch_delegate_fn1, func, p1);
 8009056:	4941      	ldr	r1, [pc, #260]	; (800915c <oslib_test_005_001_execute+0x15c>)
 8009058:	4a41      	ldr	r2, [pc, #260]	; (8009160 <oslib_test_005_001_execute+0x160>)
 800905a:	2341      	movs	r3, #65	; 0x41
 800905c:	4628      	mov	r0, r5
 800905e:	f7fa fc17 	bl	8003890 <chDelegateCallVeneer>
    test_assert(retval == (int)'A', "invalid return value");
 8009062:	f1a0 0041 	sub.w	r0, r0, #65	; 0x41
 8009066:	fab0 f080 	clz	r0, r0
 800906a:	493b      	ldr	r1, [pc, #236]	; (8009158 <oslib_test_005_001_execute+0x158>)
 800906c:	0940      	lsrs	r0, r0, #5
 800906e:	f7fb f957 	bl	8004320 <__test_assert>
 8009072:	2800      	cmp	r0, #0
 8009074:	d1ed      	bne.n	8009052 <oslib_test_005_001_execute+0x52>
 * @return              The function return value as a @p msg_t.
 */
static inline msg_t chDelegateCallDirect2(thread_t *tp, delegate_fn2_t func,
                                          msg_t p1, msg_t p2) {

  return chDelegateCallVeneer(tp, __ch_delegate_fn2, func, p1, p2);
 8009076:	2043      	movs	r0, #67	; 0x43
 8009078:	493a      	ldr	r1, [pc, #232]	; (8009164 <oslib_test_005_001_execute+0x164>)
 800907a:	9000      	str	r0, [sp, #0]
 800907c:	4a3a      	ldr	r2, [pc, #232]	; (8009168 <oslib_test_005_001_execute+0x168>)
 800907e:	2342      	movs	r3, #66	; 0x42
 8009080:	4628      	mov	r0, r5
 8009082:	f7fa fc05 	bl	8003890 <chDelegateCallVeneer>
    test_assert(retval == (int)'B', "invalid return value");
 8009086:	f1a0 0042 	sub.w	r0, r0, #66	; 0x42
 800908a:	fab0 f080 	clz	r0, r0
 800908e:	4932      	ldr	r1, [pc, #200]	; (8009158 <oslib_test_005_001_execute+0x158>)
 8009090:	0940      	lsrs	r0, r0, #5
 8009092:	f7fb f945 	bl	8004320 <__test_assert>
 8009096:	2800      	cmp	r0, #0
 8009098:	d1db      	bne.n	8009052 <oslib_test_005_001_execute+0x52>
 * @return              The function return value as a @p msg_t.
 */
static inline msg_t chDelegateCallDirect3(thread_t *tp, delegate_fn3_t func,
                                          msg_t p1, msg_t p2, msg_t p3) {

  return chDelegateCallVeneer(tp, __ch_delegate_fn3, func, p1, p2, p3);
 800909a:	2046      	movs	r0, #70	; 0x46
 800909c:	2145      	movs	r1, #69	; 0x45
 800909e:	e9cd 1000 	strd	r1, r0, [sp]
 80090a2:	4a32      	ldr	r2, [pc, #200]	; (800916c <oslib_test_005_001_execute+0x16c>)
 80090a4:	4932      	ldr	r1, [pc, #200]	; (8009170 <oslib_test_005_001_execute+0x170>)
 80090a6:	2344      	movs	r3, #68	; 0x44
 80090a8:	4628      	mov	r0, r5
 80090aa:	f7fa fbf1 	bl	8003890 <chDelegateCallVeneer>
    test_assert(retval == (int)'D', "invalid return value");
 80090ae:	f1a0 0044 	sub.w	r0, r0, #68	; 0x44
 80090b2:	fab0 f080 	clz	r0, r0
 80090b6:	4928      	ldr	r1, [pc, #160]	; (8009158 <oslib_test_005_001_execute+0x158>)
 80090b8:	0940      	lsrs	r0, r0, #5
 80090ba:	f7fb f931 	bl	8004320 <__test_assert>
 80090be:	2800      	cmp	r0, #0
 80090c0:	d1c7      	bne.n	8009052 <oslib_test_005_001_execute+0x52>
 */
static inline msg_t chDelegateCallDirect4(thread_t *tp, delegate_fn4_t func,
                                          msg_t p1, msg_t p2, msg_t p3,
                                          msg_t p4) {

  return chDelegateCallVeneer(tp, __ch_delegate_fn4, func, p1, p2, p3, p4);
 80090c2:	224a      	movs	r2, #74	; 0x4a
 80090c4:	2349      	movs	r3, #73	; 0x49
 80090c6:	2048      	movs	r0, #72	; 0x48
 80090c8:	e9cd 3201 	strd	r3, r2, [sp, #4]
 80090cc:	4929      	ldr	r1, [pc, #164]	; (8009174 <oslib_test_005_001_execute+0x174>)
 80090ce:	9000      	str	r0, [sp, #0]
 80090d0:	4a29      	ldr	r2, [pc, #164]	; (8009178 <oslib_test_005_001_execute+0x178>)
 80090d2:	2347      	movs	r3, #71	; 0x47
 80090d4:	4628      	mov	r0, r5
 80090d6:	f7fa fbdb 	bl	8003890 <chDelegateCallVeneer>
    test_assert(retval == (int)'G', "invalid return value");
 80090da:	f1a0 0047 	sub.w	r0, r0, #71	; 0x47
 80090de:	fab0 f080 	clz	r0, r0
 80090e2:	491d      	ldr	r1, [pc, #116]	; (8009158 <oslib_test_005_001_execute+0x158>)
 80090e4:	0940      	lsrs	r0, r0, #5
 80090e6:	f7fb f91b 	bl	8004320 <__test_assert>
 80090ea:	2800      	cmp	r0, #0
 80090ec:	d1b1      	bne.n	8009052 <oslib_test_005_001_execute+0x52>
  return chDelegateCallVeneer(tp, __ch_delegate_fn0, func);
 80090ee:	4918      	ldr	r1, [pc, #96]	; (8009150 <oslib_test_005_001_execute+0x150>)
 80090f0:	4a22      	ldr	r2, [pc, #136]	; (800917c <oslib_test_005_001_execute+0x17c>)
 80090f2:	4628      	mov	r0, r5
 80090f4:	f7fa fbcc 	bl	8003890 <chDelegateCallVeneer>
    test_assert(retval == 0xAA55, "invalid return value");
 80090f8:	f64a 2355 	movw	r3, #43605	; 0xaa55
 80090fc:	1ac0      	subs	r0, r0, r3
 80090fe:	fab0 f080 	clz	r0, r0
 8009102:	4915      	ldr	r1, [pc, #84]	; (8009158 <oslib_test_005_001_execute+0x158>)
 8009104:	0940      	lsrs	r0, r0, #5
 8009106:	f7fb f90b 	bl	8004320 <__test_assert>
 800910a:	2800      	cmp	r0, #0
 800910c:	d1a1      	bne.n	8009052 <oslib_test_005_001_execute+0x52>
    test_assert_sequence("0ABCDEFGHIJZ", "unexpected tokens");
 800910e:	491c      	ldr	r1, [pc, #112]	; (8009180 <oslib_test_005_001_execute+0x180>)
 8009110:	481c      	ldr	r0, [pc, #112]	; (8009184 <oslib_test_005_001_execute+0x184>)
 8009112:	f7fb f915 	bl	8004340 <__test_assert_sequence>
 8009116:	2800      	cmp	r0, #0
 8009118:	d19b      	bne.n	8009052 <oslib_test_005_001_execute+0x52>
  test_set_step(3);
 800911a:	2303      	movs	r3, #3
    msg_t msg = chThdWait(tp);
 800911c:	4628      	mov	r0, r5
  test_set_step(3);
 800911e:	6023      	str	r3, [r4, #0]
    msg_t msg = chThdWait(tp);
 8009120:	f7f8 fede 	bl	8001ee0 <chThdWait>
    test_assert(msg == 0x0FA5, "invalid exit code");
 8009124:	f640 73a5 	movw	r3, #4005	; 0xfa5
 8009128:	1ac0      	subs	r0, r0, r3
 800912a:	4917      	ldr	r1, [pc, #92]	; (8009188 <oslib_test_005_001_execute+0x188>)
 800912c:	fab0 f080 	clz	r0, r0
 8009130:	0940      	lsrs	r0, r0, #5
}
 8009132:	b00b      	add	sp, #44	; 0x2c
 8009134:	e8bd 4030 	ldmia.w	sp!, {r4, r5, lr}
    test_assert(msg == 0x0FA5, "invalid exit code");
 8009138:	f7fb b8f2 	b.w	8004320 <__test_assert>
 800913c:	20000a40 	.word	0x20000a40
 8009140:	200018e0 	.word	0x200018e0
 8009144:	0800c9d4 	.word	0x0800c9d4
 8009148:	20000c70 	.word	0x20000c70
 800914c:	08008fd1 	.word	0x08008fd1
 8009150:	080037f1 	.word	0x080037f1
 8009154:	08008fc1 	.word	0x08008fc1
 8009158:	0800c9e0 	.word	0x0800c9e0
 800915c:	08003801 	.word	0x08003801
 8009160:	08008fb1 	.word	0x08008fb1
 8009164:	08003821 	.word	0x08003821
 8009168:	08008f91 	.word	0x08008f91
 800916c:	08008f71 	.word	0x08008f71
 8009170:	08003841 	.word	0x08003841
 8009174:	08003861 	.word	0x08003861
 8009178:	08008f41 	.word	0x08008f41
 800917c:	08008f21 	.word	0x08008f21
 8009180:	0800c978 	.word	0x0800c978
 8009184:	0800c9f8 	.word	0x0800c9f8
 8009188:	0800ca08 	.word	0x0800ca08
 800918c:	00000000 	.word	0x00000000

08009190 <obj_write>:
  return false;
}

static bool obj_write(objects_cache_t *ocp,
                      oc_object_t *objp,
                      bool async) {
 8009190:	b508      	push	{r3, lr}
  (void)ocp;
  (void)async;

  test_emit_token('A' + objp->obj_key);
 8009192:	6948      	ldr	r0, [r1, #20]
 8009194:	3041      	adds	r0, #65	; 0x41
 8009196:	b2c0      	uxtb	r0, r0
 8009198:	f7fb f90a 	bl	80043b0 <test_emit_token>

  return false;
}
 800919c:	2000      	movs	r0, #0
 800919e:	bd08      	pop	{r3, pc}

080091a0 <obj_read>:
  test_emit_token('a' + objp->obj_key);
 80091a0:	694b      	ldr	r3, [r1, #20]
                     bool async) {
 80091a2:	b570      	push	{r4, r5, r6, lr}
  test_emit_token('a' + objp->obj_key);
 80091a4:	3361      	adds	r3, #97	; 0x61
                     bool async) {
 80091a6:	460c      	mov	r4, r1
 80091a8:	4606      	mov	r6, r0
  test_emit_token('a' + objp->obj_key);
 80091aa:	b2d8      	uxtb	r0, r3
                     bool async) {
 80091ac:	4615      	mov	r5, r2
  test_emit_token('a' + objp->obj_key);
 80091ae:	f7fb f8ff 	bl	80043b0 <test_emit_token>
  objp->obj_flags &= ~OC_FLAG_NOTSYNC;
 80091b2:	6a63      	ldr	r3, [r4, #36]	; 0x24
 80091b4:	f023 0308 	bic.w	r3, r3, #8
 80091b8:	6263      	str	r3, [r4, #36]	; 0x24
  if (async) {
 80091ba:	b90d      	cbnz	r5, 80091c0 <obj_read+0x20>
}
 80091bc:	2000      	movs	r0, #0
 80091be:	bd70      	pop	{r4, r5, r6, pc}
 80091c0:	2330      	movs	r3, #48	; 0x30
 80091c2:	f383 8811 	msr	BASEPRI, r3
 */
static inline void chCacheReleaseObject(objects_cache_t *ocp,
                                        oc_object_t *objp) {

  chSysLock();
  chCacheReleaseObjectI(ocp, objp);
 80091c6:	4621      	mov	r1, r4
 80091c8:	4630      	mov	r0, r6
 80091ca:	f7fa fac1 	bl	8003750 <chCacheReleaseObjectI>
  chSchRescheduleS();
 80091ce:	f7f8 fce7 	bl	8001ba0 <chSchRescheduleS>
 80091d2:	2300      	movs	r3, #0
 80091d4:	f383 8811 	msr	BASEPRI, r3
 80091d8:	2000      	movs	r0, #0
 80091da:	bd70      	pop	{r4, r5, r6, pc}
 80091dc:	0000      	movs	r0, r0
	...

080091e0 <oslib_test_006_001_execute>:
 * - [6.1.5] Checking cached objects.
 * - [6.1.6] Checking non-cached objects.
 * .
 */

static void oslib_test_006_001_execute(void) {
 80091e0:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}

  /* [6.1.1] Cache initialization.*/
  test_set_step(1);
  {
    chCacheObjectInit(&cache1,
 80091e4:	49b5      	ldr	r1, [pc, #724]	; (80094bc <oslib_test_006_001_execute+0x2dc>)
  test_set_step(1);
 80091e6:	f8df 82d8 	ldr.w	r8, [pc, #728]	; 80094c0 <oslib_test_006_001_execute+0x2e0>
    chCacheObjectInit(&cache1,
 80091ea:	4ab6      	ldr	r2, [pc, #728]	; (80094c4 <oslib_test_006_001_execute+0x2e4>)
 80091ec:	4cb6      	ldr	r4, [pc, #728]	; (80094c8 <oslib_test_006_001_execute+0x2e8>)
  test_set_step(2);
  {
    uint32_t i;

    for (i = 0; i < (NUM_OBJECTS * 2); i++) {
      oc_object_t * objp = chCacheGetObject(&cache1, 0U, i);
 80091ee:	4fb7      	ldr	r7, [pc, #732]	; (80094cc <oslib_test_006_001_execute+0x2ec>)

      test_assert((objp->obj_flags & OC_FLAG_INHASH) != 0U, "not in hash");
 80091f0:	f8df a2dc 	ldr.w	sl, [pc, #732]	; 80094d0 <oslib_test_006_001_execute+0x2f0>
      test_assert((objp->obj_flags & OC_FLAG_NOTSYNC) != 0U, "should not be in sync");
 80091f4:	f8df 92dc 	ldr.w	r9, [pc, #732]	; 80094d4 <oslib_test_006_001_execute+0x2f4>
static void oslib_test_006_001_execute(void) {
 80091f8:	b084      	sub	sp, #16
    chCacheObjectInit(&cache1,
 80091fa:	233c      	movs	r3, #60	; 0x3c
  test_set_step(1);
 80091fc:	2001      	movs	r0, #1
    chCacheObjectInit(&cache1,
 80091fe:	9403      	str	r4, [sp, #12]
  test_set_step(1);
 8009200:	f8c8 0000 	str.w	r0, [r8]
    chCacheObjectInit(&cache1,
 8009204:	e9cd 3100 	strd	r3, r1, [sp]
 8009208:	9202      	str	r2, [sp, #8]
 800920a:	2304      	movs	r3, #4
 800920c:	4ab2      	ldr	r2, [pc, #712]	; (80094d8 <oslib_test_006_001_execute+0x2f8>)
 800920e:	48af      	ldr	r0, [pc, #700]	; (80094cc <oslib_test_006_001_execute+0x2ec>)
 8009210:	2108      	movs	r1, #8
 8009212:	f7fa f9dd 	bl	80035d0 <chCacheObjectInit>
  test_set_step(2);
 8009216:	2302      	movs	r3, #2
 8009218:	f8c8 3000 	str.w	r3, [r8]
    for (i = 0; i < (NUM_OBJECTS * 2); i++) {
 800921c:	2600      	movs	r6, #0
      oc_object_t * objp = chCacheGetObject(&cache1, 0U, i);
 800921e:	4632      	mov	r2, r6
 8009220:	2100      	movs	r1, #0
 8009222:	4638      	mov	r0, r7
 8009224:	f7fa fa14 	bl	8003650 <chCacheGetObject>
 8009228:	4604      	mov	r4, r0
      test_assert((objp->obj_flags & OC_FLAG_INHASH) != 0U, "not in hash");
 800922a:	6a40      	ldr	r0, [r0, #36]	; 0x24
 800922c:	4651      	mov	r1, sl
 800922e:	f3c0 0040 	ubfx	r0, r0, #1, #1
 8009232:	f7fb f875 	bl	8004320 <__test_assert>
      test_assert((objp->obj_flags & OC_FLAG_NOTSYNC) != 0U, "should not be in sync");
 8009236:	4649      	mov	r1, r9
      test_assert((objp->obj_flags & OC_FLAG_INHASH) != 0U, "not in hash");
 8009238:	2800      	cmp	r0, #0
 800923a:	f040 813b 	bne.w	80094b4 <oslib_test_006_001_execute+0x2d4>
      test_assert((objp->obj_flags & OC_FLAG_NOTSYNC) != 0U, "should not be in sync");
 800923e:	6a60      	ldr	r0, [r4, #36]	; 0x24
 8009240:	f3c0 00c0 	ubfx	r0, r0, #3, #1
 8009244:	f7fb f86c 	bl	8004320 <__test_assert>
 8009248:	2330      	movs	r3, #48	; 0x30
 800924a:	4605      	mov	r5, r0
 800924c:	2800      	cmp	r0, #0
 800924e:	f040 8131 	bne.w	80094b4 <oslib_test_006_001_execute+0x2d4>
 8009252:	f383 8811 	msr	BASEPRI, r3
  chCacheReleaseObjectI(ocp, objp);
 8009256:	4621      	mov	r1, r4
 8009258:	4638      	mov	r0, r7
 800925a:	f7fa fa79 	bl	8003750 <chCacheReleaseObjectI>
  chSchRescheduleS();
 800925e:	f7f8 fc9f 	bl	8001ba0 <chSchRescheduleS>
 8009262:	f385 8811 	msr	BASEPRI, r5
    for (i = 0; i < (NUM_OBJECTS * 2); i++) {
 8009266:	3601      	adds	r6, #1
 8009268:	2e08      	cmp	r6, #8
 800926a:	d1d8      	bne.n	800921e <oslib_test_006_001_execute+0x3e>

      chCacheReleaseObject(&cache1, objp);
    }

    test_assert_sequence("", "unexpected tokens");
 800926c:	499b      	ldr	r1, [pc, #620]	; (80094dc <oslib_test_006_001_execute+0x2fc>)
 800926e:	489c      	ldr	r0, [pc, #624]	; (80094e0 <oslib_test_006_001_execute+0x300>)
 8009270:	f7fb f866 	bl	8004340 <__test_assert_sequence>
 8009274:	4605      	mov	r5, r0
 8009276:	2800      	cmp	r0, #0
 8009278:	f040 811c 	bne.w	80094b4 <oslib_test_006_001_execute+0x2d4>
  }
  test_end_step(2);

  /* [6.1.3] Getting and releasing objects with synchronous
     initialization.*/
  test_set_step(3);
 800927c:	2303      	movs	r3, #3
  {
    uint32_t i;
    bool error;

    for (i = 0; i < (NUM_OBJECTS * 2); i++) {
      oc_object_t *objp = chCacheGetObject(&cache1, 0U, i);
 800927e:	4f93      	ldr	r7, [pc, #588]	; (80094cc <oslib_test_006_001_execute+0x2ec>)

      test_assert((objp->obj_flags & OC_FLAG_INHASH) != 0U, "not in hash");
 8009280:	f8df 924c 	ldr.w	r9, [pc, #588]	; 80094d0 <oslib_test_006_001_execute+0x2f0>
      test_assert((objp->obj_flags & OC_FLAG_NOTSYNC) != 0U, "in sync");
 8009284:	f8df a25c 	ldr.w	sl, [pc, #604]	; 80094e4 <oslib_test_006_001_execute+0x304>
  test_set_step(3);
 8009288:	f8c8 3000 	str.w	r3, [r8]
      oc_object_t *objp = chCacheGetObject(&cache1, 0U, i);
 800928c:	462a      	mov	r2, r5
 800928e:	2100      	movs	r1, #0
 8009290:	4638      	mov	r0, r7
 8009292:	f7fa f9dd 	bl	8003650 <chCacheGetObject>
 8009296:	4604      	mov	r4, r0
      test_assert((objp->obj_flags & OC_FLAG_INHASH) != 0U, "not in hash");
 8009298:	6a40      	ldr	r0, [r0, #36]	; 0x24
 800929a:	4649      	mov	r1, r9
 800929c:	f3c0 0040 	ubfx	r0, r0, #1, #1
 80092a0:	f7fb f83e 	bl	8004320 <__test_assert>
      test_assert((objp->obj_flags & OC_FLAG_NOTSYNC) != 0U, "in sync");
 80092a4:	4651      	mov	r1, sl
      test_assert((objp->obj_flags & OC_FLAG_INHASH) != 0U, "not in hash");
 80092a6:	2800      	cmp	r0, #0
 80092a8:	f040 8104 	bne.w	80094b4 <oslib_test_006_001_execute+0x2d4>
      test_assert((objp->obj_flags & OC_FLAG_NOTSYNC) != 0U, "in sync");
 80092ac:	6a60      	ldr	r0, [r4, #36]	; 0x24
 80092ae:	f3c0 00c0 	ubfx	r0, r0, #3, #1
 80092b2:	f7fb f835 	bl	8004320 <__test_assert>
 80092b6:	4602      	mov	r2, r0

      error = chCacheReadObject(&cache1, objp, false);
 80092b8:	4621      	mov	r1, r4
 80092ba:	4638      	mov	r0, r7
      test_assert((objp->obj_flags & OC_FLAG_NOTSYNC) != 0U, "in sync");
 80092bc:	2a00      	cmp	r2, #0
 80092be:	f040 80f9 	bne.w	80094b4 <oslib_test_006_001_execute+0x2d4>
      error = chCacheReadObject(&cache1, objp, false);
 80092c2:	f7fa fa85 	bl	80037d0 <chCacheReadObject>

      test_assert(error == false, "returned error");
 80092c6:	f080 0001 	eor.w	r0, r0, #1
 80092ca:	4987      	ldr	r1, [pc, #540]	; (80094e8 <oslib_test_006_001_execute+0x308>)
 80092cc:	b2c0      	uxtb	r0, r0
 80092ce:	f7fb f827 	bl	8004320 <__test_assert>
      test_assert((objp->obj_flags & OC_FLAG_INHASH) != 0U, "not in hash");
 80092d2:	4649      	mov	r1, r9
      test_assert(error == false, "returned error");
 80092d4:	2800      	cmp	r0, #0
 80092d6:	f040 80ed 	bne.w	80094b4 <oslib_test_006_001_execute+0x2d4>
      test_assert((objp->obj_flags & OC_FLAG_INHASH) != 0U, "not in hash");
 80092da:	6a60      	ldr	r0, [r4, #36]	; 0x24
 80092dc:	f3c0 0040 	ubfx	r0, r0, #1, #1
 80092e0:	f7fb f81e 	bl	8004320 <__test_assert>
      test_assert((objp->obj_flags & OC_FLAG_NOTSYNC) == 0U, "not in sync");
 80092e4:	4981      	ldr	r1, [pc, #516]	; (80094ec <oslib_test_006_001_execute+0x30c>)
      test_assert((objp->obj_flags & OC_FLAG_INHASH) != 0U, "not in hash");
 80092e6:	2800      	cmp	r0, #0
 80092e8:	f040 80e4 	bne.w	80094b4 <oslib_test_006_001_execute+0x2d4>
      test_assert((objp->obj_flags & OC_FLAG_NOTSYNC) == 0U, "not in sync");
 80092ec:	6a60      	ldr	r0, [r4, #36]	; 0x24
 80092ee:	f080 0008 	eor.w	r0, r0, #8
 80092f2:	f3c0 00c0 	ubfx	r0, r0, #3, #1
 80092f6:	f7fb f813 	bl	8004320 <__test_assert>
 80092fa:	2330      	movs	r3, #48	; 0x30
 80092fc:	4606      	mov	r6, r0
 80092fe:	2800      	cmp	r0, #0
 8009300:	f040 80d8 	bne.w	80094b4 <oslib_test_006_001_execute+0x2d4>
 8009304:	f383 8811 	msr	BASEPRI, r3
  chCacheReleaseObjectI(ocp, objp);
 8009308:	4621      	mov	r1, r4
 800930a:	4638      	mov	r0, r7
 800930c:	f7fa fa20 	bl	8003750 <chCacheReleaseObjectI>
  chSchRescheduleS();
 8009310:	f7f8 fc46 	bl	8001ba0 <chSchRescheduleS>
 8009314:	f386 8811 	msr	BASEPRI, r6
    for (i = 0; i < (NUM_OBJECTS * 2); i++) {
 8009318:	3501      	adds	r5, #1
 800931a:	2d08      	cmp	r5, #8
 800931c:	d1b6      	bne.n	800928c <oslib_test_006_001_execute+0xac>

      chCacheReleaseObject(&cache1, objp);
    }

    test_assert_sequence("abcdefgh", "unexpected tokens");
 800931e:	496f      	ldr	r1, [pc, #444]	; (80094dc <oslib_test_006_001_execute+0x2fc>)
 8009320:	4873      	ldr	r0, [pc, #460]	; (80094f0 <oslib_test_006_001_execute+0x310>)
 8009322:	f7fb f80d 	bl	8004340 <__test_assert_sequence>
 8009326:	4604      	mov	r4, r0
 8009328:	2800      	cmp	r0, #0
 800932a:	f040 80c3 	bne.w	80094b4 <oslib_test_006_001_execute+0x2d4>
  }
  test_end_step(3);

  /* [6.1.4] Getting and releasing objects with asynchronous
     initialization.*/
  test_set_step(4);
 800932e:	2304      	movs	r3, #4
  {
    uint32_t i;
    bool error;

    for (i = 0; i < (NUM_OBJECTS * 2); i++) {
      oc_object_t *objp = chCacheGetObject(&cache1, 0U, i);
 8009330:	4e66      	ldr	r6, [pc, #408]	; (80094cc <oslib_test_006_001_execute+0x2ec>)

      test_assert((objp->obj_flags & OC_FLAG_INHASH) != 0U, "not in hash");
 8009332:	4f67      	ldr	r7, [pc, #412]	; (80094d0 <oslib_test_006_001_execute+0x2f0>)
      test_assert((objp->obj_flags & OC_FLAG_NOTSYNC) != 0U, "in sync");
 8009334:	f8df 91ac 	ldr.w	r9, [pc, #428]	; 80094e4 <oslib_test_006_001_execute+0x304>
  test_set_step(4);
 8009338:	f8c8 3000 	str.w	r3, [r8]
      oc_object_t *objp = chCacheGetObject(&cache1, 0U, i);
 800933c:	2100      	movs	r1, #0
 800933e:	4622      	mov	r2, r4
 8009340:	4630      	mov	r0, r6
 8009342:	f7fa f985 	bl	8003650 <chCacheGetObject>
 8009346:	4605      	mov	r5, r0
      test_assert((objp->obj_flags & OC_FLAG_INHASH) != 0U, "not in hash");
 8009348:	6a40      	ldr	r0, [r0, #36]	; 0x24
 800934a:	4639      	mov	r1, r7
 800934c:	f3c0 0040 	ubfx	r0, r0, #1, #1
 8009350:	f7fa ffe6 	bl	8004320 <__test_assert>
 8009354:	2800      	cmp	r0, #0
 8009356:	f040 80ad 	bne.w	80094b4 <oslib_test_006_001_execute+0x2d4>
      test_assert((objp->obj_flags & OC_FLAG_NOTSYNC) != 0U, "in sync");
 800935a:	6a68      	ldr	r0, [r5, #36]	; 0x24
 800935c:	4649      	mov	r1, r9
 800935e:	f3c0 00c0 	ubfx	r0, r0, #3, #1
 8009362:	f7fa ffdd 	bl	8004320 <__test_assert>
 8009366:	2800      	cmp	r0, #0
 8009368:	f040 80a4 	bne.w	80094b4 <oslib_test_006_001_execute+0x2d4>

      error = chCacheReadObject(&cache1, objp, true);
 800936c:	2201      	movs	r2, #1
 800936e:	4629      	mov	r1, r5
 8009370:	4630      	mov	r0, r6
 8009372:	f7fa fa2d 	bl	80037d0 <chCacheReadObject>

      test_assert(error == false, "returned error");
 8009376:	f080 0001 	eor.w	r0, r0, #1
 800937a:	495b      	ldr	r1, [pc, #364]	; (80094e8 <oslib_test_006_001_execute+0x308>)
 800937c:	b2c0      	uxtb	r0, r0
 800937e:	f7fa ffcf 	bl	8004320 <__test_assert>
 8009382:	4601      	mov	r1, r0

      objp = chCacheGetObject(&cache1, 0U, i);
 8009384:	4622      	mov	r2, r4
 8009386:	4630      	mov	r0, r6
      test_assert(error == false, "returned error");
 8009388:	2900      	cmp	r1, #0
 800938a:	f040 8093 	bne.w	80094b4 <oslib_test_006_001_execute+0x2d4>
      objp = chCacheGetObject(&cache1, 0U, i);
 800938e:	f7fa f95f 	bl	8003650 <chCacheGetObject>
 8009392:	4605      	mov	r5, r0

      test_assert((objp->obj_flags & OC_FLAG_INHASH) != 0U, "not in hash");
 8009394:	6a40      	ldr	r0, [r0, #36]	; 0x24
 8009396:	4639      	mov	r1, r7
 8009398:	f3c0 0040 	ubfx	r0, r0, #1, #1
 800939c:	f7fa ffc0 	bl	8004320 <__test_assert>
 80093a0:	2800      	cmp	r0, #0
 80093a2:	f040 8087 	bne.w	80094b4 <oslib_test_006_001_execute+0x2d4>
      test_assert((objp->obj_flags & OC_FLAG_NOTSYNC) == 0U, "not in sync");
 80093a6:	6a68      	ldr	r0, [r5, #36]	; 0x24
 80093a8:	4950      	ldr	r1, [pc, #320]	; (80094ec <oslib_test_006_001_execute+0x30c>)
 80093aa:	f080 0008 	eor.w	r0, r0, #8
 80093ae:	f3c0 00c0 	ubfx	r0, r0, #3, #1
 80093b2:	f7fa ffb5 	bl	8004320 <__test_assert>
 80093b6:	2330      	movs	r3, #48	; 0x30
 80093b8:	4682      	mov	sl, r0
 80093ba:	2800      	cmp	r0, #0
 80093bc:	d17a      	bne.n	80094b4 <oslib_test_006_001_execute+0x2d4>
 80093be:	f383 8811 	msr	BASEPRI, r3
  chCacheReleaseObjectI(ocp, objp);
 80093c2:	4629      	mov	r1, r5
 80093c4:	4630      	mov	r0, r6
 80093c6:	f7fa f9c3 	bl	8003750 <chCacheReleaseObjectI>
  chSchRescheduleS();
 80093ca:	f7f8 fbe9 	bl	8001ba0 <chSchRescheduleS>
 80093ce:	f38a 8811 	msr	BASEPRI, sl
    for (i = 0; i < (NUM_OBJECTS * 2); i++) {
 80093d2:	3401      	adds	r4, #1
 80093d4:	2c08      	cmp	r4, #8
 80093d6:	d1b1      	bne.n	800933c <oslib_test_006_001_execute+0x15c>

      chCacheReleaseObject(&cache1, objp);
    }

    test_assert_sequence("abcdefgh", "unexpected tokens");
 80093d8:	4940      	ldr	r1, [pc, #256]	; (80094dc <oslib_test_006_001_execute+0x2fc>)
 80093da:	4845      	ldr	r0, [pc, #276]	; (80094f0 <oslib_test_006_001_execute+0x310>)
 80093dc:	f7fa ffb0 	bl	8004340 <__test_assert_sequence>
 80093e0:	2800      	cmp	r0, #0
 80093e2:	d167      	bne.n	80094b4 <oslib_test_006_001_execute+0x2d4>
  }
  test_end_step(4);

  /* [6.1.5] Checking cached objects.*/
  test_set_step(5);
 80093e4:	2305      	movs	r3, #5
  {
    uint32_t i;

    for (i = NUM_OBJECTS; i < (NUM_OBJECTS * 2); i++) {
      oc_object_t *objp = chCacheGetObject(&cache1, 0U, i);
 80093e6:	4f39      	ldr	r7, [pc, #228]	; (80094cc <oslib_test_006_001_execute+0x2ec>)

      test_assert((objp->obj_flags & OC_FLAG_INHASH) != 0U, "not in hash");
 80093e8:	f8df 90e4 	ldr.w	r9, [pc, #228]	; 80094d0 <oslib_test_006_001_execute+0x2f0>
      test_assert((objp->obj_flags & OC_FLAG_NOTSYNC) == 0U, "not in sync");
 80093ec:	f8df a0fc 	ldr.w	sl, [pc, #252]	; 80094ec <oslib_test_006_001_execute+0x30c>
  test_set_step(5);
 80093f0:	f8c8 3000 	str.w	r3, [r8]
    for (i = NUM_OBJECTS; i < (NUM_OBJECTS * 2); i++) {
 80093f4:	2604      	movs	r6, #4
      oc_object_t *objp = chCacheGetObject(&cache1, 0U, i);
 80093f6:	2100      	movs	r1, #0
 80093f8:	4632      	mov	r2, r6
 80093fa:	4638      	mov	r0, r7
 80093fc:	f7fa f928 	bl	8003650 <chCacheGetObject>
 8009400:	4604      	mov	r4, r0
      test_assert((objp->obj_flags & OC_FLAG_INHASH) != 0U, "not in hash");
 8009402:	6a40      	ldr	r0, [r0, #36]	; 0x24
 8009404:	4649      	mov	r1, r9
 8009406:	f3c0 0040 	ubfx	r0, r0, #1, #1
 800940a:	f7fa ff89 	bl	8004320 <__test_assert>
 800940e:	2800      	cmp	r0, #0
 8009410:	d150      	bne.n	80094b4 <oslib_test_006_001_execute+0x2d4>
      test_assert((objp->obj_flags & OC_FLAG_NOTSYNC) == 0U, "not in sync");
 8009412:	6a60      	ldr	r0, [r4, #36]	; 0x24
 8009414:	f080 0008 	eor.w	r0, r0, #8
 8009418:	f3c0 00c0 	ubfx	r0, r0, #3, #1
 800941c:	4651      	mov	r1, sl
 800941e:	f7fa ff7f 	bl	8004320 <__test_assert>
 8009422:	2330      	movs	r3, #48	; 0x30
 8009424:	4605      	mov	r5, r0
 8009426:	2800      	cmp	r0, #0
 8009428:	d144      	bne.n	80094b4 <oslib_test_006_001_execute+0x2d4>
 800942a:	f383 8811 	msr	BASEPRI, r3
  chCacheReleaseObjectI(ocp, objp);
 800942e:	4621      	mov	r1, r4
 8009430:	4638      	mov	r0, r7
 8009432:	f7fa f98d 	bl	8003750 <chCacheReleaseObjectI>
  chSchRescheduleS();
 8009436:	f7f8 fbb3 	bl	8001ba0 <chSchRescheduleS>
 800943a:	f385 8811 	msr	BASEPRI, r5
    for (i = NUM_OBJECTS; i < (NUM_OBJECTS * 2); i++) {
 800943e:	3601      	adds	r6, #1
 8009440:	2e08      	cmp	r6, #8
 8009442:	d1d8      	bne.n	80093f6 <oslib_test_006_001_execute+0x216>

      chCacheReleaseObject(&cache1, objp);
    }

    test_assert_sequence("", "unexpected tokens");
 8009444:	4925      	ldr	r1, [pc, #148]	; (80094dc <oslib_test_006_001_execute+0x2fc>)
 8009446:	4826      	ldr	r0, [pc, #152]	; (80094e0 <oslib_test_006_001_execute+0x300>)
 8009448:	f7fa ff7a 	bl	8004340 <__test_assert_sequence>
 800944c:	4604      	mov	r4, r0
 800944e:	bb88      	cbnz	r0, 80094b4 <oslib_test_006_001_execute+0x2d4>
  }
  test_end_step(5);

  /* [6.1.6] Checking non-cached objects.*/
  test_set_step(6);
 8009450:	2306      	movs	r3, #6
 8009452:	f8c8 3000 	str.w	r3, [r8]
  {
    uint32_t i;

    for (i = 0; i < NUM_OBJECTS; i++) {
      oc_object_t *objp = chCacheGetObject(&cache1, 0U, i);
 8009456:	4f1d      	ldr	r7, [pc, #116]	; (80094cc <oslib_test_006_001_execute+0x2ec>)

      test_assert((objp->obj_flags & OC_FLAG_INHASH) != 0U, "not in hash");
 8009458:	f8df 9074 	ldr.w	r9, [pc, #116]	; 80094d0 <oslib_test_006_001_execute+0x2f0>
      test_assert((objp->obj_flags & OC_FLAG_NOTSYNC) != 0U, "in sync");
 800945c:	f8df 8084 	ldr.w	r8, [pc, #132]	; 80094e4 <oslib_test_006_001_execute+0x304>
      oc_object_t *objp = chCacheGetObject(&cache1, 0U, i);
 8009460:	2100      	movs	r1, #0
 8009462:	4622      	mov	r2, r4
 8009464:	4638      	mov	r0, r7
 8009466:	f7fa f8f3 	bl	8003650 <chCacheGetObject>
 800946a:	4605      	mov	r5, r0
      test_assert((objp->obj_flags & OC_FLAG_INHASH) != 0U, "not in hash");
 800946c:	6a40      	ldr	r0, [r0, #36]	; 0x24
 800946e:	4649      	mov	r1, r9
 8009470:	f3c0 0040 	ubfx	r0, r0, #1, #1
 8009474:	f7fa ff54 	bl	8004320 <__test_assert>
 8009478:	b9e0      	cbnz	r0, 80094b4 <oslib_test_006_001_execute+0x2d4>
      test_assert((objp->obj_flags & OC_FLAG_NOTSYNC) != 0U, "in sync");
 800947a:	6a68      	ldr	r0, [r5, #36]	; 0x24
 800947c:	4641      	mov	r1, r8
 800947e:	f3c0 00c0 	ubfx	r0, r0, #3, #1
 8009482:	f7fa ff4d 	bl	8004320 <__test_assert>
 8009486:	2330      	movs	r3, #48	; 0x30
 8009488:	4606      	mov	r6, r0
 800948a:	b998      	cbnz	r0, 80094b4 <oslib_test_006_001_execute+0x2d4>
 800948c:	f383 8811 	msr	BASEPRI, r3
  chCacheReleaseObjectI(ocp, objp);
 8009490:	4629      	mov	r1, r5
 8009492:	4638      	mov	r0, r7
 8009494:	f7fa f95c 	bl	8003750 <chCacheReleaseObjectI>
  chSchRescheduleS();
 8009498:	f7f8 fb82 	bl	8001ba0 <chSchRescheduleS>
 800949c:	f386 8811 	msr	BASEPRI, r6
    for (i = 0; i < NUM_OBJECTS; i++) {
 80094a0:	3401      	adds	r4, #1
 80094a2:	2c04      	cmp	r4, #4
 80094a4:	d1dc      	bne.n	8009460 <oslib_test_006_001_execute+0x280>

      chCacheReleaseObject(&cache1, objp);
    }

    test_assert_sequence("", "unexpected tokens");
 80094a6:	490d      	ldr	r1, [pc, #52]	; (80094dc <oslib_test_006_001_execute+0x2fc>)
 80094a8:	480d      	ldr	r0, [pc, #52]	; (80094e0 <oslib_test_006_001_execute+0x300>)
  }
  test_end_step(6);
}
 80094aa:	b004      	add	sp, #16
 80094ac:	e8bd 47f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    test_assert_sequence("", "unexpected tokens");
 80094b0:	f7fa bf46 	b.w	8004340 <__test_assert_sequence>
}
 80094b4:	b004      	add	sp, #16
 80094b6:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 80094ba:	bf00      	nop
 80094bc:	20001b54 	.word	0x20001b54
 80094c0:	20000c70 	.word	0x20000c70
 80094c4:	080091a1 	.word	0x080091a1
 80094c8:	08009191 	.word	0x08009191
 80094cc:	20001ad0 	.word	0x20001ad0
 80094d0:	0800ca50 	.word	0x0800ca50
 80094d4:	0800ca5c 	.word	0x0800ca5c
 80094d8:	20001b14 	.word	0x20001b14
 80094dc:	0800c978 	.word	0x0800c978
 80094e0:	0800a89c 	.word	0x0800a89c
 80094e4:	0800ca88 	.word	0x0800ca88
 80094e8:	0800ca74 	.word	0x0800ca74
 80094ec:	0800ca84 	.word	0x0800ca84
 80094f0:	0800c98c 	.word	0x0800c98c
	...

08009500 <null_provider>:

  (void)size;
  (void)align;

  return NULL;
}
 8009500:	2000      	movs	r0, #0
 8009502:	4770      	bx	lr
	...

08009510 <oslib_test_007_003_execute>:

static void oslib_test_007_003_setup(void) {
  chGuardedPoolObjectInit(&gmp1, sizeof (uint32_t));
}

static void oslib_test_007_003_execute(void) {
 8009510:	b508      	push	{r3, lr}

  /* [7.3.1] Trying to allocate with 100mS timeout, must fail because
     the pool is empty.*/
  test_set_step(1);
 8009512:	4b08      	ldr	r3, [pc, #32]	; (8009534 <oslib_test_007_003_execute+0x24>)
  {
    test_assert(chGuardedPoolAllocTimeout(&gmp1, TIME_MS2I(100)) == NULL, "list not empty");
 8009514:	4808      	ldr	r0, [pc, #32]	; (8009538 <oslib_test_007_003_execute+0x28>)
 8009516:	f44f 717a 	mov.w	r1, #1000	; 0x3e8
  test_set_step(1);
 800951a:	2201      	movs	r2, #1
 800951c:	601a      	str	r2, [r3, #0]
    test_assert(chGuardedPoolAllocTimeout(&gmp1, TIME_MS2I(100)) == NULL, "list not empty");
 800951e:	f7f9 feff 	bl	8003320 <chGuardedPoolAllocTimeout>
 8009522:	fab0 f080 	clz	r0, r0
  }
  test_end_step(1);
}
 8009526:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
    test_assert(chGuardedPoolAllocTimeout(&gmp1, TIME_MS2I(100)) == NULL, "list not empty");
 800952a:	4904      	ldr	r1, [pc, #16]	; (800953c <oslib_test_007_003_execute+0x2c>)
 800952c:	0940      	lsrs	r0, r0, #5
 800952e:	f7fa bef7 	b.w	8004320 <__test_assert>
 8009532:	bf00      	nop
 8009534:	20000c70 	.word	0x20000c70
 8009538:	200008a8 	.word	0x200008a8
 800953c:	0800cad8 	.word	0x0800cad8

08009540 <oslib_test_007_002_setup>:
 8009540:	2204      	movs	r2, #4
 8009542:	4802      	ldr	r0, [pc, #8]	; (800954c <oslib_test_007_002_setup+0xc>)
 8009544:	4611      	mov	r1, r2
 8009546:	f7f9 bebb 	b.w	80032c0 <chGuardedPoolObjectInitAligned>
 800954a:	bf00      	nop
 800954c:	200008a8 	.word	0x200008a8

08009550 <oslib_test_007_002_execute>:
static void oslib_test_007_002_execute(void) {
 8009550:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  test_set_step(1);
 8009552:	4d2b      	ldr	r5, [pc, #172]	; (8009600 <oslib_test_007_002_execute+0xb0>)
    chGuardedPoolLoadArray(&gmp1, objects, MEMORY_POOL_SIZE);
 8009554:	492b      	ldr	r1, [pc, #172]	; (8009604 <oslib_test_007_002_execute+0xb4>)
 8009556:	482c      	ldr	r0, [pc, #176]	; (8009608 <oslib_test_007_002_execute+0xb8>)
      test_assert(chGuardedPoolAllocTimeout(&gmp1, TIME_IMMEDIATE) != NULL, "list empty");
 8009558:	4f2b      	ldr	r7, [pc, #172]	; (8009608 <oslib_test_007_002_execute+0xb8>)
 800955a:	4e2c      	ldr	r6, [pc, #176]	; (800960c <oslib_test_007_002_execute+0xbc>)
  test_set_step(1);
 800955c:	2301      	movs	r3, #1
    chGuardedPoolLoadArray(&gmp1, objects, MEMORY_POOL_SIZE);
 800955e:	2204      	movs	r2, #4
  test_set_step(1);
 8009560:	602b      	str	r3, [r5, #0]
    chGuardedPoolLoadArray(&gmp1, objects, MEMORY_POOL_SIZE);
 8009562:	f7f9 febd 	bl	80032e0 <chGuardedPoolLoadArray>
  test_set_step(2);
 8009566:	2302      	movs	r3, #2
 8009568:	602b      	str	r3, [r5, #0]
 800956a:	2404      	movs	r4, #4
      test_assert(chGuardedPoolAllocTimeout(&gmp1, TIME_IMMEDIATE) != NULL, "list empty");
 800956c:	2100      	movs	r1, #0
 800956e:	4638      	mov	r0, r7
 8009570:	f7f9 fed6 	bl	8003320 <chGuardedPoolAllocTimeout>
 8009574:	3800      	subs	r0, #0
 8009576:	bf18      	it	ne
 8009578:	2001      	movne	r0, #1
 800957a:	4631      	mov	r1, r6
 800957c:	f7fa fed0 	bl	8004320 <__test_assert>
 8009580:	2800      	cmp	r0, #0
 8009582:	d13b      	bne.n	80095fc <oslib_test_007_002_execute+0xac>
    for (i = 0; i < MEMORY_POOL_SIZE; i++)
 8009584:	3c01      	subs	r4, #1
 8009586:	d1f1      	bne.n	800956c <oslib_test_007_002_execute+0x1c>
    test_assert(chGuardedPoolAllocTimeout(&gmp1, TIME_IMMEDIATE) == NULL, "list not empty");
 8009588:	4621      	mov	r1, r4
  test_set_step(3);
 800958a:	2303      	movs	r3, #3
    test_assert(chGuardedPoolAllocTimeout(&gmp1, TIME_IMMEDIATE) == NULL, "list not empty");
 800958c:	481e      	ldr	r0, [pc, #120]	; (8009608 <oslib_test_007_002_execute+0xb8>)
  test_set_step(3);
 800958e:	602b      	str	r3, [r5, #0]
    test_assert(chGuardedPoolAllocTimeout(&gmp1, TIME_IMMEDIATE) == NULL, "list not empty");
 8009590:	f7f9 fec6 	bl	8003320 <chGuardedPoolAllocTimeout>
 8009594:	fab0 f080 	clz	r0, r0
 8009598:	491d      	ldr	r1, [pc, #116]	; (8009610 <oslib_test_007_002_execute+0xc0>)
 800959a:	0940      	lsrs	r0, r0, #5
 800959c:	f7fa fec0 	bl	8004320 <__test_assert>
 80095a0:	bb60      	cbnz	r0, 80095fc <oslib_test_007_002_execute+0xac>
  test_set_step(4);
 80095a2:	4c18      	ldr	r4, [pc, #96]	; (8009604 <oslib_test_007_002_execute+0xb4>)
      chGuardedPoolFree(&gmp1, &objects[i]);
 80095a4:	4f18      	ldr	r7, [pc, #96]	; (8009608 <oslib_test_007_002_execute+0xb8>)
  test_set_step(4);
 80095a6:	2304      	movs	r3, #4
 80095a8:	602b      	str	r3, [r5, #0]
    for (i = 0; i < MEMORY_POOL_SIZE; i++)
 80095aa:	f104 0610 	add.w	r6, r4, #16
      chGuardedPoolFree(&gmp1, &objects[i]);
 80095ae:	4621      	mov	r1, r4
 80095b0:	4638      	mov	r0, r7
    for (i = 0; i < MEMORY_POOL_SIZE; i++)
 80095b2:	3404      	adds	r4, #4
      chGuardedPoolFree(&gmp1, &objects[i]);
 80095b4:	f7f9 fed4 	bl	8003360 <chGuardedPoolFree>
    for (i = 0; i < MEMORY_POOL_SIZE; i++)
 80095b8:	42b4      	cmp	r4, r6
 80095ba:	d1f8      	bne.n	80095ae <oslib_test_007_002_execute+0x5e>
  test_set_step(5);
 80095bc:	2305      	movs	r3, #5
      test_assert(chGuardedPoolAllocTimeout(&gmp1, TIME_IMMEDIATE) != NULL, "list empty");
 80095be:	4f12      	ldr	r7, [pc, #72]	; (8009608 <oslib_test_007_002_execute+0xb8>)
 80095c0:	4e12      	ldr	r6, [pc, #72]	; (800960c <oslib_test_007_002_execute+0xbc>)
  test_set_step(5);
 80095c2:	602b      	str	r3, [r5, #0]
 80095c4:	2404      	movs	r4, #4
      test_assert(chGuardedPoolAllocTimeout(&gmp1, TIME_IMMEDIATE) != NULL, "list empty");
 80095c6:	2100      	movs	r1, #0
 80095c8:	4638      	mov	r0, r7
 80095ca:	f7f9 fea9 	bl	8003320 <chGuardedPoolAllocTimeout>
 80095ce:	3800      	subs	r0, #0
 80095d0:	bf18      	it	ne
 80095d2:	2001      	movne	r0, #1
 80095d4:	4631      	mov	r1, r6
 80095d6:	f7fa fea3 	bl	8004320 <__test_assert>
 80095da:	b978      	cbnz	r0, 80095fc <oslib_test_007_002_execute+0xac>
    for (i = 0; i < MEMORY_POOL_SIZE; i++)
 80095dc:	3c01      	subs	r4, #1
 80095de:	d1f2      	bne.n	80095c6 <oslib_test_007_002_execute+0x76>
    test_assert(chGuardedPoolAllocTimeout(&gmp1, TIME_IMMEDIATE) == NULL, "list not empty");
 80095e0:	4621      	mov	r1, r4
  test_set_step(6);
 80095e2:	2306      	movs	r3, #6
    test_assert(chGuardedPoolAllocTimeout(&gmp1, TIME_IMMEDIATE) == NULL, "list not empty");
 80095e4:	4808      	ldr	r0, [pc, #32]	; (8009608 <oslib_test_007_002_execute+0xb8>)
  test_set_step(6);
 80095e6:	602b      	str	r3, [r5, #0]
    test_assert(chGuardedPoolAllocTimeout(&gmp1, TIME_IMMEDIATE) == NULL, "list not empty");
 80095e8:	f7f9 fe9a 	bl	8003320 <chGuardedPoolAllocTimeout>
 80095ec:	fab0 f080 	clz	r0, r0
}
 80095f0:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
    test_assert(chGuardedPoolAllocTimeout(&gmp1, TIME_IMMEDIATE) == NULL, "list not empty");
 80095f4:	4906      	ldr	r1, [pc, #24]	; (8009610 <oslib_test_007_002_execute+0xc0>)
 80095f6:	0940      	lsrs	r0, r0, #5
 80095f8:	f7fa be92 	b.w	8004320 <__test_assert>
}
 80095fc:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 80095fe:	bf00      	nop
 8009600:	20000c70 	.word	0x20000c70
 8009604:	20001c44 	.word	0x20001c44
 8009608:	200008a8 	.word	0x200008a8
 800960c:	0800cae8 	.word	0x0800cae8
 8009610:	0800cad8 	.word	0x0800cad8
	...

08009620 <oslib_test_007_001_execute>:
static void oslib_test_007_001_execute(void) {
 8009620:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  test_set_step(1);
 8009622:	4d32      	ldr	r5, [pc, #200]	; (80096ec <oslib_test_007_001_execute+0xcc>)
    chPoolLoadArray(&mp1, objects, MEMORY_POOL_SIZE);
 8009624:	4932      	ldr	r1, [pc, #200]	; (80096f0 <oslib_test_007_001_execute+0xd0>)
 8009626:	4833      	ldr	r0, [pc, #204]	; (80096f4 <oslib_test_007_001_execute+0xd4>)
      test_assert(chPoolAlloc(&mp1) != NULL, "list empty");
 8009628:	4f32      	ldr	r7, [pc, #200]	; (80096f4 <oslib_test_007_001_execute+0xd4>)
 800962a:	4e33      	ldr	r6, [pc, #204]	; (80096f8 <oslib_test_007_001_execute+0xd8>)
  test_set_step(1);
 800962c:	2301      	movs	r3, #1
    chPoolLoadArray(&mp1, objects, MEMORY_POOL_SIZE);
 800962e:	2204      	movs	r2, #4
  test_set_step(1);
 8009630:	602b      	str	r3, [r5, #0]
    chPoolLoadArray(&mp1, objects, MEMORY_POOL_SIZE);
 8009632:	f7f9 fe05 	bl	8003240 <chPoolLoadArray>
  test_set_step(2);
 8009636:	2302      	movs	r3, #2
 8009638:	602b      	str	r3, [r5, #0]
 800963a:	2404      	movs	r4, #4
      test_assert(chPoolAlloc(&mp1) != NULL, "list empty");
 800963c:	4638      	mov	r0, r7
 800963e:	f7f9 fe17 	bl	8003270 <chPoolAlloc>
 8009642:	3800      	subs	r0, #0
 8009644:	bf18      	it	ne
 8009646:	2001      	movne	r0, #1
 8009648:	4631      	mov	r1, r6
 800964a:	f7fa fe69 	bl	8004320 <__test_assert>
 800964e:	2800      	cmp	r0, #0
 8009650:	d14b      	bne.n	80096ea <oslib_test_007_001_execute+0xca>
    for (i = 0; i < MEMORY_POOL_SIZE; i++)
 8009652:	3c01      	subs	r4, #1
 8009654:	d1f2      	bne.n	800963c <oslib_test_007_001_execute+0x1c>
  test_set_step(3);
 8009656:	2303      	movs	r3, #3
    test_assert(chPoolAlloc(&mp1) == NULL, "list not empty");
 8009658:	4826      	ldr	r0, [pc, #152]	; (80096f4 <oslib_test_007_001_execute+0xd4>)
  test_set_step(3);
 800965a:	602b      	str	r3, [r5, #0]
    test_assert(chPoolAlloc(&mp1) == NULL, "list not empty");
 800965c:	f7f9 fe08 	bl	8003270 <chPoolAlloc>
 8009660:	fab0 f080 	clz	r0, r0
 8009664:	4925      	ldr	r1, [pc, #148]	; (80096fc <oslib_test_007_001_execute+0xdc>)
 8009666:	0940      	lsrs	r0, r0, #5
 8009668:	f7fa fe5a 	bl	8004320 <__test_assert>
 800966c:	2800      	cmp	r0, #0
 800966e:	d13c      	bne.n	80096ea <oslib_test_007_001_execute+0xca>
  test_set_step(4);
 8009670:	4c1f      	ldr	r4, [pc, #124]	; (80096f0 <oslib_test_007_001_execute+0xd0>)
      chPoolFree(&mp1, &objects[i]);
 8009672:	4f20      	ldr	r7, [pc, #128]	; (80096f4 <oslib_test_007_001_execute+0xd4>)
  test_set_step(4);
 8009674:	2304      	movs	r3, #4
 8009676:	602b      	str	r3, [r5, #0]
    for (i = 0; i < MEMORY_POOL_SIZE; i++)
 8009678:	f104 0610 	add.w	r6, r4, #16
      chPoolFree(&mp1, &objects[i]);
 800967c:	4621      	mov	r1, r4
 800967e:	4638      	mov	r0, r7
    for (i = 0; i < MEMORY_POOL_SIZE; i++)
 8009680:	3404      	adds	r4, #4
      chPoolFree(&mp1, &objects[i]);
 8009682:	f7f9 fe0d 	bl	80032a0 <chPoolFree>
    for (i = 0; i < MEMORY_POOL_SIZE; i++)
 8009686:	42b4      	cmp	r4, r6
 8009688:	d1f8      	bne.n	800967c <oslib_test_007_001_execute+0x5c>
  test_set_step(5);
 800968a:	2305      	movs	r3, #5
      test_assert(chPoolAlloc(&mp1) != NULL, "list empty");
 800968c:	4f19      	ldr	r7, [pc, #100]	; (80096f4 <oslib_test_007_001_execute+0xd4>)
 800968e:	4e1a      	ldr	r6, [pc, #104]	; (80096f8 <oslib_test_007_001_execute+0xd8>)
  test_set_step(5);
 8009690:	602b      	str	r3, [r5, #0]
 8009692:	2404      	movs	r4, #4
      test_assert(chPoolAlloc(&mp1) != NULL, "list empty");
 8009694:	4638      	mov	r0, r7
 8009696:	f7f9 fdeb 	bl	8003270 <chPoolAlloc>
 800969a:	3800      	subs	r0, #0
 800969c:	bf18      	it	ne
 800969e:	2001      	movne	r0, #1
 80096a0:	4631      	mov	r1, r6
 80096a2:	f7fa fe3d 	bl	8004320 <__test_assert>
 80096a6:	bb00      	cbnz	r0, 80096ea <oslib_test_007_001_execute+0xca>
    for (i = 0; i < MEMORY_POOL_SIZE; i++)
 80096a8:	3c01      	subs	r4, #1
 80096aa:	d1f3      	bne.n	8009694 <oslib_test_007_001_execute+0x74>
  test_set_step(6);
 80096ac:	2306      	movs	r3, #6
    test_assert(chPoolAlloc(&mp1) == NULL, "list not empty");
 80096ae:	4811      	ldr	r0, [pc, #68]	; (80096f4 <oslib_test_007_001_execute+0xd4>)
  test_set_step(6);
 80096b0:	602b      	str	r3, [r5, #0]
    test_assert(chPoolAlloc(&mp1) == NULL, "list not empty");
 80096b2:	f7f9 fddd 	bl	8003270 <chPoolAlloc>
 80096b6:	fab0 f080 	clz	r0, r0
 80096ba:	4910      	ldr	r1, [pc, #64]	; (80096fc <oslib_test_007_001_execute+0xdc>)
 80096bc:	0940      	lsrs	r0, r0, #5
 80096be:	f7fa fe2f 	bl	8004320 <__test_assert>
 80096c2:	b990      	cbnz	r0, 80096ea <oslib_test_007_001_execute+0xca>
  chPoolObjectInitAligned(mp, size, PORT_NATURAL_ALIGN, provider);
 80096c4:	2204      	movs	r2, #4
 80096c6:	4b0e      	ldr	r3, [pc, #56]	; (8009700 <oslib_test_007_001_execute+0xe0>)
 80096c8:	480a      	ldr	r0, [pc, #40]	; (80096f4 <oslib_test_007_001_execute+0xd4>)
 80096ca:	4611      	mov	r1, r2
  test_set_step(7);
 80096cc:	2407      	movs	r4, #7
 80096ce:	602c      	str	r4, [r5, #0]
 80096d0:	f7f9 fdae 	bl	8003230 <chPoolObjectInitAligned>
    test_assert(chPoolAlloc(&mp1) == NULL, "provider returned memory");
 80096d4:	4807      	ldr	r0, [pc, #28]	; (80096f4 <oslib_test_007_001_execute+0xd4>)
 80096d6:	f7f9 fdcb 	bl	8003270 <chPoolAlloc>
 80096da:	fab0 f080 	clz	r0, r0
}
 80096de:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
    test_assert(chPoolAlloc(&mp1) == NULL, "provider returned memory");
 80096e2:	4908      	ldr	r1, [pc, #32]	; (8009704 <oslib_test_007_001_execute+0xe4>)
 80096e4:	0940      	lsrs	r0, r0, #5
 80096e6:	f7fa be1b 	b.w	8004320 <__test_assert>
}
 80096ea:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 80096ec:	20000c70 	.word	0x20000c70
 80096f0:	20001c44 	.word	0x20001c44
 80096f4:	200008c4 	.word	0x200008c4
 80096f8:	0800cae8 	.word	0x0800cae8
 80096fc:	0800cad8 	.word	0x0800cad8
 8009700:	08009501 	.word	0x08009501
 8009704:	0800caf4 	.word	0x0800caf4
	...

08009710 <oslib_test_007_001_setup>:
 8009710:	2204      	movs	r2, #4
 8009712:	4802      	ldr	r0, [pc, #8]	; (800971c <oslib_test_007_001_setup+0xc>)
 8009714:	2300      	movs	r3, #0
 8009716:	4611      	mov	r1, r2
 8009718:	f7f9 bd8a 	b.w	8003230 <chPoolObjectInitAligned>
 800971c:	200008c4 	.word	0x200008c4

08009720 <oslib_test_007_003_setup>:
 8009720:	2204      	movs	r2, #4
 8009722:	4802      	ldr	r0, [pc, #8]	; (800972c <oslib_test_007_003_setup+0xc>)
 8009724:	4611      	mov	r1, r2
 8009726:	f7f9 bdcb 	b.w	80032c0 <chGuardedPoolObjectInitAligned>
 800972a:	bf00      	nop
 800972c:	200008a8 	.word	0x200008a8

08009730 <oslib_test_008_002_execute>:
 *   is freed using chHeapFree(), must not fail.
 * - [8.2.2] Testing allocation failure.
 * .
 */

static void oslib_test_008_002_execute(void) {
 8009730:	b570      	push	{r4, r5, r6, lr}
  void *p1;
  size_t total_size, largest_size;

  /* [8.2.1] Single block allocation using chHeapAlloc() then the block
     is freed using chHeapFree(), must not fail.*/
  test_set_step(1);
 8009732:	4e16      	ldr	r6, [pc, #88]	; (800978c <oslib_test_008_002_execute+0x5c>)
static void oslib_test_008_002_execute(void) {
 8009734:	b082      	sub	sp, #8
  test_set_step(1);
 8009736:	2301      	movs	r3, #1
  {
    (void)chHeapStatus(NULL, &total_size, &largest_size);
 8009738:	aa01      	add	r2, sp, #4
 800973a:	4669      	mov	r1, sp
 800973c:	2000      	movs	r0, #0
  test_set_step(1);
 800973e:	6033      	str	r3, [r6, #0]
    (void)chHeapStatus(NULL, &total_size, &largest_size);
 8009740:	f7f9 fd3e 	bl	80031c0 <chHeapStatus>
 *
 * @api
 */
static inline void *chHeapAlloc(memory_heap_t *heapp, size_t size) {

  return chHeapAllocAligned(heapp, size, CH_HEAP_ALIGNMENT);
 8009744:	2110      	movs	r1, #16
 8009746:	4812      	ldr	r0, [pc, #72]	; (8009790 <oslib_test_008_002_execute+0x60>)
 8009748:	2208      	movs	r2, #8
 800974a:	f7f9 fc61 	bl	8003010 <chHeapAllocAligned>
 800974e:	4605      	mov	r5, r0
    p1 = chHeapAlloc(&test_heap, ALLOC_SIZE);
    test_assert(p1 != NULL, "allocation failed");
 8009750:	3800      	subs	r0, #0
 8009752:	bf18      	it	ne
 8009754:	2001      	movne	r0, #1
 8009756:	490f      	ldr	r1, [pc, #60]	; (8009794 <oslib_test_008_002_execute+0x64>)
 8009758:	f7fa fde2 	bl	8004320 <__test_assert>
 800975c:	b108      	cbz	r0, 8009762 <oslib_test_008_002_execute+0x32>
  {
    p1 = chHeapAlloc(NULL, (size_t)-256);
    test_assert(p1 == NULL, "allocation not failed");
  }
  test_end_step(2);
}
 800975e:	b002      	add	sp, #8
 8009760:	bd70      	pop	{r4, r5, r6, pc}
    chHeapFree(p1);
 8009762:	4604      	mov	r4, r0
 8009764:	4628      	mov	r0, r5
 8009766:	f7f9 fcdb 	bl	8003120 <chHeapFree>
  test_set_step(2);
 800976a:	2302      	movs	r3, #2
 800976c:	2208      	movs	r2, #8
 800976e:	f06f 01ff 	mvn.w	r1, #255	; 0xff
 8009772:	4620      	mov	r0, r4
 8009774:	6033      	str	r3, [r6, #0]
 8009776:	f7f9 fc4b 	bl	8003010 <chHeapAllocAligned>
    test_assert(p1 == NULL, "allocation not failed");
 800977a:	fab0 f080 	clz	r0, r0
 800977e:	4906      	ldr	r1, [pc, #24]	; (8009798 <oslib_test_008_002_execute+0x68>)
 8009780:	0940      	lsrs	r0, r0, #5
 8009782:	f7fa fdcd 	bl	8004320 <__test_assert>
}
 8009786:	b002      	add	sp, #8
 8009788:	bd70      	pop	{r4, r5, r6, pc}
 800978a:	bf00      	nop
 800978c:	20000c70 	.word	0x20000c70
 8009790:	20001c54 	.word	0x20001c54
 8009794:	0800cbe8 	.word	0x0800cbe8
 8009798:	0800cbfc 	.word	0x0800cbfc
 800979c:	00000000 	.word	0x00000000

080097a0 <oslib_test_008_001_execute>:
static void oslib_test_008_001_execute(void) {
 80097a0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  test_set_step(1);
 80097a4:	4cc9      	ldr	r4, [pc, #804]	; (8009acc <oslib_test_008_001_execute+0x32c>)
    test_assert(chHeapStatus(&test_heap, &sz, NULL) == 1, "heap fragmented");
 80097a6:	48ca      	ldr	r0, [pc, #808]	; (8009ad0 <oslib_test_008_001_execute+0x330>)
static void oslib_test_008_001_execute(void) {
 80097a8:	b084      	sub	sp, #16
    test_assert(chHeapStatus(&test_heap, &sz, NULL) == 1, "heap fragmented");
 80097aa:	a901      	add	r1, sp, #4
  test_set_step(1);
 80097ac:	2301      	movs	r3, #1
    test_assert(chHeapStatus(&test_heap, &sz, NULL) == 1, "heap fragmented");
 80097ae:	2200      	movs	r2, #0
  test_set_step(1);
 80097b0:	6023      	str	r3, [r4, #0]
    test_assert(chHeapStatus(&test_heap, &sz, NULL) == 1, "heap fragmented");
 80097b2:	f7f9 fd05 	bl	80031c0 <chHeapStatus>
 80097b6:	f1a0 0001 	sub.w	r0, r0, #1
 80097ba:	fab0 f080 	clz	r0, r0
 80097be:	49c5      	ldr	r1, [pc, #788]	; (8009ad4 <oslib_test_008_001_execute+0x334>)
 80097c0:	0940      	lsrs	r0, r0, #5
 80097c2:	f7fa fdad 	bl	8004320 <__test_assert>
 80097c6:	b110      	cbz	r0, 80097ce <oslib_test_008_001_execute+0x2e>
}
 80097c8:	b004      	add	sp, #16
 80097ca:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 80097ce:	f44f 7180 	mov.w	r1, #256	; 0x100
  test_set_step(2);
 80097d2:	2302      	movs	r3, #2
 80097d4:	48be      	ldr	r0, [pc, #760]	; (8009ad0 <oslib_test_008_001_execute+0x330>)
 80097d6:	6023      	str	r3, [r4, #0]
 80097d8:	2208      	movs	r2, #8
 80097da:	f7f9 fc19 	bl	8003010 <chHeapAllocAligned>
    test_assert(p1 == NULL, "allocation not failed");
 80097de:	fab0 f080 	clz	r0, r0
 80097e2:	49bd      	ldr	r1, [pc, #756]	; (8009ad8 <oslib_test_008_001_execute+0x338>)
 80097e4:	0940      	lsrs	r0, r0, #5
 80097e6:	f7fa fd9b 	bl	8004320 <__test_assert>
 80097ea:	2800      	cmp	r0, #0
 80097ec:	d1ec      	bne.n	80097c8 <oslib_test_008_001_execute+0x28>
 80097ee:	2110      	movs	r1, #16
  test_set_step(3);
 80097f0:	2303      	movs	r3, #3
 80097f2:	48b7      	ldr	r0, [pc, #732]	; (8009ad0 <oslib_test_008_001_execute+0x330>)
 80097f4:	6023      	str	r3, [r4, #0]
 80097f6:	2208      	movs	r2, #8
 80097f8:	f7f9 fc0a 	bl	8003010 <chHeapAllocAligned>
 80097fc:	4605      	mov	r5, r0
    test_assert(p1 != NULL, "allocation failed");
 80097fe:	3800      	subs	r0, #0
 8009800:	bf18      	it	ne
 8009802:	2001      	movne	r0, #1
 8009804:	49b5      	ldr	r1, [pc, #724]	; (8009adc <oslib_test_008_001_execute+0x33c>)
 8009806:	f7fa fd8b 	bl	8004320 <__test_assert>
 800980a:	2800      	cmp	r0, #0
 800980c:	d1dc      	bne.n	80097c8 <oslib_test_008_001_execute+0x28>
    chHeapFree(p1);
 800980e:	4628      	mov	r0, r5
 8009810:	f7f9 fc86 	bl	8003120 <chHeapFree>
  test_set_step(4);
 8009814:	2304      	movs	r3, #4
    n = chHeapStatus(&test_heap, &total_size, &largest_size);
 8009816:	a902      	add	r1, sp, #8
 8009818:	48ad      	ldr	r0, [pc, #692]	; (8009ad0 <oslib_test_008_001_execute+0x330>)
  test_set_step(4);
 800981a:	6023      	str	r3, [r4, #0]
    n = chHeapStatus(&test_heap, &total_size, &largest_size);
 800981c:	aa03      	add	r2, sp, #12
 800981e:	f7f9 fccf 	bl	80031c0 <chHeapStatus>
 8009822:	4603      	mov	r3, r0
    test_assert(n == 1, "missing free block");
 8009824:	f1a0 0001 	sub.w	r0, r0, #1
 8009828:	fab0 f080 	clz	r0, r0
 800982c:	49ac      	ldr	r1, [pc, #688]	; (8009ae0 <oslib_test_008_001_execute+0x340>)
    n = chHeapStatus(&test_heap, &total_size, &largest_size);
 800982e:	9300      	str	r3, [sp, #0]
    test_assert(n == 1, "missing free block");
 8009830:	0940      	lsrs	r0, r0, #5
 8009832:	f7fa fd75 	bl	8004320 <__test_assert>
 8009836:	2800      	cmp	r0, #0
 8009838:	d1c6      	bne.n	80097c8 <oslib_test_008_001_execute+0x28>
    test_assert(total_size >= ALLOC_SIZE, "unexpected heap state");
 800983a:	9802      	ldr	r0, [sp, #8]
 800983c:	49a9      	ldr	r1, [pc, #676]	; (8009ae4 <oslib_test_008_001_execute+0x344>)
 800983e:	280f      	cmp	r0, #15
 8009840:	bf94      	ite	ls
 8009842:	2000      	movls	r0, #0
 8009844:	2001      	movhi	r0, #1
 8009846:	f7fa fd6b 	bl	8004320 <__test_assert>
 800984a:	2800      	cmp	r0, #0
 800984c:	d1bc      	bne.n	80097c8 <oslib_test_008_001_execute+0x28>
    test_assert(total_size == largest_size, "unexpected heap state");
 800984e:	e9dd 0302 	ldrd	r0, r3, [sp, #8]
 8009852:	1ac0      	subs	r0, r0, r3
 8009854:	fab0 f080 	clz	r0, r0
 8009858:	49a2      	ldr	r1, [pc, #648]	; (8009ae4 <oslib_test_008_001_execute+0x344>)
 800985a:	0940      	lsrs	r0, r0, #5
 800985c:	f7fa fd60 	bl	8004320 <__test_assert>
 8009860:	4605      	mov	r5, r0
 8009862:	2800      	cmp	r0, #0
 8009864:	d1b0      	bne.n	80097c8 <oslib_test_008_001_execute+0x28>
  test_set_step(5);
 8009866:	2305      	movs	r3, #5
 8009868:	2208      	movs	r2, #8
 800986a:	2110      	movs	r1, #16
 800986c:	4898      	ldr	r0, [pc, #608]	; (8009ad0 <oslib_test_008_001_execute+0x330>)
 800986e:	6023      	str	r3, [r4, #0]
 8009870:	f7f9 fbce 	bl	8003010 <chHeapAllocAligned>
 8009874:	2208      	movs	r2, #8
 8009876:	2110      	movs	r1, #16
 8009878:	4680      	mov	r8, r0
 800987a:	4895      	ldr	r0, [pc, #596]	; (8009ad0 <oslib_test_008_001_execute+0x330>)
 800987c:	f7f9 fbc8 	bl	8003010 <chHeapAllocAligned>
 8009880:	2208      	movs	r2, #8
 8009882:	2110      	movs	r1, #16
 8009884:	4607      	mov	r7, r0
 8009886:	4892      	ldr	r0, [pc, #584]	; (8009ad0 <oslib_test_008_001_execute+0x330>)
 8009888:	f7f9 fbc2 	bl	8003010 <chHeapAllocAligned>
 800988c:	4606      	mov	r6, r0
    chHeapFree(p1);                                 /* Does not merge.*/
 800988e:	4640      	mov	r0, r8
 8009890:	f7f9 fc46 	bl	8003120 <chHeapFree>
    chHeapFree(p2);                                 /* Merges backward.*/
 8009894:	4638      	mov	r0, r7
 8009896:	f7f9 fc43 	bl	8003120 <chHeapFree>
    chHeapFree(p3);                                 /* Merges both sides.*/
 800989a:	4630      	mov	r0, r6
 800989c:	f7f9 fc40 	bl	8003120 <chHeapFree>
    test_assert(chHeapStatus(&test_heap, &n, NULL) == 1, "heap fragmented");
 80098a0:	462a      	mov	r2, r5
 80098a2:	4669      	mov	r1, sp
 80098a4:	488a      	ldr	r0, [pc, #552]	; (8009ad0 <oslib_test_008_001_execute+0x330>)
 80098a6:	f7f9 fc8b 	bl	80031c0 <chHeapStatus>
 80098aa:	f1a0 0001 	sub.w	r0, r0, #1
 80098ae:	fab0 f080 	clz	r0, r0
 80098b2:	4988      	ldr	r1, [pc, #544]	; (8009ad4 <oslib_test_008_001_execute+0x334>)
 80098b4:	0940      	lsrs	r0, r0, #5
 80098b6:	f7fa fd33 	bl	8004320 <__test_assert>
 80098ba:	4605      	mov	r5, r0
 80098bc:	2800      	cmp	r0, #0
 80098be:	d183      	bne.n	80097c8 <oslib_test_008_001_execute+0x28>
  test_set_step(6);
 80098c0:	2306      	movs	r3, #6
 80098c2:	2208      	movs	r2, #8
 80098c4:	2110      	movs	r1, #16
 80098c6:	4882      	ldr	r0, [pc, #520]	; (8009ad0 <oslib_test_008_001_execute+0x330>)
 80098c8:	6023      	str	r3, [r4, #0]
 80098ca:	f7f9 fba1 	bl	8003010 <chHeapAllocAligned>
 80098ce:	2208      	movs	r2, #8
 80098d0:	4606      	mov	r6, r0
 80098d2:	2110      	movs	r1, #16
 80098d4:	487e      	ldr	r0, [pc, #504]	; (8009ad0 <oslib_test_008_001_execute+0x330>)
 80098d6:	f7f9 fb9b 	bl	8003010 <chHeapAllocAligned>
 80098da:	2208      	movs	r2, #8
 80098dc:	2110      	movs	r1, #16
 80098de:	4607      	mov	r7, r0
 80098e0:	487b      	ldr	r0, [pc, #492]	; (8009ad0 <oslib_test_008_001_execute+0x330>)
 80098e2:	f7f9 fb95 	bl	8003010 <chHeapAllocAligned>
    chHeapFree(p3);                                 /* Merges forward.*/
 80098e6:	f7f9 fc1b 	bl	8003120 <chHeapFree>
    chHeapFree(p2);                                 /* Merges forward.*/
 80098ea:	4638      	mov	r0, r7
 80098ec:	f7f9 fc18 	bl	8003120 <chHeapFree>
    chHeapFree(p1);                                 /* Merges forward.*/
 80098f0:	4630      	mov	r0, r6
 80098f2:	f7f9 fc15 	bl	8003120 <chHeapFree>
    test_assert(chHeapStatus(&test_heap, &n, NULL) == 1, "heap fragmented");
 80098f6:	462a      	mov	r2, r5
 80098f8:	4669      	mov	r1, sp
 80098fa:	4875      	ldr	r0, [pc, #468]	; (8009ad0 <oslib_test_008_001_execute+0x330>)
 80098fc:	f7f9 fc60 	bl	80031c0 <chHeapStatus>
 8009900:	f1a0 0001 	sub.w	r0, r0, #1
 8009904:	fab0 f080 	clz	r0, r0
 8009908:	4972      	ldr	r1, [pc, #456]	; (8009ad4 <oslib_test_008_001_execute+0x334>)
 800990a:	0940      	lsrs	r0, r0, #5
 800990c:	f7fa fd08 	bl	8004320 <__test_assert>
 8009910:	4605      	mov	r5, r0
 8009912:	2800      	cmp	r0, #0
 8009914:	f47f af58 	bne.w	80097c8 <oslib_test_008_001_execute+0x28>
  test_set_step(7);
 8009918:	2307      	movs	r3, #7
 800991a:	2208      	movs	r2, #8
 800991c:	2111      	movs	r1, #17
 800991e:	486c      	ldr	r0, [pc, #432]	; (8009ad0 <oslib_test_008_001_execute+0x330>)
 8009920:	6023      	str	r3, [r4, #0]
 8009922:	f7f9 fb75 	bl	8003010 <chHeapAllocAligned>
 8009926:	2208      	movs	r2, #8
 8009928:	4606      	mov	r6, r0
 800992a:	2110      	movs	r1, #16
 800992c:	4868      	ldr	r0, [pc, #416]	; (8009ad0 <oslib_test_008_001_execute+0x330>)
 800992e:	f7f9 fb6f 	bl	8003010 <chHeapAllocAligned>
 8009932:	4603      	mov	r3, r0
    chHeapFree(p1);
 8009934:	4630      	mov	r0, r6
 8009936:	461e      	mov	r6, r3
 8009938:	f7f9 fbf2 	bl	8003120 <chHeapFree>
    test_assert(chHeapStatus(&test_heap, &n, NULL) == 2, "invalid state");
 800993c:	462a      	mov	r2, r5
 800993e:	4669      	mov	r1, sp
 8009940:	4863      	ldr	r0, [pc, #396]	; (8009ad0 <oslib_test_008_001_execute+0x330>)
 8009942:	f7f9 fc3d 	bl	80031c0 <chHeapStatus>
 8009946:	f1a0 0002 	sub.w	r0, r0, #2
 800994a:	fab0 f080 	clz	r0, r0
 800994e:	4966      	ldr	r1, [pc, #408]	; (8009ae8 <oslib_test_008_001_execute+0x348>)
 8009950:	0940      	lsrs	r0, r0, #5
 8009952:	f7fa fce5 	bl	8004320 <__test_assert>
 8009956:	4605      	mov	r5, r0
 8009958:	2800      	cmp	r0, #0
 800995a:	f47f af35 	bne.w	80097c8 <oslib_test_008_001_execute+0x28>
 800995e:	2208      	movs	r2, #8
 8009960:	2110      	movs	r1, #16
 8009962:	485b      	ldr	r0, [pc, #364]	; (8009ad0 <oslib_test_008_001_execute+0x330>)
 8009964:	f7f9 fb54 	bl	8003010 <chHeapAllocAligned>
    test_assert((chHeapStatus(&test_heap, &n, NULL) == 1) ||
 8009968:	462a      	mov	r2, r5
 800996a:	4607      	mov	r7, r0
 800996c:	4669      	mov	r1, sp
 800996e:	4858      	ldr	r0, [pc, #352]	; (8009ad0 <oslib_test_008_001_execute+0x330>)
 8009970:	f7f9 fc26 	bl	80031c0 <chHeapStatus>
 8009974:	2801      	cmp	r0, #1
 8009976:	f000 80a6 	beq.w	8009ac6 <oslib_test_008_001_execute+0x326>
 800997a:	4855      	ldr	r0, [pc, #340]	; (8009ad0 <oslib_test_008_001_execute+0x330>)
 800997c:	2200      	movs	r2, #0
 800997e:	4669      	mov	r1, sp
 8009980:	f7f9 fc1e 	bl	80031c0 <chHeapStatus>
 8009984:	f1a0 0802 	sub.w	r8, r0, #2
 8009988:	f1d8 0000 	rsbs	r0, r8, #0
 800998c:	eb40 0008 	adc.w	r0, r0, r8
 8009990:	4950      	ldr	r1, [pc, #320]	; (8009ad4 <oslib_test_008_001_execute+0x334>)
 8009992:	f7fa fcc5 	bl	8004320 <__test_assert>
 8009996:	4605      	mov	r5, r0
 8009998:	2800      	cmp	r0, #0
 800999a:	f47f af15 	bne.w	80097c8 <oslib_test_008_001_execute+0x28>
    chHeapFree(p2);
 800999e:	4630      	mov	r0, r6
 80099a0:	f7f9 fbbe 	bl	8003120 <chHeapFree>
    chHeapFree(p1);
 80099a4:	4638      	mov	r0, r7
 80099a6:	f7f9 fbbb 	bl	8003120 <chHeapFree>
    test_assert(chHeapStatus(&test_heap, &n, NULL) == 1, "heap fragmented");
 80099aa:	462a      	mov	r2, r5
 80099ac:	4669      	mov	r1, sp
 80099ae:	4848      	ldr	r0, [pc, #288]	; (8009ad0 <oslib_test_008_001_execute+0x330>)
 80099b0:	f7f9 fc06 	bl	80031c0 <chHeapStatus>
 80099b4:	f100 3eff 	add.w	lr, r0, #4294967295	; 0xffffffff
 80099b8:	f1de 0000 	rsbs	r0, lr, #0
 80099bc:	4945      	ldr	r1, [pc, #276]	; (8009ad4 <oslib_test_008_001_execute+0x334>)
 80099be:	eb40 000e 	adc.w	r0, r0, lr
 80099c2:	f7fa fcad 	bl	8004320 <__test_assert>
 80099c6:	4606      	mov	r6, r0
 80099c8:	2800      	cmp	r0, #0
 80099ca:	f47f aefd 	bne.w	80097c8 <oslib_test_008_001_execute+0x28>
  test_set_step(8);
 80099ce:	2508      	movs	r5, #8
 80099d0:	462a      	mov	r2, r5
 80099d2:	2110      	movs	r1, #16
 80099d4:	483e      	ldr	r0, [pc, #248]	; (8009ad0 <oslib_test_008_001_execute+0x330>)
 80099d6:	6025      	str	r5, [r4, #0]
 80099d8:	f7f9 fb1a 	bl	8003010 <chHeapAllocAligned>
 80099dc:	462a      	mov	r2, r5
 80099de:	2110      	movs	r1, #16
 80099e0:	4680      	mov	r8, r0
 80099e2:	483b      	ldr	r0, [pc, #236]	; (8009ad0 <oslib_test_008_001_execute+0x330>)
 80099e4:	f7f9 fb14 	bl	8003010 <chHeapAllocAligned>
 80099e8:	4607      	mov	r7, r0
    chHeapFree(p1);
 80099ea:	4640      	mov	r0, r8
 80099ec:	f7f9 fb98 	bl	8003120 <chHeapFree>
    test_assert( chHeapStatus(&test_heap, &n, NULL) == 2, "invalid state");
 80099f0:	4632      	mov	r2, r6
 80099f2:	4669      	mov	r1, sp
 80099f4:	4836      	ldr	r0, [pc, #216]	; (8009ad0 <oslib_test_008_001_execute+0x330>)
 80099f6:	f7f9 fbe3 	bl	80031c0 <chHeapStatus>
 80099fa:	f1a0 0c02 	sub.w	ip, r0, #2
 80099fe:	f1dc 0000 	rsbs	r0, ip, #0
 8009a02:	4939      	ldr	r1, [pc, #228]	; (8009ae8 <oslib_test_008_001_execute+0x348>)
 8009a04:	eb40 000c 	adc.w	r0, r0, ip
 8009a08:	f7fa fc8a 	bl	8004320 <__test_assert>
 8009a0c:	4606      	mov	r6, r0
 8009a0e:	2800      	cmp	r0, #0
 8009a10:	f47f aeda 	bne.w	80097c8 <oslib_test_008_001_execute+0x28>
 8009a14:	462a      	mov	r2, r5
 8009a16:	2120      	movs	r1, #32
 8009a18:	482d      	ldr	r0, [pc, #180]	; (8009ad0 <oslib_test_008_001_execute+0x330>)
 8009a1a:	f7f9 faf9 	bl	8003010 <chHeapAllocAligned>
    chHeapFree(p1);
 8009a1e:	f7f9 fb7f 	bl	8003120 <chHeapFree>
    chHeapFree(p2);
 8009a22:	4638      	mov	r0, r7
 8009a24:	f7f9 fb7c 	bl	8003120 <chHeapFree>
    test_assert(chHeapStatus(&test_heap, &n, NULL) == 1, "heap fragmented");
 8009a28:	4632      	mov	r2, r6
 8009a2a:	4669      	mov	r1, sp
 8009a2c:	4828      	ldr	r0, [pc, #160]	; (8009ad0 <oslib_test_008_001_execute+0x330>)
 8009a2e:	f7f9 fbc7 	bl	80031c0 <chHeapStatus>
 8009a32:	1e46      	subs	r6, r0, #1
 8009a34:	4270      	negs	r0, r6
 8009a36:	4927      	ldr	r1, [pc, #156]	; (8009ad4 <oslib_test_008_001_execute+0x334>)
 8009a38:	4170      	adcs	r0, r6
 8009a3a:	f7fa fc71 	bl	8004320 <__test_assert>
 8009a3e:	4602      	mov	r2, r0
 8009a40:	2800      	cmp	r0, #0
 8009a42:	f47f aec1 	bne.w	80097c8 <oslib_test_008_001_execute+0x28>
  test_set_step(9);
 8009a46:	2309      	movs	r3, #9
    (void)chHeapStatus(&test_heap, &n, NULL);
 8009a48:	4669      	mov	r1, sp
 8009a4a:	4821      	ldr	r0, [pc, #132]	; (8009ad0 <oslib_test_008_001_execute+0x330>)
  test_set_step(9);
 8009a4c:	6023      	str	r3, [r4, #0]
    (void)chHeapStatus(&test_heap, &n, NULL);
 8009a4e:	f7f9 fbb7 	bl	80031c0 <chHeapStatus>
 8009a52:	462a      	mov	r2, r5
 8009a54:	9900      	ldr	r1, [sp, #0]
 8009a56:	481e      	ldr	r0, [pc, #120]	; (8009ad0 <oslib_test_008_001_execute+0x330>)
 8009a58:	f7f9 fada 	bl	8003010 <chHeapAllocAligned>
 8009a5c:	4606      	mov	r6, r0
    test_assert(p1 != NULL, "allocation failed");
 8009a5e:	3800      	subs	r0, #0
 8009a60:	491e      	ldr	r1, [pc, #120]	; (8009adc <oslib_test_008_001_execute+0x33c>)
 8009a62:	bf18      	it	ne
 8009a64:	2001      	movne	r0, #1
 8009a66:	f7fa fc5b 	bl	8004320 <__test_assert>
 8009a6a:	4602      	mov	r2, r0
 8009a6c:	2800      	cmp	r0, #0
 8009a6e:	f47f aeab 	bne.w	80097c8 <oslib_test_008_001_execute+0x28>
    test_assert(chHeapStatus(&test_heap, NULL, NULL) == 0, "not empty");
 8009a72:	4601      	mov	r1, r0
 8009a74:	4816      	ldr	r0, [pc, #88]	; (8009ad0 <oslib_test_008_001_execute+0x330>)
 8009a76:	f7f9 fba3 	bl	80031c0 <chHeapStatus>
 8009a7a:	fab0 f080 	clz	r0, r0
 8009a7e:	491b      	ldr	r1, [pc, #108]	; (8009aec <oslib_test_008_001_execute+0x34c>)
 8009a80:	0940      	lsrs	r0, r0, #5
 8009a82:	f7fa fc4d 	bl	8004320 <__test_assert>
 8009a86:	4605      	mov	r5, r0
 8009a88:	2800      	cmp	r0, #0
 8009a8a:	f47f ae9d 	bne.w	80097c8 <oslib_test_008_001_execute+0x28>
    chHeapFree(p1);
 8009a8e:	4630      	mov	r0, r6
 8009a90:	f7f9 fb46 	bl	8003120 <chHeapFree>
    test_assert(chHeapStatus(&test_heap, &n, NULL) == 1, "heap fragmented");
 8009a94:	462a      	mov	r2, r5
 8009a96:	4669      	mov	r1, sp
  test_set_step(10);
 8009a98:	230a      	movs	r3, #10
    test_assert(chHeapStatus(&test_heap, &n, NULL) == 1, "heap fragmented");
 8009a9a:	480d      	ldr	r0, [pc, #52]	; (8009ad0 <oslib_test_008_001_execute+0x330>)
  test_set_step(10);
 8009a9c:	6023      	str	r3, [r4, #0]
    test_assert(chHeapStatus(&test_heap, &n, NULL) == 1, "heap fragmented");
 8009a9e:	f7f9 fb8f 	bl	80031c0 <chHeapStatus>
 8009aa2:	1e42      	subs	r2, r0, #1
 8009aa4:	4250      	negs	r0, r2
 8009aa6:	4150      	adcs	r0, r2
 8009aa8:	490a      	ldr	r1, [pc, #40]	; (8009ad4 <oslib_test_008_001_execute+0x334>)
 8009aaa:	f7fa fc39 	bl	8004320 <__test_assert>
 8009aae:	2800      	cmp	r0, #0
 8009ab0:	f47f ae8a 	bne.w	80097c8 <oslib_test_008_001_execute+0x28>
    test_assert(n == sz, "size changed");
 8009ab4:	e9dd 0300 	ldrd	r0, r3, [sp]
 8009ab8:	1ac3      	subs	r3, r0, r3
 8009aba:	4258      	negs	r0, r3
 8009abc:	490c      	ldr	r1, [pc, #48]	; (8009af0 <oslib_test_008_001_execute+0x350>)
 8009abe:	4158      	adcs	r0, r3
 8009ac0:	f7fa fc2e 	bl	8004320 <__test_assert>
 8009ac4:	e680      	b.n	80097c8 <oslib_test_008_001_execute+0x28>
    test_assert((chHeapStatus(&test_heap, &n, NULL) == 1) ||
 8009ac6:	2001      	movs	r0, #1
 8009ac8:	e762      	b.n	8009990 <oslib_test_008_001_execute+0x1f0>
 8009aca:	bf00      	nop
 8009acc:	20000c70 	.word	0x20000c70
 8009ad0:	20001c54 	.word	0x20001c54
 8009ad4:	0800bf00 	.word	0x0800bf00
 8009ad8:	0800cbfc 	.word	0x0800cbfc
 8009adc:	0800cbe8 	.word	0x0800cbe8
 8009ae0:	0800cc14 	.word	0x0800cc14
 8009ae4:	0800cc28 	.word	0x0800cc28
 8009ae8:	0800cc40 	.word	0x0800cc40
 8009aec:	0800c734 	.word	0x0800c734
 8009af0:	0800cc50 	.word	0x0800cc50
	...

08009b00 <oslib_test_008_001_setup>:
  chHeapObjectInit(&test_heap, test_heap_buffer, sizeof(test_heap_buffer));
 8009b00:	4902      	ldr	r1, [pc, #8]	; (8009b0c <oslib_test_008_001_setup+0xc>)
 8009b02:	4803      	ldr	r0, [pc, #12]	; (8009b10 <oslib_test_008_001_setup+0x10>)
 8009b04:	2280      	movs	r2, #128	; 0x80
 8009b06:	f7f9 ba73 	b.w	8002ff0 <chHeapObjectInit>
 8009b0a:	bf00      	nop
 8009b0c:	20001c70 	.word	0x20001c70
 8009b10:	20001c54 	.word	0x20001c54
	...

08009b20 <oslib_test_009_006_teardown>:
 *   trigger an assertion.
 * - [9.6.6] Retrieving the dynamic pipe by name again, must not exist.
 * .
 */

static void oslib_test_009_006_teardown(void) {
 8009b20:	b510      	push	{r4, lr}
  dyn_pipe_t *dpp;

  dpp = chFactoryFindPipe("mypipe");
 8009b22:	4807      	ldr	r0, [pc, #28]	; (8009b40 <oslib_test_009_006_teardown+0x20>)
 8009b24:	f7fa fa0c 	bl	8003f40 <chFactoryFindPipe>
  if (dpp != NULL) {
 8009b28:	b140      	cbz	r0, 8009b3c <oslib_test_009_006_teardown+0x1c>
    while (dpp->element.refs > 0U) {
 8009b2a:	6843      	ldr	r3, [r0, #4]
 8009b2c:	4604      	mov	r4, r0
 8009b2e:	b12b      	cbz	r3, 8009b3c <oslib_test_009_006_teardown+0x1c>
      chFactoryReleasePipe(dpp);
 8009b30:	4620      	mov	r0, r4
 8009b32:	f7fa fa2d 	bl	8003f90 <chFactoryReleasePipe>
    while (dpp->element.refs > 0U) {
 8009b36:	6863      	ldr	r3, [r4, #4]
 8009b38:	2b00      	cmp	r3, #0
 8009b3a:	d1f9      	bne.n	8009b30 <oslib_test_009_006_teardown+0x10>
    }
  }
}
 8009b3c:	bd10      	pop	{r4, pc}
 8009b3e:	bf00      	nop
 8009b40:	0800ccd4 	.word	0x0800ccd4
	...

08009b50 <oslib_test_009_005_teardown>:
static void oslib_test_009_005_teardown(void) {
 8009b50:	b510      	push	{r4, lr}
  dofp = chFactoryFindObjectsFIFO("myfifo");
 8009b52:	4807      	ldr	r0, [pc, #28]	; (8009b70 <oslib_test_009_005_teardown+0x20>)
 8009b54:	f7fa f984 	bl	8003e60 <chFactoryFindObjectsFIFO>
  if (dofp != NULL) {
 8009b58:	b140      	cbz	r0, 8009b6c <oslib_test_009_005_teardown+0x1c>
    while (dofp->element.refs > 0U) {
 8009b5a:	6843      	ldr	r3, [r0, #4]
 8009b5c:	4604      	mov	r4, r0
 8009b5e:	b12b      	cbz	r3, 8009b6c <oslib_test_009_005_teardown+0x1c>
      chFactoryReleaseObjectsFIFO(dofp);
 8009b60:	4620      	mov	r0, r4
 8009b62:	f7fa f9a5 	bl	8003eb0 <chFactoryReleaseObjectsFIFO>
    while (dofp->element.refs > 0U) {
 8009b66:	6863      	ldr	r3, [r4, #4]
 8009b68:	2b00      	cmp	r3, #0
 8009b6a:	d1f9      	bne.n	8009b60 <oslib_test_009_005_teardown+0x10>
}
 8009b6c:	bd10      	pop	{r4, pc}
 8009b6e:	bf00      	nop
 8009b70:	0800ccdc 	.word	0x0800ccdc
	...

08009b80 <oslib_test_009_004_teardown>:
static void oslib_test_009_004_teardown(void) {
 8009b80:	b510      	push	{r4, lr}
  dmp = chFactoryFindMailbox("mymbx");
 8009b82:	4807      	ldr	r0, [pc, #28]	; (8009ba0 <oslib_test_009_004_teardown+0x20>)
 8009b84:	f7fa f8e4 	bl	8003d50 <chFactoryFindMailbox>
  if (dmp != NULL) {
 8009b88:	b140      	cbz	r0, 8009b9c <oslib_test_009_004_teardown+0x1c>
    while (dmp->element.refs > 0U) {
 8009b8a:	6843      	ldr	r3, [r0, #4]
 8009b8c:	4604      	mov	r4, r0
 8009b8e:	b12b      	cbz	r3, 8009b9c <oslib_test_009_004_teardown+0x1c>
      chFactoryReleaseMailbox(dmp);
 8009b90:	4620      	mov	r0, r4
 8009b92:	f7fa f905 	bl	8003da0 <chFactoryReleaseMailbox>
    while (dmp->element.refs > 0U) {
 8009b96:	6863      	ldr	r3, [r4, #4]
 8009b98:	2b00      	cmp	r3, #0
 8009b9a:	d1f9      	bne.n	8009b90 <oslib_test_009_004_teardown+0x10>
}
 8009b9c:	bd10      	pop	{r4, pc}
 8009b9e:	bf00      	nop
 8009ba0:	0800cce4 	.word	0x0800cce4
	...

08009bb0 <oslib_test_009_003_teardown>:
static void oslib_test_009_003_teardown(void) {
 8009bb0:	b510      	push	{r4, lr}
  dsp = chFactoryFindSemaphore("mysem");
 8009bb2:	4807      	ldr	r0, [pc, #28]	; (8009bd0 <oslib_test_009_003_teardown+0x20>)
 8009bb4:	f7fa f85c 	bl	8003c70 <chFactoryFindSemaphore>
  if (dsp != NULL) {
 8009bb8:	b140      	cbz	r0, 8009bcc <oslib_test_009_003_teardown+0x1c>
    while (dsp->element.refs > 0U) {
 8009bba:	6843      	ldr	r3, [r0, #4]
 8009bbc:	4604      	mov	r4, r0
 8009bbe:	b12b      	cbz	r3, 8009bcc <oslib_test_009_003_teardown+0x1c>
      chFactoryReleaseSemaphore(dsp);
 8009bc0:	4620      	mov	r0, r4
 8009bc2:	f7fa f87d 	bl	8003cc0 <chFactoryReleaseSemaphore>
    while (dsp->element.refs > 0U) {
 8009bc6:	6863      	ldr	r3, [r4, #4]
 8009bc8:	2b00      	cmp	r3, #0
 8009bca:	d1f9      	bne.n	8009bc0 <oslib_test_009_003_teardown+0x10>
}
 8009bcc:	bd10      	pop	{r4, pc}
 8009bce:	bf00      	nop
 8009bd0:	0800ccec 	.word	0x0800ccec
	...

08009be0 <oslib_test_009_002_teardown>:
static void oslib_test_009_002_teardown(void) {
 8009be0:	b510      	push	{r4, lr}
  dbp = chFactoryFindBuffer("mybuf");
 8009be2:	4807      	ldr	r0, [pc, #28]	; (8009c00 <oslib_test_009_002_teardown+0x20>)
 8009be4:	f7f9 ffac 	bl	8003b40 <chFactoryFindBuffer>
  if (dbp != NULL) {
 8009be8:	b140      	cbz	r0, 8009bfc <oslib_test_009_002_teardown+0x1c>
    while (dbp->element.refs > 0U) {
 8009bea:	6843      	ldr	r3, [r0, #4]
 8009bec:	4604      	mov	r4, r0
 8009bee:	b12b      	cbz	r3, 8009bfc <oslib_test_009_002_teardown+0x1c>
      chFactoryReleaseBuffer(dbp);
 8009bf0:	4620      	mov	r0, r4
 8009bf2:	f7f9 ffcd 	bl	8003b90 <chFactoryReleaseBuffer>
    while (dbp->element.refs > 0U) {
 8009bf6:	6863      	ldr	r3, [r4, #4]
 8009bf8:	2b00      	cmp	r3, #0
 8009bfa:	d1f9      	bne.n	8009bf0 <oslib_test_009_002_teardown+0x10>
}
 8009bfc:	bd10      	pop	{r4, pc}
 8009bfe:	bf00      	nop
 8009c00:	0800ccf4 	.word	0x0800ccf4
	...

08009c10 <oslib_test_009_001_teardown>:
static void oslib_test_009_001_teardown(void) {
 8009c10:	b510      	push	{r4, lr}
  rop = chFactoryFindObject("myobj");
 8009c12:	4807      	ldr	r0, [pc, #28]	; (8009c30 <oslib_test_009_001_teardown+0x20>)
 8009c14:	f7f9 ff24 	bl	8003a60 <chFactoryFindObject>
  if (rop != NULL) {
 8009c18:	b140      	cbz	r0, 8009c2c <oslib_test_009_001_teardown+0x1c>
    while (rop->element.refs > 0U) {
 8009c1a:	6843      	ldr	r3, [r0, #4]
 8009c1c:	4604      	mov	r4, r0
 8009c1e:	b12b      	cbz	r3, 8009c2c <oslib_test_009_001_teardown+0x1c>
      chFactoryReleaseObject(rop);
 8009c20:	4620      	mov	r0, r4
 8009c22:	f7f9 ff45 	bl	8003ab0 <chFactoryReleaseObject>
    while (rop->element.refs > 0U) {
 8009c26:	6863      	ldr	r3, [r4, #4]
 8009c28:	2b00      	cmp	r3, #0
 8009c2a:	d1f9      	bne.n	8009c20 <oslib_test_009_001_teardown+0x10>
}
 8009c2c:	bd10      	pop	{r4, pc}
 8009c2e:	bf00      	nop
 8009c30:	0800ccfc 	.word	0x0800ccfc
	...

08009c40 <oslib_test_009_006_execute>:

static void oslib_test_009_006_execute(void) {
 8009c40:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  dyn_pipe_t *dpp;

  /* [9.6.1] Retrieving a dynamic pipe by name, must not exist.*/
  test_set_step(1);
 8009c42:	4c47      	ldr	r4, [pc, #284]	; (8009d60 <oslib_test_009_006_execute+0x120>)
  {
    dpp = chFactoryFindPipe("mypipe");
 8009c44:	4847      	ldr	r0, [pc, #284]	; (8009d64 <oslib_test_009_006_execute+0x124>)
  test_set_step(1);
 8009c46:	2501      	movs	r5, #1
 8009c48:	6025      	str	r5, [r4, #0]
    dpp = chFactoryFindPipe("mypipe");
 8009c4a:	f7fa f979 	bl	8003f40 <chFactoryFindPipe>
    test_assert(dpp == NULL, "found");
 8009c4e:	fab0 f080 	clz	r0, r0
 8009c52:	4945      	ldr	r1, [pc, #276]	; (8009d68 <oslib_test_009_006_execute+0x128>)
 8009c54:	0940      	lsrs	r0, r0, #5
 8009c56:	f7fa fb63 	bl	8004320 <__test_assert>
 8009c5a:	b100      	cbz	r0, 8009c5e <oslib_test_009_006_execute+0x1e>
  {
    dpp = chFactoryFindPipe("mypipe");
    test_assert(dpp == NULL, "found");
  }
  test_end_step(6);
}
 8009c5c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    dpp = chFactoryCreatePipe("mypipe", 16U);
 8009c5e:	2110      	movs	r1, #16
  test_set_step(2);
 8009c60:	2302      	movs	r3, #2
    dpp = chFactoryCreatePipe("mypipe", 16U);
 8009c62:	4840      	ldr	r0, [pc, #256]	; (8009d64 <oslib_test_009_006_execute+0x124>)
  test_set_step(2);
 8009c64:	6023      	str	r3, [r4, #0]
    dpp = chFactoryCreatePipe("mypipe", 16U);
 8009c66:	f7fa f94b 	bl	8003f00 <chFactoryCreatePipe>
 8009c6a:	4606      	mov	r6, r0
    test_assert(dpp != NULL, "cannot create");
 8009c6c:	3800      	subs	r0, #0
 8009c6e:	bf18      	it	ne
 8009c70:	2001      	movne	r0, #1
 8009c72:	493e      	ldr	r1, [pc, #248]	; (8009d6c <oslib_test_009_006_execute+0x12c>)
 8009c74:	f7fa fb54 	bl	8004320 <__test_assert>
 8009c78:	2800      	cmp	r0, #0
 8009c7a:	d1ef      	bne.n	8009c5c <oslib_test_009_006_execute+0x1c>
    dpp1 = chFactoryCreatePipe("mypipe", 16U);
 8009c7c:	2110      	movs	r1, #16
  test_set_step(3);
 8009c7e:	2303      	movs	r3, #3
    dpp1 = chFactoryCreatePipe("mypipe", 16U);
 8009c80:	4838      	ldr	r0, [pc, #224]	; (8009d64 <oslib_test_009_006_execute+0x124>)
  test_set_step(3);
 8009c82:	6023      	str	r3, [r4, #0]
    dpp1 = chFactoryCreatePipe("mypipe", 16U);
 8009c84:	f7fa f93c 	bl	8003f00 <chFactoryCreatePipe>
    test_assert(dpp1 == NULL, "can create");
 8009c88:	fab0 f080 	clz	r0, r0
 8009c8c:	4938      	ldr	r1, [pc, #224]	; (8009d70 <oslib_test_009_006_execute+0x130>)
 8009c8e:	0940      	lsrs	r0, r0, #5
 8009c90:	f7fa fb46 	bl	8004320 <__test_assert>
 8009c94:	2800      	cmp	r0, #0
 8009c96:	d1e1      	bne.n	8009c5c <oslib_test_009_006_execute+0x1c>
  test_set_step(4);
 8009c98:	2304      	movs	r3, #4
    dpp1 = chFactoryFindPipe("mypipe");
 8009c9a:	4832      	ldr	r0, [pc, #200]	; (8009d64 <oslib_test_009_006_execute+0x124>)
  test_set_step(4);
 8009c9c:	6023      	str	r3, [r4, #0]
    dpp1 = chFactoryFindPipe("mypipe");
 8009c9e:	f7fa f94f 	bl	8003f40 <chFactoryFindPipe>
    test_assert(dpp1 != NULL, "not found");
 8009ca2:	4607      	mov	r7, r0
 8009ca4:	3800      	subs	r0, #0
 8009ca6:	bf18      	it	ne
 8009ca8:	2001      	movne	r0, #1
 8009caa:	4932      	ldr	r1, [pc, #200]	; (8009d74 <oslib_test_009_006_execute+0x134>)
 8009cac:	f7fa fb38 	bl	8004320 <__test_assert>
 8009cb0:	2800      	cmp	r0, #0
 8009cb2:	d1d3      	bne.n	8009c5c <oslib_test_009_006_execute+0x1c>
    test_assert(dpp == dpp1, "object reference mismatch");
 8009cb4:	1bf0      	subs	r0, r6, r7
 8009cb6:	fab0 f080 	clz	r0, r0
 8009cba:	492f      	ldr	r1, [pc, #188]	; (8009d78 <oslib_test_009_006_execute+0x138>)
 8009cbc:	0940      	lsrs	r0, r0, #5
 8009cbe:	f7fa fb2f 	bl	8004320 <__test_assert>
 8009cc2:	2800      	cmp	r0, #0
 8009cc4:	d1ca      	bne.n	8009c5c <oslib_test_009_006_execute+0x1c>
    test_assert(dpp1->element.refs == 2, "object reference mismatch");
 8009cc6:	6878      	ldr	r0, [r7, #4]
 8009cc8:	492b      	ldr	r1, [pc, #172]	; (8009d78 <oslib_test_009_006_execute+0x138>)
 8009cca:	f1a0 0002 	sub.w	r0, r0, #2
 8009cce:	fab0 f080 	clz	r0, r0
 8009cd2:	0940      	lsrs	r0, r0, #5
 8009cd4:	f7fa fb24 	bl	8004320 <__test_assert>
 8009cd8:	2800      	cmp	r0, #0
 8009cda:	d1bf      	bne.n	8009c5c <oslib_test_009_006_execute+0x1c>
 *
 * @api
 */
static inline dyn_element_t *chFactoryDuplicateReference(dyn_element_t *dep) {

  dep->refs++;
 8009cdc:	687b      	ldr	r3, [r7, #4]
    test_assert(dpp1 == dpp2, "object reference mismatch");
 8009cde:	4926      	ldr	r1, [pc, #152]	; (8009d78 <oslib_test_009_006_execute+0x138>)
 8009ce0:	442b      	add	r3, r5
 8009ce2:	4628      	mov	r0, r5
 8009ce4:	607b      	str	r3, [r7, #4]
 8009ce6:	f7fa fb1b 	bl	8004320 <__test_assert>
 8009cea:	2800      	cmp	r0, #0
 8009cec:	d1b6      	bne.n	8009c5c <oslib_test_009_006_execute+0x1c>
    test_assert(dpp2->element.refs == 3, "object reference mismatch");
 8009cee:	6878      	ldr	r0, [r7, #4]
 8009cf0:	4921      	ldr	r1, [pc, #132]	; (8009d78 <oslib_test_009_006_execute+0x138>)
 8009cf2:	f1a0 0003 	sub.w	r0, r0, #3
 8009cf6:	fab0 f080 	clz	r0, r0
 8009cfa:	0940      	lsrs	r0, r0, #5
 8009cfc:	f7fa fb10 	bl	8004320 <__test_assert>
 8009d00:	2800      	cmp	r0, #0
 8009d02:	d1ab      	bne.n	8009c5c <oslib_test_009_006_execute+0x1c>
    chFactoryReleasePipe(dpp2);
 8009d04:	4638      	mov	r0, r7
 8009d06:	f7fa f943 	bl	8003f90 <chFactoryReleasePipe>
    test_assert(dpp1->element.refs == 2, "references mismatch");
 8009d0a:	6878      	ldr	r0, [r7, #4]
 8009d0c:	491b      	ldr	r1, [pc, #108]	; (8009d7c <oslib_test_009_006_execute+0x13c>)
 8009d0e:	f1a0 0002 	sub.w	r0, r0, #2
 8009d12:	fab0 f080 	clz	r0, r0
 8009d16:	0940      	lsrs	r0, r0, #5
 8009d18:	f7fa fb02 	bl	8004320 <__test_assert>
 8009d1c:	2800      	cmp	r0, #0
 8009d1e:	d19d      	bne.n	8009c5c <oslib_test_009_006_execute+0x1c>
    chFactoryReleasePipe(dpp1);
 8009d20:	4638      	mov	r0, r7
 8009d22:	f7fa f935 	bl	8003f90 <chFactoryReleasePipe>
    test_assert(dpp->element.refs == 1, "references mismatch");
 8009d26:	6870      	ldr	r0, [r6, #4]
 8009d28:	4914      	ldr	r1, [pc, #80]	; (8009d7c <oslib_test_009_006_execute+0x13c>)
 8009d2a:	1b40      	subs	r0, r0, r5
 8009d2c:	fab0 f080 	clz	r0, r0
 8009d30:	0940      	lsrs	r0, r0, #5
 8009d32:	f7fa faf5 	bl	8004320 <__test_assert>
 8009d36:	2800      	cmp	r0, #0
 8009d38:	d190      	bne.n	8009c5c <oslib_test_009_006_execute+0x1c>
    chFactoryReleasePipe(dpp);
 8009d3a:	4630      	mov	r0, r6
  test_set_step(5);
 8009d3c:	2305      	movs	r3, #5
 8009d3e:	6023      	str	r3, [r4, #0]
    chFactoryReleasePipe(dpp);
 8009d40:	f7fa f926 	bl	8003f90 <chFactoryReleasePipe>
  test_set_step(6);
 8009d44:	2306      	movs	r3, #6
    dpp = chFactoryFindPipe("mypipe");
 8009d46:	4807      	ldr	r0, [pc, #28]	; (8009d64 <oslib_test_009_006_execute+0x124>)
  test_set_step(6);
 8009d48:	6023      	str	r3, [r4, #0]
    dpp = chFactoryFindPipe("mypipe");
 8009d4a:	f7fa f8f9 	bl	8003f40 <chFactoryFindPipe>
    test_assert(dpp == NULL, "found");
 8009d4e:	fab0 f080 	clz	r0, r0
}
 8009d52:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
    test_assert(dpp == NULL, "found");
 8009d56:	4904      	ldr	r1, [pc, #16]	; (8009d68 <oslib_test_009_006_execute+0x128>)
 8009d58:	0940      	lsrs	r0, r0, #5
 8009d5a:	f7fa bae1 	b.w	8004320 <__test_assert>
 8009d5e:	bf00      	nop
 8009d60:	20000c70 	.word	0x20000c70
 8009d64:	0800ccd4 	.word	0x0800ccd4
 8009d68:	0800cd24 	.word	0x0800cd24
 8009d6c:	0800cd04 	.word	0x0800cd04
 8009d70:	0800cd14 	.word	0x0800cd14
 8009d74:	0800cd20 	.word	0x0800cd20
 8009d78:	0800cd2c 	.word	0x0800cd2c
 8009d7c:	0800cd48 	.word	0x0800cd48

08009d80 <oslib_test_009_005_execute>:
static void oslib_test_009_005_execute(void) {
 8009d80:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  test_set_step(1);
 8009d82:	4c49      	ldr	r4, [pc, #292]	; (8009ea8 <oslib_test_009_005_execute+0x128>)
    dofp = chFactoryFindObjectsFIFO("myfifo");
 8009d84:	4849      	ldr	r0, [pc, #292]	; (8009eac <oslib_test_009_005_execute+0x12c>)
  test_set_step(1);
 8009d86:	2501      	movs	r5, #1
 8009d88:	6025      	str	r5, [r4, #0]
    dofp = chFactoryFindObjectsFIFO("myfifo");
 8009d8a:	f7fa f869 	bl	8003e60 <chFactoryFindObjectsFIFO>
    test_assert(dofp == NULL, "found");
 8009d8e:	fab0 f080 	clz	r0, r0
 8009d92:	4947      	ldr	r1, [pc, #284]	; (8009eb0 <oslib_test_009_005_execute+0x130>)
 8009d94:	0940      	lsrs	r0, r0, #5
 8009d96:	f7fa fac3 	bl	8004320 <__test_assert>
 8009d9a:	b100      	cbz	r0, 8009d9e <oslib_test_009_005_execute+0x1e>
}
 8009d9c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    dofp = chFactoryCreateObjectsFIFO("myfifo", 16U, 16U, PORT_NATURAL_ALIGN);
 8009d9e:	2210      	movs	r2, #16
  test_set_step(2);
 8009da0:	2002      	movs	r0, #2
    dofp = chFactoryCreateObjectsFIFO("myfifo", 16U, 16U, PORT_NATURAL_ALIGN);
 8009da2:	4611      	mov	r1, r2
  test_set_step(2);
 8009da4:	6020      	str	r0, [r4, #0]
    dofp = chFactoryCreateObjectsFIFO("myfifo", 16U, 16U, PORT_NATURAL_ALIGN);
 8009da6:	2304      	movs	r3, #4
 8009da8:	4840      	ldr	r0, [pc, #256]	; (8009eac <oslib_test_009_005_execute+0x12c>)
 8009daa:	f7fa f821 	bl	8003df0 <chFactoryCreateObjectsFIFO>
 8009dae:	4606      	mov	r6, r0
    test_assert(dofp != NULL, "cannot create");
 8009db0:	3800      	subs	r0, #0
 8009db2:	bf18      	it	ne
 8009db4:	2001      	movne	r0, #1
 8009db6:	493f      	ldr	r1, [pc, #252]	; (8009eb4 <oslib_test_009_005_execute+0x134>)
 8009db8:	f7fa fab2 	bl	8004320 <__test_assert>
 8009dbc:	2800      	cmp	r0, #0
 8009dbe:	d1ed      	bne.n	8009d9c <oslib_test_009_005_execute+0x1c>
    dofp1 = chFactoryCreateObjectsFIFO("myfifo", 16U, 16U, PORT_NATURAL_ALIGN);
 8009dc0:	2210      	movs	r2, #16
  test_set_step(3);
 8009dc2:	2003      	movs	r0, #3
    dofp1 = chFactoryCreateObjectsFIFO("myfifo", 16U, 16U, PORT_NATURAL_ALIGN);
 8009dc4:	4611      	mov	r1, r2
  test_set_step(3);
 8009dc6:	6020      	str	r0, [r4, #0]
    dofp1 = chFactoryCreateObjectsFIFO("myfifo", 16U, 16U, PORT_NATURAL_ALIGN);
 8009dc8:	2304      	movs	r3, #4
 8009dca:	4838      	ldr	r0, [pc, #224]	; (8009eac <oslib_test_009_005_execute+0x12c>)
 8009dcc:	f7fa f810 	bl	8003df0 <chFactoryCreateObjectsFIFO>
    test_assert(dofp1 == NULL, "can create");
 8009dd0:	fab0 f080 	clz	r0, r0
 8009dd4:	4938      	ldr	r1, [pc, #224]	; (8009eb8 <oslib_test_009_005_execute+0x138>)
 8009dd6:	0940      	lsrs	r0, r0, #5
 8009dd8:	f7fa faa2 	bl	8004320 <__test_assert>
 8009ddc:	2800      	cmp	r0, #0
 8009dde:	d1dd      	bne.n	8009d9c <oslib_test_009_005_execute+0x1c>
  test_set_step(4);
 8009de0:	2304      	movs	r3, #4
    dofp1 = chFactoryFindObjectsFIFO("myfifo");
 8009de2:	4832      	ldr	r0, [pc, #200]	; (8009eac <oslib_test_009_005_execute+0x12c>)
  test_set_step(4);
 8009de4:	6023      	str	r3, [r4, #0]
    dofp1 = chFactoryFindObjectsFIFO("myfifo");
 8009de6:	f7fa f83b 	bl	8003e60 <chFactoryFindObjectsFIFO>
    test_assert(dofp1 != NULL, "not found");
 8009dea:	4607      	mov	r7, r0
 8009dec:	3800      	subs	r0, #0
 8009dee:	bf18      	it	ne
 8009df0:	2001      	movne	r0, #1
 8009df2:	4932      	ldr	r1, [pc, #200]	; (8009ebc <oslib_test_009_005_execute+0x13c>)
 8009df4:	f7fa fa94 	bl	8004320 <__test_assert>
 8009df8:	2800      	cmp	r0, #0
 8009dfa:	d1cf      	bne.n	8009d9c <oslib_test_009_005_execute+0x1c>
    test_assert(dofp == dofp1, "object reference mismatch");
 8009dfc:	1bf0      	subs	r0, r6, r7
 8009dfe:	fab0 f080 	clz	r0, r0
 8009e02:	492f      	ldr	r1, [pc, #188]	; (8009ec0 <oslib_test_009_005_execute+0x140>)
 8009e04:	0940      	lsrs	r0, r0, #5
 8009e06:	f7fa fa8b 	bl	8004320 <__test_assert>
 8009e0a:	2800      	cmp	r0, #0
 8009e0c:	d1c6      	bne.n	8009d9c <oslib_test_009_005_execute+0x1c>
    test_assert(dofp1->element.refs == 2, "object reference mismatch");
 8009e0e:	6878      	ldr	r0, [r7, #4]
 8009e10:	492b      	ldr	r1, [pc, #172]	; (8009ec0 <oslib_test_009_005_execute+0x140>)
 8009e12:	f1a0 0002 	sub.w	r0, r0, #2
 8009e16:	fab0 f080 	clz	r0, r0
 8009e1a:	0940      	lsrs	r0, r0, #5
 8009e1c:	f7fa fa80 	bl	8004320 <__test_assert>
 8009e20:	2800      	cmp	r0, #0
 8009e22:	d1bb      	bne.n	8009d9c <oslib_test_009_005_execute+0x1c>
 8009e24:	687b      	ldr	r3, [r7, #4]
    test_assert(dofp1 == dofp2, "object reference mismatch");
 8009e26:	4926      	ldr	r1, [pc, #152]	; (8009ec0 <oslib_test_009_005_execute+0x140>)
 8009e28:	442b      	add	r3, r5
 8009e2a:	4628      	mov	r0, r5
 8009e2c:	607b      	str	r3, [r7, #4]
 8009e2e:	f7fa fa77 	bl	8004320 <__test_assert>
 8009e32:	2800      	cmp	r0, #0
 8009e34:	d1b2      	bne.n	8009d9c <oslib_test_009_005_execute+0x1c>
    test_assert(dofp2->element.refs == 3, "object reference mismatch");
 8009e36:	6878      	ldr	r0, [r7, #4]
 8009e38:	4921      	ldr	r1, [pc, #132]	; (8009ec0 <oslib_test_009_005_execute+0x140>)
 8009e3a:	f1a0 0003 	sub.w	r0, r0, #3
 8009e3e:	fab0 f080 	clz	r0, r0
 8009e42:	0940      	lsrs	r0, r0, #5
 8009e44:	f7fa fa6c 	bl	8004320 <__test_assert>
 8009e48:	2800      	cmp	r0, #0
 8009e4a:	d1a7      	bne.n	8009d9c <oslib_test_009_005_execute+0x1c>
    chFactoryReleaseObjectsFIFO(dofp2);
 8009e4c:	4638      	mov	r0, r7
 8009e4e:	f7fa f82f 	bl	8003eb0 <chFactoryReleaseObjectsFIFO>
    test_assert(dofp1->element.refs == 2, "references mismatch");
 8009e52:	6878      	ldr	r0, [r7, #4]
 8009e54:	491b      	ldr	r1, [pc, #108]	; (8009ec4 <oslib_test_009_005_execute+0x144>)
 8009e56:	f1a0 0002 	sub.w	r0, r0, #2
 8009e5a:	fab0 f080 	clz	r0, r0
 8009e5e:	0940      	lsrs	r0, r0, #5
 8009e60:	f7fa fa5e 	bl	8004320 <__test_assert>
 8009e64:	2800      	cmp	r0, #0
 8009e66:	d199      	bne.n	8009d9c <oslib_test_009_005_execute+0x1c>
    chFactoryReleaseObjectsFIFO(dofp1);
 8009e68:	4638      	mov	r0, r7
 8009e6a:	f7fa f821 	bl	8003eb0 <chFactoryReleaseObjectsFIFO>
    test_assert(dofp->element.refs == 1, "references mismatch");
 8009e6e:	6870      	ldr	r0, [r6, #4]
 8009e70:	4914      	ldr	r1, [pc, #80]	; (8009ec4 <oslib_test_009_005_execute+0x144>)
 8009e72:	1b40      	subs	r0, r0, r5
 8009e74:	fab0 f080 	clz	r0, r0
 8009e78:	0940      	lsrs	r0, r0, #5
 8009e7a:	f7fa fa51 	bl	8004320 <__test_assert>
 8009e7e:	2800      	cmp	r0, #0
 8009e80:	d18c      	bne.n	8009d9c <oslib_test_009_005_execute+0x1c>
    chFactoryReleaseObjectsFIFO(dofp);
 8009e82:	4630      	mov	r0, r6
  test_set_step(5);
 8009e84:	2305      	movs	r3, #5
 8009e86:	6023      	str	r3, [r4, #0]
    chFactoryReleaseObjectsFIFO(dofp);
 8009e88:	f7fa f812 	bl	8003eb0 <chFactoryReleaseObjectsFIFO>
  test_set_step(6);
 8009e8c:	2306      	movs	r3, #6
    dofp = chFactoryFindObjectsFIFO("myfifo");
 8009e8e:	4807      	ldr	r0, [pc, #28]	; (8009eac <oslib_test_009_005_execute+0x12c>)
  test_set_step(6);
 8009e90:	6023      	str	r3, [r4, #0]
    dofp = chFactoryFindObjectsFIFO("myfifo");
 8009e92:	f7f9 ffe5 	bl	8003e60 <chFactoryFindObjectsFIFO>
    test_assert(dofp == NULL, "found");
 8009e96:	fab0 f080 	clz	r0, r0
}
 8009e9a:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
    test_assert(dofp == NULL, "found");
 8009e9e:	4904      	ldr	r1, [pc, #16]	; (8009eb0 <oslib_test_009_005_execute+0x130>)
 8009ea0:	0940      	lsrs	r0, r0, #5
 8009ea2:	f7fa ba3d 	b.w	8004320 <__test_assert>
 8009ea6:	bf00      	nop
 8009ea8:	20000c70 	.word	0x20000c70
 8009eac:	0800ccdc 	.word	0x0800ccdc
 8009eb0:	0800cd24 	.word	0x0800cd24
 8009eb4:	0800cd04 	.word	0x0800cd04
 8009eb8:	0800cd14 	.word	0x0800cd14
 8009ebc:	0800cd20 	.word	0x0800cd20
 8009ec0:	0800cd2c 	.word	0x0800cd2c
 8009ec4:	0800cd48 	.word	0x0800cd48
	...

08009ed0 <oslib_test_009_004_execute>:
static void oslib_test_009_004_execute(void) {
 8009ed0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  test_set_step(1);
 8009ed2:	4c47      	ldr	r4, [pc, #284]	; (8009ff0 <oslib_test_009_004_execute+0x120>)
    dmp = chFactoryFindMailbox("mymbx");
 8009ed4:	4847      	ldr	r0, [pc, #284]	; (8009ff4 <oslib_test_009_004_execute+0x124>)
  test_set_step(1);
 8009ed6:	2501      	movs	r5, #1
 8009ed8:	6025      	str	r5, [r4, #0]
    dmp = chFactoryFindMailbox("mymbx");
 8009eda:	f7f9 ff39 	bl	8003d50 <chFactoryFindMailbox>
    test_assert(dmp == NULL, "found");
 8009ede:	fab0 f080 	clz	r0, r0
 8009ee2:	4945      	ldr	r1, [pc, #276]	; (8009ff8 <oslib_test_009_004_execute+0x128>)
 8009ee4:	0940      	lsrs	r0, r0, #5
 8009ee6:	f7fa fa1b 	bl	8004320 <__test_assert>
 8009eea:	b100      	cbz	r0, 8009eee <oslib_test_009_004_execute+0x1e>
}
 8009eec:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    dmp = chFactoryCreateMailbox("mymbx", 16U);
 8009eee:	2110      	movs	r1, #16
  test_set_step(2);
 8009ef0:	2302      	movs	r3, #2
    dmp = chFactoryCreateMailbox("mymbx", 16U);
 8009ef2:	4840      	ldr	r0, [pc, #256]	; (8009ff4 <oslib_test_009_004_execute+0x124>)
  test_set_step(2);
 8009ef4:	6023      	str	r3, [r4, #0]
    dmp = chFactoryCreateMailbox("mymbx", 16U);
 8009ef6:	f7f9 ff0b 	bl	8003d10 <chFactoryCreateMailbox>
 8009efa:	4606      	mov	r6, r0
    test_assert(dmp != NULL, "cannot create");
 8009efc:	3800      	subs	r0, #0
 8009efe:	bf18      	it	ne
 8009f00:	2001      	movne	r0, #1
 8009f02:	493e      	ldr	r1, [pc, #248]	; (8009ffc <oslib_test_009_004_execute+0x12c>)
 8009f04:	f7fa fa0c 	bl	8004320 <__test_assert>
 8009f08:	2800      	cmp	r0, #0
 8009f0a:	d1ef      	bne.n	8009eec <oslib_test_009_004_execute+0x1c>
    dmp1 = chFactoryCreateMailbox("mymbx", 16U);
 8009f0c:	2110      	movs	r1, #16
  test_set_step(3);
 8009f0e:	2303      	movs	r3, #3
    dmp1 = chFactoryCreateMailbox("mymbx", 16U);
 8009f10:	4838      	ldr	r0, [pc, #224]	; (8009ff4 <oslib_test_009_004_execute+0x124>)
  test_set_step(3);
 8009f12:	6023      	str	r3, [r4, #0]
    dmp1 = chFactoryCreateMailbox("mymbx", 16U);
 8009f14:	f7f9 fefc 	bl	8003d10 <chFactoryCreateMailbox>
    test_assert(dmp1 == NULL, "can create");
 8009f18:	fab0 f080 	clz	r0, r0
 8009f1c:	4938      	ldr	r1, [pc, #224]	; (800a000 <oslib_test_009_004_execute+0x130>)
 8009f1e:	0940      	lsrs	r0, r0, #5
 8009f20:	f7fa f9fe 	bl	8004320 <__test_assert>
 8009f24:	2800      	cmp	r0, #0
 8009f26:	d1e1      	bne.n	8009eec <oslib_test_009_004_execute+0x1c>
  test_set_step(4);
 8009f28:	2304      	movs	r3, #4
    dmp1 = chFactoryFindMailbox("mymbx");
 8009f2a:	4832      	ldr	r0, [pc, #200]	; (8009ff4 <oslib_test_009_004_execute+0x124>)
  test_set_step(4);
 8009f2c:	6023      	str	r3, [r4, #0]
    dmp1 = chFactoryFindMailbox("mymbx");
 8009f2e:	f7f9 ff0f 	bl	8003d50 <chFactoryFindMailbox>
    test_assert(dmp1 != NULL, "not found");
 8009f32:	4607      	mov	r7, r0
 8009f34:	3800      	subs	r0, #0
 8009f36:	bf18      	it	ne
 8009f38:	2001      	movne	r0, #1
 8009f3a:	4932      	ldr	r1, [pc, #200]	; (800a004 <oslib_test_009_004_execute+0x134>)
 8009f3c:	f7fa f9f0 	bl	8004320 <__test_assert>
 8009f40:	2800      	cmp	r0, #0
 8009f42:	d1d3      	bne.n	8009eec <oslib_test_009_004_execute+0x1c>
    test_assert(dmp == dmp1, "object reference mismatch");
 8009f44:	1bf0      	subs	r0, r6, r7
 8009f46:	fab0 f080 	clz	r0, r0
 8009f4a:	492f      	ldr	r1, [pc, #188]	; (800a008 <oslib_test_009_004_execute+0x138>)
 8009f4c:	0940      	lsrs	r0, r0, #5
 8009f4e:	f7fa f9e7 	bl	8004320 <__test_assert>
 8009f52:	2800      	cmp	r0, #0
 8009f54:	d1ca      	bne.n	8009eec <oslib_test_009_004_execute+0x1c>
    test_assert(dmp1->element.refs == 2, "object reference mismatch");
 8009f56:	6878      	ldr	r0, [r7, #4]
 8009f58:	492b      	ldr	r1, [pc, #172]	; (800a008 <oslib_test_009_004_execute+0x138>)
 8009f5a:	f1a0 0002 	sub.w	r0, r0, #2
 8009f5e:	fab0 f080 	clz	r0, r0
 8009f62:	0940      	lsrs	r0, r0, #5
 8009f64:	f7fa f9dc 	bl	8004320 <__test_assert>
 8009f68:	2800      	cmp	r0, #0
 8009f6a:	d1bf      	bne.n	8009eec <oslib_test_009_004_execute+0x1c>
 8009f6c:	687b      	ldr	r3, [r7, #4]
    test_assert(dmp1 == dmp2, "object reference mismatch");
 8009f6e:	4926      	ldr	r1, [pc, #152]	; (800a008 <oslib_test_009_004_execute+0x138>)
 8009f70:	442b      	add	r3, r5
 8009f72:	4628      	mov	r0, r5
 8009f74:	607b      	str	r3, [r7, #4]
 8009f76:	f7fa f9d3 	bl	8004320 <__test_assert>
 8009f7a:	2800      	cmp	r0, #0
 8009f7c:	d1b6      	bne.n	8009eec <oslib_test_009_004_execute+0x1c>
    test_assert(dmp2->element.refs == 3, "object reference mismatch");
 8009f7e:	6878      	ldr	r0, [r7, #4]
 8009f80:	4921      	ldr	r1, [pc, #132]	; (800a008 <oslib_test_009_004_execute+0x138>)
 8009f82:	f1a0 0003 	sub.w	r0, r0, #3
 8009f86:	fab0 f080 	clz	r0, r0
 8009f8a:	0940      	lsrs	r0, r0, #5
 8009f8c:	f7fa f9c8 	bl	8004320 <__test_assert>
 8009f90:	2800      	cmp	r0, #0
 8009f92:	d1ab      	bne.n	8009eec <oslib_test_009_004_execute+0x1c>
    chFactoryReleaseMailbox(dmp2);
 8009f94:	4638      	mov	r0, r7
 8009f96:	f7f9 ff03 	bl	8003da0 <chFactoryReleaseMailbox>
    test_assert(dmp1->element.refs == 2, "references mismatch");
 8009f9a:	6878      	ldr	r0, [r7, #4]
 8009f9c:	491b      	ldr	r1, [pc, #108]	; (800a00c <oslib_test_009_004_execute+0x13c>)
 8009f9e:	f1a0 0002 	sub.w	r0, r0, #2
 8009fa2:	fab0 f080 	clz	r0, r0
 8009fa6:	0940      	lsrs	r0, r0, #5
 8009fa8:	f7fa f9ba 	bl	8004320 <__test_assert>
 8009fac:	2800      	cmp	r0, #0
 8009fae:	d19d      	bne.n	8009eec <oslib_test_009_004_execute+0x1c>
    chFactoryReleaseMailbox(dmp1);
 8009fb0:	4638      	mov	r0, r7
 8009fb2:	f7f9 fef5 	bl	8003da0 <chFactoryReleaseMailbox>
    test_assert(dmp->element.refs == 1, "references mismatch");
 8009fb6:	6870      	ldr	r0, [r6, #4]
 8009fb8:	4914      	ldr	r1, [pc, #80]	; (800a00c <oslib_test_009_004_execute+0x13c>)
 8009fba:	1b40      	subs	r0, r0, r5
 8009fbc:	fab0 f080 	clz	r0, r0
 8009fc0:	0940      	lsrs	r0, r0, #5
 8009fc2:	f7fa f9ad 	bl	8004320 <__test_assert>
 8009fc6:	2800      	cmp	r0, #0
 8009fc8:	d190      	bne.n	8009eec <oslib_test_009_004_execute+0x1c>
    chFactoryReleaseMailbox(dmp);
 8009fca:	4630      	mov	r0, r6
  test_set_step(5);
 8009fcc:	2305      	movs	r3, #5
 8009fce:	6023      	str	r3, [r4, #0]
    chFactoryReleaseMailbox(dmp);
 8009fd0:	f7f9 fee6 	bl	8003da0 <chFactoryReleaseMailbox>
  test_set_step(6);
 8009fd4:	2306      	movs	r3, #6
    dmp = chFactoryFindMailbox("mymbx");
 8009fd6:	4807      	ldr	r0, [pc, #28]	; (8009ff4 <oslib_test_009_004_execute+0x124>)
  test_set_step(6);
 8009fd8:	6023      	str	r3, [r4, #0]
    dmp = chFactoryFindMailbox("mymbx");
 8009fda:	f7f9 feb9 	bl	8003d50 <chFactoryFindMailbox>
    test_assert(dmp == NULL, "found");
 8009fde:	fab0 f080 	clz	r0, r0
}
 8009fe2:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
    test_assert(dmp == NULL, "found");
 8009fe6:	4904      	ldr	r1, [pc, #16]	; (8009ff8 <oslib_test_009_004_execute+0x128>)
 8009fe8:	0940      	lsrs	r0, r0, #5
 8009fea:	f7fa b999 	b.w	8004320 <__test_assert>
 8009fee:	bf00      	nop
 8009ff0:	20000c70 	.word	0x20000c70
 8009ff4:	0800cce4 	.word	0x0800cce4
 8009ff8:	0800cd24 	.word	0x0800cd24
 8009ffc:	0800cd04 	.word	0x0800cd04
 800a000:	0800cd14 	.word	0x0800cd14
 800a004:	0800cd20 	.word	0x0800cd20
 800a008:	0800cd2c 	.word	0x0800cd2c
 800a00c:	0800cd48 	.word	0x0800cd48

0800a010 <oslib_test_009_003_execute>:
static void oslib_test_009_003_execute(void) {
 800a010:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  test_set_step(1);
 800a012:	4c47      	ldr	r4, [pc, #284]	; (800a130 <oslib_test_009_003_execute+0x120>)
    dsp = chFactoryFindSemaphore("mysem");
 800a014:	4847      	ldr	r0, [pc, #284]	; (800a134 <oslib_test_009_003_execute+0x124>)
  test_set_step(1);
 800a016:	2501      	movs	r5, #1
 800a018:	6025      	str	r5, [r4, #0]
    dsp = chFactoryFindSemaphore("mysem");
 800a01a:	f7f9 fe29 	bl	8003c70 <chFactoryFindSemaphore>
    test_assert(dsp == NULL, "found");
 800a01e:	fab0 f080 	clz	r0, r0
 800a022:	4945      	ldr	r1, [pc, #276]	; (800a138 <oslib_test_009_003_execute+0x128>)
 800a024:	0940      	lsrs	r0, r0, #5
 800a026:	f7fa f97b 	bl	8004320 <__test_assert>
 800a02a:	b100      	cbz	r0, 800a02e <oslib_test_009_003_execute+0x1e>
}
 800a02c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    dsp = chFactoryCreateSemaphore("mysem", 0);
 800a02e:	4601      	mov	r1, r0
  test_set_step(2);
 800a030:	2302      	movs	r3, #2
    dsp = chFactoryCreateSemaphore("mysem", 0);
 800a032:	4840      	ldr	r0, [pc, #256]	; (800a134 <oslib_test_009_003_execute+0x124>)
  test_set_step(2);
 800a034:	6023      	str	r3, [r4, #0]
    dsp = chFactoryCreateSemaphore("mysem", 0);
 800a036:	f7f9 fdd3 	bl	8003be0 <chFactoryCreateSemaphore>
 800a03a:	4606      	mov	r6, r0
    test_assert(dsp != NULL, "cannot create");
 800a03c:	3800      	subs	r0, #0
 800a03e:	bf18      	it	ne
 800a040:	2001      	movne	r0, #1
 800a042:	493e      	ldr	r1, [pc, #248]	; (800a13c <oslib_test_009_003_execute+0x12c>)
 800a044:	f7fa f96c 	bl	8004320 <__test_assert>
 800a048:	2800      	cmp	r0, #0
 800a04a:	d1ef      	bne.n	800a02c <oslib_test_009_003_execute+0x1c>
    dsp1 = chFactoryCreateSemaphore("mysem", 0);
 800a04c:	4601      	mov	r1, r0
  test_set_step(3);
 800a04e:	2303      	movs	r3, #3
    dsp1 = chFactoryCreateSemaphore("mysem", 0);
 800a050:	4838      	ldr	r0, [pc, #224]	; (800a134 <oslib_test_009_003_execute+0x124>)
  test_set_step(3);
 800a052:	6023      	str	r3, [r4, #0]
    dsp1 = chFactoryCreateSemaphore("mysem", 0);
 800a054:	f7f9 fdc4 	bl	8003be0 <chFactoryCreateSemaphore>
    test_assert(dsp1 == NULL, "can create");
 800a058:	fab0 f080 	clz	r0, r0
 800a05c:	4938      	ldr	r1, [pc, #224]	; (800a140 <oslib_test_009_003_execute+0x130>)
 800a05e:	0940      	lsrs	r0, r0, #5
 800a060:	f7fa f95e 	bl	8004320 <__test_assert>
 800a064:	2800      	cmp	r0, #0
 800a066:	d1e1      	bne.n	800a02c <oslib_test_009_003_execute+0x1c>
  test_set_step(4);
 800a068:	2304      	movs	r3, #4
    dsp1 = chFactoryFindSemaphore("mysem");
 800a06a:	4832      	ldr	r0, [pc, #200]	; (800a134 <oslib_test_009_003_execute+0x124>)
  test_set_step(4);
 800a06c:	6023      	str	r3, [r4, #0]
    dsp1 = chFactoryFindSemaphore("mysem");
 800a06e:	f7f9 fdff 	bl	8003c70 <chFactoryFindSemaphore>
    test_assert(dsp1 != NULL, "not found");
 800a072:	4607      	mov	r7, r0
 800a074:	3800      	subs	r0, #0
 800a076:	bf18      	it	ne
 800a078:	2001      	movne	r0, #1
 800a07a:	4932      	ldr	r1, [pc, #200]	; (800a144 <oslib_test_009_003_execute+0x134>)
 800a07c:	f7fa f950 	bl	8004320 <__test_assert>
 800a080:	2800      	cmp	r0, #0
 800a082:	d1d3      	bne.n	800a02c <oslib_test_009_003_execute+0x1c>
    test_assert(dsp == dsp1, "object reference mismatch");
 800a084:	1bf0      	subs	r0, r6, r7
 800a086:	fab0 f080 	clz	r0, r0
 800a08a:	492f      	ldr	r1, [pc, #188]	; (800a148 <oslib_test_009_003_execute+0x138>)
 800a08c:	0940      	lsrs	r0, r0, #5
 800a08e:	f7fa f947 	bl	8004320 <__test_assert>
 800a092:	2800      	cmp	r0, #0
 800a094:	d1ca      	bne.n	800a02c <oslib_test_009_003_execute+0x1c>
    test_assert(dsp1->element.refs == 2, "object reference mismatch");
 800a096:	6878      	ldr	r0, [r7, #4]
 800a098:	492b      	ldr	r1, [pc, #172]	; (800a148 <oslib_test_009_003_execute+0x138>)
 800a09a:	f1a0 0002 	sub.w	r0, r0, #2
 800a09e:	fab0 f080 	clz	r0, r0
 800a0a2:	0940      	lsrs	r0, r0, #5
 800a0a4:	f7fa f93c 	bl	8004320 <__test_assert>
 800a0a8:	2800      	cmp	r0, #0
 800a0aa:	d1bf      	bne.n	800a02c <oslib_test_009_003_execute+0x1c>
 800a0ac:	687b      	ldr	r3, [r7, #4]
    test_assert(dsp1 == dsp2, "object reference mismatch");
 800a0ae:	4926      	ldr	r1, [pc, #152]	; (800a148 <oslib_test_009_003_execute+0x138>)
 800a0b0:	442b      	add	r3, r5
 800a0b2:	4628      	mov	r0, r5
 800a0b4:	607b      	str	r3, [r7, #4]
 800a0b6:	f7fa f933 	bl	8004320 <__test_assert>
 800a0ba:	2800      	cmp	r0, #0
 800a0bc:	d1b6      	bne.n	800a02c <oslib_test_009_003_execute+0x1c>
    test_assert(dsp2->element.refs == 3, "object reference mismatch");
 800a0be:	6878      	ldr	r0, [r7, #4]
 800a0c0:	4921      	ldr	r1, [pc, #132]	; (800a148 <oslib_test_009_003_execute+0x138>)
 800a0c2:	f1a0 0003 	sub.w	r0, r0, #3
 800a0c6:	fab0 f080 	clz	r0, r0
 800a0ca:	0940      	lsrs	r0, r0, #5
 800a0cc:	f7fa f928 	bl	8004320 <__test_assert>
 800a0d0:	2800      	cmp	r0, #0
 800a0d2:	d1ab      	bne.n	800a02c <oslib_test_009_003_execute+0x1c>
    chFactoryReleaseSemaphore(dsp2);
 800a0d4:	4638      	mov	r0, r7
 800a0d6:	f7f9 fdf3 	bl	8003cc0 <chFactoryReleaseSemaphore>
    test_assert(dsp1->element.refs == 2, "references mismatch");
 800a0da:	6878      	ldr	r0, [r7, #4]
 800a0dc:	491b      	ldr	r1, [pc, #108]	; (800a14c <oslib_test_009_003_execute+0x13c>)
 800a0de:	f1a0 0002 	sub.w	r0, r0, #2
 800a0e2:	fab0 f080 	clz	r0, r0
 800a0e6:	0940      	lsrs	r0, r0, #5
 800a0e8:	f7fa f91a 	bl	8004320 <__test_assert>
 800a0ec:	2800      	cmp	r0, #0
 800a0ee:	d19d      	bne.n	800a02c <oslib_test_009_003_execute+0x1c>
    chFactoryReleaseSemaphore(dsp1);
 800a0f0:	4638      	mov	r0, r7
 800a0f2:	f7f9 fde5 	bl	8003cc0 <chFactoryReleaseSemaphore>
    test_assert(dsp->element.refs == 1, "references mismatch");
 800a0f6:	6870      	ldr	r0, [r6, #4]
 800a0f8:	4914      	ldr	r1, [pc, #80]	; (800a14c <oslib_test_009_003_execute+0x13c>)
 800a0fa:	1b40      	subs	r0, r0, r5
 800a0fc:	fab0 f080 	clz	r0, r0
 800a100:	0940      	lsrs	r0, r0, #5
 800a102:	f7fa f90d 	bl	8004320 <__test_assert>
 800a106:	2800      	cmp	r0, #0
 800a108:	d190      	bne.n	800a02c <oslib_test_009_003_execute+0x1c>
    chFactoryReleaseSemaphore(dsp);
 800a10a:	4630      	mov	r0, r6
  test_set_step(5);
 800a10c:	2305      	movs	r3, #5
 800a10e:	6023      	str	r3, [r4, #0]
    chFactoryReleaseSemaphore(dsp);
 800a110:	f7f9 fdd6 	bl	8003cc0 <chFactoryReleaseSemaphore>
  test_set_step(6);
 800a114:	2306      	movs	r3, #6
    dsp = chFactoryFindSemaphore("mysem");
 800a116:	4807      	ldr	r0, [pc, #28]	; (800a134 <oslib_test_009_003_execute+0x124>)
  test_set_step(6);
 800a118:	6023      	str	r3, [r4, #0]
    dsp = chFactoryFindSemaphore("mysem");
 800a11a:	f7f9 fda9 	bl	8003c70 <chFactoryFindSemaphore>
    test_assert(dsp == NULL, "found");
 800a11e:	fab0 f080 	clz	r0, r0
}
 800a122:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
    test_assert(dsp == NULL, "found");
 800a126:	4904      	ldr	r1, [pc, #16]	; (800a138 <oslib_test_009_003_execute+0x128>)
 800a128:	0940      	lsrs	r0, r0, #5
 800a12a:	f7fa b8f9 	b.w	8004320 <__test_assert>
 800a12e:	bf00      	nop
 800a130:	20000c70 	.word	0x20000c70
 800a134:	0800ccec 	.word	0x0800ccec
 800a138:	0800cd24 	.word	0x0800cd24
 800a13c:	0800cd04 	.word	0x0800cd04
 800a140:	0800cd14 	.word	0x0800cd14
 800a144:	0800cd20 	.word	0x0800cd20
 800a148:	0800cd2c 	.word	0x0800cd2c
 800a14c:	0800cd48 	.word	0x0800cd48

0800a150 <oslib_test_009_002_execute>:
static void oslib_test_009_002_execute(void) {
 800a150:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  test_set_step(1);
 800a152:	4c47      	ldr	r4, [pc, #284]	; (800a270 <oslib_test_009_002_execute+0x120>)
    dbp = chFactoryFindBuffer("mybuf");
 800a154:	4847      	ldr	r0, [pc, #284]	; (800a274 <oslib_test_009_002_execute+0x124>)
  test_set_step(1);
 800a156:	2501      	movs	r5, #1
 800a158:	6025      	str	r5, [r4, #0]
    dbp = chFactoryFindBuffer("mybuf");
 800a15a:	f7f9 fcf1 	bl	8003b40 <chFactoryFindBuffer>
    test_assert(dbp == NULL, "found");
 800a15e:	fab0 f080 	clz	r0, r0
 800a162:	4945      	ldr	r1, [pc, #276]	; (800a278 <oslib_test_009_002_execute+0x128>)
 800a164:	0940      	lsrs	r0, r0, #5
 800a166:	f7fa f8db 	bl	8004320 <__test_assert>
 800a16a:	b100      	cbz	r0, 800a16e <oslib_test_009_002_execute+0x1e>
}
 800a16c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    dbp = chFactoryCreateBuffer("mybuf", 128U);
 800a16e:	2180      	movs	r1, #128	; 0x80
  test_set_step(2);
 800a170:	2302      	movs	r3, #2
    dbp = chFactoryCreateBuffer("mybuf", 128U);
 800a172:	4840      	ldr	r0, [pc, #256]	; (800a274 <oslib_test_009_002_execute+0x124>)
  test_set_step(2);
 800a174:	6023      	str	r3, [r4, #0]
    dbp = chFactoryCreateBuffer("mybuf", 128U);
 800a176:	f7f9 fcc3 	bl	8003b00 <chFactoryCreateBuffer>
 800a17a:	4606      	mov	r6, r0
    test_assert(dbp != NULL, "cannot create");
 800a17c:	3800      	subs	r0, #0
 800a17e:	bf18      	it	ne
 800a180:	2001      	movne	r0, #1
 800a182:	493e      	ldr	r1, [pc, #248]	; (800a27c <oslib_test_009_002_execute+0x12c>)
 800a184:	f7fa f8cc 	bl	8004320 <__test_assert>
 800a188:	2800      	cmp	r0, #0
 800a18a:	d1ef      	bne.n	800a16c <oslib_test_009_002_execute+0x1c>
    dbp1 = chFactoryCreateBuffer("mybuf", 128U);
 800a18c:	2180      	movs	r1, #128	; 0x80
  test_set_step(3);
 800a18e:	2303      	movs	r3, #3
    dbp1 = chFactoryCreateBuffer("mybuf", 128U);
 800a190:	4838      	ldr	r0, [pc, #224]	; (800a274 <oslib_test_009_002_execute+0x124>)
  test_set_step(3);
 800a192:	6023      	str	r3, [r4, #0]
    dbp1 = chFactoryCreateBuffer("mybuf", 128U);
 800a194:	f7f9 fcb4 	bl	8003b00 <chFactoryCreateBuffer>
    test_assert(dbp1 == NULL, "can create");
 800a198:	fab0 f080 	clz	r0, r0
 800a19c:	4938      	ldr	r1, [pc, #224]	; (800a280 <oslib_test_009_002_execute+0x130>)
 800a19e:	0940      	lsrs	r0, r0, #5
 800a1a0:	f7fa f8be 	bl	8004320 <__test_assert>
 800a1a4:	2800      	cmp	r0, #0
 800a1a6:	d1e1      	bne.n	800a16c <oslib_test_009_002_execute+0x1c>
  test_set_step(4);
 800a1a8:	2304      	movs	r3, #4
    dbp1 = chFactoryFindBuffer("mybuf");
 800a1aa:	4832      	ldr	r0, [pc, #200]	; (800a274 <oslib_test_009_002_execute+0x124>)
  test_set_step(4);
 800a1ac:	6023      	str	r3, [r4, #0]
    dbp1 = chFactoryFindBuffer("mybuf");
 800a1ae:	f7f9 fcc7 	bl	8003b40 <chFactoryFindBuffer>
    test_assert(dbp1 != NULL, "not found");
 800a1b2:	4607      	mov	r7, r0
 800a1b4:	3800      	subs	r0, #0
 800a1b6:	bf18      	it	ne
 800a1b8:	2001      	movne	r0, #1
 800a1ba:	4932      	ldr	r1, [pc, #200]	; (800a284 <oslib_test_009_002_execute+0x134>)
 800a1bc:	f7fa f8b0 	bl	8004320 <__test_assert>
 800a1c0:	2800      	cmp	r0, #0
 800a1c2:	d1d3      	bne.n	800a16c <oslib_test_009_002_execute+0x1c>
    test_assert(dbp == dbp1, "object reference mismatch");
 800a1c4:	1bf0      	subs	r0, r6, r7
 800a1c6:	fab0 f080 	clz	r0, r0
 800a1ca:	492f      	ldr	r1, [pc, #188]	; (800a288 <oslib_test_009_002_execute+0x138>)
 800a1cc:	0940      	lsrs	r0, r0, #5
 800a1ce:	f7fa f8a7 	bl	8004320 <__test_assert>
 800a1d2:	2800      	cmp	r0, #0
 800a1d4:	d1ca      	bne.n	800a16c <oslib_test_009_002_execute+0x1c>
    test_assert(dbp1->element.refs == 2, "object reference mismatch");
 800a1d6:	6878      	ldr	r0, [r7, #4]
 800a1d8:	492b      	ldr	r1, [pc, #172]	; (800a288 <oslib_test_009_002_execute+0x138>)
 800a1da:	f1a0 0002 	sub.w	r0, r0, #2
 800a1de:	fab0 f080 	clz	r0, r0
 800a1e2:	0940      	lsrs	r0, r0, #5
 800a1e4:	f7fa f89c 	bl	8004320 <__test_assert>
 800a1e8:	2800      	cmp	r0, #0
 800a1ea:	d1bf      	bne.n	800a16c <oslib_test_009_002_execute+0x1c>
 800a1ec:	687b      	ldr	r3, [r7, #4]
    test_assert(dbp1 == dbp2, "object reference mismatch");
 800a1ee:	4926      	ldr	r1, [pc, #152]	; (800a288 <oslib_test_009_002_execute+0x138>)
 800a1f0:	442b      	add	r3, r5
 800a1f2:	4628      	mov	r0, r5
 800a1f4:	607b      	str	r3, [r7, #4]
 800a1f6:	f7fa f893 	bl	8004320 <__test_assert>
 800a1fa:	2800      	cmp	r0, #0
 800a1fc:	d1b6      	bne.n	800a16c <oslib_test_009_002_execute+0x1c>
    test_assert(dbp2->element.refs == 3, "object reference mismatch");
 800a1fe:	6878      	ldr	r0, [r7, #4]
 800a200:	4921      	ldr	r1, [pc, #132]	; (800a288 <oslib_test_009_002_execute+0x138>)
 800a202:	f1a0 0003 	sub.w	r0, r0, #3
 800a206:	fab0 f080 	clz	r0, r0
 800a20a:	0940      	lsrs	r0, r0, #5
 800a20c:	f7fa f888 	bl	8004320 <__test_assert>
 800a210:	2800      	cmp	r0, #0
 800a212:	d1ab      	bne.n	800a16c <oslib_test_009_002_execute+0x1c>
    chFactoryReleaseBuffer(dbp2);
 800a214:	4638      	mov	r0, r7
 800a216:	f7f9 fcbb 	bl	8003b90 <chFactoryReleaseBuffer>
    test_assert(dbp1->element.refs == 2, "references mismatch");
 800a21a:	6878      	ldr	r0, [r7, #4]
 800a21c:	491b      	ldr	r1, [pc, #108]	; (800a28c <oslib_test_009_002_execute+0x13c>)
 800a21e:	f1a0 0002 	sub.w	r0, r0, #2
 800a222:	fab0 f080 	clz	r0, r0
 800a226:	0940      	lsrs	r0, r0, #5
 800a228:	f7fa f87a 	bl	8004320 <__test_assert>
 800a22c:	2800      	cmp	r0, #0
 800a22e:	d19d      	bne.n	800a16c <oslib_test_009_002_execute+0x1c>
    chFactoryReleaseBuffer(dbp1);
 800a230:	4638      	mov	r0, r7
 800a232:	f7f9 fcad 	bl	8003b90 <chFactoryReleaseBuffer>
    test_assert(dbp->element.refs == 1, "references mismatch");
 800a236:	6870      	ldr	r0, [r6, #4]
 800a238:	4914      	ldr	r1, [pc, #80]	; (800a28c <oslib_test_009_002_execute+0x13c>)
 800a23a:	1b40      	subs	r0, r0, r5
 800a23c:	fab0 f080 	clz	r0, r0
 800a240:	0940      	lsrs	r0, r0, #5
 800a242:	f7fa f86d 	bl	8004320 <__test_assert>
 800a246:	2800      	cmp	r0, #0
 800a248:	d190      	bne.n	800a16c <oslib_test_009_002_execute+0x1c>
    chFactoryReleaseBuffer(dbp);
 800a24a:	4630      	mov	r0, r6
  test_set_step(5);
 800a24c:	2305      	movs	r3, #5
 800a24e:	6023      	str	r3, [r4, #0]
    chFactoryReleaseBuffer(dbp);
 800a250:	f7f9 fc9e 	bl	8003b90 <chFactoryReleaseBuffer>
  test_set_step(6);
 800a254:	2306      	movs	r3, #6
    dbp = chFactoryFindBuffer("mybuf");
 800a256:	4807      	ldr	r0, [pc, #28]	; (800a274 <oslib_test_009_002_execute+0x124>)
  test_set_step(6);
 800a258:	6023      	str	r3, [r4, #0]
    dbp = chFactoryFindBuffer("mybuf");
 800a25a:	f7f9 fc71 	bl	8003b40 <chFactoryFindBuffer>
    test_assert(dbp == NULL, "found");
 800a25e:	fab0 f080 	clz	r0, r0
}
 800a262:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
    test_assert(dbp == NULL, "found");
 800a266:	4904      	ldr	r1, [pc, #16]	; (800a278 <oslib_test_009_002_execute+0x128>)
 800a268:	0940      	lsrs	r0, r0, #5
 800a26a:	f7fa b859 	b.w	8004320 <__test_assert>
 800a26e:	bf00      	nop
 800a270:	20000c70 	.word	0x20000c70
 800a274:	0800ccf4 	.word	0x0800ccf4
 800a278:	0800cd24 	.word	0x0800cd24
 800a27c:	0800cd04 	.word	0x0800cd04
 800a280:	0800cd14 	.word	0x0800cd14
 800a284:	0800cd20 	.word	0x0800cd20
 800a288:	0800cd2c 	.word	0x0800cd2c
 800a28c:	0800cd48 	.word	0x0800cd48

0800a290 <oslib_test_009_001_execute>:
static void oslib_test_009_001_execute(void) {
 800a290:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  test_set_step(1);
 800a294:	4c53      	ldr	r4, [pc, #332]	; (800a3e4 <oslib_test_009_001_execute+0x154>)
    rop = chFactoryFindObject("myobj");
 800a296:	4854      	ldr	r0, [pc, #336]	; (800a3e8 <oslib_test_009_001_execute+0x158>)
  test_set_step(1);
 800a298:	2501      	movs	r5, #1
 800a29a:	6025      	str	r5, [r4, #0]
    rop = chFactoryFindObject("myobj");
 800a29c:	f7f9 fbe0 	bl	8003a60 <chFactoryFindObject>
    test_assert(rop == NULL, "found");
 800a2a0:	fab0 f080 	clz	r0, r0
 800a2a4:	4951      	ldr	r1, [pc, #324]	; (800a3ec <oslib_test_009_001_execute+0x15c>)
 800a2a6:	0940      	lsrs	r0, r0, #5
 800a2a8:	f7fa f83a 	bl	8004320 <__test_assert>
 800a2ac:	b108      	cbz	r0, 800a2b2 <oslib_test_009_001_execute+0x22>
}
 800a2ae:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    rop = chFactoryRegisterObject("myobj", (void *)&myobj);
 800a2b2:	494f      	ldr	r1, [pc, #316]	; (800a3f0 <oslib_test_009_001_execute+0x160>)
 800a2b4:	484c      	ldr	r0, [pc, #304]	; (800a3e8 <oslib_test_009_001_execute+0x158>)
  test_set_step(2);
 800a2b6:	2302      	movs	r3, #2
 800a2b8:	6023      	str	r3, [r4, #0]
    rop = chFactoryRegisterObject("myobj", (void *)&myobj);
 800a2ba:	f7f9 fb89 	bl	80039d0 <chFactoryRegisterObject>
 800a2be:	4606      	mov	r6, r0
    test_assert(rop != NULL, "cannot register");
 800a2c0:	3800      	subs	r0, #0
 800a2c2:	bf18      	it	ne
 800a2c4:	2001      	movne	r0, #1
 800a2c6:	494b      	ldr	r1, [pc, #300]	; (800a3f4 <oslib_test_009_001_execute+0x164>)
 800a2c8:	f7fa f82a 	bl	8004320 <__test_assert>
 800a2cc:	2800      	cmp	r0, #0
 800a2ce:	d1ee      	bne.n	800a2ae <oslib_test_009_001_execute+0x1e>
    rop1 = chFactoryRegisterObject("myobj", (void *)&myobj);
 800a2d0:	4949      	ldr	r1, [pc, #292]	; (800a3f8 <oslib_test_009_001_execute+0x168>)
 800a2d2:	4845      	ldr	r0, [pc, #276]	; (800a3e8 <oslib_test_009_001_execute+0x158>)
  test_set_step(3);
 800a2d4:	2303      	movs	r3, #3
 800a2d6:	6023      	str	r3, [r4, #0]
    rop1 = chFactoryRegisterObject("myobj", (void *)&myobj);
 800a2d8:	f7f9 fb7a 	bl	80039d0 <chFactoryRegisterObject>
    test_assert(rop1 == NULL, "can register");
 800a2dc:	fab0 f080 	clz	r0, r0
 800a2e0:	4946      	ldr	r1, [pc, #280]	; (800a3fc <oslib_test_009_001_execute+0x16c>)
 800a2e2:	0940      	lsrs	r0, r0, #5
 800a2e4:	f7fa f81c 	bl	8004320 <__test_assert>
 800a2e8:	2800      	cmp	r0, #0
 800a2ea:	d1e0      	bne.n	800a2ae <oslib_test_009_001_execute+0x1e>
  test_set_step(4);
 800a2ec:	2304      	movs	r3, #4
    rop1 = chFactoryFindObject("myobj");
 800a2ee:	483e      	ldr	r0, [pc, #248]	; (800a3e8 <oslib_test_009_001_execute+0x158>)
  test_set_step(4);
 800a2f0:	6023      	str	r3, [r4, #0]
    rop1 = chFactoryFindObject("myobj");
 800a2f2:	f7f9 fbb5 	bl	8003a60 <chFactoryFindObject>
    test_assert(rop1 != NULL, "not found");
 800a2f6:	4607      	mov	r7, r0
 800a2f8:	3800      	subs	r0, #0
 800a2fa:	bf18      	it	ne
 800a2fc:	2001      	movne	r0, #1
 800a2fe:	4940      	ldr	r1, [pc, #256]	; (800a400 <oslib_test_009_001_execute+0x170>)
 800a300:	f7fa f80e 	bl	8004320 <__test_assert>
 800a304:	2800      	cmp	r0, #0
 800a306:	d1d2      	bne.n	800a2ae <oslib_test_009_001_execute+0x1e>
    test_assert(*(uint32_t *)(rop1->objp) == 0x55aa, "object mismatch");
 800a308:	693b      	ldr	r3, [r7, #16]
 800a30a:	493e      	ldr	r1, [pc, #248]	; (800a404 <oslib_test_009_001_execute+0x174>)
 800a30c:	6818      	ldr	r0, [r3, #0]
 800a30e:	f245 58aa 	movw	r8, #21930	; 0x55aa
 800a312:	eba0 0008 	sub.w	r0, r0, r8
 800a316:	fab0 f080 	clz	r0, r0
 800a31a:	0940      	lsrs	r0, r0, #5
 800a31c:	f7fa f800 	bl	8004320 <__test_assert>
 800a320:	2800      	cmp	r0, #0
 800a322:	d1c4      	bne.n	800a2ae <oslib_test_009_001_execute+0x1e>
    test_assert(rop == rop1, "object reference mismatch");
 800a324:	1bf0      	subs	r0, r6, r7
 800a326:	fab0 f080 	clz	r0, r0
 800a32a:	4937      	ldr	r1, [pc, #220]	; (800a408 <oslib_test_009_001_execute+0x178>)
 800a32c:	0940      	lsrs	r0, r0, #5
 800a32e:	f7f9 fff7 	bl	8004320 <__test_assert>
 800a332:	2800      	cmp	r0, #0
 800a334:	d1bb      	bne.n	800a2ae <oslib_test_009_001_execute+0x1e>
    test_assert(rop1->element.refs == 2, "object reference mismatch");
 800a336:	6878      	ldr	r0, [r7, #4]
 800a338:	4933      	ldr	r1, [pc, #204]	; (800a408 <oslib_test_009_001_execute+0x178>)
 800a33a:	f1a0 0002 	sub.w	r0, r0, #2
 800a33e:	fab0 f080 	clz	r0, r0
 800a342:	0940      	lsrs	r0, r0, #5
 800a344:	f7f9 ffec 	bl	8004320 <__test_assert>
 800a348:	2800      	cmp	r0, #0
 800a34a:	d1b0      	bne.n	800a2ae <oslib_test_009_001_execute+0x1e>
 800a34c:	687b      	ldr	r3, [r7, #4]
    test_assert(rop1 == rop2, "object reference mismatch");
 800a34e:	492e      	ldr	r1, [pc, #184]	; (800a408 <oslib_test_009_001_execute+0x178>)
 800a350:	442b      	add	r3, r5
 800a352:	4628      	mov	r0, r5
 800a354:	607b      	str	r3, [r7, #4]
 800a356:	f7f9 ffe3 	bl	8004320 <__test_assert>
 800a35a:	2800      	cmp	r0, #0
 800a35c:	d1a7      	bne.n	800a2ae <oslib_test_009_001_execute+0x1e>
    test_assert(*(uint32_t *)(rop2->objp) == 0x55aa, "object mismatch");
 800a35e:	693b      	ldr	r3, [r7, #16]
 800a360:	4928      	ldr	r1, [pc, #160]	; (800a404 <oslib_test_009_001_execute+0x174>)
 800a362:	6818      	ldr	r0, [r3, #0]
 800a364:	eba0 0008 	sub.w	r0, r0, r8
 800a368:	fab0 f080 	clz	r0, r0
 800a36c:	0940      	lsrs	r0, r0, #5
 800a36e:	f7f9 ffd7 	bl	8004320 <__test_assert>
 800a372:	2800      	cmp	r0, #0
 800a374:	d19b      	bne.n	800a2ae <oslib_test_009_001_execute+0x1e>
    test_assert(rop2->element.refs == 3, "object reference mismatch");
 800a376:	6878      	ldr	r0, [r7, #4]
 800a378:	4923      	ldr	r1, [pc, #140]	; (800a408 <oslib_test_009_001_execute+0x178>)
 800a37a:	f1a0 0003 	sub.w	r0, r0, #3
 800a37e:	fab0 f080 	clz	r0, r0
 800a382:	0940      	lsrs	r0, r0, #5
 800a384:	f7f9 ffcc 	bl	8004320 <__test_assert>
 800a388:	2800      	cmp	r0, #0
 800a38a:	d190      	bne.n	800a2ae <oslib_test_009_001_execute+0x1e>
    chFactoryReleaseObject(rop2);
 800a38c:	4638      	mov	r0, r7
 800a38e:	f7f9 fb8f 	bl	8003ab0 <chFactoryReleaseObject>
    test_assert(rop1->element.refs == 2, "references mismatch");
 800a392:	6878      	ldr	r0, [r7, #4]
 800a394:	491d      	ldr	r1, [pc, #116]	; (800a40c <oslib_test_009_001_execute+0x17c>)
 800a396:	1e82      	subs	r2, r0, #2
 800a398:	4250      	negs	r0, r2
 800a39a:	4150      	adcs	r0, r2
 800a39c:	f7f9 ffc0 	bl	8004320 <__test_assert>
 800a3a0:	2800      	cmp	r0, #0
 800a3a2:	d184      	bne.n	800a2ae <oslib_test_009_001_execute+0x1e>
    chFactoryReleaseObject(rop1);
 800a3a4:	4638      	mov	r0, r7
 800a3a6:	f7f9 fb83 	bl	8003ab0 <chFactoryReleaseObject>
    test_assert(rop->element.refs == 1, "references mismatch");
 800a3aa:	6870      	ldr	r0, [r6, #4]
 800a3ac:	4917      	ldr	r1, [pc, #92]	; (800a40c <oslib_test_009_001_execute+0x17c>)
 800a3ae:	1b43      	subs	r3, r0, r5
 800a3b0:	4258      	negs	r0, r3
 800a3b2:	4158      	adcs	r0, r3
 800a3b4:	f7f9 ffb4 	bl	8004320 <__test_assert>
 800a3b8:	2800      	cmp	r0, #0
 800a3ba:	f47f af78 	bne.w	800a2ae <oslib_test_009_001_execute+0x1e>
    chFactoryReleaseObject(rop);
 800a3be:	4630      	mov	r0, r6
  test_set_step(5);
 800a3c0:	2305      	movs	r3, #5
 800a3c2:	6023      	str	r3, [r4, #0]
    chFactoryReleaseObject(rop);
 800a3c4:	f7f9 fb74 	bl	8003ab0 <chFactoryReleaseObject>
  test_set_step(6);
 800a3c8:	2306      	movs	r3, #6
    rop = chFactoryFindObject("myobj");
 800a3ca:	4807      	ldr	r0, [pc, #28]	; (800a3e8 <oslib_test_009_001_execute+0x158>)
  test_set_step(6);
 800a3cc:	6023      	str	r3, [r4, #0]
    rop = chFactoryFindObject("myobj");
 800a3ce:	f7f9 fb47 	bl	8003a60 <chFactoryFindObject>
    test_assert(rop == NULL, "found");
 800a3d2:	fab0 f080 	clz	r0, r0
}
 800a3d6:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
    test_assert(rop == NULL, "found");
 800a3da:	4904      	ldr	r1, [pc, #16]	; (800a3ec <oslib_test_009_001_execute+0x15c>)
 800a3dc:	0940      	lsrs	r0, r0, #5
 800a3de:	f7f9 bf9f 	b.w	8004320 <__test_assert>
 800a3e2:	bf00      	nop
 800a3e4:	20000c70 	.word	0x20000c70
 800a3e8:	0800ccfc 	.word	0x0800ccfc
 800a3ec:	0800cd24 	.word	0x0800cd24
 800a3f0:	200008d8 	.word	0x200008d8
 800a3f4:	0800cd5c 	.word	0x0800cd5c
 800a3f8:	200008d4 	.word	0x200008d4
 800a3fc:	0800cd6c 	.word	0x0800cd6c
 800a400:	0800cd20 	.word	0x0800cd20
 800a404:	0800cd7c 	.word	0x0800cd7c
 800a408:	0800cd2c 	.word	0x0800cd2c
 800a40c:	0800cd48 	.word	0x0800cd48

0800a410 <Thread1>:

/*
 * Green LED blinker thread, times are in milliseconds.
 */
static THD_WORKING_AREA(waThread1, 128);
static THD_FUNCTION(Thread1, arg) {
 800a410:	b508      	push	{r3, lr}
 * @api
 */
static inline void chRegSetThreadName(const char *name) {

#if CH_CFG_USE_REGISTRY == TRUE
  __sch_get_currthread()->name = name;
 800a412:	4b09      	ldr	r3, [pc, #36]	; (800a438 <Thread1+0x28>)
 800a414:	4a09      	ldr	r2, [pc, #36]	; (800a43c <Thread1+0x2c>)
 800a416:	68db      	ldr	r3, [r3, #12]

  (void)arg;
  chRegSetThreadName("blinker");
  while (true) {
    palClearLine(LINE_LED_GREEN);
 800a418:	4c09      	ldr	r4, [pc, #36]	; (800a440 <Thread1+0x30>)
 800a41a:	61da      	str	r2, [r3, #28]
 800a41c:	2508      	movs	r5, #8
 800a41e:	462e      	mov	r6, r5
 800a420:	8366      	strh	r6, [r4, #26]
    chThdSleepMilliseconds(500);
 800a422:	f241 3088 	movw	r0, #5000	; 0x1388
 800a426:	f7f7 fdc3 	bl	8001fb0 <chThdSleep>
    palSetLine(LINE_LED_GREEN);
 800a42a:	8325      	strh	r5, [r4, #24]
    chThdSleepMilliseconds(500);
 800a42c:	f241 3088 	movw	r0, #5000	; 0x1388
 800a430:	f7f7 fdbe 	bl	8001fb0 <chThdSleep>
  while (true) {
 800a434:	e7f4      	b.n	800a420 <Thread1+0x10>
 800a436:	bf00      	nop
 800a438:	20000a40 	.word	0x20000a40
 800a43c:	0800cebc 	.word	0x0800cebc
 800a440:	48000400 	.word	0x48000400
	...

0800a450 <main>:
}

/*
 * Application entry point.
 */
int main(void) {
 800a450:	b500      	push	{lr}
 800a452:	b083      	sub	sp, #12
   * - HAL initialization, this also initializes the configured device drivers
   *   and performs the board-specific initializations.
   * - Kernel initialization, the main() function becomes a thread and the
   *   RTOS is active.
   */
  halInit();
 800a454:	f7f6 f814 	bl	8000480 <halInit>
  chSysInit();
 800a458:	f7f7 f87a 	bl	8001550 <chSysInit>

  /*
   * Activates the serial driver 2 using the driver default configuration.
   */
  sdStart(&SD2, NULL);
 800a45c:	2100      	movs	r1, #0
 800a45e:	480f      	ldr	r0, [pc, #60]	; (800a49c <main+0x4c>)
  /*
   * Normal main() thread activity, in this demo it does nothing except
   * sleeping in a loop and check the button state.
   */
  while (true) {
    if (!palReadLine(LINE_ARD_D3)) {
 800a460:	4e0f      	ldr	r6, [pc, #60]	; (800a4a0 <main+0x50>)
  return (msg_t)test_execute_stream(stream, tsp);
 800a462:	4d10      	ldr	r5, [pc, #64]	; (800a4a4 <main+0x54>)
 800a464:	4c0d      	ldr	r4, [pc, #52]	; (800a49c <main+0x4c>)
  sdStart(&SD2, NULL);
 800a466:	f7f6 fa6b 	bl	8000940 <sdStart>
  chThdCreateStatic(waThread1, sizeof(waThread1), NORMALPRIO, Thread1, NULL);
 800a46a:	2200      	movs	r2, #0
 800a46c:	9200      	str	r2, [sp, #0]
 800a46e:	4b0e      	ldr	r3, [pc, #56]	; (800a4a8 <main+0x58>)
 800a470:	480e      	ldr	r0, [pc, #56]	; (800a4ac <main+0x5c>)
 800a472:	2280      	movs	r2, #128	; 0x80
 800a474:	f44f 71b8 	mov.w	r1, #368	; 0x170
 800a478:	f7f7 fc9a 	bl	8001db0 <chThdCreateStatic>
    if (!palReadLine(LINE_ARD_D3)) {
 800a47c:	6933      	ldr	r3, [r6, #16]
 800a47e:	07db      	lsls	r3, r3, #31
 800a480:	4629      	mov	r1, r5
 800a482:	4620      	mov	r0, r4
 800a484:	d405      	bmi.n	800a492 <main+0x42>
 800a486:	f7f9 ffa3 	bl	80043d0 <test_execute_stream>
 800a48a:	4909      	ldr	r1, [pc, #36]	; (800a4b0 <main+0x60>)
 800a48c:	4620      	mov	r0, r4
 800a48e:	f7f9 ff9f 	bl	80043d0 <test_execute_stream>
      test_execute((BaseSequentialStream *)&SD2, &rt_test_suite);
      test_execute((BaseSequentialStream *)&SD2, &oslib_test_suite);
    }
    chThdSleepMilliseconds(500);
 800a492:	f241 3088 	movw	r0, #5000	; 0x1388
 800a496:	f7f7 fd8b 	bl	8001fb0 <chThdSleep>
    if (!palReadLine(LINE_ARD_D3)) {
 800a49a:	e7ef      	b.n	800a47c <main+0x2c>
 800a49c:	200009c4 	.word	0x200009c4
 800a4a0:	48000400 	.word	0x48000400
 800a4a4:	0800aa7c 	.word	0x0800aa7c
 800a4a8:	0800a411 	.word	0x0800a411
 800a4ac:	20001cf0 	.word	0x20001cf0
 800a4b0:	0800c390 	.word	0x0800c390

0800a4b4 <memcmp>:
 800a4b4:	2a03      	cmp	r2, #3
 800a4b6:	b510      	push	{r4, lr}
 800a4b8:	d917      	bls.n	800a4ea <memcmp+0x36>
 800a4ba:	ea40 0c01 	orr.w	ip, r0, r1
 800a4be:	f01c 0f03 	tst.w	ip, #3
 800a4c2:	4604      	mov	r4, r0
 800a4c4:	460b      	mov	r3, r1
 800a4c6:	d123      	bne.n	800a510 <memcmp+0x5c>
 800a4c8:	4619      	mov	r1, r3
 800a4ca:	4620      	mov	r0, r4
 800a4cc:	f8d1 e000 	ldr.w	lr, [r1]
 800a4d0:	f8d0 c000 	ldr.w	ip, [r0]
 800a4d4:	45f4      	cmp	ip, lr
 800a4d6:	f104 0404 	add.w	r4, r4, #4
 800a4da:	f103 0304 	add.w	r3, r3, #4
 800a4de:	d117      	bne.n	800a510 <memcmp+0x5c>
 800a4e0:	3a04      	subs	r2, #4
 800a4e2:	2a03      	cmp	r2, #3
 800a4e4:	4620      	mov	r0, r4
 800a4e6:	4619      	mov	r1, r3
 800a4e8:	d8ee      	bhi.n	800a4c8 <memcmp+0x14>
 800a4ea:	1e54      	subs	r4, r2, #1
 800a4ec:	b1a2      	cbz	r2, 800a518 <memcmp+0x64>
 800a4ee:	f100 3cff 	add.w	ip, r0, #4294967295	; 0xffffffff
 800a4f2:	3901      	subs	r1, #1
 800a4f4:	e001      	b.n	800a4fa <memcmp+0x46>
 800a4f6:	18c3      	adds	r3, r0, r3
 800a4f8:	d00c      	beq.n	800a514 <memcmp+0x60>
 800a4fa:	f81c ef01 	ldrb.w	lr, [ip, #1]!
 800a4fe:	f811 2f01 	ldrb.w	r2, [r1, #1]!
 800a502:	4596      	cmp	lr, r2
 800a504:	eba4 030c 	sub.w	r3, r4, ip
 800a508:	d0f5      	beq.n	800a4f6 <memcmp+0x42>
 800a50a:	ebae 0002 	sub.w	r0, lr, r2
 800a50e:	bd10      	pop	{r4, pc}
 800a510:	1e54      	subs	r4, r2, #1
 800a512:	e7ec      	b.n	800a4ee <memcmp+0x3a>
 800a514:	4618      	mov	r0, r3
 800a516:	bd10      	pop	{r4, pc}
 800a518:	4610      	mov	r0, r2
 800a51a:	bd10      	pop	{r4, pc}

0800a51c <memset>:
 800a51c:	0783      	lsls	r3, r0, #30
 800a51e:	b530      	push	{r4, r5, lr}
 800a520:	d048      	beq.n	800a5b4 <memset+0x98>
 800a522:	1e54      	subs	r4, r2, #1
 800a524:	2a00      	cmp	r2, #0
 800a526:	d03f      	beq.n	800a5a8 <memset+0x8c>
 800a528:	b2ca      	uxtb	r2, r1
 800a52a:	4603      	mov	r3, r0
 800a52c:	e001      	b.n	800a532 <memset+0x16>
 800a52e:	3c01      	subs	r4, #1
 800a530:	d33a      	bcc.n	800a5a8 <memset+0x8c>
 800a532:	f803 2b01 	strb.w	r2, [r3], #1
 800a536:	079d      	lsls	r5, r3, #30
 800a538:	d1f9      	bne.n	800a52e <memset+0x12>
 800a53a:	2c03      	cmp	r4, #3
 800a53c:	d92d      	bls.n	800a59a <memset+0x7e>
 800a53e:	b2cd      	uxtb	r5, r1
 800a540:	ea45 2505 	orr.w	r5, r5, r5, lsl #8
 800a544:	2c0f      	cmp	r4, #15
 800a546:	ea45 4505 	orr.w	r5, r5, r5, lsl #16
 800a54a:	d936      	bls.n	800a5ba <memset+0x9e>
 800a54c:	f1a4 0210 	sub.w	r2, r4, #16
 800a550:	f022 0c0f 	bic.w	ip, r2, #15
 800a554:	f103 0e20 	add.w	lr, r3, #32
 800a558:	44e6      	add	lr, ip
 800a55a:	ea4f 1c12 	mov.w	ip, r2, lsr #4
 800a55e:	f103 0210 	add.w	r2, r3, #16
 800a562:	e942 5504 	strd	r5, r5, [r2, #-16]
 800a566:	e942 5502 	strd	r5, r5, [r2, #-8]
 800a56a:	3210      	adds	r2, #16
 800a56c:	4572      	cmp	r2, lr
 800a56e:	d1f8      	bne.n	800a562 <memset+0x46>
 800a570:	f10c 0201 	add.w	r2, ip, #1
 800a574:	f014 0f0c 	tst.w	r4, #12
 800a578:	eb03 1202 	add.w	r2, r3, r2, lsl #4
 800a57c:	f004 0c0f 	and.w	ip, r4, #15
 800a580:	d013      	beq.n	800a5aa <memset+0x8e>
 800a582:	f1ac 0304 	sub.w	r3, ip, #4
 800a586:	f023 0303 	bic.w	r3, r3, #3
 800a58a:	3304      	adds	r3, #4
 800a58c:	4413      	add	r3, r2
 800a58e:	f842 5b04 	str.w	r5, [r2], #4
 800a592:	4293      	cmp	r3, r2
 800a594:	d1fb      	bne.n	800a58e <memset+0x72>
 800a596:	f00c 0403 	and.w	r4, ip, #3
 800a59a:	b12c      	cbz	r4, 800a5a8 <memset+0x8c>
 800a59c:	b2ca      	uxtb	r2, r1
 800a59e:	441c      	add	r4, r3
 800a5a0:	f803 2b01 	strb.w	r2, [r3], #1
 800a5a4:	429c      	cmp	r4, r3
 800a5a6:	d1fb      	bne.n	800a5a0 <memset+0x84>
 800a5a8:	bd30      	pop	{r4, r5, pc}
 800a5aa:	4664      	mov	r4, ip
 800a5ac:	4613      	mov	r3, r2
 800a5ae:	2c00      	cmp	r4, #0
 800a5b0:	d1f4      	bne.n	800a59c <memset+0x80>
 800a5b2:	e7f9      	b.n	800a5a8 <memset+0x8c>
 800a5b4:	4603      	mov	r3, r0
 800a5b6:	4614      	mov	r4, r2
 800a5b8:	e7bf      	b.n	800a53a <memset+0x1e>
 800a5ba:	461a      	mov	r2, r3
 800a5bc:	46a4      	mov	ip, r4
 800a5be:	e7e0      	b.n	800a582 <memset+0x66>

0800a5c0 <strncmp>:
 800a5c0:	b3a2      	cbz	r2, 800a62c <strncmp+0x6c>
 800a5c2:	b530      	push	{r4, r5, lr}
 800a5c4:	ea40 0401 	orr.w	r4, r0, r1
 800a5c8:	07a4      	lsls	r4, r4, #30
 800a5ca:	4684      	mov	ip, r0
 800a5cc:	460b      	mov	r3, r1
 800a5ce:	d02a      	beq.n	800a626 <strncmp+0x66>
 800a5d0:	f89c 0000 	ldrb.w	r0, [ip]
 800a5d4:	780c      	ldrb	r4, [r1, #0]
 800a5d6:	4284      	cmp	r4, r0
 800a5d8:	d12f      	bne.n	800a63a <strncmp+0x7a>
 800a5da:	2a01      	cmp	r2, #1
 800a5dc:	d00d      	beq.n	800a5fa <strncmp+0x3a>
 800a5de:	46e6      	mov	lr, ip
 800a5e0:	b160      	cbz	r0, 800a5fc <strncmp+0x3c>
 800a5e2:	f81e 0f01 	ldrb.w	r0, [lr, #1]!
 800a5e6:	f811 4f01 	ldrb.w	r4, [r1, #1]!
 800a5ea:	ea6f 030e 	mvn.w	r3, lr
 800a5ee:	42a0      	cmp	r0, r4
 800a5f0:	4413      	add	r3, r2
 800a5f2:	d122      	bne.n	800a63a <strncmp+0x7a>
 800a5f4:	eb1c 0303 	adds.w	r3, ip, r3
 800a5f8:	d1f2      	bne.n	800a5e0 <strncmp+0x20>
 800a5fa:	2000      	movs	r0, #0
 800a5fc:	bd30      	pop	{r4, r5, pc}
 800a5fe:	6804      	ldr	r4, [r0, #0]
 800a600:	4619      	mov	r1, r3
 800a602:	f853 5b04 	ldr.w	r5, [r3], #4
 800a606:	f1a4 3e01 	sub.w	lr, r4, #16843009	; 0x1010101
 800a60a:	42ac      	cmp	r4, r5
 800a60c:	4684      	mov	ip, r0
 800a60e:	ea2e 0e04 	bic.w	lr, lr, r4
 800a612:	f100 0004 	add.w	r0, r0, #4
 800a616:	d10b      	bne.n	800a630 <strncmp+0x70>
 800a618:	3a04      	subs	r2, #4
 800a61a:	4684      	mov	ip, r0
 800a61c:	4619      	mov	r1, r3
 800a61e:	d0ec      	beq.n	800a5fa <strncmp+0x3a>
 800a620:	f01e 3f80 	tst.w	lr, #2155905152	; 0x80808080
 800a624:	d1e9      	bne.n	800a5fa <strncmp+0x3a>
 800a626:	2a03      	cmp	r2, #3
 800a628:	d8e9      	bhi.n	800a5fe <strncmp+0x3e>
 800a62a:	e7d1      	b.n	800a5d0 <strncmp+0x10>
 800a62c:	4610      	mov	r0, r2
 800a62e:	4770      	bx	lr
 800a630:	f89c 0000 	ldrb.w	r0, [ip]
 800a634:	780c      	ldrb	r4, [r1, #0]
 800a636:	42a0      	cmp	r0, r4
 800a638:	d0d1      	beq.n	800a5de <strncmp+0x1e>
 800a63a:	1b00      	subs	r0, r0, r4
 800a63c:	bd30      	pop	{r4, r5, pc}
 800a63e:	bf00      	nop
